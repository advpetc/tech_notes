# Permutations

Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

 

**Example 1:**

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Example 2:**

```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```

**Example 3:**

```
Input: nums = [1]
Output: [[1]]
```

 

**Constraints:**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- All the integers of `nums` are **unique**.

## Analysis

### Traditional DFS

There are two recursive ways to solve this problem. One way is the traditional DFS with the help of using an additional memory to record any existed configuration. For each iteration, we use an index to locate which index we are going to place our number, and the base case is when this index reaches the end. When placing our number to this index, we should try out all the numbers from `nums[0]` to `nums[end]`, and compare them with the current visited memory to decide if we can put that number to the index. This process for each iteration will take up $O(n)$ complexity, and there will be `n!` results at the bottom level, so the total time complexity is $O(n \times n!) $



