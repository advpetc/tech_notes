{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Haoyang's Tech Notes \u00b6 What's included \u00b6 Leetcode c Java iOS Crypto Python Machine Learning Lai Google Kick Start LibreOJ No Longer Update \u00b6 Old gitbook cnblog","title":"Welcome to Haoyang's Tech Notes"},{"location":"#welcome-to-haoyangs-tech-notes","text":"","title":"Welcome to Haoyang's Tech Notes"},{"location":"#whats-included","text":"Leetcode c Java iOS Crypto Python Machine Learning Lai Google Kick Start LibreOJ","title":"What's included"},{"location":"#no-longer-update","text":"Old gitbook cnblog","title":"No Longer Update"},{"location":"about/","text":"About \u00b6 Hi, I'm Haoyang Chen (\u9648\u98a2\u9633). I am a student major in Computer Science and Engineering. Ping me AT peterchen.xyz.","title":"About"},{"location":"about/#about","text":"Hi, I'm Haoyang Chen (\u9648\u98a2\u9633). I am a student major in Computer Science and Engineering. Ping me AT peterchen.xyz.","title":"About"},{"location":"Crypto/rsa-en%26decryption/","text":"Symbolics \u00b6 p and q are two very large primes n = p * q : Modulus phi = (p-1) * (q-1) : Totient e Public Key: is the prime number chosen in the range [3, phi(n)] d Secret Key Calculate d and Encrypt the message \u00b6 using extended-Euclid's algorithm to find the resulting equation when gcd = 1: it should always look like this: 1 = (a) * phi + (b) * e And d = phi * k - b (k is any integer that could make d > 0) To verify: e * d = 1 mod phi, this could be done easily Encrypt the message using public key e and n: M ^ e mod n the result C is the encrypted message Decrypt C using private key \u00b6 M = c ^ d mod n Sometimes it's being called the signature sign","title":"Rsa en&decryption"},{"location":"Crypto/rsa-en%26decryption/#symbolics","text":"p and q are two very large primes n = p * q : Modulus phi = (p-1) * (q-1) : Totient e Public Key: is the prime number chosen in the range [3, phi(n)] d Secret Key","title":"Symbolics"},{"location":"Crypto/rsa-en%26decryption/#calculate-d-and-encrypt-the-message","text":"using extended-Euclid's algorithm to find the resulting equation when gcd = 1: it should always look like this: 1 = (a) * phi + (b) * e And d = phi * k - b (k is any integer that could make d > 0) To verify: e * d = 1 mod phi, this could be done easily Encrypt the message using public key e and n: M ^ e mod n the result C is the encrypted message","title":"Calculate d and Encrypt the message"},{"location":"Crypto/rsa-en%26decryption/#decrypt-c-using-private-key","text":"M = c ^ d mod n Sometimes it's being called the signature sign","title":"Decrypt C using private key"},{"location":"Google%20Kick%20Start/2020---round-a/","text":"Allocation \u00b6 There are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. Limits Time limit: 15 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 B \u2264 105. 1 \u2264 Ai \u2264 1000, for all i. Test set 1 1 \u2264 N \u2264 100. Test set 2 1 \u2264 N \u2264 105. Sample Input Output 3 4 100 20 90 40 90 4 50 30 30 10 10 3 300 999 999 999 Case #1: 2 Case #2: 3 Case #3: 0 In Sample Case #1, you have a budget of 100 dollars. You can buy the 1 st and 3 rd houses for 20 + 40 = 60 dollars. In Sample Case #2, you have a budget of 50 dollars. You can buy the 1 st , 3 rd and 4 th houses for 30 + 10 + 10 = 50 dollars. In Sample Case #3, you have a budget of 300 dollars. You cannot buy any houses (so the answer is 0). Analysis \u00b6 To buy the maxmimum amount of houses, we can greedy buy the ones with the smallest cost first, and until we reach to the point when there is no money left to buy the next higher cost house, we can stop. Prove by replacement: assume the solution is A = {a1, ..., ak} where ai represents the house cost you choose for the max amount. assume the optimal solution is O = {oi, ..., om} where oi represents the true solution. assume oj is not presented in A we want to prove that A == O pick an ai that is in A, and replace it with oj. oj is not in A, so oj is less than ai. since size of B is the same, the solution is still the most optimal one. keep doing this until there is A == O. Code \u00b6 sort with nlog n \u00b6 /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; vector < int > costs(N, 0 ); for ( int j = 0 ; j < N; ++ j) { cin >> costs[j]; } sort(costs.begin(), costs.end()); // nlog n int cnt = 0 ; for ( int k = 0 ; k < N; ++ k) if (B >= costs[k]) { B -= costs[k]; cnt ++ ; } else break ; cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; } count sort with n \u00b6 because 1 \u2264 Ai \u2264 1000, we can use count sort /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int n = 1010 ; int A[n]; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; memset(A, 0 , sizeof A); int v; for ( int i = 0 ; i < N; ++ i) { cin >> v; A[v] ++ ; } int cnt = 0 ; for ( int i = 1 ; B > 0 && i <= 1000 ; ++ i) { // i is house price int curr = min(B / i, A[i]); // case when there are less than you can buy cnt += curr; B -= curr * i; } cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; } Plates \u00b6 Dr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 K \u2264 30. 1 \u2264 P \u2264 N * K. The beauty values are between 1 and 100, inclusive. Test set 1 1 \u2264 N \u2264 3. Test set 2 1 \u2264 N \u2264 50. Sample Input Output 2 2 4 5 10 10 100 30 80 50 10 50 3 2 3 80 80 15 50 20 10 Case #1: 250 Case #2: 180 In Sample Case #1, Dr. Patel needs to pick P = 5 plates: He can pick the top 3 plates from the first stack (10 + 10 + 100 = 120). He can pick the top 2 plates from the second stack (80 + 50 = 130) . In total, the sum of beauty values is 250. In Sample Case #2, Dr. Patel needs to pick P = 3 plates: He can pick the top 2 plates from the first stack (80 + 80 = 160). He can pick no plates from the second stack. He can pick the top plate from the third stack (20). In total, the sum of beauty values is 180. Analysis \u00b6 dp[N][P]: from first n stacks, with p plates, the maximum beauty values dp[i][j] = max(dp[i][j], val[k] + dp[i - 1][p - k]) for choosing current stack's top k plates, you need to give up the previous stacks k plates, so the previous state is dp[i - 1][p - k] the answer is dp[N][P] Code \u00b6 /* * plates.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T; int N, K, P; // n: # of stacks, k: # of items for each stack, # total to be // borrowed cin >> T; for ( int t = 0 ; t < T; ++ t) { cin >> N >> K >> P; int dp[N + 1 ][P + 1 ]; // from 0-N, the max value for P plates memset(dp, 0 , sizeof dp); for ( int i = 1 ; i <= N; ++ i) { int val[K + 1 ]; memset(val, 0 , sizeof val); for ( int j = 1 ; j <= K; ++ j) { cin >> val[j]; } // calculate preSum for ( int k = 1 ; k <= K; ++ k) { val[k] = val[k - 1 ] + val[k]; } for ( int p = 1 ; p <= P; ++ p) { for ( int k = 0 ; k <= min(p, K); ++ k) { dp[i][p] = max(dp[i][p], val[k] + dp[i - 1 ][p - k]); } } } cout << \"Case #\" << t << \": \" << dp[N][P] << endl; } return 0 ; } Workout \u00b6 Tambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. For at most 10 test cases, 2 \u2264 N \u2264 105. For all other test cases, 2 \u2264 N \u2264 300. 1 \u2264 Mi \u2264 109. Mi < Mi+1 for all i. Test set 1 K = 1. Test set 2 1 \u2264 K \u2264 105. Samples Input 1 Output 1 1 3 1 100 200 230 Case #1: 50 Input 2 Output 2 3 5 2 10 13 15 16 17 5 6 9 10 20 26 30 8 3 1 2 3 4 5 6 7 10 Case #1: 2 Case #2: 3 Case #3: 1 Sample #1 In Case #1: Tambourine can add up to one session. The added sessions are marked in bold: 100 150 200 230. The difficulty is now 50. Sample #2 In Case #1: Tambourine can add up to two sessions. The added sessions are marked in bold: 10 11 13 15 16 17 18. The difficulty is now 2. In Case #2: Tambourine can add up to six sessions. The added sessions are marked in bold: 9 10 12 14 16 18 20 23 26 29 30. The difficulty is now 3. In Case #3: Tambourine can add up to three sessions. The added sessions are marked in bold: 1 2 3 4 5 6 7 8 9 10. The difficulty is now 1. Note that Tambourine only added two sessions. Analysis \u00b6 Priority Queue : Find an array that record the gaps every two sessions. Call it gaps[N-1]. To add one session, the new one should be between the one that has the greatest gap. However, we cannot do that all at once for the first greatest gap. Instead, we should do it \"greedily\". When adding the one, we need to find a way to get the updated max gap from the total gaps. In order to do so, we need to use priority queue. The top of the queue will store the maxmium gap. To keep update the gap, we don't want to manually modify the default gap, but to add a \"cnt\" which will be divied by the gap. When making the comparsion, the real gap value is gap default value / cnt. Binary Search : Our goal is to find the most difficult gap, and try to minimize it as much as possible. It now becomes a search problem. The gap is in between 1 ~ a[n-1]-a[0], and for each gap, we calculate the desire \"cuts\" to satisfy k. To calculate the desire \"cuts\", we should find the gap between each one, and then ceil(gap / most difficult gap) - 1 (check line 21 from solution 2). If the \"cuts\" is less than K, that means we have room to lower our difficulty by using the unused \"cuts\", so our search range is decreased by half from 1 ~ mb, else it will be mb + 1 ~ rb. Code \u00b6 Priority Queue \u00b6 #include <bits/stdc++.h> using namespace std; struct node { int sum, cnt; node() {} node( int sum, int cnt) : sum(sum) , cnt(cnt) { } bool operator < ( const node & b) const { int x = (sum / cnt) + (sum % cnt > 0 ); // sort by averged out by cnt int y = (b.sum / b.cnt) + (b.sum % b.cnt > 0 ); return x < y; } }; int main ( int argc, char * argv[]) { int T; int N, K; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> K; int m[N]; memset(m, 0 , sizeof m); for ( int n = 0 ; n < N; ++ n) { cin >> m[n]; } int gap[N - 1 ]; memset(gap, 0 , sizeof gap); for ( int i = 0 ; i < N - 1 ; ++ i) { gap[i] = m[i + 1 ] - m[i]; } if (K == 1 ) { sort(gap, gap + N - 1 ); if (N == 2 ) printf( \"Case #%d: %d \\n \" , i, (gap[ 0 ] + 1 ) / 2 ); else printf( \"Case #%d: %d \\n \" , i, max((gap[N - 2 ] + 1 ) / 2 , gap[N - 3 ])); } else { priority_queue < node > q; for ( int i = 0 ; i < N - 1 ; ++ i) { q.push(node(gap[i], 1 )); } for ( int i = 0 ; i < K; ++ i) { auto p = q.top(); q.pop(); q.push(node(p.sum, p.cnt + 1 )); // add one to split it } auto p = q.top(); int res = (p.sum / p.cnt) + (p.sum % p.cnt > 0 ); printf( \"Case #%d: %d \\n \" , i, res); } } return 0 ; } Binary search \u00b6 #include <bits/stdc++.h> using namespace std; #define ll long long #define ar array int n, k, a[ 100000 ]; void solve () { cin >> n >> k; // n: size of a, k: # of total insertions for ( int i = 0 ; i < n; ++ i) cin >> a[i]; int lb = 1 , rb = a[n - 1 ] - a[ 0 ]; // total difference while (lb < rb) { int mb = (lb + rb) / 2 ; // guess the most optimal difference is mb int k2 = 0 ; for ( int i = 1 ; i < n; ++ i) { int d = a[i] - a[i - 1 ]; k2 += (d + mb - 1 ) / mb - 1 ; // # of all inserted class if mb is the optimal } if (k2 <= k) // if less than k, we can potentially decrease the difficulity rb = mb; else // or we have to increase the difficulity lb = mb + 1 ; } cout << lb << \" \\n \" ; } int main () { ios :: sync_with_stdio( 0 ); cin.tie( 0 ); int t, i = 1 ; cin >> t; while (t -- ) { cout << \"Case #\" << i << \": \" ; solve(); ++ i; } } Bundling \u00b6 Pip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example: The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is 'RA'). The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is 'FIRE'). The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ''). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip's strings. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 2 \u2264 N \u2264 105. 2 \u2264 K \u2264 N. K divides N. Each of Pip's strings contain at least one character. Each string consists only of letters from A to Z. Test set 1 Each of Pip's strings contain at most 5 characters. Test set 2 The total number of characters in Pip's strings across all test cases is at most 2 \u00d7 106. Samples Input 1 2 2 2 KICK START 8 2 G G GO GO GOO GOO GOOO GOOO Output 1 Case #1: 0 Case #2: 10 Input 2 1 6 3 RAINBOW FIREBALL RANK RANDOM FIREWALL FIREFIGHTER Output 2 Case #1: 6 Sample #1 In Case #1, Pip can achieve a total score of 0 by make the groups: {KICK, START}, with a score of 0. In Case #2, Pip can achieve a total score of 10 by make the groups: {G, G}, with a score of 1. {GO, GO}, with a score of 2. {GOO, GOO}, with a score of 3. {GOOO, GOOO}, with a score of 4. Sample #2 In Case #1, Pip can achieve a total score of 6 by make the groups: {RAINBOW, RANK, RANDOM}, with a score of 2. {FIREBALL, FIREWALL, FIREFIGHTER}, with a score of 4. Analysis \u00b6 Assume each bundle has prefix as P_i P_i , and the CNT_i CNT_i represents the number of strings shares that prefix. Assign k string to the bundle, now we have CNT_i \\% k CNT_i \\% k string left. Do the same thing for preifx P_{i + 1} P_{i + 1} which has a CNT_{i+1} < CNT_i CNT_{i+1} < CNT_i , now we have CNT_{i + 1} \\% k CNT_{i + 1} \\% k left. Keep this procedure until CNT_j \\% k == 0 CNT_j \\% k == 0 which means all the string have assigned to a particular bundle. Now the problem becomes finding the total count. Split into n/k groups, and each group has k strings. Use trie to find the common prefix. Each trie node has 26 children nodes, and one cnt int for counting the number of prefix exist by the current node. Insert: insert into trie and update the cnt for each ending character node. Query: just search from the root of the trie and traverse through the last level of the trie, because all the nodes from root has a count that represent the occurance of word that is ended with node character. Code \u00b6 #include <bits/stdc++.h> using namespace std; #define endl \"\\n\" #define int long long const int N = 1e5 + 5 ; typedef struct data { data * bit[ 26 ]; int cnt = 0 ; }trie; trie * head; void insert (string & s) { trie * cur = head; for ( auto & it:s) { int b = it - 'A' ; if ( ! cur -> bit[b]) cur -> bit[b] = new trie(); // create new node if not exist cur = cur -> bit[b]; // proceed through next character cur -> cnt ++ ; // end with current character } } int n, k; string s[N]; int query (trie * cur) { if ( ! cur) return 0 ; int ans = (cur -> cnt / k); // there are k words each, so there are k times repeat counts for ( int i = 0 ; i <= 25 ; i ++ ) if (cur -> bit[i]) ans += query(cur -> bit[i]); // proceeds to next level and check the count return ans; } int main () { int t; cin >> t; int tc = 0 ; while (t -- ) { head = new trie(); tc ++ ; cin >> n >> k; for ( int i = 1 ; i <= n; i ++ ) { cin >> s[i]; insert(s[i]); } int ans = query(head); cout << \"Case #\" << tc << \": \" << ans << endl; } return 0 ; }","title":"2020   round a"},{"location":"Google%20Kick%20Start/2020---round-a/#allocation","text":"There are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. Limits Time limit: 15 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 B \u2264 105. 1 \u2264 Ai \u2264 1000, for all i. Test set 1 1 \u2264 N \u2264 100. Test set 2 1 \u2264 N \u2264 105. Sample Input Output 3 4 100 20 90 40 90 4 50 30 30 10 10 3 300 999 999 999 Case #1: 2 Case #2: 3 Case #3: 0 In Sample Case #1, you have a budget of 100 dollars. You can buy the 1 st and 3 rd houses for 20 + 40 = 60 dollars. In Sample Case #2, you have a budget of 50 dollars. You can buy the 1 st , 3 rd and 4 th houses for 30 + 10 + 10 = 50 dollars. In Sample Case #3, you have a budget of 300 dollars. You cannot buy any houses (so the answer is 0).","title":"Allocation"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis","text":"To buy the maxmimum amount of houses, we can greedy buy the ones with the smallest cost first, and until we reach to the point when there is no money left to buy the next higher cost house, we can stop. Prove by replacement: assume the solution is A = {a1, ..., ak} where ai represents the house cost you choose for the max amount. assume the optimal solution is O = {oi, ..., om} where oi represents the true solution. assume oj is not presented in A we want to prove that A == O pick an ai that is in A, and replace it with oj. oj is not in A, so oj is less than ai. since size of B is the same, the solution is still the most optimal one. keep doing this until there is A == O.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code","text":"","title":"Code"},{"location":"Google%20Kick%20Start/2020---round-a/#sort-with-nlog-n","text":"/* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; vector < int > costs(N, 0 ); for ( int j = 0 ; j < N; ++ j) { cin >> costs[j]; } sort(costs.begin(), costs.end()); // nlog n int cnt = 0 ; for ( int k = 0 ; k < N; ++ k) if (B >= costs[k]) { B -= costs[k]; cnt ++ ; } else break ; cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; }","title":"sort with nlog n"},{"location":"Google%20Kick%20Start/2020---round-a/#count-sort-with-n","text":"because 1 \u2264 Ai \u2264 1000, we can use count sort /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int n = 1010 ; int A[n]; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; memset(A, 0 , sizeof A); int v; for ( int i = 0 ; i < N; ++ i) { cin >> v; A[v] ++ ; } int cnt = 0 ; for ( int i = 1 ; B > 0 && i <= 1000 ; ++ i) { // i is house price int curr = min(B / i, A[i]); // case when there are less than you can buy cnt += curr; B -= curr * i; } cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; }","title":"count sort with n"},{"location":"Google%20Kick%20Start/2020---round-a/#plates","text":"Dr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 K \u2264 30. 1 \u2264 P \u2264 N * K. The beauty values are between 1 and 100, inclusive. Test set 1 1 \u2264 N \u2264 3. Test set 2 1 \u2264 N \u2264 50. Sample Input Output 2 2 4 5 10 10 100 30 80 50 10 50 3 2 3 80 80 15 50 20 10 Case #1: 250 Case #2: 180 In Sample Case #1, Dr. Patel needs to pick P = 5 plates: He can pick the top 3 plates from the first stack (10 + 10 + 100 = 120). He can pick the top 2 plates from the second stack (80 + 50 = 130) . In total, the sum of beauty values is 250. In Sample Case #2, Dr. Patel needs to pick P = 3 plates: He can pick the top 2 plates from the first stack (80 + 80 = 160). He can pick no plates from the second stack. He can pick the top plate from the third stack (20). In total, the sum of beauty values is 180.","title":"Plates"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis_1","text":"dp[N][P]: from first n stacks, with p plates, the maximum beauty values dp[i][j] = max(dp[i][j], val[k] + dp[i - 1][p - k]) for choosing current stack's top k plates, you need to give up the previous stacks k plates, so the previous state is dp[i - 1][p - k] the answer is dp[N][P]","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code_1","text":"/* * plates.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T; int N, K, P; // n: # of stacks, k: # of items for each stack, # total to be // borrowed cin >> T; for ( int t = 0 ; t < T; ++ t) { cin >> N >> K >> P; int dp[N + 1 ][P + 1 ]; // from 0-N, the max value for P plates memset(dp, 0 , sizeof dp); for ( int i = 1 ; i <= N; ++ i) { int val[K + 1 ]; memset(val, 0 , sizeof val); for ( int j = 1 ; j <= K; ++ j) { cin >> val[j]; } // calculate preSum for ( int k = 1 ; k <= K; ++ k) { val[k] = val[k - 1 ] + val[k]; } for ( int p = 1 ; p <= P; ++ p) { for ( int k = 0 ; k <= min(p, K); ++ k) { dp[i][p] = max(dp[i][p], val[k] + dp[i - 1 ][p - k]); } } } cout << \"Case #\" << t << \": \" << dp[N][P] << endl; } return 0 ; }","title":"Code"},{"location":"Google%20Kick%20Start/2020---round-a/#workout","text":"Tambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. For at most 10 test cases, 2 \u2264 N \u2264 105. For all other test cases, 2 \u2264 N \u2264 300. 1 \u2264 Mi \u2264 109. Mi < Mi+1 for all i. Test set 1 K = 1. Test set 2 1 \u2264 K \u2264 105. Samples Input 1 Output 1 1 3 1 100 200 230 Case #1: 50 Input 2 Output 2 3 5 2 10 13 15 16 17 5 6 9 10 20 26 30 8 3 1 2 3 4 5 6 7 10 Case #1: 2 Case #2: 3 Case #3: 1 Sample #1 In Case #1: Tambourine can add up to one session. The added sessions are marked in bold: 100 150 200 230. The difficulty is now 50. Sample #2 In Case #1: Tambourine can add up to two sessions. The added sessions are marked in bold: 10 11 13 15 16 17 18. The difficulty is now 2. In Case #2: Tambourine can add up to six sessions. The added sessions are marked in bold: 9 10 12 14 16 18 20 23 26 29 30. The difficulty is now 3. In Case #3: Tambourine can add up to three sessions. The added sessions are marked in bold: 1 2 3 4 5 6 7 8 9 10. The difficulty is now 1. Note that Tambourine only added two sessions.","title":"Workout"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis_2","text":"Priority Queue : Find an array that record the gaps every two sessions. Call it gaps[N-1]. To add one session, the new one should be between the one that has the greatest gap. However, we cannot do that all at once for the first greatest gap. Instead, we should do it \"greedily\". When adding the one, we need to find a way to get the updated max gap from the total gaps. In order to do so, we need to use priority queue. The top of the queue will store the maxmium gap. To keep update the gap, we don't want to manually modify the default gap, but to add a \"cnt\" which will be divied by the gap. When making the comparsion, the real gap value is gap default value / cnt. Binary Search : Our goal is to find the most difficult gap, and try to minimize it as much as possible. It now becomes a search problem. The gap is in between 1 ~ a[n-1]-a[0], and for each gap, we calculate the desire \"cuts\" to satisfy k. To calculate the desire \"cuts\", we should find the gap between each one, and then ceil(gap / most difficult gap) - 1 (check line 21 from solution 2). If the \"cuts\" is less than K, that means we have room to lower our difficulty by using the unused \"cuts\", so our search range is decreased by half from 1 ~ mb, else it will be mb + 1 ~ rb.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code_2","text":"","title":"Code"},{"location":"Google%20Kick%20Start/2020---round-a/#priority-queue","text":"#include <bits/stdc++.h> using namespace std; struct node { int sum, cnt; node() {} node( int sum, int cnt) : sum(sum) , cnt(cnt) { } bool operator < ( const node & b) const { int x = (sum / cnt) + (sum % cnt > 0 ); // sort by averged out by cnt int y = (b.sum / b.cnt) + (b.sum % b.cnt > 0 ); return x < y; } }; int main ( int argc, char * argv[]) { int T; int N, K; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> K; int m[N]; memset(m, 0 , sizeof m); for ( int n = 0 ; n < N; ++ n) { cin >> m[n]; } int gap[N - 1 ]; memset(gap, 0 , sizeof gap); for ( int i = 0 ; i < N - 1 ; ++ i) { gap[i] = m[i + 1 ] - m[i]; } if (K == 1 ) { sort(gap, gap + N - 1 ); if (N == 2 ) printf( \"Case #%d: %d \\n \" , i, (gap[ 0 ] + 1 ) / 2 ); else printf( \"Case #%d: %d \\n \" , i, max((gap[N - 2 ] + 1 ) / 2 , gap[N - 3 ])); } else { priority_queue < node > q; for ( int i = 0 ; i < N - 1 ; ++ i) { q.push(node(gap[i], 1 )); } for ( int i = 0 ; i < K; ++ i) { auto p = q.top(); q.pop(); q.push(node(p.sum, p.cnt + 1 )); // add one to split it } auto p = q.top(); int res = (p.sum / p.cnt) + (p.sum % p.cnt > 0 ); printf( \"Case #%d: %d \\n \" , i, res); } } return 0 ; }","title":"Priority Queue"},{"location":"Google%20Kick%20Start/2020---round-a/#binary-search","text":"#include <bits/stdc++.h> using namespace std; #define ll long long #define ar array int n, k, a[ 100000 ]; void solve () { cin >> n >> k; // n: size of a, k: # of total insertions for ( int i = 0 ; i < n; ++ i) cin >> a[i]; int lb = 1 , rb = a[n - 1 ] - a[ 0 ]; // total difference while (lb < rb) { int mb = (lb + rb) / 2 ; // guess the most optimal difference is mb int k2 = 0 ; for ( int i = 1 ; i < n; ++ i) { int d = a[i] - a[i - 1 ]; k2 += (d + mb - 1 ) / mb - 1 ; // # of all inserted class if mb is the optimal } if (k2 <= k) // if less than k, we can potentially decrease the difficulity rb = mb; else // or we have to increase the difficulity lb = mb + 1 ; } cout << lb << \" \\n \" ; } int main () { ios :: sync_with_stdio( 0 ); cin.tie( 0 ); int t, i = 1 ; cin >> t; while (t -- ) { cout << \"Case #\" << i << \": \" ; solve(); ++ i; } }","title":"Binary search"},{"location":"Google%20Kick%20Start/2020---round-a/#bundling","text":"Pip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example: The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is 'RA'). The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is 'FIRE'). The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ''). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip's strings. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 2 \u2264 N \u2264 105. 2 \u2264 K \u2264 N. K divides N. Each of Pip's strings contain at least one character. Each string consists only of letters from A to Z. Test set 1 Each of Pip's strings contain at most 5 characters. Test set 2 The total number of characters in Pip's strings across all test cases is at most 2 \u00d7 106. Samples Input 1 2 2 2 KICK START 8 2 G G GO GO GOO GOO GOOO GOOO Output 1 Case #1: 0 Case #2: 10 Input 2 1 6 3 RAINBOW FIREBALL RANK RANDOM FIREWALL FIREFIGHTER Output 2 Case #1: 6 Sample #1 In Case #1, Pip can achieve a total score of 0 by make the groups: {KICK, START}, with a score of 0. In Case #2, Pip can achieve a total score of 10 by make the groups: {G, G}, with a score of 1. {GO, GO}, with a score of 2. {GOO, GOO}, with a score of 3. {GOOO, GOOO}, with a score of 4. Sample #2 In Case #1, Pip can achieve a total score of 6 by make the groups: {RAINBOW, RANK, RANDOM}, with a score of 2. {FIREBALL, FIREWALL, FIREFIGHTER}, with a score of 4.","title":"Bundling"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis_3","text":"Assume each bundle has prefix as P_i P_i , and the CNT_i CNT_i represents the number of strings shares that prefix. Assign k string to the bundle, now we have CNT_i \\% k CNT_i \\% k string left. Do the same thing for preifx P_{i + 1} P_{i + 1} which has a CNT_{i+1} < CNT_i CNT_{i+1} < CNT_i , now we have CNT_{i + 1} \\% k CNT_{i + 1} \\% k left. Keep this procedure until CNT_j \\% k == 0 CNT_j \\% k == 0 which means all the string have assigned to a particular bundle. Now the problem becomes finding the total count. Split into n/k groups, and each group has k strings. Use trie to find the common prefix. Each trie node has 26 children nodes, and one cnt int for counting the number of prefix exist by the current node. Insert: insert into trie and update the cnt for each ending character node. Query: just search from the root of the trie and traverse through the last level of the trie, because all the nodes from root has a count that represent the occurance of word that is ended with node character.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code_3","text":"#include <bits/stdc++.h> using namespace std; #define endl \"\\n\" #define int long long const int N = 1e5 + 5 ; typedef struct data { data * bit[ 26 ]; int cnt = 0 ; }trie; trie * head; void insert (string & s) { trie * cur = head; for ( auto & it:s) { int b = it - 'A' ; if ( ! cur -> bit[b]) cur -> bit[b] = new trie(); // create new node if not exist cur = cur -> bit[b]; // proceed through next character cur -> cnt ++ ; // end with current character } } int n, k; string s[N]; int query (trie * cur) { if ( ! cur) return 0 ; int ans = (cur -> cnt / k); // there are k words each, so there are k times repeat counts for ( int i = 0 ; i <= 25 ; i ++ ) if (cur -> bit[i]) ans += query(cur -> bit[i]); // proceeds to next level and check the count return ans; } int main () { int t; cin >> t; int tc = 0 ; while (t -- ) { head = new trie(); tc ++ ; cin >> n >> k; for ( int i = 1 ; i <= n; i ++ ) { cin >> s[i]; insert(s[i]); } int ans = query(head); cout << \"Case #\" << tc << \": \" << ans << endl; } return 0 ; }","title":"Code"},{"location":"Java/array%2C-class-and-objects/","text":"1D/2D Array constructor initialization read/write length/dimension traversal Main Function public static void main(String[] args) signacture OOD or OOP class, object, reference, dereference Student tom = new Student(\"Tom\", 5, 4.0); Declaration Instantiation Initialization Assignment Array \u00b6 1-D array \u00b6 create: int[] array = new int[10]; once create, size cannot be modified int [] numbers = new int [] { 1 , 2 , 3 , 4 }; int num = numbers [ 2 ] ; number [ 4 ] = 15 ; int size = numbers. length ; for ( int index = 0 ; index < number. length ; ++ index) {} for ( int num : numbers) {} Max value \u00b6 Integer. MAX_VALUE Integer. MIN_VALUE Insert \u00b6 public int [] reverse ( int [] arr) { int [] new_arr = new int [ arr. length - 1 ] ; for ( int i = 0 ; i < position; ++ i) { new_arr [ i ] = arr [ i ] ; } new_arr [ position ] = element; for ( int i = position; i < arr. length ; ++ i) { new_arr [ i + 1 ] = arr [ i ] ; } return new_arr; } Reverse Array \u00b6 swap public int [] reverse ( int [] arr) { int i = 0 , j = arr. length - 1 ; while (i < j) { int tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp; i ++ , j -- ; } return arr; } 2-D Array \u00b6 create \u00b6 int [][] matrix = new int [][] {{ 2 , 1 },{ 4 , 7 },{ 5 , 9 }}; int [] firstRow = matrix [ 0 ] ; int firstElementOfSecondRow = matrix [ 1 ][ 0 ] ; int rows = matrix. length ; // (row = 3 because the array has 3 elements) int cols = matrix [ 0 ] . length ; calculate \"g\": the diagonal -- has to be square matrix \u00b6 public int [] reverse ( int [][] matrix) { int g = 0 ; for ( int i = 0 ; i < matrix. length ; ++ i) { g += matrix [ i ][ i ] ; } return g; } calculate sum of two matrix -- has to be same dimension \u00b6 public int [][] reverse ( int [][] matrix1, int [][] matrix2) { int row = matrix1. length ; int col = matrix1 [ 0 ] . length ; int [][] result = new int [][] ; for ( int i = 0 ; i < row; ++ i) { for ( int j = 0 ; j < col; ++ j) { result [ i ][ j ] = matrix1 [ i ][ j ] + matrix2 [ i ][ j ] ; } } return result; } Main Function \u00b6 public static void main (String [] args) { System. out . println ( \"hello world.\" ); } OOD or OOP \u00b6 Memory Layout \u00b6 Stack: local variable (in function or scope) Heap: all the object","title":"Array, class and objects"},{"location":"Java/array%2C-class-and-objects/#array","text":"","title":"Array"},{"location":"Java/array%2C-class-and-objects/#1-d-array","text":"create: int[] array = new int[10]; once create, size cannot be modified int [] numbers = new int [] { 1 , 2 , 3 , 4 }; int num = numbers [ 2 ] ; number [ 4 ] = 15 ; int size = numbers. length ; for ( int index = 0 ; index < number. length ; ++ index) {} for ( int num : numbers) {}","title":"1-D array"},{"location":"Java/array%2C-class-and-objects/#max-value","text":"Integer. MAX_VALUE Integer. MIN_VALUE","title":"Max value"},{"location":"Java/array%2C-class-and-objects/#insert","text":"public int [] reverse ( int [] arr) { int [] new_arr = new int [ arr. length - 1 ] ; for ( int i = 0 ; i < position; ++ i) { new_arr [ i ] = arr [ i ] ; } new_arr [ position ] = element; for ( int i = position; i < arr. length ; ++ i) { new_arr [ i + 1 ] = arr [ i ] ; } return new_arr; }","title":"Insert"},{"location":"Java/array%2C-class-and-objects/#reverse-array","text":"swap public int [] reverse ( int [] arr) { int i = 0 , j = arr. length - 1 ; while (i < j) { int tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp; i ++ , j -- ; } return arr; }","title":"Reverse Array"},{"location":"Java/array%2C-class-and-objects/#2-d-array","text":"","title":"2-D Array"},{"location":"Java/array%2C-class-and-objects/#create","text":"int [][] matrix = new int [][] {{ 2 , 1 },{ 4 , 7 },{ 5 , 9 }}; int [] firstRow = matrix [ 0 ] ; int firstElementOfSecondRow = matrix [ 1 ][ 0 ] ; int rows = matrix. length ; // (row = 3 because the array has 3 elements) int cols = matrix [ 0 ] . length ;","title":"create"},{"location":"Java/array%2C-class-and-objects/#calculate-g-the-diagonal-has-to-be-square-matrix","text":"public int [] reverse ( int [][] matrix) { int g = 0 ; for ( int i = 0 ; i < matrix. length ; ++ i) { g += matrix [ i ][ i ] ; } return g; }","title":"calculate \"g\": the diagonal -- has to be square matrix"},{"location":"Java/array%2C-class-and-objects/#calculate-sum-of-two-matrix-has-to-be-same-dimension","text":"public int [][] reverse ( int [][] matrix1, int [][] matrix2) { int row = matrix1. length ; int col = matrix1 [ 0 ] . length ; int [][] result = new int [][] ; for ( int i = 0 ; i < row; ++ i) { for ( int j = 0 ; j < col; ++ j) { result [ i ][ j ] = matrix1 [ i ][ j ] + matrix2 [ i ][ j ] ; } } return result; }","title":"calculate sum of two matrix -- has to be same dimension"},{"location":"Java/array%2C-class-and-objects/#main-function","text":"public static void main (String [] args) { System. out . println ( \"hello world.\" ); }","title":"Main Function"},{"location":"Java/array%2C-class-and-objects/#ood-or-oop","text":"","title":"OOD or OOP"},{"location":"Java/array%2C-class-and-objects/#memory-layout","text":"Stack: local variable (in function or scope) Heap: all the object","title":"Memory Layout"},{"location":"Java/common-problem/","text":"Java pass-by-value \u00b6 reassignment int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b = new int [] { 2 }; // if print a, it will output 1 int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b [ 0 ] = 2 ; // if print a, it will output 2 pass in as parameter // anything \"new\" in function will stay local and will not modify the outter scope variable public void reassign ( int [] array) { array = new int [] { 2 }; } public void modify ( int [] array) { array [ 0 ] = 2 ; } public int [] returnArray ( int [] array) { array = new int [] { 2 }; return array; } public void foo ( int [] array) { array [ 0 ] = 2 ; // output this value 2 array = new int [] { 3 }; array [ 0 ] = 4 ; } public void foo2 ( int [] array) { array [ 0 ] = 2 ; array [ 0 ] = 4 ; // output 4 array = new int [] { 3 }; } public static void main (String [] args) { int [] array = new int [] { 1 }; reassign(array); //what\u2019s the result? 1 modify(array); //what\u2019s the result? 2 (ignore previous statement) array = returnArray(array); //what\u2019s the result? 2 (ignore previous statement) } debug \u00b6 public class Solution { public void reverse ( int [] array) { int [] array1 = new int [ array. length ] ; for ( int i = 0 ; i < array. length ; i = i + 1 ) { array1 [ i ]= array [ array. length - 1 - i ] ; } array = array1; // Write your solution here } Problem: Give an array list of integer, calculate the sum of squares of all its elements. Note: return 0 if the list is null or empty. Example: list = {1,2,3} \u2192 returns 14 (14=1 1+2 2+3*3) public class Solution { public int sumOfSquare (List < Integer > list) { if (list == null || list. isEmpty ()) { return 0 ; } int sum = 0 ; for ( int i = 0 ; i < list. size (); i ++ ) { sum += list. get (i) * list. get (i); } return sum; } Misc \u00b6 String s = 4 + \"aa\"; // will print 4aa, because 4.toString() + \"aa\", however it won't work in c++ low -> high precision: will cast implicitly (no need to add (long) for example). high -> low precision: need explict cast","title":"Common problem"},{"location":"Java/common-problem/#java-pass-by-value","text":"reassignment int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b = new int [] { 2 }; // if print a, it will output 1 int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b [ 0 ] = 2 ; // if print a, it will output 2 pass in as parameter // anything \"new\" in function will stay local and will not modify the outter scope variable public void reassign ( int [] array) { array = new int [] { 2 }; } public void modify ( int [] array) { array [ 0 ] = 2 ; } public int [] returnArray ( int [] array) { array = new int [] { 2 }; return array; } public void foo ( int [] array) { array [ 0 ] = 2 ; // output this value 2 array = new int [] { 3 }; array [ 0 ] = 4 ; } public void foo2 ( int [] array) { array [ 0 ] = 2 ; array [ 0 ] = 4 ; // output 4 array = new int [] { 3 }; } public static void main (String [] args) { int [] array = new int [] { 1 }; reassign(array); //what\u2019s the result? 1 modify(array); //what\u2019s the result? 2 (ignore previous statement) array = returnArray(array); //what\u2019s the result? 2 (ignore previous statement) }","title":"Java pass-by-value"},{"location":"Java/common-problem/#debug","text":"public class Solution { public void reverse ( int [] array) { int [] array1 = new int [ array. length ] ; for ( int i = 0 ; i < array. length ; i = i + 1 ) { array1 [ i ]= array [ array. length - 1 - i ] ; } array = array1; // Write your solution here } Problem: Give an array list of integer, calculate the sum of squares of all its elements. Note: return 0 if the list is null or empty. Example: list = {1,2,3} \u2192 returns 14 (14=1 1+2 2+3*3) public class Solution { public int sumOfSquare (List < Integer > list) { if (list == null || list. isEmpty ()) { return 0 ; } int sum = 0 ; for ( int i = 0 ; i < list. size (); i ++ ) { sum += list. get (i) * list. get (i); } return sum; }","title":"debug"},{"location":"Java/common-problem/#misc","text":"String s = 4 + \"aa\"; // will print 4aa, because 4.toString() + \"aa\", however it won't work in c++ low -> high precision: will cast implicitly (no need to add (long) for example). high -> low precision: need explict cast","title":"Misc"},{"location":"Java/control-flow-and-methods/","text":"Method overloading \u00b6 method name is the same, but parameter type list is different 1. different types 2. different num of parameters 3. different order Notes \u00b6 return type cannot be used to identify which function to use \u00b6 public class test { public static int add ( double a, double b) { return ( int ) (a + b); } public static double add ( double a, double b) { return (a + b); } public static void main (String [] args) { double a = 1.3 , b = 2.4 ; // int c = add(a, b); System. out . println (add(a, b)); } }","title":"Control flow and methods"},{"location":"Java/control-flow-and-methods/#method-overloading","text":"method name is the same, but parameter type list is different 1. different types 2. different num of parameters 3. different order","title":"Method overloading"},{"location":"Java/control-flow-and-methods/#notes","text":"","title":"Notes"},{"location":"Java/control-flow-and-methods/#return-type-cannot-be-used-to-identify-which-function-to-use","text":"public class test { public static int add ( double a, double b) { return ( int ) (a + b); } public static double add ( double a, double b) { return (a + b); } public static void main (String [] args) { double a = 1.3 , b = 2.4 ; // int c = add(a, b); System. out . println (add(a, b)); } }","title":"return type cannot be used to identify which function to use"},{"location":"Java/css/","text":"@ CHARSET \"UTF-8\" ; html { height : 100 % ; } hr { margin-right : 10 px ; margin-left : 10 px ; height : 2 px ; background : url( http://ibrahimjabbari.com/english/images/hr-11.png ) repeat-x 0 0 ; border-top : 1 px dashed #866760 ; } table { border-radius : 10 px ; border-collapse : collapse ; } th { background-color : #7c7dca ; color : white ; border-bottom : 2 px dashed white ; } input[type=text] : focus { background-color : #d9e6e5 ; } input[type=text] : hover { width : 170 px ; } input[type=text] { width : 200 px ; box-sizing : border-box ; border : 2 px solid #ccc ; border-radius : 4 px ; font-size : 16 px ; padding : 5 px 5 px 5 px 10 px ; -webkit-transition : width 0.4 s ease-in-out ; transition : width 0.4 s ease-in-out ; } body { background-image : linear-gradient( to bottom , rgba( 33 , 97 , 140 , 0.3 ) 0 % ,rgba( 213 , 219 , 219 , 0.3 ) 100 % ); width : 100 % ; background-repeat : no-repeat ; background-size : cover ; background-attachment : fixed ; } th { font-family : 'Macondo' , Cursive; } a : hover { background-color : rgba( 230 , 230 , 230 , 0.6 ); } a { text-decoration : none ; color : #5f609a ; } #leftTd{ position : fixed ; } input { animation :showInput 3 s ease 1 forwards ; } #centerTd{ animation :showTable 1 s ease 1 forwards ; margin-bottom : 100 px ; } #uscImage{ -webkit-animation :spin 8 s linear infinite ; -moz-animation :spin 8 s linear infinite ; animation :spin 8 s linear infinite ; } @ keyframes spin { 100% { -webkit-transform : rotate( 360 deg ); transform :rotate( 360 deg ); } } @ -moz-keyframes spin { 100% { -moz-transform : rotate( 360 deg ); } } @ -webkit-keyframes spin { 100% { -webkit-transform : rotate( 360 deg ); } } @ -webkit-keyframes showInput { 0% { opacity : 0 ; width : 100 px ; } 50% { opacity : 0.5 ; width : 90 px ; } 100% { opacity : 1 ; width : 100 px ; } } @ -webkit-keyframes showTable { 0% { opacity : 0 ; } 50% { opacity : 0.5 ; } 100% { opacity : 1 ; } }","title":"Css"},{"location":"Java/primitive-types-and-basic-operations/","text":"Primitive Types \u00b6 char 2 bytes 2's complement \u00b6 flip all digit and +1 Default Value \u00b6 Instance field: 0 false null Local variable: not allow -> will throw compile exception","title":"Primitive types and basic operations"},{"location":"Java/primitive-types-and-basic-operations/#primitive-types","text":"char 2 bytes","title":"Primitive Types"},{"location":"Java/primitive-types-and-basic-operations/#2s-complement","text":"flip all digit and +1","title":"2's complement"},{"location":"Java/primitive-types-and-basic-operations/#default-value","text":"Instance field: 0 false null Local variable: not allow -> will throw compile exception","title":"Default Value"},{"location":"Java/serialization/","text":"Compare two Files containing two integer Complete the method below to read two integers from the input file, compare them, and write true or false into the output file based on whether the values are the same or not. // inputFile: path to input file; outputFile: path to output file public void compareValues (String inputFile, String outputFile) { Scanner scan = null ; PrintWriter pw = null ; try { scan = new Scanner( new FileReader(inputFile)); int num1 = scan. nextInt (); int num2 = scan. nextInt (); pw = new PrintWriter( new FileWriter(outputFile)); if (num1 == num2) { pw. println ( \"true\" ); } else { pw. println ( \"false\" ); } } catch (FileNotFoundException fnfe) { System. out . println ( \"fnfe: \" + fnfe. getMessage ()); } catch (IOException ioe) { System. out . println ( \"ioe: \" + ioe. getMessage ()); } finally { if (pw != null ) { pw. close (); } if (scan != null ) { scan. close (); } } } Scanner takes in a FileReader instannce FileReader takes in a path string ChatRoom Practice -- Serialization in network \u00b6 main thread for connection, and each thread with each client PrintWriter for printing string","title":"Serialization"},{"location":"Java/serialization/#chatroom-practice-serialization-in-network","text":"main thread for connection, and each thread with each client PrintWriter for printing string","title":"ChatRoom Practice -- Serialization in network"},{"location":"Java/tips/","text":"Min and Max value \u00b6 int: Integer.MAX_VALUE ( 2^{31} - 1 2^{31} - 1 ), Integer.MIN_VALUE ( -2^{31} -2^{31} )","title":"Tips"},{"location":"Java/tips/#min-and-max-value","text":"int: Integer.MAX_VALUE ( 2^{31} - 1 2^{31} - 1 ), Integer.MIN_VALUE ( -2^{31} -2^{31} )","title":"Min and Max value"},{"location":"Lai/behavior-questions/","text":"Rule of thumb \u00b6 Don't confront your interviewers How to talk when you have nothing to say, say nothing never criticize your previous employers calm and reasonable Say something for a reason Praise someone Criticie someone (how?) CART: clarify, assumption, result, test cases Q1: tell me about yourself \u00b6 Don't just say yourself Name, edu Skills: primary programming language, projects, experiences, past internship. Thank you Other variants: - tell me your weakness (e.g. weakness: cannot do multiple things at the same time. in the future, learn how to prioritize and analyze dependencies.) - 2 nd chance problems - Retrospection - E.g. Biggest failure during your college/work - Key points: how to avoid/address the same problems in the future. Q2: when you have different opinions from your colleagues \u00b6 Scenarios Communication how when where keep in mind: say something for a reason, praise and criticize someone what if? backup solutions how to express yourself? (e.g. how to do prep for meetings, 1 on 1?) e.g. we might have difference knowledge base, so I will try to share our knowledge together. focus on things but not on people Q3: When you have limited time avaliable to finish your project. Quality vs. Speed \u00b6 consider tradeoffs for different tasks, use a quantative way to analyze the data variant 1: provide an e.g. scenario in which you made a quick decision under pressure variant 2: write an email to your manager on how to explain why you missed the deadline Q4: what is your career plan for the next 5 years \u00b6 show self-motivation, start from small/short term goal to big/long term goal. Q5: please tell me one of the most challenging projects you have accomplished \u00b6 technical challenge + human resource (team work, work with mentor, verify tasks, etc.) variant: mistake you have done first tell what you ahfve done wrong Q6: do you have any questions for me \u00b6 tech stack, I may have some similar skills what's your most challenge project Others \u00b6 1, \u5f00\u4f1a\u4e4b\u524d\uff0c\u4e00\u5b9a\u51c6\u5907\u597d 2\uff0c\u4e00\u5b9a\u8981\u7cfb\u7edf\u6027\u7684\u601d\u8003\uff0cconstruction way thinking 3\uff0c\u628a\u505a\u4e8b\u50cf\u7f16\u7a0b\u4e00\u6837\u89c4\u5212 4\uff0c\u5343\u4e07\u4e0d\u8981\u548c\u9762\u8bd5\u5b98\u603c\uff0c\u6709\u53ef\u80fd\u662f\u538b\u529b\u6d4b\u8bd5\uff01\uff01 5\uff0c*** \u5f53\u6ca1\u6709\u4efb\u4f55nice\u7684\u8bdd\u53bb\u8bf4\u7684\u65f6\u5019\uff0c\u9009\u62e9\u4e0d\u8981\u8bf4 6\uff0c\u4ecb\u7ecd\u81ea\u5df1\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u53ea\u8bf4\u81ea\u5df1\uff0c\u6709\u4e0d\u5c11\u5751\uff01\uff01\uff081\uff09\u540d\u5b57\uff0c\u548c\u6559\u80b2\u80cc\u666f 2\uff09\u4ecb\u7ecd\u4e3b\u8981\u7684\u6280\u80fd\u80cc\u666f 3\uff09Thank you\uff09 7\uff0c\u4ecb\u7ecd\u5f31\u70b9\uff1f 8\uff0c \u89c2\u70b9\u4e0d\u540c\uff1f\u5148\u542c\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u540c\uff0c\u7136\u540e\u5bf9\u6bd4\u4e0d\u540c\uff0c\u7136\u540e\u518d\u5206\u6790\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u4e00\u5b9a\u4e0d\u80fd\u4e00\u5f00\u59cb\u5c31\u7ed9\u51fa\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u8fd9\u6837\u592a\u5bf9\u7acb\u4e86\uff01\uff01 9\uff0c\u6279\u8bc4\u4e00\u4ef6\u4e8b\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u6279\u8bc4\u8fd9\u4ef6\u4e8b\uff0c\u8868\u626c\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u8868\u626c\u8fd9\u4e2a\u4eba\uff08\u6279\u8bc4\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u7ed9\u4eba\u7559\u9762\u5b50\uff01\uff0910 \uff0c \u4efb\u4f55\u4e8b\u60c5\u90fd\u6709trade off\uff0c\u8981\u91cf\u5316\u5206\u6790 11\uff0c\u63a5\u4e0b\u67655\u5e74\u7684\u5de5\u4f5c\u8ba1\u5212\uff1f\u4e00\u5b9a\u8981\u4f53\u73b0\u51faself motivated 12\uff0cmost challenging \uff1f 13\uff0c\u5f53\u53d1\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u8bda\u6073\u7684\u544a\u8bc9\u9762\u8bd5\u5b98\uff0c\u54ea\u91cc\u9519\uff0c\u54ea\u91cc\u5bf9\uff01\uff01 14\uff0cmanager\u5347\u4ec0\u4e48\u6837\u7684\u4eba\uff1f\u628a\u6700\u91cd\u8981\u7684\u5de5\u4f5c\u7ed9\u8c01\uff0c\u8c01\u5c31\u4f1a\u5347\u804c 15\uff0c\u597d\u7684reputation\u662f\u4e00\u6b21\u6b21\u6210\u529f\u79ef\u7d2f\u8d77\u6765\u7684\uff01\uff01 16\uff0c\u5f53\u5728stressful situation\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u5411\u7740\u81ea\u5df1\u4ef7\u503c\u89c2\u7684\u65b9\u5411 17\uff0c\u9ad8\u5c14\u592b\u7403\u95ee\u9898\uff1fC\uff1a\u5728\u54ea\u513f\uff0c\u5c3a\u5bf8 A\uff1a\u7cbe\u5ea6\u8981\u6c42 R\uff1a\u5982\u4f55\u89e3\u51b3 T\uff1a\u600e\u4e48\u53bb\u9a8c\u8bc1 18\uff0c\u7528\u529b\uff0c\u7528\u8111\uff0c\u7528\u5fc3 19\uff0c work with smart people\uff0charderrrrrr\uff08\u673a\u4f1a\u4e0d\u80fd\u63a7\u5236\uff0c\u4f46\u662f\u52aa\u529b\u53ef\u4ee5\uff01\uff0920\uff0c\u4e00\u5b9a\u8981\u5bf9\u5f97\u8d77\u522b\u4eba\u7684\u4fe1\u4efb ***** 21\uff0c\u300a\u6052\u5fc3\u300b22\uff0c\u56f0\u96be\u7684\u65f6\u5019\u6709\u591a\u4eba\u613f\u610f\u5e2e\u52a9\u4f60\uff0c\u505a\u4e8b\u7684\u65f6\u5019\uff0c\u6709\u591a\u5c11\u4eba\u8ffd\u968f\u4f60 23\uff0cleadership\u7684\u5206\u91cf\u5f88\u91cd\uff0c\u7528reputation\u53bb\u5efa\u7acb*** 24\uff0c\u62a2\u7740\u4e70\u5355\uff0c\u4e5f\u633a\u597d\u768425\uff0c\u5343\u4e07\u4e0d\u8981\u635f\u574f\u522b\u4eba\u7684\u6838\u5fc3\u5229\u76ca\uff0126\uff0c\u4e00\u5b9a\u8981\u63d0\u4f9b\u5efa\u8bbe\u6027\u610f\u89c1\uff0c\u8fd9\u6837\u80fd\u5e2e\u522b\u4eba\u53d8\u5f97\u66f4\u597d 27\uff0c1day\uff1a\u611f\u8c22\u4fe1 1week\uff1a\u8d8a\u4e00\u4e2a\u4f1a\uff0c\u8ba8\u8bba\u4e00\u4e0b\u81ea\u5df1\u7684\u90e8\u5206 1month\uff1a\u5c3d\u91cf\u62a5\u559c\uff0c\u8bf4\u81ea\u5df1\u7684\u6210\u7ee9\uff0c\u76ee\u6807 1year\uff1a\u4e70\u4e00\u4e2a\u7cbe\u7f8e\u7684thanks card\uff0c\u63d0\u51fa\u5347\u804c\u7684\u8bc9\u6c42 28\uff0c\u4ec0\u4e48\u95ee\u9898\u662f\u597d\u95ee\u9898\uff1f29\uff0c***\u4e00\u5b9a\u8981\u627e\u7684mentor\uff08\u7ed9\u81ea\u5df1\u5efa\u8bbe\u6027\u610f\u89c1\u7684\u4eba\uff0930\uff0c\u53cd\u601d\uff0c\u8ba1\u5212\uff0c\u884c\u52a8 31\uff0cBetter Person","title":"Behavior questions"},{"location":"Lai/behavior-questions/#rule-of-thumb","text":"Don't confront your interviewers How to talk when you have nothing to say, say nothing never criticize your previous employers calm and reasonable Say something for a reason Praise someone Criticie someone (how?) CART: clarify, assumption, result, test cases","title":"Rule of thumb"},{"location":"Lai/behavior-questions/#q1-tell-me-about-yourself","text":"Don't just say yourself Name, edu Skills: primary programming language, projects, experiences, past internship. Thank you Other variants: - tell me your weakness (e.g. weakness: cannot do multiple things at the same time. in the future, learn how to prioritize and analyze dependencies.) - 2 nd chance problems - Retrospection - E.g. Biggest failure during your college/work - Key points: how to avoid/address the same problems in the future.","title":"Q1: tell me about yourself"},{"location":"Lai/behavior-questions/#q2-when-you-have-different-opinions-from-your-colleagues","text":"Scenarios Communication how when where keep in mind: say something for a reason, praise and criticize someone what if? backup solutions how to express yourself? (e.g. how to do prep for meetings, 1 on 1?) e.g. we might have difference knowledge base, so I will try to share our knowledge together. focus on things but not on people","title":"Q2: when you have different opinions from your colleagues"},{"location":"Lai/behavior-questions/#q3-when-you-have-limited-time-avaliable-to-finish-your-project-quality-vs-speed","text":"consider tradeoffs for different tasks, use a quantative way to analyze the data variant 1: provide an e.g. scenario in which you made a quick decision under pressure variant 2: write an email to your manager on how to explain why you missed the deadline","title":"Q3: When you have limited time avaliable to finish your project. Quality vs. Speed"},{"location":"Lai/behavior-questions/#q4-what-is-your-career-plan-for-the-next-5-years","text":"show self-motivation, start from small/short term goal to big/long term goal.","title":"Q4: what is your career plan for the next 5 years"},{"location":"Lai/behavior-questions/#q5-please-tell-me-one-of-the-most-challenging-projects-you-have-accomplished","text":"technical challenge + human resource (team work, work with mentor, verify tasks, etc.) variant: mistake you have done first tell what you ahfve done wrong","title":"Q5: please tell me one of the most challenging projects you have accomplished"},{"location":"Lai/behavior-questions/#q6-do-you-have-any-questions-for-me","text":"tech stack, I may have some similar skills what's your most challenge project","title":"Q6: do you have any questions for me"},{"location":"Lai/behavior-questions/#others","text":"1, \u5f00\u4f1a\u4e4b\u524d\uff0c\u4e00\u5b9a\u51c6\u5907\u597d 2\uff0c\u4e00\u5b9a\u8981\u7cfb\u7edf\u6027\u7684\u601d\u8003\uff0cconstruction way thinking 3\uff0c\u628a\u505a\u4e8b\u50cf\u7f16\u7a0b\u4e00\u6837\u89c4\u5212 4\uff0c\u5343\u4e07\u4e0d\u8981\u548c\u9762\u8bd5\u5b98\u603c\uff0c\u6709\u53ef\u80fd\u662f\u538b\u529b\u6d4b\u8bd5\uff01\uff01 5\uff0c*** \u5f53\u6ca1\u6709\u4efb\u4f55nice\u7684\u8bdd\u53bb\u8bf4\u7684\u65f6\u5019\uff0c\u9009\u62e9\u4e0d\u8981\u8bf4 6\uff0c\u4ecb\u7ecd\u81ea\u5df1\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u53ea\u8bf4\u81ea\u5df1\uff0c\u6709\u4e0d\u5c11\u5751\uff01\uff01\uff081\uff09\u540d\u5b57\uff0c\u548c\u6559\u80b2\u80cc\u666f 2\uff09\u4ecb\u7ecd\u4e3b\u8981\u7684\u6280\u80fd\u80cc\u666f 3\uff09Thank you\uff09 7\uff0c\u4ecb\u7ecd\u5f31\u70b9\uff1f 8\uff0c \u89c2\u70b9\u4e0d\u540c\uff1f\u5148\u542c\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u540c\uff0c\u7136\u540e\u5bf9\u6bd4\u4e0d\u540c\uff0c\u7136\u540e\u518d\u5206\u6790\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u4e00\u5b9a\u4e0d\u80fd\u4e00\u5f00\u59cb\u5c31\u7ed9\u51fa\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u8fd9\u6837\u592a\u5bf9\u7acb\u4e86\uff01\uff01 9\uff0c\u6279\u8bc4\u4e00\u4ef6\u4e8b\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u6279\u8bc4\u8fd9\u4ef6\u4e8b\uff0c\u8868\u626c\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u8868\u626c\u8fd9\u4e2a\u4eba\uff08\u6279\u8bc4\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u7ed9\u4eba\u7559\u9762\u5b50\uff01\uff0910 \uff0c \u4efb\u4f55\u4e8b\u60c5\u90fd\u6709trade off\uff0c\u8981\u91cf\u5316\u5206\u6790 11\uff0c\u63a5\u4e0b\u67655\u5e74\u7684\u5de5\u4f5c\u8ba1\u5212\uff1f\u4e00\u5b9a\u8981\u4f53\u73b0\u51faself motivated 12\uff0cmost challenging \uff1f 13\uff0c\u5f53\u53d1\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u8bda\u6073\u7684\u544a\u8bc9\u9762\u8bd5\u5b98\uff0c\u54ea\u91cc\u9519\uff0c\u54ea\u91cc\u5bf9\uff01\uff01 14\uff0cmanager\u5347\u4ec0\u4e48\u6837\u7684\u4eba\uff1f\u628a\u6700\u91cd\u8981\u7684\u5de5\u4f5c\u7ed9\u8c01\uff0c\u8c01\u5c31\u4f1a\u5347\u804c 15\uff0c\u597d\u7684reputation\u662f\u4e00\u6b21\u6b21\u6210\u529f\u79ef\u7d2f\u8d77\u6765\u7684\uff01\uff01 16\uff0c\u5f53\u5728stressful situation\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u5411\u7740\u81ea\u5df1\u4ef7\u503c\u89c2\u7684\u65b9\u5411 17\uff0c\u9ad8\u5c14\u592b\u7403\u95ee\u9898\uff1fC\uff1a\u5728\u54ea\u513f\uff0c\u5c3a\u5bf8 A\uff1a\u7cbe\u5ea6\u8981\u6c42 R\uff1a\u5982\u4f55\u89e3\u51b3 T\uff1a\u600e\u4e48\u53bb\u9a8c\u8bc1 18\uff0c\u7528\u529b\uff0c\u7528\u8111\uff0c\u7528\u5fc3 19\uff0c work with smart people\uff0charderrrrrr\uff08\u673a\u4f1a\u4e0d\u80fd\u63a7\u5236\uff0c\u4f46\u662f\u52aa\u529b\u53ef\u4ee5\uff01\uff0920\uff0c\u4e00\u5b9a\u8981\u5bf9\u5f97\u8d77\u522b\u4eba\u7684\u4fe1\u4efb ***** 21\uff0c\u300a\u6052\u5fc3\u300b22\uff0c\u56f0\u96be\u7684\u65f6\u5019\u6709\u591a\u4eba\u613f\u610f\u5e2e\u52a9\u4f60\uff0c\u505a\u4e8b\u7684\u65f6\u5019\uff0c\u6709\u591a\u5c11\u4eba\u8ffd\u968f\u4f60 23\uff0cleadership\u7684\u5206\u91cf\u5f88\u91cd\uff0c\u7528reputation\u53bb\u5efa\u7acb*** 24\uff0c\u62a2\u7740\u4e70\u5355\uff0c\u4e5f\u633a\u597d\u768425\uff0c\u5343\u4e07\u4e0d\u8981\u635f\u574f\u522b\u4eba\u7684\u6838\u5fc3\u5229\u76ca\uff0126\uff0c\u4e00\u5b9a\u8981\u63d0\u4f9b\u5efa\u8bbe\u6027\u610f\u89c1\uff0c\u8fd9\u6837\u80fd\u5e2e\u522b\u4eba\u53d8\u5f97\u66f4\u597d 27\uff0c1day\uff1a\u611f\u8c22\u4fe1 1week\uff1a\u8d8a\u4e00\u4e2a\u4f1a\uff0c\u8ba8\u8bba\u4e00\u4e0b\u81ea\u5df1\u7684\u90e8\u5206 1month\uff1a\u5c3d\u91cf\u62a5\u559c\uff0c\u8bf4\u81ea\u5df1\u7684\u6210\u7ee9\uff0c\u76ee\u6807 1year\uff1a\u4e70\u4e00\u4e2a\u7cbe\u7f8e\u7684thanks card\uff0c\u63d0\u51fa\u5347\u804c\u7684\u8bc9\u6c42 28\uff0c\u4ec0\u4e48\u95ee\u9898\u662f\u597d\u95ee\u9898\uff1f29\uff0c***\u4e00\u5b9a\u8981\u627e\u7684mentor\uff08\u7ed9\u81ea\u5df1\u5efa\u8bbe\u6027\u610f\u89c1\u7684\u4eba\uff0930\uff0c\u53cd\u601d\uff0c\u8ba1\u5212\uff0c\u884c\u52a8 31\uff0cBetter Person","title":"Others"},{"location":"Lai/binary-search/","text":"Binary Search \u00b6 2 Principles: 1. Guarantee that the search space decreases over time (after each iteration). // prevent while \"true\" 2. Guarantee that the target (if exist) cannot be ruled out accidentally, when we change the value of Left or Right. while (l <= r): 1 element can get in while (l < r): 1 element cannot get in l = l + 1: eleminate l for next iteration l = l: check if 1 element will cause inf Classic Binary Search \u00b6 int binarySearch (vector < int >& a, int target) { int left = 0 , right = a.size() - 1 ; while (left <= right) { // <= int mid = left + right >> 1 ; if (a[mid] == target) return mid; else if (a[mid] < target) left = mid + 1 ; else right = mid - 1 ; } return - 1 ; } 2D Space Binary Search \u00b6 1 3 4 6 7 9 10 11 14 17 19 20 target = 11 index = col * row - 1 col = index / size of col row = index % size of col int l = 0 , r = col * row - 1 ; while (l <= r) { int m = (l + r) >> 1 ; int x = m / col, y = m % col; if (a[x][y] == target) return true; else if (a[x][y] < target) l = m + 1 ; else r = m - 1 ; } return false; Closest Element to Target \u00b6 target == 4 [1,2,3,8,9] -> return 3's index which is 2 while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { return m; } else if (a[m] < target) { l = m; } else { r = m; } } if (target - a[l] < a[r] - target) // return the one that is close to target, because there are two elements return l; else return r; First target \u00b6 target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { r = m; // r = m - 1 -> wrong } else if (a[m] < target) { l = m; // l = m + 1 -> right } else { r = m; // r = m - 1 -> right } } if (target == a[l]) // return the left that is equal to target, because it goes from left to right return l; if (target == a[r]) return r; else return - 1 ; Last target (variant for previous one) \u00b6 target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { l = m; // now change to l } else if (a[m] < target) { l = m; } else { r = m; } } if (target == a[r]) // return the right that is equal to target, because it goes from right to left return l; if (target == a[l]) return r; else return - 1 ; Closest k Elements \u00b6 how to return the index of k elements that are closest elements to the target k = 3, target = 5, a = [1,2,3,8,9] return 2,3,8 Solution 1: 1. run binary search to find L and R, where L is the largest value that is smaller than target 2. if l is close to target, l--; else r++ Complexity: O(log(n) + k), what if k \\approx \\approx n? Complexity will be O(n) int largestSmallerEqual (vector < int > arr, int target) { int left = 0 , right = arr.size() - 1 ; while (left < right - 1 ) { int mid = left + right >> 1 ; if (arr[mid] <= target) { left = mid; } else { right = mid; } } if (arr[right] <= target) return right; if (arr[left] <= target) return left; return - 1 ; } vector < int > kClosest(vector < int > arr, int target, int k) { int left = largestSmallerEqual(arr, target); int right = left + 1 ; vector < int > res(k); for ( int i = 0 ; i < k; ++ i) { if (right >= arr.size() || left >= 0 && target - arr[left] <= arr[right] - target) { res[i] = arr[left -- ]; } else { res[i] = arr[right ++ ]; } } return res; } Solution 2: 1. binary search to find L and R 2. using offset to form two more arrays: leftArray = {3 2 1} rightArray = {4 5} then use the method introduced later to find the median. Don't need to preprocess the offset beforehand, but just to update when visited. Solution 3: Moving the sliding window to get the least sum diff. To get the minimal, it has to be the mid point of the sliding window. case 1: x - A[mid] < A[mid + k] - x, need to move window go left -------x----A[mid]-----------------A[mid + k]---------- case 2: x - A[mid] < A[mid + k] - x, need to move window go left again -------A[mid]----x-----------------A[mid + k]---------- case 3: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]------------------x---A[mid + k]---------- case 4: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]---------------------A[mid + k]----x------ vector < int > kClosest(vector < int > a, int x, int k) { int n = a.size(); int l = 0 , r = n - k; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (x - a[m] > a[m + k] - x) l = m + 1 ; else r = m; } auto res = vector < int > (a.begin() + l, a.begin() + l + k ); // this sort is unecessary if there is no requirement for what order to be returned // sort(res.begin(), res.end(), [&](const int l, const int r) { // return abs(l - x) < abs(r - x); // }); return res; } Smallest element that is greater than target \u00b6 sss eee bbb -> same as first target, because we want to find the first b case 1: if input[m] < target: l = m + 1 // l = m also work case 2: if input[m] == target: l = m + 1 // l = m also work case 3: if input[m] > target: r = m // r = m - 1 is wrong, becasue it will wipe out the first b while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] > target) { r = m; } else if (a[m] <= target) { // or just else l = m; } } if (a[l] > target) return l; if (a[r] < target) return r; return - 1 ; Kth smallest in two sorted arrays \u00b6 how to find the median how to find k-th smallest element from them A[] = {2,5,7,10,13} B[] = {1,3,4,13,20,29} k = 5 output = 5 solution 1: two pointer, i++ if a[i] < b[j] else j++, stop until k steps -> O(k) solution 2: binary search Binary Search with Unknown Size \u00b6 dict = {1 3 5 6 .... 1000000}, target = 9999 Assumption: - No dict.size() - if dict.get(index) == null, then we know the size of dict is < index. solution 1: 1. keep jumping out with size = size * 2. until dict.get(index) == null 2. do binary search from 0 to current size Followup: Why not size = size * 10? Which one is better? Don't say an answer (if you don't know yet), but say let's analyze together.","title":"Binary search"},{"location":"Lai/binary-search/#binary-search","text":"2 Principles: 1. Guarantee that the search space decreases over time (after each iteration). // prevent while \"true\" 2. Guarantee that the target (if exist) cannot be ruled out accidentally, when we change the value of Left or Right. while (l <= r): 1 element can get in while (l < r): 1 element cannot get in l = l + 1: eleminate l for next iteration l = l: check if 1 element will cause inf","title":"Binary Search"},{"location":"Lai/binary-search/#classic-binary-search","text":"int binarySearch (vector < int >& a, int target) { int left = 0 , right = a.size() - 1 ; while (left <= right) { // <= int mid = left + right >> 1 ; if (a[mid] == target) return mid; else if (a[mid] < target) left = mid + 1 ; else right = mid - 1 ; } return - 1 ; }","title":"Classic Binary Search"},{"location":"Lai/binary-search/#2d-space-binary-search","text":"1 3 4 6 7 9 10 11 14 17 19 20 target = 11 index = col * row - 1 col = index / size of col row = index % size of col int l = 0 , r = col * row - 1 ; while (l <= r) { int m = (l + r) >> 1 ; int x = m / col, y = m % col; if (a[x][y] == target) return true; else if (a[x][y] < target) l = m + 1 ; else r = m - 1 ; } return false;","title":"2D Space Binary Search"},{"location":"Lai/binary-search/#closest-element-to-target","text":"target == 4 [1,2,3,8,9] -> return 3's index which is 2 while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { return m; } else if (a[m] < target) { l = m; } else { r = m; } } if (target - a[l] < a[r] - target) // return the one that is close to target, because there are two elements return l; else return r;","title":"Closest Element to Target"},{"location":"Lai/binary-search/#first-target","text":"target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { r = m; // r = m - 1 -> wrong } else if (a[m] < target) { l = m; // l = m + 1 -> right } else { r = m; // r = m - 1 -> right } } if (target == a[l]) // return the left that is equal to target, because it goes from left to right return l; if (target == a[r]) return r; else return - 1 ;","title":"First target"},{"location":"Lai/binary-search/#last-target-variant-for-previous-one","text":"target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { l = m; // now change to l } else if (a[m] < target) { l = m; } else { r = m; } } if (target == a[r]) // return the right that is equal to target, because it goes from right to left return l; if (target == a[l]) return r; else return - 1 ;","title":"Last target (variant for previous one)"},{"location":"Lai/binary-search/#closest-k-elements","text":"how to return the index of k elements that are closest elements to the target k = 3, target = 5, a = [1,2,3,8,9] return 2,3,8 Solution 1: 1. run binary search to find L and R, where L is the largest value that is smaller than target 2. if l is close to target, l--; else r++ Complexity: O(log(n) + k), what if k \\approx \\approx n? Complexity will be O(n) int largestSmallerEqual (vector < int > arr, int target) { int left = 0 , right = arr.size() - 1 ; while (left < right - 1 ) { int mid = left + right >> 1 ; if (arr[mid] <= target) { left = mid; } else { right = mid; } } if (arr[right] <= target) return right; if (arr[left] <= target) return left; return - 1 ; } vector < int > kClosest(vector < int > arr, int target, int k) { int left = largestSmallerEqual(arr, target); int right = left + 1 ; vector < int > res(k); for ( int i = 0 ; i < k; ++ i) { if (right >= arr.size() || left >= 0 && target - arr[left] <= arr[right] - target) { res[i] = arr[left -- ]; } else { res[i] = arr[right ++ ]; } } return res; } Solution 2: 1. binary search to find L and R 2. using offset to form two more arrays: leftArray = {3 2 1} rightArray = {4 5} then use the method introduced later to find the median. Don't need to preprocess the offset beforehand, but just to update when visited. Solution 3: Moving the sliding window to get the least sum diff. To get the minimal, it has to be the mid point of the sliding window. case 1: x - A[mid] < A[mid + k] - x, need to move window go left -------x----A[mid]-----------------A[mid + k]---------- case 2: x - A[mid] < A[mid + k] - x, need to move window go left again -------A[mid]----x-----------------A[mid + k]---------- case 3: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]------------------x---A[mid + k]---------- case 4: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]---------------------A[mid + k]----x------ vector < int > kClosest(vector < int > a, int x, int k) { int n = a.size(); int l = 0 , r = n - k; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (x - a[m] > a[m + k] - x) l = m + 1 ; else r = m; } auto res = vector < int > (a.begin() + l, a.begin() + l + k ); // this sort is unecessary if there is no requirement for what order to be returned // sort(res.begin(), res.end(), [&](const int l, const int r) { // return abs(l - x) < abs(r - x); // }); return res; }","title":"Closest k Elements"},{"location":"Lai/binary-search/#smallest-element-that-is-greater-than-target","text":"sss eee bbb -> same as first target, because we want to find the first b case 1: if input[m] < target: l = m + 1 // l = m also work case 2: if input[m] == target: l = m + 1 // l = m also work case 3: if input[m] > target: r = m // r = m - 1 is wrong, becasue it will wipe out the first b while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] > target) { r = m; } else if (a[m] <= target) { // or just else l = m; } } if (a[l] > target) return l; if (a[r] < target) return r; return - 1 ;","title":"Smallest element that is greater than target"},{"location":"Lai/binary-search/#kth-smallest-in-two-sorted-arrays","text":"how to find the median how to find k-th smallest element from them A[] = {2,5,7,10,13} B[] = {1,3,4,13,20,29} k = 5 output = 5 solution 1: two pointer, i++ if a[i] < b[j] else j++, stop until k steps -> O(k) solution 2: binary search","title":"Kth smallest in two sorted arrays"},{"location":"Lai/binary-search/#binary-search-with-unknown-size","text":"dict = {1 3 5 6 .... 1000000}, target = 9999 Assumption: - No dict.size() - if dict.get(index) == null, then we know the size of dict is < index. solution 1: 1. keep jumping out with size = size * 2. until dict.get(index) == null 2. do binary search from 0 to current size Followup: Why not size = size * 10? Which one is better? Don't say an answer (if you don't know yet), but say let's analyze together.","title":"Binary Search with Unknown Size"},{"location":"Lai/choose-k-cards-and-find-the-maximum/","text":"There are two players playing alternatively, and there is a deck of cards. Each player can pick 1~3 cards from the top of the deck. Find the maximum that player one get. e.g. [8,1,1,1,1] -> p1 pick 1, p2 picks 1,1,1. finally p1 pick 8 which is the highest point it can get. DP[i] = max( sum(0, i) - DP[i-1], sum(0, i) - DP[i-2], sum(0, i) - DP[i-3] ) = sum(0, i) - min(DP[i-1], DP[i-2], DP[i-3])","title":"Choose k cards and find the maximum"},{"location":"Lai/divide-two-integer/","text":"self intro infrastructure engineer in search ml infrastructure, inside tools for testing and developments service owner for search slogan service team search feature - for users and other engineering teams drive the team of search quality - responsible organize and manage the developments and teams - details impact, complexity for what you have done technically!! millions level users and high qps, autoscaling and analysis tech stacks - details Why do you want to change your company? food truck search problem \u6ca1\u542c\u6e05\u695a \u2192 double check What is the biggest bug/mistake you have committed in your work? broken for the owned service details - main service -> microservice, parameters - coordination of the dependency of push process for different time zone - Why - deep analysis What - 3.1 how do you solve the problem - oncall wake up 2AM - push and rollback in time 3.2 what do you learnt and what to do in the future - use the centralized timezone - how do you enforce? What are the actions? - change the whole process, share calendar, ping on slack and calendar, link on other events, mark and account for the completeness - work and cooperate with diverse working environment - proactively communication Literal point 0 insight point 1 - why your interviewer asked this question? Passion to join company? insight point 2 - think about in depth what he wants to know? What can you bring to our company? \u8f6c\u4e13\u4e1a\u7684\u95ee\u4e3a\u5565\u8f6c\u7801\u5e94\u8be5\u600e\u4e48\u56de\u7b54\u2029?? insight point 1 - passion + motivation \u21d2 100 / 3 100 -3-3-3-3-3 \u2026.. 10^10 / 1 Given two int value a and b, find a/b Notice: you can not use \"/\" operation. 4 / 3 = 1 --- 1 4 / 3 = 1 x * 3 = closet number to 4 but smaller than 4 < 0 sign 1 or both > 0 sign 1, -1 Math.abs(a) Math.abs(b) if (a == 0) { return 0; } min = 1, max = dividend mid = (max - min) / 2 + min mid * divisor = number > dividend max = mid; mid * divisor = number < dividend min = mid + 1 until we make min == max min will be the closest we can and smaller than dividend dividend = 4, divsior = 3 min = 1, max = 4 mid = (4 - 1) >> 1 + min = 2; number = 2 * 3 = 6 > 4 max = mid = 2 min = 1, max = 2 mid = 1 number = 1 * 3 = 3 < 4 min = mid + 1 = 2; min = 2, max = 2 we get result as 2 we check 2, 2 * 3 = 6 we will return 2 - 1 = 1 min = mid max = mid - 1 min =1 , max = 4 mid = 2 max = 2 - 1 min = 1, max = 1 public int divide(int dividend, int divisor) { if (divisior == 0) { throw new Exception(\u201cdivisor cannot be 0\u201d); } if (dividend == 0 || dividend < divisor) { return 0; } int min = 1, max = dividend; while (min < max) { // when min equals max, end it int mid = (max - min) >> 1 + min; // get mid value int number = mid * divisor; // calculate possible value if (number == dividend) { // we find it, so we directly return it return mid; } else if (number > dividend) { // it looks max = mid - 1; } else { min = mid; } } return min; } dividend = 10, divisor = 5 min = 1, max = 10 mid = 5 5 * 5 = 25 > 10 min = 1, max = 4 mid = 2 5 * 2 = 10 = 10 return 2 dividend = 4, divisor = 3 dividend = 0 return 0 divisor = 0 throw out of exception 1 / 2 dividend < divisor 0 dividend = 11 divisor = 3 min: 1 max: 11 mid = 6 * 3 = 18 > 11 min: 1 max: 5 mid = 3 * 3 = 9 < 11 min: 3 max: 5 mid = 4 * 3 = 12 > 11 min: 3 max: 3 mid = 3 * 3 = 9 < 11 mi 1 -- dividend log(dividend) O(1) in the worst case, 1 2 ^ 32 ---> 2^31 ---> 10^10 / 10^9 = 10 1 0 1 0 search range - [1, 2^4] min: 1 to max: 10^10 log(a/b) = loga - logb Clarification & Assumptions: b = 0? Why throw an exception in this case? - this is runtime error NullPointerException ArrayIndexOutOfBoundException IlegalArumentException IlegalStateException ArithmeticException (\"divisor can not be 0\") types of a,b - int, overflow? the result will never overflow? MIN_VALUE = -2^31 MAX_VALUE = 2^31 - 1 MIN_VALUE / -1 = ? What is the result type? int positive/negative for a,b? -7 / 4 = -1 or -2 Result: Binary Search Application \u52a8\u624b\u8fc7\u4f8b\u5b50\uff0c---> 1. \u903b\u8f91\u7684\u5173\u952e\u90e8\u5206 \u6574\u7406\u6e05\u695a \u5404\u79cdcase\uff0c\u7269\u7406\u610f\u4e49\uff0c 2. \u89e3\u91ca\u4f60\u7684high level\uff0cdetail\u7684\u903b\u8f91 4 / 3 1 2 3 4 3 6 9 12 min mid max 2*3 =6 min,max high level - \u4e3a\u4ec0\u4e48\u80fd\u7528binary search \u628aBinary Search\u7684\u8981\u70b9\u8bb2\u6e05\u695a 1. search range \u2192 [min, max] 2. search range reduce size each round \u2192 while loop()\u80fd\u8fdb\u5f97\u53bb\u548c\u8df3\u7684\u51fa\u6765 [1, 2] min max mid case 1 max = mid - 1 case 2 min = mid Test cover all possible code branches 10 / 3 = 3","title":"Divide two integer"},{"location":"Lai/dynamic-programming/","text":"what to do when asking a DP question \u00b6 base case induction rule: DP[i] physical meaning find global min/max \u00b6 recusion: DFS -> permute all possible outcomes -> optimal BFS - heap Greedy - need proof DP Q0: largest sum of a subarray \u00b6 {1, 2, 4, -1, -2, 10, 1} => {1, 2, 4, -1, -2, 10} with max sum of 14 Q1: maximal product: cutting rope \u00b6 Given a rope, cut the rope so that the product of total length is max","title":"Dynamic programming"},{"location":"Lai/dynamic-programming/#what-to-do-when-asking-a-dp-question","text":"base case induction rule: DP[i] physical meaning","title":"what to do when asking a DP question"},{"location":"Lai/dynamic-programming/#find-global-minmax","text":"recusion: DFS -> permute all possible outcomes -> optimal BFS - heap Greedy - need proof DP","title":"find global min/max"},{"location":"Lai/dynamic-programming/#q0-largest-sum-of-a-subarray","text":"{1, 2, 4, -1, -2, 10, 1} => {1, 2, 4, -1, -2, 10} with max sum of 14","title":"Q0: largest sum of a subarray"},{"location":"Lai/dynamic-programming/#q1-maximal-product-cutting-rope","text":"Given a rope, cut the rope so that the product of total length is max","title":"Q1: maximal product: cutting rope"},{"location":"Lai/find-minimum-in-rotated-sorted-array/","text":"LaiCode 23 \u00b6 Idea \u00b6 Two Situations: 2 4 5 6 0 1: mid (5) > r (1) -> l-mid is sorted and pivot is on the right -> if [right] < [left] then min is not on the l-mid -> search mid+1 - right (mid cannot be the minimum). 6 0 1 2 4 5: mid (1) < r -> right is sorted -> l-mid is what to be searched (minimum is located) -> mid can be the minimum (e.g. 6 7 | 1 2 4 5) // Assume array != null, array.length >= 2 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ r ] ; } strict -> loose 1. left <= right: 1 element can still jump in to the while loop 2. left < right: >= 2 elements 3. left < right - 1: >= 3 elements Two elements left (l < r - 1) \u00b6 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r - 1 ) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ l ] < array [ r ] ? array [ l ] : array [ r ] ; }","title":"Find minimum in rotated sorted array"},{"location":"Lai/find-minimum-in-rotated-sorted-array/#laicode-23","text":"","title":"LaiCode 23"},{"location":"Lai/find-minimum-in-rotated-sorted-array/#idea","text":"Two Situations: 2 4 5 6 0 1: mid (5) > r (1) -> l-mid is sorted and pivot is on the right -> if [right] < [left] then min is not on the l-mid -> search mid+1 - right (mid cannot be the minimum). 6 0 1 2 4 5: mid (1) < r -> right is sorted -> l-mid is what to be searched (minimum is located) -> mid can be the minimum (e.g. 6 7 | 1 2 4 5) // Assume array != null, array.length >= 2 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ r ] ; } strict -> loose 1. left <= right: 1 element can still jump in to the while loop 2. left < right: >= 2 elements 3. left < right - 1: >= 3 elements","title":"Idea"},{"location":"Lai/find-minimum-in-rotated-sorted-array/#two-elements-left-l-r-1","text":"public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r - 1 ) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ l ] < array [ r ] ? array [ l ] : array [ r ] ; }","title":"Two elements left (l &lt; r - 1)"},{"location":"Lai/graph/","text":"Tree vs Graph \u00b6 Graph can have cycle while tree cannot Graph can be not connected, which tree cannot Analyze Time Complexiy \u00b6 G = V + E \\ V: vertex, E: edge \\ min edge = 0 (not connected) \\ max edge = V^2 V^2 (each vertex can connect to all the other in directed graph) \\ O(N) = O(V^2) O(N) = O(V^2) DFS vs BFS: space less than BFS \u00b6 1.5 Given an input array with integers, how to split the array into k subarray, such that each subarray shares the same sum. e.g. input[N] = {3,-1,4,6,-8,1,1}, and k = 3 output = {3,-1} {4,6,-8} {1,1} with all sum is equal to two 1.6 Given an input array with integers, how to split the array into k subarrays (subarray may NOT be adjacent to each other), such that each subarray shares the same sum E.g. input[N] = { 3 -1,1 1 1 2 2 2 4, 6, -8, 1, 1 }. and k == 3. Output = {3,-1} {4, 6, - 8} {1, 1} which all have a sum that is equal to two.","title":"Graph"},{"location":"Lai/graph/#tree-vs-graph","text":"Graph can have cycle while tree cannot Graph can be not connected, which tree cannot","title":"Tree vs Graph"},{"location":"Lai/graph/#analyze-time-complexiy","text":"G = V + E \\ V: vertex, E: edge \\ min edge = 0 (not connected) \\ max edge = V^2 V^2 (each vertex can connect to all the other in directed graph) \\ O(N) = O(V^2) O(N) = O(V^2)","title":"Analyze Time Complexiy"},{"location":"Lai/graph/#dfs-vs-bfs-space-less-than-bfs","text":"1.5 Given an input array with integers, how to split the array into k subarray, such that each subarray shares the same sum. e.g. input[N] = {3,-1,4,6,-8,1,1}, and k = 3 output = {3,-1} {4,6,-8} {1,1} with all sum is equal to two 1.6 Given an input array with integers, how to split the array into k subarrays (subarray may NOT be adjacent to each other), such that each subarray shares the same sum E.g. input[N] = { 3 -1,1 1 1 2 2 2 4, 6, -8, 1, 1 }. and k == 3. Output = {3,-1} {4, 6, - 8} {1, 1} which all have a sum that is equal to two.","title":"DFS vs BFS: space less than BFS"},{"location":"Lai/knight-dialer/","text":"e.g. input: 1 output: 10 e.g. input: 2 output: 20 1: 6, 8 2: 7, 9 3: 4, 8 4: 3, 9, 0 5: - 6: 1, 7, 0 7: 2, 6 8: 1, 3 9: 4, 2 0: 4, 6 e.g. input: 3 output: 48 DFS with memo \u00b6 Time Complexity: O(n) -> size of memo, Space Complexity: O(n), But call stack is very large. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 , MAX = 10010 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; int res = 0 , n; int memo[ 10 ][MAX]; int dfs ( int pos, int hops) { if (memo[pos][hops] != 0 ) return memo[pos][hops]; int cnt = 0 ; for ( char i : nxt[pos]) { cnt += dfs(i - '0' , hops - 1 ); } return memo[pos][hops] = cnt; } void solve () { for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int pos = 0 ; pos < 10 ; ++ pos) res += dfs(pos, n - 1 ); } int main () { cin >> n; solve(); cout << res % mod; return 0 ; } DP with 2D matrix \u00b6 memo[pos][hops]: # of solution when ends in \"pos\" in \"hops\" hops. base case: memo[x][0] = 1 #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll memo[ 10 ][n]; for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += memo[nei - '0' ][hops - 1 ]; } memo[pos][hops] = cnt; } } for ( int i = 0 ; i < 10 ; ++ i) { res += memo[i][n - 1 ]; } cout << res % mod; return 0 ; } DP with constant space \u00b6 only need to record last state, so just two array is fine. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll prev[ 10 ], curr[ 10 ]; for ( int i = 0 ; i < 10 ; ++ i) prev[i] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += prev[nei - '0' ]; } curr[pos] = cnt; } for ( int pos = 0 ; pos < 10 ; ++ pos) { prev[pos] = curr[pos]; curr[pos] = 0 ; } } for ( int i = 0 ; i < 10 ; ++ i) { res += prev[i]; } cout << res % mod; return 0 ; }","title":"Knight dialer"},{"location":"Lai/knight-dialer/#dfs-with-memo","text":"Time Complexity: O(n) -> size of memo, Space Complexity: O(n), But call stack is very large. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 , MAX = 10010 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; int res = 0 , n; int memo[ 10 ][MAX]; int dfs ( int pos, int hops) { if (memo[pos][hops] != 0 ) return memo[pos][hops]; int cnt = 0 ; for ( char i : nxt[pos]) { cnt += dfs(i - '0' , hops - 1 ); } return memo[pos][hops] = cnt; } void solve () { for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int pos = 0 ; pos < 10 ; ++ pos) res += dfs(pos, n - 1 ); } int main () { cin >> n; solve(); cout << res % mod; return 0 ; }","title":"DFS with memo"},{"location":"Lai/knight-dialer/#dp-with-2d-matrix","text":"memo[pos][hops]: # of solution when ends in \"pos\" in \"hops\" hops. base case: memo[x][0] = 1 #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll memo[ 10 ][n]; for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += memo[nei - '0' ][hops - 1 ]; } memo[pos][hops] = cnt; } } for ( int i = 0 ; i < 10 ; ++ i) { res += memo[i][n - 1 ]; } cout << res % mod; return 0 ; }","title":"DP with 2D matrix"},{"location":"Lai/knight-dialer/#dp-with-constant-space","text":"only need to record last state, so just two array is fine. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll prev[ 10 ], curr[ 10 ]; for ( int i = 0 ; i < 10 ; ++ i) prev[i] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += prev[nei - '0' ]; } curr[pos] = cnt; } for ( int pos = 0 ; pos < 10 ; ++ pos) { prev[pos] = curr[pos]; curr[pos] = 0 ; } } for ( int i = 0 ; i < 10 ; ++ i) { res += prev[i]; } cout << res % mod; return 0 ; }","title":"DP with constant space"},{"location":"Lai/linkedlist/","text":"Define \u00b6 Logically consecutive list, but physically not consecutive Q1: reverse Linkedlist \u00b6 Need two pointers: one for previous, one for curr; reverse is simply change the direction Recursion \u00b6 ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL; return res; } Q2: insert into sorted linkedlist \u00b6 ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; } Q3: reorganize linkedlist \u00b6 Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; } Q4: partition list \u00b6 L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Linkedlist"},{"location":"Lai/linkedlist/#define","text":"Logically consecutive list, but physically not consecutive","title":"Define"},{"location":"Lai/linkedlist/#q1-reverse-linkedlist","text":"Need two pointers: one for previous, one for curr; reverse is simply change the direction","title":"Q1: reverse Linkedlist"},{"location":"Lai/linkedlist/#recursion","text":"ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL; return res; }","title":"Recursion"},{"location":"Lai/linkedlist/#q2-insert-into-sorted-linkedlist","text":"ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; }","title":"Q2: insert into sorted linkedlist"},{"location":"Lai/linkedlist/#q3-reorganize-linkedlist","text":"Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; }","title":"Q3: reorganize linkedlist"},{"location":"Lai/linkedlist/#q4-partition-list","text":"L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Q4: partition list"},{"location":"Lai/maximum-product-subarray/","text":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. How many subarrays in total? \u00b6 There are N^2 N^2 subarrays. You can choose 1 out of N for the start of the subarray, and also 1 out of N for the end of the subarray, so in total it will be N^2 / 2 N^2 / 2 (divide by two because of duplicates). DFS with memo O(n^2) O(n^2) \u00b6 map<int,int> where key is the end and value is the product, create the map every time when start changes. DP O(n) O(n) with space O(n) O(n) \u00b6 max_dp[i]: from 0-i, the maximum product min_dp[i]: from 0-i, the minimum product base case: 1. max_dp[0] = max(0, array[0]) // you can choose itself or nothing 2. min_dp[0] = min(0, array[0]) induction: max_dp[i] = max(min_dp[i] * array[i], max_dp[i-1] * array[i], array[i]) where min_dp[i] * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp[i] * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int n = nums.size(); int max_dp[n], min_dp[n]; memset(max_dp, 0 , sizeof max_dp); memset(min_dp, 0 , sizeof min_dp); int res = INT_MIN; for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) { min_dp[i] = nums[i]; max_dp[i] = nums[i]; } else { max_dp[i] = max(max(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); min_dp[i] = min(min(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); } res = max(res, max_dp[i]); } return res; } }; Optimize DP with O(1) O(1) space \u00b6 max_dp: from 0-i, the maximum product min_dp: from 0-i, the minimum product base case: 1. pre_max_dp = array[0] // you can choose itself or nothing 2. pre_min_dp = array[0] induction: max_dp = max(min_dp * array[i], pre_max_dp * array[i], array[i]) where min_dp * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int size = nums.size(); if (size == 0 ) { return 0 ; } int oldMin = nums[ 0 ]; int oldMax = nums[ 0 ]; int ret = nums[ 0 ]; for ( int i = 1 ; i < size; ++ i) { int newMax = max(nums[i], nums[i] > 0 ? oldMax * nums[i] : oldMin * nums[i]); int newMin = min(nums[i], nums[i] > 0 ? oldMin * nums[i] : oldMax * nums[i]); ret = max(ret, newMax); oldMin = newMin; oldMax = newMax; } return ret; } };","title":"Maximum product subarray"},{"location":"Lai/maximum-product-subarray/#how-many-subarrays-in-total","text":"There are N^2 N^2 subarrays. You can choose 1 out of N for the start of the subarray, and also 1 out of N for the end of the subarray, so in total it will be N^2 / 2 N^2 / 2 (divide by two because of duplicates).","title":"How many subarrays in total?"},{"location":"Lai/maximum-product-subarray/#dfs-with-memo-on2on2","text":"map<int,int> where key is the end and value is the product, create the map every time when start changes.","title":"DFS with memo O(n^2)O(n^2)"},{"location":"Lai/maximum-product-subarray/#dp-onon-with-space-onon","text":"max_dp[i]: from 0-i, the maximum product min_dp[i]: from 0-i, the minimum product base case: 1. max_dp[0] = max(0, array[0]) // you can choose itself or nothing 2. min_dp[0] = min(0, array[0]) induction: max_dp[i] = max(min_dp[i] * array[i], max_dp[i-1] * array[i], array[i]) where min_dp[i] * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp[i] * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int n = nums.size(); int max_dp[n], min_dp[n]; memset(max_dp, 0 , sizeof max_dp); memset(min_dp, 0 , sizeof min_dp); int res = INT_MIN; for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) { min_dp[i] = nums[i]; max_dp[i] = nums[i]; } else { max_dp[i] = max(max(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); min_dp[i] = min(min(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); } res = max(res, max_dp[i]); } return res; } };","title":"DP O(n)O(n) with space O(n)O(n)"},{"location":"Lai/maximum-product-subarray/#optimize-dp-with-o1o1-space","text":"max_dp: from 0-i, the maximum product min_dp: from 0-i, the minimum product base case: 1. pre_max_dp = array[0] // you can choose itself or nothing 2. pre_min_dp = array[0] induction: max_dp = max(min_dp * array[i], pre_max_dp * array[i], array[i]) where min_dp * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int size = nums.size(); if (size == 0 ) { return 0 ; } int oldMin = nums[ 0 ]; int oldMax = nums[ 0 ]; int ret = nums[ 0 ]; for ( int i = 1 ; i < size; ++ i) { int newMax = max(nums[i], nums[i] > 0 ? oldMax * nums[i] : oldMin * nums[i]); int newMin = min(nums[i], nums[i] > 0 ? oldMin * nums[i] : oldMax * nums[i]); ret = max(ret, newMax); oldMin = newMin; oldMax = newMax; } return ret; } };","title":"Optimize DP with O(1)O(1) space"},{"location":"Lai/ood/","text":"Vending Machine \u00b6 no need to talk about how many user using (distribute system design) Data \u00b6 item vending machine Action \u00b6 buy/purchase: input (item id, money) and output (item, remain money) input and return type: int, Item exceptions (could talk later in details): if there is no more items remaining, or there is not enough money could talk about use case: assumption (money for change is efficient), use the most familiar one for your use case. Class \u00b6 Item (first design the most fundmental class) price: int name/id: int/string type Vending Machine money remaining: int colllection of Item: unordered_map -> unordered_map Item: should represent type of item instead of specific item -> add a field in item for type buy/purchase API more: if there are multiple tracks Elevator Simulator \u00b6 start from use case (discuss with the interviewer): 1. show level button or just up and down then select inside the elevator 2. swipe card to validate or not 3. support for multiple elevator -> design elevator system 4. how to schedule (it could be discussed later): support different types of requests State to determine attribute \u00b6 which floor move up or move down weight/headcount and capacity -> if overload what to do when reach a floor what to determine to open or not: depends on the request (from outside or inside people) after open door: get in and get out -> next requests determine whether to change the direction Data \u00b6 Action \u00b6 open/close door","title":"Ood"},{"location":"Lai/ood/#vending-machine","text":"no need to talk about how many user using (distribute system design)","title":"Vending Machine"},{"location":"Lai/ood/#data","text":"item vending machine","title":"Data"},{"location":"Lai/ood/#action","text":"buy/purchase: input (item id, money) and output (item, remain money) input and return type: int, Item exceptions (could talk later in details): if there is no more items remaining, or there is not enough money could talk about use case: assumption (money for change is efficient), use the most familiar one for your use case.","title":"Action"},{"location":"Lai/ood/#class","text":"Item (first design the most fundmental class) price: int name/id: int/string type Vending Machine money remaining: int colllection of Item: unordered_map -> unordered_map Item: should represent type of item instead of specific item -> add a field in item for type buy/purchase API more: if there are multiple tracks","title":"Class"},{"location":"Lai/ood/#elevator-simulator","text":"start from use case (discuss with the interviewer): 1. show level button or just up and down then select inside the elevator 2. swipe card to validate or not 3. support for multiple elevator -> design elevator system 4. how to schedule (it could be discussed later): support different types of requests","title":"Elevator Simulator"},{"location":"Lai/ood/#state-to-determine-attribute","text":"which floor move up or move down weight/headcount and capacity -> if overload what to do when reach a floor what to determine to open or not: depends on the request (from outside or inside people) after open door: get in and get out -> next requests determine whether to change the direction","title":"State to determine attribute"},{"location":"Lai/ood/#data_1","text":"","title":"Data"},{"location":"Lai/ood/#action_1","text":"open/close door","title":"Action"},{"location":"Lai/recursion-tree/","text":"Is tree symmetric \u00b6 Recurison Tree \u00b6 Solution \u00b6 bool isSymmetric(left, right) if left == null and right == null return true else if left == null || right == null return false else if left.val != right.val return false else return isSymmetric(left.left, right.right) and isSymmetric(left.right, right.left) Time = O(n/2)=O(n)","title":"Recursion tree"},{"location":"Lai/recursion-tree/#is-tree-symmetric","text":"","title":"Is tree symmetric"},{"location":"Lai/recursion-tree/#recurison-tree","text":"","title":"Recurison Tree"},{"location":"Lai/recursion-tree/#solution","text":"bool isSymmetric(left, right) if left == null and right == null return true else if left == null || right == null return false else if left.val != right.val return false else return isSymmetric(left.left, right.right) and isSymmetric(left.right, right.left) Time = O(n/2)=O(n)","title":"Solution"},{"location":"Lai/recursion/","text":"Fibonacci Sequence \u00b6 Clarification Assumption Result Test Time Complexity: total nodes of the recursion tree Space Complexity: call stack (typically equals to the height of the recursion tree) Naive Approach \u00b6 int fib ( int n) { if (n == 0 || n == 1 ) return n; return fib(n - 1 ) + fib(n - 2 ); } Time: 2^0+2^1+2^2...+2^n \\approx 2^n 2^0+2^1+2^2...+2^n \\approx 2^n Space: n pow(a, b) \u00b6 don't care the case for a == 0 or b < 0 for now Naive Approach \u00b6 int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b - 1 ) * a; } analysis \u00b6 recursion tree: 2^999 | 2^998 | 2^997 | 2^996 ... there are b nodes and the longest path is b Time: O(b) Space: O(b) Optimize Space \u00b6 int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b / 2 ) * pow(a, b - b / 2 ); // why not using b/2? because 3/2 = 1.5 = 1 } 2^999 | | 2^500 2^499 | | | | 250 250 250 249 ... there are 1 + 2 + 4 + ... 2^log(b) = b => time: O(b) Space: O(log(b))","title":"Recursion"},{"location":"Lai/recursion/#fibonacci-sequence","text":"Clarification Assumption Result Test Time Complexity: total nodes of the recursion tree Space Complexity: call stack (typically equals to the height of the recursion tree)","title":"Fibonacci Sequence"},{"location":"Lai/recursion/#naive-approach","text":"int fib ( int n) { if (n == 0 || n == 1 ) return n; return fib(n - 1 ) + fib(n - 2 ); } Time: 2^0+2^1+2^2...+2^n \\approx 2^n 2^0+2^1+2^2...+2^n \\approx 2^n Space: n","title":"Naive Approach"},{"location":"Lai/recursion/#powa-b","text":"don't care the case for a == 0 or b < 0 for now","title":"pow(a, b)"},{"location":"Lai/recursion/#naive-approach_1","text":"int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b - 1 ) * a; }","title":"Naive Approach"},{"location":"Lai/recursion/#analysis","text":"recursion tree: 2^999 | 2^998 | 2^997 | 2^996 ... there are b nodes and the longest path is b Time: O(b) Space: O(b)","title":"analysis"},{"location":"Lai/recursion/#optimize-space","text":"int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b / 2 ) * pow(a, b - b / 2 ); // why not using b/2? because 3/2 = 1.5 = 1 } 2^999 | | 2^500 2^499 | | | | 250 250 250 249 ... there are 1 + 2 + 4 + ... 2^log(b) = b => time: O(b) Space: O(log(b))","title":"Optimize Space"},{"location":"Lai/reviews/","text":"6/5 \u00b6","title":"Reviews"},{"location":"Lai/reviews/#65","text":"","title":"6/5"},{"location":"Lai/sorting-algorithms/","text":"Overview \u00b6 Selection Sort \u00b6 arr[] = 64 25 12 22 11 // Find the minimum element in arr[0...4] // and place it at beginning 11 25 12 22 64 // Find the minimum element in arr[1...4] // and place it at beginning of arr[1...4] 11 12 25 22 64 // Find the minimum element in arr[2...4] // and place it at beginning of arr[2...4] 11 12 22 25 64 // Find the minimum element in arr[3...4] // and place it at beginning of arr[3...4] 11 12 22 25 64 /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length /* advance the position through the entire array */ /* (could do i < aLength-1 because single element is also min element) */ for (i = 0 ; i < aLength - 1 ; i ++ ) { /* find the min element in the unsorted a[i .. aLength-1] */ /* assume the min is the first element */ int jMin = i; /* test against elements after i to find the smallest */ for (j = i + 1 ; j < aLength; j ++ ) { /* if this element is less, then it is the new minimum */ if (a[j] < a[jMin]) { /* found new minimum; remember its index */ jMin = j; } } if (jMin != i) { swap(a[i], a[jMin]); } } Complexity \u00b6 O(\\frac{(n-1)+1}{2} \\times (n-1)) O(\\frac{(n-1)+1}{2} \\times (n-1)) = O(n^2) O(n^2) -- no matter if is pre-sorted or not Q1: sort with stacks \u00b6 sort with two stacks: counter: count number of element that is less than current top. 1. compare sorted.top() with item, pop all the elements back to the input stack that are greater than item 2. push the item to the sorted top 3. using the counter to determine when to stop when pushing the pop the input stack Here input stack's top (from top to top + counter) works as the buffer Insertion Sort \u00b6 for ( int i = 0 ; i < A.size(); ++ i) { for ( int j = i; j > 0 && A[j - 1 ] > A[j]; -- j) { // can terminate early if unsatisfy swap(A[j], A[j - 1 ]); } } 1, 4, 7, 11, 6, 2, -3, -8 1... 1, 4... 1, 4, 7... 1, 4, 7, 11... 1, 4, 6, 7, 11... 1, 2, 4, 6, 7, 11... -3, 1, 2, 4, 6, 11... -8, -3, 1, 2, 4, 6, 11 if the origional array is pre-sorted, then the complexity is O(n) O(n) , if not, it will be O(n^2) O(n^2) Counting Sort \u00b6 A[] original array to be sorted B[] sorted array from less to greater C[] is pre-sum for counting the frequency of each element (element is the index) on line 11, it keep \"filling\" the element from right to the left (greater to less) to B[]. initial \u00b6 after pre-sum \u00b6 Complexity \u00b6 Time: O(n) O(n) , Space: O(|max - min|) O(|max - min|) Merge Sort: stable \u00b6 int tmp[ 1010 ]; void merge_sort (vector < int >& q, int l, int r) { if (l >= r) return ; int mid = (l + r) >> 1 ; merge_sort(q, l, mid); merge_sort(q, mid + 1 , r); int k = 0 , i = l, j = mid + 1 ; while (i <= mid && j <= r) { // two pointers if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; } while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0 ; i <= r; i ++ , j ++ ) q[i] = tmp[j]; } vector < int > mergeSort(vector < int > array) { // write your solution here vector < int > res = array; merge_sort(res, 0 , array.size() - 1 ); return res; } Use merge sort to find Inversion Count \u00b6 Inversion Count: a_i > a_j a_i > a_j and i < j i < j , to do so, just uncomment line 12. Complexity \u00b6 space: - call stack: O(log(n)) O(log(n)) - heap: O(n) O(n) Q1: \u00b6 Quick Sort: not stable \u00b6 class Solution { public: void quick_sort(vector < int >& q, int l, int r) { if (l >= r) return ; // pivot at mid int i = l - 1 , j = r + 1 , x = q[(l + r) >> 1 ]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1 , r); } vector < int > quickSort(vector < int > array) { // write your solution here quick_sort(array, 0 , array.size() - 1 ); return array; } }; Quick select: select kth element \u00b6 Differ from Merge Sort, Quick sort first split array into two half where the values on the left of x are less than x and values on the right of x are equal or greater than x. Auxiliary Space : Mergesort uses extra space , quicksort requires little space and exhibits good cache locality. Quick sort is an in-place sorting algorithm. In-place sorting means no additional storage space is needed to perform sorting. Merge sort requires a temporary array to merge the sorted arrays and hence it is not in-place giving Quick sort the advantage of space. Worst Cases : The worst case of quicksort O(n^2) O(n^2) can be avoided by using randomized quicksort . It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort. Locality of reference : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment. Merge sort is better for large data structures : Mergesort is a stable sort , unlike quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Best time complexity: O(n \\log n) O(n \\log n) , Worst: O(n^2) O(n^2) . It works great in small size array, and for large size array it's better to use merge sort. Q1: moving zeros \u00b6 Move 0s to the right end of the array, no need to keep the relative order of the elements in the origional array vector < int > moveZeros(vector < int > arr) { if (arr.size() <= 1 ) return arr; int l = 0 , r = arr.size() - 1 ; while (l <= r) { if (arr[l] != 0 ) l ++ ; else if (arr[r] == 0 ) r -- ; else swap (arr[l ++ ], arr[r -- ]); } return arr; } Q2: rainbow sort \u00b6 sort the array by three color (a,b,c represent three colors). e.g. given [a,b,a,a,a,c,b,a] -> [a,a,a,a,a,b,b,c] i): all elements to the left of arr[i] are a [i-j): all elements between arr[i] ~ arr[j] are b [j-k]: all elements between arr[j] ~ arr[k] are unexplored range [k: all elements to the right of arr[k] are c if arr[j] == a: swap(arr[i++], arr[j++]) // i++ because i~j are b, and after sway, arr[i] is a if arr[j] == b: j++ if arr[j] == c: swap(arr[j], arr[k--]) // don't need to j++ becasue arr[j] is unknown void rainbowSort (vector < char >& arr) { if (arr.size() <= 1 ) return ; int i = 0 , j = 0 , k = arr.size() - 1 ; while (j <= k) { if (arr[j] == 'a' ) swap(arr[i ++ ], arr[j ++ ]); else if (arr[j] == 'b' ) j ++ ; else swap(arr[j], arr[k -- ]); } } Q3: sort four color \u00b6 [aaa i0) [bbb i1) [ccc i2) [dddd i3) XXXX a=0,b=1,c=2,d=3 i0): all elements to the left of arr[i0] are a [i0-i1): all elements between arr[i0] ~ arr[i1] are b [i1-i2): all elements between arr[i1] ~ arr[i2] are c [i2-i3): all elements between arr[i2] ~ arr[i3] are d [i3: all elements to the right of arr[i3] are unexplored range if arr[i3] == d: i3++ if arr[i3] == c: swap(arr[i3++], arr[i2++]) if arr[i3] == b: swap(arr[i3++], arr[i2++]), swap(arr[i1++, i2]) if arr[i3] == a: swap(arr[i3++], arr[i2++]), swap(arr[i1++], arr[i2]) , swap(arr[i0++], arr[i1]) public int [] rainbowSortII ( int [] array) { // Write your solution here int i0 = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; while (i3 < array. length ) { if (array [ i3 ] == 3 ) { i3 ++ ; } else if (array [ i3 ] == 2 ) { swap(array, i2, i3); i2 ++ ; i3 ++ ; } else if (array [ i3 ] == 1 ) { swap(array, i2, i3); swap(array, i1, i2); i1 ++ ; i2 ++ ; i3 ++ ; } else { swap(array, i2, i3); swap(array, i1, i2); swap(array, i0, i1); i0 ++ ; i1 ++ ; i2 ++ ; i3 ++ ; } } return array; } Q4: What about k color? \u00b6 use counting sort, sort in linear time! class Solution { public : vector < int > rainbowSortIII (vector < int > a, int k) { vector < int > cnt (k + 1 ); // accumulate cnt of each element (from 0 - k) int n = a. size (); for ( int i = 0 ; i < n; ++ i) cnt [ a [ i ]]++ ; for ( int i = 1 ; i <= k; ++ i) cnt [ i ] = cnt [ i ] + cnt [ i - 1 ] ; vector < int > res (n); for ( int i = n - 1 ; i >= 0 ; -- i) { res [ cnt [ a [ i ]] - 1 ] = a [ i ] ; cnt [ a [ i ]]-- ; } return res; } }; \u590d\u6742\u5ea6\u5206\u6790 \u00b6 \u65f6\u95f4\uff1a O(n) O(n) \u7a7a\u95f4\uff1a O(n) O(n) <- this is not a in-place algorithm \u5206\u6790 \u00b6 \u5982\u679c\u6709k\u4e2acolor\uff0c\u90a3\u4e48\u5982\u679c\u60f3\u8981\u77e5\u9053\u6bcf\u4e2acolor\u5e94\u8be5\u653e\u5728\u54ea\u91cc\u9700\u8981\u77e5\u9053\u4ee5\u4e0b\u4fe1\u606f\uff1a 1. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e 2. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u4e2a\u6570 \u8fd9\u4e24\u4e2a\u4fe1\u606f\u867d\u7136\u770b\u4f3c\u6ca1\u6709\u5173\u8054\u5b9e\u9645\u4e0a\u662f\uff1a\u5f53\u77e5\u9053\u6240\u6709\u5728\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272 \u6bcf\u4e2a\u4e2a\u6570\u4e4b\u540e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\u3002\u90a3\u4e48\u5c31\u662f\u8981\u5904\u7406\u5982\u4f55\u77e5\u9053\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u6240\u6709\u989c\u8272 \u4e2a\u6570\u3002 \u8fd9\u91cc\u5c31\u53ef\u4ee5\u60f3\u5230accumulate list\u6216\u8005pre sum list\u6765\u5904\u7406\u3002 for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; \u8fd9\u4e24\u884c\u505a\u7684\u4e8b\u60c5\u5206\u522b\u662f\u627e\u5230\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u91cf\uff0c\u7136\u540e\u8ba1\u7b97presum\uff0c\u8fd9\u91cc\u7684presum\u4fbf\u662f\u4e0a\u9762\u8bf4\u7684 \u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272*\u6bcf\u4e2a\u4e2a\u6570 \u3002\u5f53\u77e5\u9053\u4e86\u8fd9\u4e24\u4e2a\u4fe1\u606f\u4e4b\u540e\u4fbf\u53ef\u4ee5\u628a\u4ed6\u4eec\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230sort\u597d\u7684res\u6570\u7ec4\u4e86\u3002 for ( int i = n - 1 ; i >= 0 ; -- i) { res[cnt[a[i]] - 1 ] = a[i]; cnt[a[i]] -- ; } \u6ce8\u610f\uff1a\u6bcf\u6b21\u904d\u5386\u7684\u65f6\u5019\u9700\u8981\u66f4\u65b0cnt(cnt --)\uff0c\u540c\u65f6\u56e0\u4e3a\u6570\u7ec4\u662f0 base\uff0c\u4f46\u662f\u989c\u8272\u662f\u4ece[1\uff5ek]\uff0c\u6240\u4ee5\u6bcf\u6b21res\u7684index\u8981-1. \u5982\u4f55\u89e3\u51b3\u975e\u6570\u5b57\u95ee\u9898 \u00b6 \u5047\u5982\u989c\u8272\u4e0d\u662f1\uff5ek\u7684\u6570\u5b57\uff0c\u90a3\u4e48\u4e3a\u4e86\u8ba1\u7b97presum\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u67d0\u79cd\u65b9\u6cd5\u6765\u77e5\u9053\u6bcf\u4e24\u4e2a\u5143\u7d20\u7684\u76f8\u5bf9\u4f4d\u7f6e\uff1a \u5047\u8bbeobjA < objB\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a unordered_map<Obj, int> mapping \u6765\u4e3a\u6bcf\u4e2a\u5143\u7d20\u8d4b\u503c\u3002\u5373\uff1a for ( int i = 0 ; i < n; ++ i) cnt[mapping[a[i]]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; In-place sort: space O(k), time O(n) \u00b6 vector < int > rainbowSortIII(vector < int > a, int k) { vector < int > cnt(k + 1 ); // cnt of each element (from 0 - k) int n = a.size(); for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 , idx = 0 ; i <= k; ++ i) { while (cnt[i] != 0 ) { a[idx ++ ] = i; cnt[i] -- ; } } return a; } Q5: reorder the array \u00b6 An array contains both pos and neg numbers in random order. Order the array elements so that pos and neg are placed alternatively. If there are more pos they appear at the end of the array. If there are more neg, they also appear at the end of the array. e.g. input: [1,2,3,4,5,-1,-1,-1], output: [1,-1,2,-1,3,-1,4,5] (the ordering of pos/neg number doesn't matter) Analysis \u00b6 Use quick sort's partition to split the array into two half, then put them back to the new array alternatively Code \u00b6 #include <bits/stdc++.h> using namespace std; #define N 1010 int nums[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; int x = 0 , l = 0 , r = n - 1 ; while (l < r) { while (nums[ ++ l] > x); while (nums[ -- r] < x); if (l < r) swap(nums[l], nums[r]); } cout << nums[l] << \" \" << nums[r] << endl; int res[n]; memset(res, - 1 , sizeof res); int idx = 0 ; for ( int i = 0 ; idx <= r; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i = 1 ; idx < n; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Sorting algorithms"},{"location":"Lai/sorting-algorithms/#overview","text":"","title":"Overview"},{"location":"Lai/sorting-algorithms/#selection-sort","text":"arr[] = 64 25 12 22 11 // Find the minimum element in arr[0...4] // and place it at beginning 11 25 12 22 64 // Find the minimum element in arr[1...4] // and place it at beginning of arr[1...4] 11 12 25 22 64 // Find the minimum element in arr[2...4] // and place it at beginning of arr[2...4] 11 12 22 25 64 // Find the minimum element in arr[3...4] // and place it at beginning of arr[3...4] 11 12 22 25 64 /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length /* advance the position through the entire array */ /* (could do i < aLength-1 because single element is also min element) */ for (i = 0 ; i < aLength - 1 ; i ++ ) { /* find the min element in the unsorted a[i .. aLength-1] */ /* assume the min is the first element */ int jMin = i; /* test against elements after i to find the smallest */ for (j = i + 1 ; j < aLength; j ++ ) { /* if this element is less, then it is the new minimum */ if (a[j] < a[jMin]) { /* found new minimum; remember its index */ jMin = j; } } if (jMin != i) { swap(a[i], a[jMin]); } }","title":"Selection Sort"},{"location":"Lai/sorting-algorithms/#complexity","text":"O(\\frac{(n-1)+1}{2} \\times (n-1)) O(\\frac{(n-1)+1}{2} \\times (n-1)) = O(n^2) O(n^2) -- no matter if is pre-sorted or not","title":"Complexity"},{"location":"Lai/sorting-algorithms/#q1-sort-with-stacks","text":"sort with two stacks: counter: count number of element that is less than current top. 1. compare sorted.top() with item, pop all the elements back to the input stack that are greater than item 2. push the item to the sorted top 3. using the counter to determine when to stop when pushing the pop the input stack Here input stack's top (from top to top + counter) works as the buffer","title":"Q1: sort with stacks"},{"location":"Lai/sorting-algorithms/#insertion-sort","text":"for ( int i = 0 ; i < A.size(); ++ i) { for ( int j = i; j > 0 && A[j - 1 ] > A[j]; -- j) { // can terminate early if unsatisfy swap(A[j], A[j - 1 ]); } } 1, 4, 7, 11, 6, 2, -3, -8 1... 1, 4... 1, 4, 7... 1, 4, 7, 11... 1, 4, 6, 7, 11... 1, 2, 4, 6, 7, 11... -3, 1, 2, 4, 6, 11... -8, -3, 1, 2, 4, 6, 11 if the origional array is pre-sorted, then the complexity is O(n) O(n) , if not, it will be O(n^2) O(n^2)","title":"Insertion Sort"},{"location":"Lai/sorting-algorithms/#counting-sort","text":"A[] original array to be sorted B[] sorted array from less to greater C[] is pre-sum for counting the frequency of each element (element is the index) on line 11, it keep \"filling\" the element from right to the left (greater to less) to B[].","title":"Counting Sort"},{"location":"Lai/sorting-algorithms/#initial","text":"","title":"initial"},{"location":"Lai/sorting-algorithms/#after-pre-sum","text":"","title":"after pre-sum"},{"location":"Lai/sorting-algorithms/#complexity_1","text":"Time: O(n) O(n) , Space: O(|max - min|) O(|max - min|)","title":"Complexity"},{"location":"Lai/sorting-algorithms/#merge-sort-stable","text":"int tmp[ 1010 ]; void merge_sort (vector < int >& q, int l, int r) { if (l >= r) return ; int mid = (l + r) >> 1 ; merge_sort(q, l, mid); merge_sort(q, mid + 1 , r); int k = 0 , i = l, j = mid + 1 ; while (i <= mid && j <= r) { // two pointers if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; } while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0 ; i <= r; i ++ , j ++ ) q[i] = tmp[j]; } vector < int > mergeSort(vector < int > array) { // write your solution here vector < int > res = array; merge_sort(res, 0 , array.size() - 1 ); return res; }","title":"Merge Sort: stable"},{"location":"Lai/sorting-algorithms/#use-merge-sort-to-find-inversion-count","text":"Inversion Count: a_i > a_j a_i > a_j and i < j i < j , to do so, just uncomment line 12.","title":"Use merge sort to find Inversion Count"},{"location":"Lai/sorting-algorithms/#complexity_2","text":"space: - call stack: O(log(n)) O(log(n)) - heap: O(n) O(n)","title":"Complexity"},{"location":"Lai/sorting-algorithms/#q1","text":"","title":"Q1:"},{"location":"Lai/sorting-algorithms/#quick-sort-not-stable","text":"class Solution { public: void quick_sort(vector < int >& q, int l, int r) { if (l >= r) return ; // pivot at mid int i = l - 1 , j = r + 1 , x = q[(l + r) >> 1 ]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1 , r); } vector < int > quickSort(vector < int > array) { // write your solution here quick_sort(array, 0 , array.size() - 1 ); return array; } };","title":"Quick Sort: not stable"},{"location":"Lai/sorting-algorithms/#quick-select-select-kth-element","text":"Differ from Merge Sort, Quick sort first split array into two half where the values on the left of x are less than x and values on the right of x are equal or greater than x. Auxiliary Space : Mergesort uses extra space , quicksort requires little space and exhibits good cache locality. Quick sort is an in-place sorting algorithm. In-place sorting means no additional storage space is needed to perform sorting. Merge sort requires a temporary array to merge the sorted arrays and hence it is not in-place giving Quick sort the advantage of space. Worst Cases : The worst case of quicksort O(n^2) O(n^2) can be avoided by using randomized quicksort . It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort. Locality of reference : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment. Merge sort is better for large data structures : Mergesort is a stable sort , unlike quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Best time complexity: O(n \\log n) O(n \\log n) , Worst: O(n^2) O(n^2) . It works great in small size array, and for large size array it's better to use merge sort.","title":"Quick select: select kth element"},{"location":"Lai/sorting-algorithms/#q1-moving-zeros","text":"Move 0s to the right end of the array, no need to keep the relative order of the elements in the origional array vector < int > moveZeros(vector < int > arr) { if (arr.size() <= 1 ) return arr; int l = 0 , r = arr.size() - 1 ; while (l <= r) { if (arr[l] != 0 ) l ++ ; else if (arr[r] == 0 ) r -- ; else swap (arr[l ++ ], arr[r -- ]); } return arr; }","title":"Q1: moving zeros"},{"location":"Lai/sorting-algorithms/#q2-rainbow-sort","text":"sort the array by three color (a,b,c represent three colors). e.g. given [a,b,a,a,a,c,b,a] -> [a,a,a,a,a,b,b,c] i): all elements to the left of arr[i] are a [i-j): all elements between arr[i] ~ arr[j] are b [j-k]: all elements between arr[j] ~ arr[k] are unexplored range [k: all elements to the right of arr[k] are c if arr[j] == a: swap(arr[i++], arr[j++]) // i++ because i~j are b, and after sway, arr[i] is a if arr[j] == b: j++ if arr[j] == c: swap(arr[j], arr[k--]) // don't need to j++ becasue arr[j] is unknown void rainbowSort (vector < char >& arr) { if (arr.size() <= 1 ) return ; int i = 0 , j = 0 , k = arr.size() - 1 ; while (j <= k) { if (arr[j] == 'a' ) swap(arr[i ++ ], arr[j ++ ]); else if (arr[j] == 'b' ) j ++ ; else swap(arr[j], arr[k -- ]); } }","title":"Q2: rainbow sort"},{"location":"Lai/sorting-algorithms/#q3-sort-four-color","text":"[aaa i0) [bbb i1) [ccc i2) [dddd i3) XXXX a=0,b=1,c=2,d=3 i0): all elements to the left of arr[i0] are a [i0-i1): all elements between arr[i0] ~ arr[i1] are b [i1-i2): all elements between arr[i1] ~ arr[i2] are c [i2-i3): all elements between arr[i2] ~ arr[i3] are d [i3: all elements to the right of arr[i3] are unexplored range if arr[i3] == d: i3++ if arr[i3] == c: swap(arr[i3++], arr[i2++]) if arr[i3] == b: swap(arr[i3++], arr[i2++]), swap(arr[i1++, i2]) if arr[i3] == a: swap(arr[i3++], arr[i2++]), swap(arr[i1++], arr[i2]) , swap(arr[i0++], arr[i1]) public int [] rainbowSortII ( int [] array) { // Write your solution here int i0 = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; while (i3 < array. length ) { if (array [ i3 ] == 3 ) { i3 ++ ; } else if (array [ i3 ] == 2 ) { swap(array, i2, i3); i2 ++ ; i3 ++ ; } else if (array [ i3 ] == 1 ) { swap(array, i2, i3); swap(array, i1, i2); i1 ++ ; i2 ++ ; i3 ++ ; } else { swap(array, i2, i3); swap(array, i1, i2); swap(array, i0, i1); i0 ++ ; i1 ++ ; i2 ++ ; i3 ++ ; } } return array; }","title":"Q3: sort four color"},{"location":"Lai/sorting-algorithms/#q4-what-about-k-color","text":"use counting sort, sort in linear time! class Solution { public : vector < int > rainbowSortIII (vector < int > a, int k) { vector < int > cnt (k + 1 ); // accumulate cnt of each element (from 0 - k) int n = a. size (); for ( int i = 0 ; i < n; ++ i) cnt [ a [ i ]]++ ; for ( int i = 1 ; i <= k; ++ i) cnt [ i ] = cnt [ i ] + cnt [ i - 1 ] ; vector < int > res (n); for ( int i = n - 1 ; i >= 0 ; -- i) { res [ cnt [ a [ i ]] - 1 ] = a [ i ] ; cnt [ a [ i ]]-- ; } return res; } };","title":"Q4: What about k color?"},{"location":"Lai/sorting-algorithms/#_1","text":"\u65f6\u95f4\uff1a O(n) O(n) \u7a7a\u95f4\uff1a O(n) O(n) <- this is not a in-place algorithm","title":"\u590d\u6742\u5ea6\u5206\u6790"},{"location":"Lai/sorting-algorithms/#_2","text":"\u5982\u679c\u6709k\u4e2acolor\uff0c\u90a3\u4e48\u5982\u679c\u60f3\u8981\u77e5\u9053\u6bcf\u4e2acolor\u5e94\u8be5\u653e\u5728\u54ea\u91cc\u9700\u8981\u77e5\u9053\u4ee5\u4e0b\u4fe1\u606f\uff1a 1. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e 2. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u4e2a\u6570 \u8fd9\u4e24\u4e2a\u4fe1\u606f\u867d\u7136\u770b\u4f3c\u6ca1\u6709\u5173\u8054\u5b9e\u9645\u4e0a\u662f\uff1a\u5f53\u77e5\u9053\u6240\u6709\u5728\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272 \u6bcf\u4e2a\u4e2a\u6570\u4e4b\u540e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\u3002\u90a3\u4e48\u5c31\u662f\u8981\u5904\u7406\u5982\u4f55\u77e5\u9053\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u6240\u6709\u989c\u8272 \u4e2a\u6570\u3002 \u8fd9\u91cc\u5c31\u53ef\u4ee5\u60f3\u5230accumulate list\u6216\u8005pre sum list\u6765\u5904\u7406\u3002 for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; \u8fd9\u4e24\u884c\u505a\u7684\u4e8b\u60c5\u5206\u522b\u662f\u627e\u5230\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u91cf\uff0c\u7136\u540e\u8ba1\u7b97presum\uff0c\u8fd9\u91cc\u7684presum\u4fbf\u662f\u4e0a\u9762\u8bf4\u7684 \u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272*\u6bcf\u4e2a\u4e2a\u6570 \u3002\u5f53\u77e5\u9053\u4e86\u8fd9\u4e24\u4e2a\u4fe1\u606f\u4e4b\u540e\u4fbf\u53ef\u4ee5\u628a\u4ed6\u4eec\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230sort\u597d\u7684res\u6570\u7ec4\u4e86\u3002 for ( int i = n - 1 ; i >= 0 ; -- i) { res[cnt[a[i]] - 1 ] = a[i]; cnt[a[i]] -- ; } \u6ce8\u610f\uff1a\u6bcf\u6b21\u904d\u5386\u7684\u65f6\u5019\u9700\u8981\u66f4\u65b0cnt(cnt --)\uff0c\u540c\u65f6\u56e0\u4e3a\u6570\u7ec4\u662f0 base\uff0c\u4f46\u662f\u989c\u8272\u662f\u4ece[1\uff5ek]\uff0c\u6240\u4ee5\u6bcf\u6b21res\u7684index\u8981-1.","title":"\u5206\u6790"},{"location":"Lai/sorting-algorithms/#_3","text":"\u5047\u5982\u989c\u8272\u4e0d\u662f1\uff5ek\u7684\u6570\u5b57\uff0c\u90a3\u4e48\u4e3a\u4e86\u8ba1\u7b97presum\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u67d0\u79cd\u65b9\u6cd5\u6765\u77e5\u9053\u6bcf\u4e24\u4e2a\u5143\u7d20\u7684\u76f8\u5bf9\u4f4d\u7f6e\uff1a \u5047\u8bbeobjA < objB\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a unordered_map<Obj, int> mapping \u6765\u4e3a\u6bcf\u4e2a\u5143\u7d20\u8d4b\u503c\u3002\u5373\uff1a for ( int i = 0 ; i < n; ++ i) cnt[mapping[a[i]]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ];","title":"\u5982\u4f55\u89e3\u51b3\u975e\u6570\u5b57\u95ee\u9898"},{"location":"Lai/sorting-algorithms/#in-place-sort-space-ok-time-on","text":"vector < int > rainbowSortIII(vector < int > a, int k) { vector < int > cnt(k + 1 ); // cnt of each element (from 0 - k) int n = a.size(); for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 , idx = 0 ; i <= k; ++ i) { while (cnt[i] != 0 ) { a[idx ++ ] = i; cnt[i] -- ; } } return a; }","title":"In-place sort: space O(k), time O(n)"},{"location":"Lai/sorting-algorithms/#q5-reorder-the-array","text":"An array contains both pos and neg numbers in random order. Order the array elements so that pos and neg are placed alternatively. If there are more pos they appear at the end of the array. If there are more neg, they also appear at the end of the array. e.g. input: [1,2,3,4,5,-1,-1,-1], output: [1,-1,2,-1,3,-1,4,5] (the ordering of pos/neg number doesn't matter)","title":"Q5: reorder the array"},{"location":"Lai/sorting-algorithms/#analysis","text":"Use quick sort's partition to split the array into two half, then put them back to the new array alternatively","title":"Analysis"},{"location":"Lai/sorting-algorithms/#code","text":"#include <bits/stdc++.h> using namespace std; #define N 1010 int nums[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; int x = 0 , l = 0 , r = n - 1 ; while (l < r) { while (nums[ ++ l] > x); while (nums[ -- r] < x); if (l < r) swap(nums[l], nums[r]); } cout << nums[l] << \" \" << nums[r] << endl; int res[n]; memset(res, - 1 , sizeof res); int idx = 0 ; for ( int i = 0 ; idx <= r; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i = 1 ; idx < n; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Code"},{"location":"Lai/stack-and-queue/","text":"","title":"Stack and queue"},{"location":"Lai/tree/","text":"Balanced Tree \u00b6 Def: height of the left and right subtrees of every node differ by 1 or less. Method 1: check is balanced \u00b6 int height (TreeNode * root) { if ( ! root) return 0 ; return max(height(root -> left), height(root -> right)) + 1 ; } bool isBalanced (TreeNode * root) { if ( ! root) return true; if (abs(height(root -> left) - height(root -> right)) > 1 ) return false; return isBalanced(root -> left) && isBalanced(root -> right); } Analysis \u00b6 Time: worst case happens when tree is balanced, so there are log(n) levels. first level requires n ops to get height, second = n/2, ....1. So total complexity is n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} Space: \\log{n} \\log{n} Method 2: check is balanced \u00b6 int checkDepth (TreeNode * root) { if ( ! root) return 0 ; int left = checkDepth(root -> left); if (left == - 1 ) return - 1 ; int right = checkDepth(root -> right); if (right == - 1 ) return - 1 ; if (abs(right - left) > 1 ) return - 1 ; else return 1 + max(left, right); } bool isBalanced (TreeNode * root) { if (checkDepth(root) == - 1 ) return false; else return true; } Analysis \u00b6 For each node, early terminate if left or right subtree is invalid. Each node only requries to visit once, so the time compleixty is O(n) O(n) Space Compleixty: the worst case would be like a linkedlist and the height is n, so O(n) O(n) Symmetric Tree \u00b6 Assume if we tweak the lchild with rchild of an arbitrary node in a binary tree, then the \"structure\" of the tree are not changed. Then how can we determinte whether two binary trees' structures are identical. bool isTweakedIdentical (TreeNode * l, TreeNode * r) { // write your solution here if ( ! l && ! r) return true; if ( ! l || ! r) return false; if (l -> value != r -> value) return false; return (isTweakedIdentical(l -> left, r -> right) && isTweakedIdentical(l -> right, r -> left)) || (isTweakedIdentical(l -> right, r -> right) && isTweakedIdentical(l -> left, r -> left)) || (isTweakedIdentical(l -> left, r -> left) && isTweakedIdentical(l -> right, r -> right)) || (isTweakedIdentical(l -> right, r -> left) && isTweakedIdentical(l -> left, r -> right)); } Analysis \u00b6 Each level has four nodes, and total cost is N. There are \\log_2{N} \\log_2{N} because the wrost case is when the tree is balanced (there are not a lot early terminations). Total number of nodes in the quadral tree is 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) Space: wrost case is linkedlist so O(n) O(n) Traverse Tree \u00b6 pre-order: root -> left -> right in-order: left -> root -> right post-order: left -> right -> root Pre-order \u00b6 recursion: vector < int > res; vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; res.push_back(root -> val); preorderTraversal(root -> left); preorderTraversal(root -> right); /* traverse a graph for (int i = 0; i < n; ++i) preorder(root -> neighbour[i]); */ return res; } iterative: vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st{{root}}; while ( ! st.empty()) { TreeNode * t = st.top(); st.pop(); res.push_back(t -> val); /* traverse a graph for (int i = n - 1; i >= 0; --i) preorder(root -> neighbour[i]); */ if (t -> right) st.push(t -> right); // push right first, so it will be popped last if (t -> left) st.push(t -> left); } return res; } In-order \u00b6 recursion: vector < int > res; vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; /* traverse a graph: all from 0 to current root for (int i = 0; i < m; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> left); res.push_back(root -> val); /* traverse a graph: all from current root to the end for (int i = m; i < n; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> right); return res; } iterative: vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st; while (root || ! st.empty()) { while (root) { // first push all the left children to the stack st.push(root); root = root -> left; } root = st.top(); st.pop(); res.push_back(root -> val); root = root -> right; } return res; } Post-order \u00b6 recursion: vector < int > res; vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; postorderTraversal(root -> left); postorderTraversal(root -> right); res.push_back(root -> val); return res; } iterative: vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> s; while (root || ! s.empty()) { if (root) { s.push(root); res.insert(res.begin(), root -> val); root = root -> right; } else { TreeNode * pleft = s.top(); s.pop(); root = pleft -> left; } } return res; }","title":"Tree"},{"location":"Lai/tree/#balanced-tree","text":"Def: height of the left and right subtrees of every node differ by 1 or less.","title":"Balanced Tree"},{"location":"Lai/tree/#method-1-check-is-balanced","text":"int height (TreeNode * root) { if ( ! root) return 0 ; return max(height(root -> left), height(root -> right)) + 1 ; } bool isBalanced (TreeNode * root) { if ( ! root) return true; if (abs(height(root -> left) - height(root -> right)) > 1 ) return false; return isBalanced(root -> left) && isBalanced(root -> right); }","title":"Method 1: check is balanced"},{"location":"Lai/tree/#analysis","text":"Time: worst case happens when tree is balanced, so there are log(n) levels. first level requires n ops to get height, second = n/2, ....1. So total complexity is n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} Space: \\log{n} \\log{n}","title":"Analysis"},{"location":"Lai/tree/#method-2-check-is-balanced","text":"int checkDepth (TreeNode * root) { if ( ! root) return 0 ; int left = checkDepth(root -> left); if (left == - 1 ) return - 1 ; int right = checkDepth(root -> right); if (right == - 1 ) return - 1 ; if (abs(right - left) > 1 ) return - 1 ; else return 1 + max(left, right); } bool isBalanced (TreeNode * root) { if (checkDepth(root) == - 1 ) return false; else return true; }","title":"Method 2: check is balanced"},{"location":"Lai/tree/#analysis_1","text":"For each node, early terminate if left or right subtree is invalid. Each node only requries to visit once, so the time compleixty is O(n) O(n) Space Compleixty: the worst case would be like a linkedlist and the height is n, so O(n) O(n)","title":"Analysis"},{"location":"Lai/tree/#symmetric-tree","text":"Assume if we tweak the lchild with rchild of an arbitrary node in a binary tree, then the \"structure\" of the tree are not changed. Then how can we determinte whether two binary trees' structures are identical. bool isTweakedIdentical (TreeNode * l, TreeNode * r) { // write your solution here if ( ! l && ! r) return true; if ( ! l || ! r) return false; if (l -> value != r -> value) return false; return (isTweakedIdentical(l -> left, r -> right) && isTweakedIdentical(l -> right, r -> left)) || (isTweakedIdentical(l -> right, r -> right) && isTweakedIdentical(l -> left, r -> left)) || (isTweakedIdentical(l -> left, r -> left) && isTweakedIdentical(l -> right, r -> right)) || (isTweakedIdentical(l -> right, r -> left) && isTweakedIdentical(l -> left, r -> right)); }","title":"Symmetric Tree"},{"location":"Lai/tree/#analysis_2","text":"Each level has four nodes, and total cost is N. There are \\log_2{N} \\log_2{N} because the wrost case is when the tree is balanced (there are not a lot early terminations). Total number of nodes in the quadral tree is 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) Space: wrost case is linkedlist so O(n) O(n)","title":"Analysis"},{"location":"Lai/tree/#traverse-tree","text":"pre-order: root -> left -> right in-order: left -> root -> right post-order: left -> right -> root","title":"Traverse Tree"},{"location":"Lai/tree/#pre-order","text":"recursion: vector < int > res; vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; res.push_back(root -> val); preorderTraversal(root -> left); preorderTraversal(root -> right); /* traverse a graph for (int i = 0; i < n; ++i) preorder(root -> neighbour[i]); */ return res; } iterative: vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st{{root}}; while ( ! st.empty()) { TreeNode * t = st.top(); st.pop(); res.push_back(t -> val); /* traverse a graph for (int i = n - 1; i >= 0; --i) preorder(root -> neighbour[i]); */ if (t -> right) st.push(t -> right); // push right first, so it will be popped last if (t -> left) st.push(t -> left); } return res; }","title":"Pre-order"},{"location":"Lai/tree/#in-order","text":"recursion: vector < int > res; vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; /* traverse a graph: all from 0 to current root for (int i = 0; i < m; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> left); res.push_back(root -> val); /* traverse a graph: all from current root to the end for (int i = m; i < n; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> right); return res; } iterative: vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st; while (root || ! st.empty()) { while (root) { // first push all the left children to the stack st.push(root); root = root -> left; } root = st.top(); st.pop(); res.push_back(root -> val); root = root -> right; } return res; }","title":"In-order"},{"location":"Lai/tree/#post-order","text":"recursion: vector < int > res; vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; postorderTraversal(root -> left); postorderTraversal(root -> right); res.push_back(root -> val); return res; } iterative: vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> s; while (root || ! s.empty()) { if (root) { s.push(root); res.insert(res.begin(), root -> val); root = root -> right; } else { TreeNode * pleft = s.top(); s.pop(); root = pleft -> left; } } return res; }","title":"Post-order"},{"location":"Lai/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/","text":"5.26 Consider a hash table of size seven, with starting index zero, and a hash function (7x+3) mod 4. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing ? Here \u201c__\u201d denotes an empty location in the table. _ 1 _ _ 3 _ 1 _ _ 3 _ 1 8 _ _ 3 10 1 8 _ _ _ 5.25 To implement Dijkstra\u2019s shortest path algorithm on unweighted graphs so that it runs in linear time, the data structure to be used is\uff1f Priority Queue 5.24 When do we consider using dynamic programming? For problem that can be solved by dividing problems to sub problems, where results of sub problems can be reused. It can be solved by recursion method but recursion here is sometimes not ideal in time complexity (too many overlapping a). Since the results can be reused. DP provides a way to record and reuse the results from previous solved sub problems, which greatly reduce the time complexity. 5.23 Analysis Complexity 5.22 Check output 5.21 Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix. 5.20 What does final mean in Java? What does finally mean in Java? final is a keyword that once a field/method/class has been designed, it\u2019s unchangeable and un override-able. Finally is a block that always executed when the try block exits. 5.19 What is dependency injection\uff1f https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/ 5.18 What are the differences between overload and override? 1). The real object type in the run-time, not the reference variable's type, determines which overridden method is used at runtime. In contrast, reference type determines which overloaded method will be used at compile time. 2). Polymorphism applies to overriding, not to overloading. 3). Overriding is a run-time concept while overloading is a compile-time concept. 5.17 Which class does all the Enums directly extend? All enums extend java.lang.Enum. Enum cannot extend any other class. 5.16 Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than that of array. Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity? \u6536\u5230\u5927\u5bb6\u7684\u6253\u5361\u5566~\u6628\u5929\u57fa\u7840\u9898\u7684\u7b54\u6848\u662f Heap Sort\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nLogk) create a Min heap \uff0c\u6700\u5c0f\u5143\u7d20\u5728\u7b2ck+1\u4f4d\u7f6e\uff0c\u6392\u5e8f\u6574\u4e2aarray\uff0co(k)\u5efa\u7acb\u4e00\u4e2amin heap,O(n-k)logk\u5bf9\u4e8e\u5269\u4f59\u5143\u7d20\uff0cO1\u4ecemin heap\u4e2d\u53d6\u51fa\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6nlogk 5.15 What is OOPS? Could you name some important OOPS features in Java? Object Oriented Programing ,like java, is different from Process Oriented programing, like C. More focus on the object itself rather running process. we can bind the data and the function methods together in the object. Program become more flexible. Important features like inheritance, abstraction, polymorphism, Encapsulation and so on. 5.14 In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child? \u55ef\u55ef\uff0c\u6bcf\u4e2anode\u7684child\u90fd\u662f2\u4e2a\uff0c\u90a3node\u7684descendent\u5c31\u4f1a\u662f0\uff0c2\uff0c4\uff0c6 and so on \u5982\u679c\u8981\u8bc1\u660e\u7684\u8bdd\uff0c\u53ef\u4ee5\u7528\u53cd\u6b63\u6cd5\uff1a\u82e5\u5b58\u5728\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9X\uff0c\u5047\u8bbeX->right=NULL\uff0c\u90a3\u4e48\u7531\u4e8eX\u548cX->left\u7684descendent\u6570\u76ee\u5747\u8981\u4e3a\u5947\u6570\uff0c\u4f46\u8fd9\u4e24\u4e2a\u503c\u53ea\u5dee1\uff0c\u56e0\u6b64\u77db\u76fe 5.13 What are the differences between traversing a graph and traversing a tree? tree \u7684\u904d\u5386\u53ef\u4ee5\u7528 pre-order, in-order, post-order, level-order, \u524d\u4e09\u79cd\u90fd\u53ef\u4ee5\u7528 dfs \u6765\u5b9e\u73b0\uff0c\u6700\u540e\u4e00\u79cd\u7528 bfs\u3002graph \u7684\u904d\u5386\u4e5f\u53ef\u4ee5\u7528 dfs \u6216\u8005 bfs\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f graph \u4e2d\u53ef\u80fd\u6709\u975e\u8fde\u901a\u533a\u57df\uff0c\u9700\u8981\u4ee5\u6bcf\u4e2a\u8282\u70b9\u4e3a\u8d77\u59cb\u6765\u505a\u4e00\u904d bfs/dfs\uff0c\u5f53\u7136\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b deduplicate \u673a\u5236\u6765\u907f\u514d\u91cd\u590d 5.12 An unordered list contains n distinct elements. What is number of comparisons to find an element in this list that is neither maximum nor minimum? worst case\u662f3\u6b21 \u590d\u6742\u5ea6\u662f\u0398(1) \u9700\u8981\u8ba8\u8bban!=length\u7684case 5.26 Alien Dictionary https://app.laicode.io/app/problem/501 5.25 Merge Stones https://app.laicode.io/app/problem/96 5.24 Edit Distance https://app.laicode.io/app/problem/100 5.23 Largest Rectangle Of 1s https://app.laicode.io/app/problem/102 5.22 Depth Of Forest https://app.laicode.io/app/problem/323 5.21 Walls and gates https://app.laicode.io/app/problem/503 5.20 All Permutations II https://app.laicode.io/app/problem/65 5.19 Restore IP Addresses https://app.laicode.io/app/problem/147 5.18 Longest Substring With K Typed Characters https://app.laicode.io/app/problem/285 5.17 Compress String https://app.laicode.io/app/problem/173 StringBuilder in Java 5.16 Distance Of Two Nodes In Binary Tree https://app.laicode.io/app/problem/299 LCA 5.15 Longest Ascending Path Binary Tree https://app.laicode.io/app/problem/388 tree height 5.14 Merge Sort Linked List https://app.laicode.io/app/problem/29 5.13 Search In Bitonic Array https://app.laicode.io/app/problem/401 bst 5.12 Largest Container https://app.laicode.io/app/problem/201 Longest Substring With K Typed Characters \u00b6 Given a string, return the longest contiguous substring that contains exactly k type of characters. Return null if there does not exist such substring. Assumptions: The given string is not null and guaranteed to have at least k different characters. k > 0. Examples: input = \"aabcc\", k = 3, output = \"aabcc\". input = \"aabcccc\", k = 2, output = \"bcccc\". Analysis \u00b6 Using sliding window to search and update the current longest string: dabaaebac: l = 0, r = 0, cnt = 0, len = 9 l = 0, r = 7: dabaaeba Code \u00b6 class Solution { public: string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt <= k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt <= k && len < r - l) { // cnt is valid len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // cnt is invalid len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } };","title":"\u6bcf\u65e5\u6253\u5361"},{"location":"Lai/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#longest-substring-with-k-typed-characters","text":"Given a string, return the longest contiguous substring that contains exactly k type of characters. Return null if there does not exist such substring. Assumptions: The given string is not null and guaranteed to have at least k different characters. k > 0. Examples: input = \"aabcc\", k = 3, output = \"aabcc\". input = \"aabcccc\", k = 2, output = \"bcccc\".","title":"Longest Substring With K Typed Characters"},{"location":"Lai/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#analysis","text":"Using sliding window to search and update the current longest string: dabaaebac: l = 0, r = 0, cnt = 0, len = 9 l = 0, r = 7: dabaaeba","title":"Analysis"},{"location":"Lai/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#code","text":"class Solution { public: string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt <= k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt <= k && len < r - l) { // cnt is valid len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // cnt is invalid len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } };","title":"Code"},{"location":"Leetcode/10.-regular-expression-matching/","text":"class Solution { public: bool isMatch(string s, string p) { int n = s.length(), m = p.length(); vector < vector < bool >> f(n + 1 , vector < bool > (m + 1 , false)); s = \" \" + s; p = \" \" + p; f[ 0 ][ 0 ] = true; for ( int i = 0 ; i <= n; i ++ ) for ( int j = 1 ; j <= m; j ++ ) { if (i > 0 && (s[i] == p[j] || p[j] == '.' )) f[i][j] = f[i - 1 ][j - 1 ]; if (p[j] == '*' ) { if (j >= 2 ) f[i][j] = f[i][j - 2 ]; if (i > 0 && (s[i] == p[j - 1 ] || p[j - 1 ] == '.' )) f[i][j] = f[i][j] | f[i - 1 ][j]; // if anything happened to set f[i][j] = true, here will ignore if f[i-1][j] ?= true } } return f[n][m]; } }; dp[i][j]: s[0:i] matches p[0:j] if p[i] == . then matches everything from s, so dp[i][j] = true if p[i] == * then if dp[i][j-2] (skip the last one and check if previous one matches) or s[i] == p[j-1] or p[j-1] (match anything) set dp[i][j] = true","title":"10. regular expression matching"},{"location":"Leetcode/1057.-campus-bikes/","text":"On a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid. Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers. The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|. Return a vector ansof length N, where ans[i]is the index (0-indexed) of the bike that the i-th worker is assigned to. Example 1: Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]] Output: [1,0] Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0]. Example 2: Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]] Output: [0,2,1] Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1]. Note: 0 <= workers[i][j], bikes[i][j] < 1000 All worker and bike locations are distinct. 1 <= workers.length <= bikes.length <= 1000 Analysis \u00b6 Sort based on 1. Manahattan distance between bike and worker 2. Worker index 3. Bike index Using Priority Queue if the input is unbounded. Code \u00b6 /* * tmp.cpp * Copyright (C) 2020 Haoyang <me@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; typedef tuple < int , int , int > TII; int inline manhattan (vector < int >& p1, vector < int >& p2) { return abs(p1[ 0 ] - p2[ 0 ]) + abs(p1[ 1 ] - p2[ 1 ]); } vector < int > assignBikes(vector < vector < int >>& workers, vector < vector < int >>& bikes) { /* *auto cmp = [](const TII& l, const TII& r) { * int ld = get<0>(l), rd = get<0>(r), wl = get<1>(l), wr = get<1>(r), * bl = get<2>(l), br = get<2>(r); * if (ld != rd) * return ld > rd; * else if (wl != wr) * return wl > wr; * else * return bl > br; *}; */ //priority_queue<TII, vector<TII>, decltype(cmp)> pq(cmp); priority_queue < TII, vector < TII > , greater < TII >> pq; for ( int i = 0 ; i < workers.size(); ++ i) { for ( int j = 0 ; j < bikes.size(); ++ j) { pq.push({manhattan(workers[i], bikes[j]), i, j}); } } vector < int > wo(workers.size(), - 1 ), bi(bikes.size(), - 1 ); int assigned = 0 ; while ( ! pq.empty() && assigned < workers.size()) { TII t = pq.top(); printf( \"after: %d, %d, %d \\n \" , get < 0 > (t), get < 1 > (t), get < 2 > (t)); pq.pop(); if (wo[get < 1 > (t)] == - 1 && bi[get < 2 > (t)] == - 1 ) { // both unassigned wo[get < 1 > (t)] = get < 2 > (t); bi[get < 2 > (t)] = get < 1 > (t); assigned ++ ; } } return wo; } int main() { int w, b; cin >> w; vector < vector < int >> workers, bikes; for ( int i = 0 ; i < w; ++ i) { int x, y; cin >> x >> y; workers.push_back({x, y}); } cin >> b; for ( int i = 0 ; i < b; ++ i) { int x, y; cin >> x >> y; bikes.push_back({x, y}); } vector < int > res = assignBikes(workers, bikes); for ( int i : res) cout << i << \" \" ; return 0 ; } Variant 1: match as much as possible \u00b6 Find the assignment such that the most workers can be matched (there are obstacle that some bikes ain't reachabe by certain cars ). Using Hungarian algorithm \u00b6 match the workers in the order of manhattan distance (it actually doesn't matter, the order can be random) to the bike, keep matching until there is a tie. find the one with tie's other matches (same distance but different bike). Find the max # of matches for this bipartite graph Start from node 1, matches with 6 (because 6 < 8), then node 2 matches with 5 (5 < 7): mark matches with red lines When it comes to node 3, it can only matches with 6, but node 6 is already matched with 1. However, since node 1 can also matches with 8, node 1 will concede 6 and gives 6 to node 3. Final match: 4 pairs Complete Bipartite graph \u00b6 Since all workers can freely assigned with all the bikes, and bikes can \"choose\" any of the workers. It's a complete bipartitie graph. We should assume # of bikes != # of workes, or the ans is simply # of bikes or # of workers. #include<iostream> #include<cstring> using namespace std; const int N = 510 , M = 100010 ; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add ( int a , int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void init () { memset(h, - 1 , sizeof h); } int find ( int x) { //\u904d\u5386\u81ea\u5df1\u559c\u6b22\u7684\u5973\u5b69 for ( int i = h[x] ; i != - 1 ;i = ne[i]) { int j = e[i]; if ( ! st[j]) //\u5982\u679c\u5728\u8fd9\u4e00\u8f6e\u6a21\u62df\u5339\u914d\u4e2d,\u8fd9\u4e2a\u5973\u5b69\u5c1a\u672a\u88ab\u9884\u5b9a { st[j] = true; //\u90a3x\u5c31\u9884\u5b9a\u8fd9\u4e2a\u5973\u5b69\u4e86 //\u5982\u679c\u5973\u5b69j\u6ca1\u6709\u7537\u670b\u53cb\uff0c\u6216\u8005\u5979\u539f\u6765\u7684\u7537\u670b\u53cb\u80fd\u591f\u9884\u5b9a\u5176\u5b83\u559c\u6b22\u7684\u5973\u5b69\u3002\u914d\u5bf9\u6210\u529f if ( ! match[j] || find(match[j])) { match[j] = x; return true; } } } //\u81ea\u5df1\u4e2d\u610f\u7684\u5168\u90e8\u90fd\u88ab\u9884\u5b9a\u4e86\u3002\u914d\u5bf9\u5931\u8d25\u3002 return false; } int main () { init(); cin >> n1 >> n2 >> m; while (m -- ) { int a,b; cin >> a >> b; add(a,b); } int res = 0 ; for ( int i = 1 ; i <= n1 ;i ++ ) { //\u56e0\u4e3a\u6bcf\u6b21\u6a21\u62df\u5339\u914d\u7684\u9884\u5b9a\u60c5\u51b5\u90fd\u662f\u4e0d\u4e00\u6837\u7684\u6240\u4ee5\u6bcf\u8f6e\u6a21\u62df\u90fd\u8981\u521d\u59cb\u5316 memset(st,false, sizeof st); if (find(i)) res ++ ; } cout << res << endl; } \u4f5c\u8005\uff1a\u5728\u7ebf\u767d\u7ed9 \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/5334/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Variant 2: find the minimal total matches' manhattan distance \u00b6 Variant 3: find the max manhattan to be the smallest \u00b6 https://www.acwing.com/problem/content/259/ Property of the max distance: - dis > max: can assign all the bikes and workers whose manhattan distance are greater than max distance into other pairs (already assigned, so even if they have higher manhattan distance, they can still get the bike) - dis < max: there is a at least one bike and worker cannot be assigned whose distance is greater than max distance Use binary search for finding the biggest distance where the graph is still bipartite Use dfs to check if all the other can have the coloring Now we have a different problem: find the if the graph is bipartitie if max = ?, and we find the smallest max #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 20010 , M = 200010 ; int n, m; int h[N], e[M], w[M], ne[M], idx; int color[N]; void add ( int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs ( int u, int c, int limit) { color[u] = c; // color current node to c for ( int i = h[u]; ~ i; i = ne[i]) { if (w[i] <= limit) continue ; // weight is less than current found max wight int j = e[i]; if (color[j]) { if (color[j] == c) return false; // in the same group } else if ( ! dfs(j, 3 - c, limit)) return false; // check alternative coloring => place j to another group } return true; } bool check ( int limit) { memset(color, 0 , sizeof color); for ( int i = 1 ; i <= n; i ++ ) if (color[i] == 0 ) if ( ! dfs(i, 1 , limit)) // start with coloring current node with 1, any that couldn't make it work will return false return false; return true; } int main () { scanf( \"%d%d\" , & n, & m); memset(h, - 1 , sizeof h); while (m -- ) { int a, b, c; scanf( \"%d%d%d\" , & a, & b, & c); // a: bike id, b: worker id, c: weight add(a, b, c); add(b, a, c); } int l = 0 , r = 1e9 ; while (l < r) { int mid = l + r >> 1 ; if (check(mid)) r = mid; else l = mid + 1 ; } printf( \"%d \\n \" , l); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/3042/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"1057. campus bikes"},{"location":"Leetcode/1057.-campus-bikes/#analysis","text":"Sort based on 1. Manahattan distance between bike and worker 2. Worker index 3. Bike index Using Priority Queue if the input is unbounded.","title":"Analysis"},{"location":"Leetcode/1057.-campus-bikes/#code","text":"/* * tmp.cpp * Copyright (C) 2020 Haoyang <me@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; typedef tuple < int , int , int > TII; int inline manhattan (vector < int >& p1, vector < int >& p2) { return abs(p1[ 0 ] - p2[ 0 ]) + abs(p1[ 1 ] - p2[ 1 ]); } vector < int > assignBikes(vector < vector < int >>& workers, vector < vector < int >>& bikes) { /* *auto cmp = [](const TII& l, const TII& r) { * int ld = get<0>(l), rd = get<0>(r), wl = get<1>(l), wr = get<1>(r), * bl = get<2>(l), br = get<2>(r); * if (ld != rd) * return ld > rd; * else if (wl != wr) * return wl > wr; * else * return bl > br; *}; */ //priority_queue<TII, vector<TII>, decltype(cmp)> pq(cmp); priority_queue < TII, vector < TII > , greater < TII >> pq; for ( int i = 0 ; i < workers.size(); ++ i) { for ( int j = 0 ; j < bikes.size(); ++ j) { pq.push({manhattan(workers[i], bikes[j]), i, j}); } } vector < int > wo(workers.size(), - 1 ), bi(bikes.size(), - 1 ); int assigned = 0 ; while ( ! pq.empty() && assigned < workers.size()) { TII t = pq.top(); printf( \"after: %d, %d, %d \\n \" , get < 0 > (t), get < 1 > (t), get < 2 > (t)); pq.pop(); if (wo[get < 1 > (t)] == - 1 && bi[get < 2 > (t)] == - 1 ) { // both unassigned wo[get < 1 > (t)] = get < 2 > (t); bi[get < 2 > (t)] = get < 1 > (t); assigned ++ ; } } return wo; } int main() { int w, b; cin >> w; vector < vector < int >> workers, bikes; for ( int i = 0 ; i < w; ++ i) { int x, y; cin >> x >> y; workers.push_back({x, y}); } cin >> b; for ( int i = 0 ; i < b; ++ i) { int x, y; cin >> x >> y; bikes.push_back({x, y}); } vector < int > res = assignBikes(workers, bikes); for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Code"},{"location":"Leetcode/1057.-campus-bikes/#variant-1-match-as-much-as-possible","text":"Find the assignment such that the most workers can be matched (there are obstacle that some bikes ain't reachabe by certain cars ).","title":"Variant 1: match as much as possible"},{"location":"Leetcode/1057.-campus-bikes/#using-hungarian-algorithm","text":"match the workers in the order of manhattan distance (it actually doesn't matter, the order can be random) to the bike, keep matching until there is a tie. find the one with tie's other matches (same distance but different bike). Find the max # of matches for this bipartite graph Start from node 1, matches with 6 (because 6 < 8), then node 2 matches with 5 (5 < 7): mark matches with red lines When it comes to node 3, it can only matches with 6, but node 6 is already matched with 1. However, since node 1 can also matches with 8, node 1 will concede 6 and gives 6 to node 3. Final match: 4 pairs","title":"Using Hungarian algorithm"},{"location":"Leetcode/1057.-campus-bikes/#complete-bipartite-graph","text":"Since all workers can freely assigned with all the bikes, and bikes can \"choose\" any of the workers. It's a complete bipartitie graph. We should assume # of bikes != # of workes, or the ans is simply # of bikes or # of workers. #include<iostream> #include<cstring> using namespace std; const int N = 510 , M = 100010 ; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add ( int a , int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void init () { memset(h, - 1 , sizeof h); } int find ( int x) { //\u904d\u5386\u81ea\u5df1\u559c\u6b22\u7684\u5973\u5b69 for ( int i = h[x] ; i != - 1 ;i = ne[i]) { int j = e[i]; if ( ! st[j]) //\u5982\u679c\u5728\u8fd9\u4e00\u8f6e\u6a21\u62df\u5339\u914d\u4e2d,\u8fd9\u4e2a\u5973\u5b69\u5c1a\u672a\u88ab\u9884\u5b9a { st[j] = true; //\u90a3x\u5c31\u9884\u5b9a\u8fd9\u4e2a\u5973\u5b69\u4e86 //\u5982\u679c\u5973\u5b69j\u6ca1\u6709\u7537\u670b\u53cb\uff0c\u6216\u8005\u5979\u539f\u6765\u7684\u7537\u670b\u53cb\u80fd\u591f\u9884\u5b9a\u5176\u5b83\u559c\u6b22\u7684\u5973\u5b69\u3002\u914d\u5bf9\u6210\u529f if ( ! match[j] || find(match[j])) { match[j] = x; return true; } } } //\u81ea\u5df1\u4e2d\u610f\u7684\u5168\u90e8\u90fd\u88ab\u9884\u5b9a\u4e86\u3002\u914d\u5bf9\u5931\u8d25\u3002 return false; } int main () { init(); cin >> n1 >> n2 >> m; while (m -- ) { int a,b; cin >> a >> b; add(a,b); } int res = 0 ; for ( int i = 1 ; i <= n1 ;i ++ ) { //\u56e0\u4e3a\u6bcf\u6b21\u6a21\u62df\u5339\u914d\u7684\u9884\u5b9a\u60c5\u51b5\u90fd\u662f\u4e0d\u4e00\u6837\u7684\u6240\u4ee5\u6bcf\u8f6e\u6a21\u62df\u90fd\u8981\u521d\u59cb\u5316 memset(st,false, sizeof st); if (find(i)) res ++ ; } cout << res << endl; } \u4f5c\u8005\uff1a\u5728\u7ebf\u767d\u7ed9 \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/5334/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Complete Bipartite graph"},{"location":"Leetcode/1057.-campus-bikes/#variant-2-find-the-minimal-total-matches-manhattan-distance","text":"","title":"Variant 2: find the minimal total matches' manhattan distance"},{"location":"Leetcode/1057.-campus-bikes/#variant-3-find-the-max-manhattan-to-be-the-smallest","text":"https://www.acwing.com/problem/content/259/ Property of the max distance: - dis > max: can assign all the bikes and workers whose manhattan distance are greater than max distance into other pairs (already assigned, so even if they have higher manhattan distance, they can still get the bike) - dis < max: there is a at least one bike and worker cannot be assigned whose distance is greater than max distance Use binary search for finding the biggest distance where the graph is still bipartite Use dfs to check if all the other can have the coloring Now we have a different problem: find the if the graph is bipartitie if max = ?, and we find the smallest max #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 20010 , M = 200010 ; int n, m; int h[N], e[M], w[M], ne[M], idx; int color[N]; void add ( int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs ( int u, int c, int limit) { color[u] = c; // color current node to c for ( int i = h[u]; ~ i; i = ne[i]) { if (w[i] <= limit) continue ; // weight is less than current found max wight int j = e[i]; if (color[j]) { if (color[j] == c) return false; // in the same group } else if ( ! dfs(j, 3 - c, limit)) return false; // check alternative coloring => place j to another group } return true; } bool check ( int limit) { memset(color, 0 , sizeof color); for ( int i = 1 ; i <= n; i ++ ) if (color[i] == 0 ) if ( ! dfs(i, 1 , limit)) // start with coloring current node with 1, any that couldn't make it work will return false return false; return true; } int main () { scanf( \"%d%d\" , & n, & m); memset(h, - 1 , sizeof h); while (m -- ) { int a, b, c; scanf( \"%d%d%d\" , & a, & b, & c); // a: bike id, b: worker id, c: weight add(a, b, c); add(b, a, c); } int l = 0 , r = 1e9 ; while (l < r) { int mid = l + r >> 1 ; if (check(mid)) r = mid; else l = mid + 1 ; } printf( \"%d \\n \" , l); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/3042/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Variant 3: find the max manhattan to be the smallest"},{"location":"Leetcode/11.-container-with-most-water/","text":"Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Using two pointers \u00b6 if height[r] > height[l], then the next bigger one will be somewhere betweeen height[l+1] - height[r] curr = (height[r] - height[l]) * (r - l) next two candidates are: 1. (height[r-1] - height[l]) * (r - 1 - l) = (height[r-1] - height[l]) * (r - l) - (height[r-1] - height[l]) * 1 2. (height[r] - height[l+1]) * (r - 1 - l) = (height[r] - height[l+1]) * (r - l) - (height[r] - height[l+1]) * 1 Use 1. - curr:","title":"11. container with most water"},{"location":"Leetcode/11.-container-with-most-water/#using-two-pointers","text":"if height[r] > height[l], then the next bigger one will be somewhere betweeen height[l+1] - height[r] curr = (height[r] - height[l]) * (r - l) next two candidates are: 1. (height[r-1] - height[l]) * (r - 1 - l) = (height[r-1] - height[l]) * (r - l) - (height[r-1] - height[l]) * 1 2. (height[r] - height[l+1]) * (r - 1 - l) = (height[r] - height[l+1]) * (r - l) - (height[r] - height[l+1]) * 1 Use 1. - curr:","title":"Using two pointers"},{"location":"Leetcode/115.-distinct-subsequences/","text":"class Solution { public: int numDistinct(string s, string t) { int m = t.length(), n = s.length(); int64_t dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int j = 0 ; j <= n; j ++ ) dp[ 0 ][j] = 1 ; for ( int i = 1 ; i <= m; i ++ ) for ( int j = i; j <= n; j ++ ) dp[i][j] = dp[i][j - 1 ] + (t[i - 1 ] == s[j - 1 ] ? dp[i - 1 ][j - 1 ] : 0 ); return dp[m][n]; } }; S = \"rabbbit\", T = \"rabbit\" rabbbit ^ ^ ^^ rabbbit ^^ ^ ^ rabbbit ^ ^ note: can only delete dp[i][j]: ways to transform S[0:i] to T[0:j] if t is \"\", then only one way to form t from s (delete all) if t[i] == s[j]: dp[i][j] = dp[i-1][j-1]+dp[i][j-1] -> t can choose either delete the current one or not, both are valid if t[i] != s[j]: dp[i][j] = dp[i][j-1] -> the extra one cannot be counted and should only use the previous stage result (delete current one)","title":"115. distinct subsequences"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/","text":"solution all referenced from: \u4f5c\u8005\uff1alabuladong \u94fe\u63a5\uff1a https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. presumptions \u00b6 there is only one stock to be bought no consective buy or sell happens (buy on day one and buy one day two, instead, can only choose rest or sell) state machine \u00b6 representation dp[i][j][k] 1. i: current day from day zero 2. j: transections left 3. k: {1,0} own (rest) or sold (sell) dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 sell ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6ca1\u6709\u6301\u6709\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u662f\u6211\u6628\u5929\u5c31\u6ca1\u6709\u6301\u6709\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u662f\u6ca1\u6709\u6301\u6709\uff1b \u8981\u4e48\u662f\u6211\u6628\u5929\u6301\u6709\u80a1\u7968\uff0c\u4f46\u662f\u4eca\u5929\u6211 sell \u4e86\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u6ca1\u6709\u6301\u6709\u80a1\u7968\u4e86\u3002 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 buy ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6301\u6709\u7740\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u6211\u6628\u5929\u5c31\u6301\u6709\u7740\u80a1\u7968\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u6301\u6709\u7740\u80a1\u7968\uff1b \u8981\u4e48\u6211\u6628\u5929\u672c\u6ca1\u6709\u6301\u6709\uff0c\u4f46\u4eca\u5929\u6211\u9009\u62e9 buy\uff0c\u6240\u4ee5\u4eca\u5929\u6211\u5c31\u6301\u6709\u80a1\u7968\u4e86\u3002 inital : dp[-1][k][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a i \u662f\u4ece 0 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 i = -1 \u610f\u5473\u7740\u8fd8\u6ca1\u6709\u5f00\u59cb\uff0c\u8fd9\u65f6\u5019\u7684\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[-1][k][1] = -infinity \u89e3\u91ca\uff1a\u8fd8\u6ca1\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 dp[i][0][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a k \u662f\u4ece 1 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 k = 0 \u610f\u5473\u7740\u6839\u672c\u4e0d\u5141\u8bb8\u4ea4\u6613\uff0c\u8fd9\u65f6\u5019\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[i][0][1] = -infinity \u89e3\u91ca\uff1a\u4e0d\u5141\u8bb8\u4ea4\u6613\u7684\u60c5\u51b5\u4e0b\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 part 1: one transection \u00b6 dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) \u89e3\u91ca\uff1ak = 0 \u7684 base case\uff0c\u6240\u4ee5 dp[i-1][0][0] = 0\u3002 \u73b0\u5728\u53d1\u73b0 k \u90fd\u662f 1\uff0c\u4e0d\u4f1a\u6539\u53d8\uff0c\u5373 k \u5bf9\u72b6\u6001\u8f6c\u79fb\u5df2\u7ecf\u6ca1\u6709\u5f71\u54cd\u4e86\u3002 \u53ef\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u5316\u7b80\u53bb\u6389\u6240\u6709 k\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) for ( int i = 0 ; i < n; i ++ ) { if (i - 1 == - 1 ) { // i==0 dp[i][ 0 ] = 0 ; // \u89e3\u91ca\uff1a // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][ 1 ] = - prices[i]; //\u89e3\u91ca\uff1a // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue ; } dp[i][ 0 ] = max(dp[i - 1 ][ 0 ], dp[i - 1 ][ 1 ] + prices[i]); dp[i][ 1 ] = max(dp[i - 1 ][ 1 ], - prices[i]); // now is sell, if last is sold now has to hold // if last is buy, now is rest } return dp[n - 1 ][ 0 ]; part 2: k transections \u00b6 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) \u6211\u4eec\u53d1\u73b0\u6570\u7ec4\u4e2d\u7684 k \u5df2\u7ecf\u4e0d\u4f1a\u6539\u53d8\u4e86\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u9700\u8981\u8bb0\u5f55 k \u8fd9\u4e2a\u72b6\u6001\u4e86\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) int maxProfit_k_inf (vector < int > prices) { int n = prices.size(); int dp_i_0 = 0 , dp_i_1 = INT_MIN; for ( int i = 0 ; i < n; i ++ ) { int temp = dp_i_0; // last state is dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, temp - prices[i]); } return dp_i_0; }","title":"121,123,132,188,309,714 best time to buy and sell stock"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#presumptions","text":"there is only one stock to be bought no consective buy or sell happens (buy on day one and buy one day two, instead, can only choose rest or sell)","title":"presumptions"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#state-machine","text":"representation dp[i][j][k] 1. i: current day from day zero 2. j: transections left 3. k: {1,0} own (rest) or sold (sell) dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 sell ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6ca1\u6709\u6301\u6709\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u662f\u6211\u6628\u5929\u5c31\u6ca1\u6709\u6301\u6709\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u662f\u6ca1\u6709\u6301\u6709\uff1b \u8981\u4e48\u662f\u6211\u6628\u5929\u6301\u6709\u80a1\u7968\uff0c\u4f46\u662f\u4eca\u5929\u6211 sell \u4e86\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u6ca1\u6709\u6301\u6709\u80a1\u7968\u4e86\u3002 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 buy ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6301\u6709\u7740\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u6211\u6628\u5929\u5c31\u6301\u6709\u7740\u80a1\u7968\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u6301\u6709\u7740\u80a1\u7968\uff1b \u8981\u4e48\u6211\u6628\u5929\u672c\u6ca1\u6709\u6301\u6709\uff0c\u4f46\u4eca\u5929\u6211\u9009\u62e9 buy\uff0c\u6240\u4ee5\u4eca\u5929\u6211\u5c31\u6301\u6709\u80a1\u7968\u4e86\u3002 inital : dp[-1][k][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a i \u662f\u4ece 0 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 i = -1 \u610f\u5473\u7740\u8fd8\u6ca1\u6709\u5f00\u59cb\uff0c\u8fd9\u65f6\u5019\u7684\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[-1][k][1] = -infinity \u89e3\u91ca\uff1a\u8fd8\u6ca1\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 dp[i][0][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a k \u662f\u4ece 1 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 k = 0 \u610f\u5473\u7740\u6839\u672c\u4e0d\u5141\u8bb8\u4ea4\u6613\uff0c\u8fd9\u65f6\u5019\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[i][0][1] = -infinity \u89e3\u91ca\uff1a\u4e0d\u5141\u8bb8\u4ea4\u6613\u7684\u60c5\u51b5\u4e0b\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002","title":"state machine"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#part-1-one-transection","text":"dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) \u89e3\u91ca\uff1ak = 0 \u7684 base case\uff0c\u6240\u4ee5 dp[i-1][0][0] = 0\u3002 \u73b0\u5728\u53d1\u73b0 k \u90fd\u662f 1\uff0c\u4e0d\u4f1a\u6539\u53d8\uff0c\u5373 k \u5bf9\u72b6\u6001\u8f6c\u79fb\u5df2\u7ecf\u6ca1\u6709\u5f71\u54cd\u4e86\u3002 \u53ef\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u5316\u7b80\u53bb\u6389\u6240\u6709 k\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) for ( int i = 0 ; i < n; i ++ ) { if (i - 1 == - 1 ) { // i==0 dp[i][ 0 ] = 0 ; // \u89e3\u91ca\uff1a // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][ 1 ] = - prices[i]; //\u89e3\u91ca\uff1a // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue ; } dp[i][ 0 ] = max(dp[i - 1 ][ 0 ], dp[i - 1 ][ 1 ] + prices[i]); dp[i][ 1 ] = max(dp[i - 1 ][ 1 ], - prices[i]); // now is sell, if last is sold now has to hold // if last is buy, now is rest } return dp[n - 1 ][ 0 ];","title":"part 1: one transection"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#part-2-k-transections","text":"dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) \u6211\u4eec\u53d1\u73b0\u6570\u7ec4\u4e2d\u7684 k \u5df2\u7ecf\u4e0d\u4f1a\u6539\u53d8\u4e86\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u9700\u8981\u8bb0\u5f55 k \u8fd9\u4e2a\u72b6\u6001\u4e86\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) int maxProfit_k_inf (vector < int > prices) { int n = prices.size(); int dp_i_0 = 0 , dp_i_1 = INT_MIN; for ( int i = 0 ; i < n; i ++ ) { int temp = dp_i_0; // last state is dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, temp - prices[i]); } return dp_i_0; }","title":"part 2: k transections"},{"location":"Leetcode/139.-word-break/","text":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false cpp: dfs with memo \u00b6 class Solution { public: unordered_map < string, bool > memo; bool wordBreak (string s, vector < string >& wordDict) { unordered_set < string > dict(wordDict.begin(), wordDict.end()); return dfs(s, dict); } bool dfs (string s, unordered_set < string >& dict) { if (memo.count(s)) return memo[s]; if (dict.count(s)) return memo[s] = true; for ( int i = 1 ; i < s.size(); ++ i) { if (dict.count(s.substr( 0 , i)) == 0 ) // cannot split from here continue ; if (dfs(s.substr(i), dict)) // 0-i do exist, now check the rest return memo[s] = true; } return memo[s] = false; // has tried all options } }; java: dp \u00b6 public class Solution { public boolean wordBreak (String s, Set < String > dict) { boolean [] f = new boolean [ s. length () + 1 ] ; f [ 0 ] = true ; /* First DP for(int i = 1; i <= s.length(); i++){ for(String str: dict){ // check each element in dp if(str.length() <= i){ if(f[i - str.length()]){ // complement exist if(s.substring(i-str.length(), i).equals(str)){ f[i] = true; break; } } } } }*/ //Second DP for ( int i = 1 ; i <= s. length (); i ++ ){ for ( int j = 0 ; j < i; j ++ ){ // split current s into s[0:j] and s[j:i] if (f [ j ] && dict. contains (s. substring (j, i))){ f [ i ] = true ; break ; } } } return f [ s. length () ] ; } } f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes. The default value for boolean array is false. Therefore we need to set f[0] to be true. cpp w/ optimization \u00b6 class Solution { public: bool wordBreak(string s, vector < string >& word) { int n = s.size(); vector < bool > dp(n + 1 ); dp[ 0 ] = true; for ( int i = 0 ; i < n; i ++ ) if (dp[i]) { // only consider if s[0:i] already exists for ( auto & str: word) { int l = str.size(); if (s.substr(i, l) == str) dp[i + l] = true; // s[0:i] and s[i+str.size()] all valid } } return dp.back(); } }; instead of comparing with the rest from s, compare with the word dict.","title":"139. word break"},{"location":"Leetcode/139.-word-break/#cpp-dfs-with-memo","text":"class Solution { public: unordered_map < string, bool > memo; bool wordBreak (string s, vector < string >& wordDict) { unordered_set < string > dict(wordDict.begin(), wordDict.end()); return dfs(s, dict); } bool dfs (string s, unordered_set < string >& dict) { if (memo.count(s)) return memo[s]; if (dict.count(s)) return memo[s] = true; for ( int i = 1 ; i < s.size(); ++ i) { if (dict.count(s.substr( 0 , i)) == 0 ) // cannot split from here continue ; if (dfs(s.substr(i), dict)) // 0-i do exist, now check the rest return memo[s] = true; } return memo[s] = false; // has tried all options } };","title":"cpp: dfs with memo"},{"location":"Leetcode/139.-word-break/#java-dp","text":"public class Solution { public boolean wordBreak (String s, Set < String > dict) { boolean [] f = new boolean [ s. length () + 1 ] ; f [ 0 ] = true ; /* First DP for(int i = 1; i <= s.length(); i++){ for(String str: dict){ // check each element in dp if(str.length() <= i){ if(f[i - str.length()]){ // complement exist if(s.substring(i-str.length(), i).equals(str)){ f[i] = true; break; } } } } }*/ //Second DP for ( int i = 1 ; i <= s. length (); i ++ ){ for ( int j = 0 ; j < i; j ++ ){ // split current s into s[0:j] and s[j:i] if (f [ j ] && dict. contains (s. substring (j, i))){ f [ i ] = true ; break ; } } } return f [ s. length () ] ; } } f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes. The default value for boolean array is false. Therefore we need to set f[0] to be true.","title":"java: dp"},{"location":"Leetcode/139.-word-break/#cpp-w-optimization","text":"class Solution { public: bool wordBreak(string s, vector < string >& word) { int n = s.size(); vector < bool > dp(n + 1 ); dp[ 0 ] = true; for ( int i = 0 ; i < n; i ++ ) if (dp[i]) { // only consider if s[0:i] already exists for ( auto & str: word) { int l = str.size(); if (s.substr(i, l) == str) dp[i + l] = true; // s[0:i] and s[i+str.size()] all valid } } return dp.back(); } }; instead of comparing with the rest from s, compare with the word dict.","title":"cpp w/ optimization"},{"location":"Leetcode/140.-word-break-ii/","text":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"catsanddog\" wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output: [ \"cats and dog\", \"cat sand dog\" ] Example 2: Input: s = \"pineapplepenapple\" wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] Output: [ \"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\" ] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\" wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: [] dfs w/ memo \u00b6 class Solution { unordered_map < string, vector < string >> m; vector < string > combine (string word, vector < string > prev){ for ( int i = 0 ;i < prev. size (); ++ i){ prev [ i ]+= \" \" + word; } return prev; } public: vector < string > wordBreak (string s, unordered_set < string >& dict) { if (m. count (s)) return m [ s ] ; //take from memory vector < string > result; if (dict. count (s)){ //a whole string is a word result. push_back (s); } for ( int i = 1 ;i < s. size (); ++ i){ string word = s. substr (i); if (dict. count (word)){ //s[0:i] and s[i:], s[i:] is checked, now check s[0:i] string rem = s. substr ( 0 ,i); vector < string > prev = combine(word,wordBreak(rem,dict)); result. insert (result. end (),prev. begin (), prev. end ()); } } m [ s ]= result; //memorize return result; } }; dfs always takes in from s[0:i], and check s[i:] for current branch cache is the map of current s[0:i] to all the combination for this substring, so for s[0:i+1], to check s[0:i], just uses the cached one and combine with s[:i]","title":"140. word break ii"},{"location":"Leetcode/140.-word-break-ii/#dfs-w-memo","text":"class Solution { unordered_map < string, vector < string >> m; vector < string > combine (string word, vector < string > prev){ for ( int i = 0 ;i < prev. size (); ++ i){ prev [ i ]+= \" \" + word; } return prev; } public: vector < string > wordBreak (string s, unordered_set < string >& dict) { if (m. count (s)) return m [ s ] ; //take from memory vector < string > result; if (dict. count (s)){ //a whole string is a word result. push_back (s); } for ( int i = 1 ;i < s. size (); ++ i){ string word = s. substr (i); if (dict. count (word)){ //s[0:i] and s[i:], s[i:] is checked, now check s[0:i] string rem = s. substr ( 0 ,i); vector < string > prev = combine(word,wordBreak(rem,dict)); result. insert (result. end (),prev. begin (), prev. end ()); } } m [ s ]= result; //memorize return result; } }; dfs always takes in from s[0:i], and check s[i:] for current branch cache is the map of current s[0:i] to all the combination for this substring, so for s[0:i+1], to check s[0:i], just uses the cached one and combine with s[:i]","title":"dfs w/ memo"},{"location":"Leetcode/146.-lru-cache/","text":"Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 / capacity / ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 double linked list with map (java) \u00b6 import java.util.Hashtable; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } /** * Always add the new node right after head; */ /* before: node.pre - node - node.post head - head.post (tail) after: head - node - head.post (tail) */ private void addNode (DLinkedNode node) { node. pre = head; node. post = head. post ; head. post . pre = node; head. post = node; } /** * Remove an existing node from the linked list. */ // pre - node - post -> pre - post private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } /** * Move certain node in between to the head. */ private void moveToHead (DLinkedNode node){ this . removeNode (node); this . addNode (node); // head->post now point to node } // pop the current tail. private DLinkedNode popTail (){ DLinkedNode res = tail. pre ; this . removeNode (res); // return res; } private Hashtable < Integer, DLinkedNode > cache = new Hashtable < Integer, DLinkedNode > (); private int count; private int capacity; private DLinkedNode head, tail; // head.pre (null) - head - head.post (tail) // tail.pre (head) - tail - tail.post (null) // -> head.pre (null) - head - tail - tail.post (null) public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } public int get ( int key) { DLinkedNode node = cache. get (key); if (node == null ){ return - 1 ; // should raise exception here. } // move the accessed node to the head; this . moveToHead (node); return node. value ; } public void put ( int key, int value) { DLinkedNode node = cache. get (key); if (node == null ){ // need to insert new key-value pair into the list DLinkedNode newNode = new DLinkedNode(); newNode. key = key; newNode. value = value; this . cache . put (key, newNode); this . addNode (newNode); ++ count; // same as the size of cache.size() if (count > capacity){ // pop the tail DLinkedNode tail = this . popTail (); this . cache . remove (tail. key ); -- count; } } else { // just swap to the head and update value node. value = value; this . moveToHead (node); } } } why bother doubly linked list \u00b6 Fast removal. Doubly linked lists let us remove and insert in constant time if we have access to a node directly. The hashtable gives us access to a node directly. If we use a singly linked list we will need to spend O(n) time to remove a node even if we have direct reference to the node that needs to get removed. (This is because to remove in a singly linked list we need to point nodeToDelete's previous node to nodeToDelete's next node. Finding nodeToDelete's previous is expensive if nodeToDelete is the last node in the list.) why cannot converted to singly linked list in Java \u00b6 People who are wondering why we have double-linked list here instead of single-linked linked list : Yes, the purpose can be achieved with a single-linked LL with some hacks but NOT in java. Let's say I've to remove node n and it's previous node is p. If n is the last node in the list, I've to modify the next field of p to point to null. This can't be done if I don't have access to p.next since in java, method parameters are actually references of the objects and they are passed by value. So, let's say right now, n and p.next point to the same object (i.e. n of course). If I do n=null, that doesn't makes the object null. The object is still there and p.next points to that object. The only diff is that now n doesn't point to that object. In fact, it doesn't point to anything. n=null doesn't remove n, but just send what it points-to to null public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } if tail.pre is always pointing to head, and head.post always points to tail private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } cpp \u00b6 class LRUCache { struct Node { int key, val; Node * next, * pre; Node( int key, int val) : key(key) , val(val) { } }; private: unordered_map < int , Node *> map; int cap; Node * head, * tail; public: LRUCache( int capacity) { cap = capacity; head = NULL, tail = NULL; } int get( int key) { if ( ! map.count(key)) return - 1 ; Node * node = map[key]; if (node != tail) { if (node == head) { head = head -> next; // head always point to newly added node } else { node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL; tail = node; } return node -> val; } void put( int key, int value) { // exist if (map.count(key)) { Node * node = map[key]; node -> val = value; // update value if (node != tail) { if (node == head) { // head now points to the second recent used node head = head -> next; } else { // split out node, now node.pre - node.next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL; tail = node; } } else { Node * newNode = new Node(key, value); if (cap == 0 ) { // cap == capacity - map.size() Node * temp = head; head = head -> next; map.erase(temp -> key); cap ++ ; } if (head == NULL && tail == NULL) { head = newNode; } else { tail -> next = newNode; newNode -> pre = tail; newNode -> next = NULL; } tail = newNode; map[key] = newNode; cap -- ; } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ head: least recent used node tail: most recent used node","title":"146. lru cache"},{"location":"Leetcode/146.-lru-cache/#double-linked-list-with-map-java","text":"import java.util.Hashtable; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } /** * Always add the new node right after head; */ /* before: node.pre - node - node.post head - head.post (tail) after: head - node - head.post (tail) */ private void addNode (DLinkedNode node) { node. pre = head; node. post = head. post ; head. post . pre = node; head. post = node; } /** * Remove an existing node from the linked list. */ // pre - node - post -> pre - post private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } /** * Move certain node in between to the head. */ private void moveToHead (DLinkedNode node){ this . removeNode (node); this . addNode (node); // head->post now point to node } // pop the current tail. private DLinkedNode popTail (){ DLinkedNode res = tail. pre ; this . removeNode (res); // return res; } private Hashtable < Integer, DLinkedNode > cache = new Hashtable < Integer, DLinkedNode > (); private int count; private int capacity; private DLinkedNode head, tail; // head.pre (null) - head - head.post (tail) // tail.pre (head) - tail - tail.post (null) // -> head.pre (null) - head - tail - tail.post (null) public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } public int get ( int key) { DLinkedNode node = cache. get (key); if (node == null ){ return - 1 ; // should raise exception here. } // move the accessed node to the head; this . moveToHead (node); return node. value ; } public void put ( int key, int value) { DLinkedNode node = cache. get (key); if (node == null ){ // need to insert new key-value pair into the list DLinkedNode newNode = new DLinkedNode(); newNode. key = key; newNode. value = value; this . cache . put (key, newNode); this . addNode (newNode); ++ count; // same as the size of cache.size() if (count > capacity){ // pop the tail DLinkedNode tail = this . popTail (); this . cache . remove (tail. key ); -- count; } } else { // just swap to the head and update value node. value = value; this . moveToHead (node); } } }","title":"double linked list with map (java)"},{"location":"Leetcode/146.-lru-cache/#why-bother-doubly-linked-list","text":"Fast removal. Doubly linked lists let us remove and insert in constant time if we have access to a node directly. The hashtable gives us access to a node directly. If we use a singly linked list we will need to spend O(n) time to remove a node even if we have direct reference to the node that needs to get removed. (This is because to remove in a singly linked list we need to point nodeToDelete's previous node to nodeToDelete's next node. Finding nodeToDelete's previous is expensive if nodeToDelete is the last node in the list.)","title":"why bother doubly linked list"},{"location":"Leetcode/146.-lru-cache/#why-cannot-converted-to-singly-linked-list-in-java","text":"People who are wondering why we have double-linked list here instead of single-linked linked list : Yes, the purpose can be achieved with a single-linked LL with some hacks but NOT in java. Let's say I've to remove node n and it's previous node is p. If n is the last node in the list, I've to modify the next field of p to point to null. This can't be done if I don't have access to p.next since in java, method parameters are actually references of the objects and they are passed by value. So, let's say right now, n and p.next point to the same object (i.e. n of course). If I do n=null, that doesn't makes the object null. The object is still there and p.next points to that object. The only diff is that now n doesn't point to that object. In fact, it doesn't point to anything. n=null doesn't remove n, but just send what it points-to to null public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } if tail.pre is always pointing to head, and head.post always points to tail private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; }","title":"why cannot converted to singly linked list in Java"},{"location":"Leetcode/146.-lru-cache/#cpp","text":"class LRUCache { struct Node { int key, val; Node * next, * pre; Node( int key, int val) : key(key) , val(val) { } }; private: unordered_map < int , Node *> map; int cap; Node * head, * tail; public: LRUCache( int capacity) { cap = capacity; head = NULL, tail = NULL; } int get( int key) { if ( ! map.count(key)) return - 1 ; Node * node = map[key]; if (node != tail) { if (node == head) { head = head -> next; // head always point to newly added node } else { node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL; tail = node; } return node -> val; } void put( int key, int value) { // exist if (map.count(key)) { Node * node = map[key]; node -> val = value; // update value if (node != tail) { if (node == head) { // head now points to the second recent used node head = head -> next; } else { // split out node, now node.pre - node.next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL; tail = node; } } else { Node * newNode = new Node(key, value); if (cap == 0 ) { // cap == capacity - map.size() Node * temp = head; head = head -> next; map.erase(temp -> key); cap ++ ; } if (head == NULL && tail == NULL) { head = newNode; } else { tail -> next = newNode; newNode -> pre = tail; newNode -> next = NULL; } tail = newNode; map[key] = newNode; cap -- ; } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ head: least recent used node tail: most recent used node","title":"cpp"},{"location":"Leetcode/152.-maximum-product-subarray/","text":"refer to /tech_notes/Lai/Maximum Product Subarray","title":"152. maximum product subarray"},{"location":"Leetcode/2.-add-two-numbers/","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. Analysis \u00b6 Two input linkedlists have already revsered, so we can just use two pointer to make the addition. To deal with carry bit, we need a integer to show the current sum. If the current sum is equal/greater than 10, then carry = 1 and sum %= 10 Time: O(min(size of l1, size of l2)) Code \u00b6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode * addTwoNumbers(ListNode * l1, ListNode * l2) { ListNode * dummy = new ListNode( - 1 ), * curr = dummy; int carry = 0 ; while (l1 || l2) { // either one is terminated int val1 = l1 ? l1 -> val : 0 ; int val2 = l2 ? l2 -> val : 0 ; int sum = val1 + val2 + carry; carry = sum / 10 ; // if greater than 10 -> carry > 0 curr -> next = new ListNode(sum % 10 ); curr = curr -> next; if (l1) l1 = l1 -> next; if (l2) l2 = l2 -> next; } if (carry) // final check curr -> next = new ListNode( 1 ); return dummy -> next; } };","title":"2. add two numbers"},{"location":"Leetcode/2.-add-two-numbers/#analysis","text":"Two input linkedlists have already revsered, so we can just use two pointer to make the addition. To deal with carry bit, we need a integer to show the current sum. If the current sum is equal/greater than 10, then carry = 1 and sum %= 10 Time: O(min(size of l1, size of l2))","title":"Analysis"},{"location":"Leetcode/2.-add-two-numbers/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode * addTwoNumbers(ListNode * l1, ListNode * l2) { ListNode * dummy = new ListNode( - 1 ), * curr = dummy; int carry = 0 ; while (l1 || l2) { // either one is terminated int val1 = l1 ? l1 -> val : 0 ; int val2 = l2 ? l2 -> val : 0 ; int sum = val1 + val2 + carry; carry = sum / 10 ; // if greater than 10 -> carry > 0 curr -> next = new ListNode(sum % 10 ); curr = curr -> next; if (l1) l1 = l1 -> next; if (l2) l2 = l2 -> next; } if (carry) // final check curr -> next = new ListNode( 1 ); return dummy -> next; } };","title":"Code"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/","text":"Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Property for Trie Tree \u00b6 each node does not store complete word each path has a character, the word to current node is the path with all the characters each leaf node marks as end for telling it's a complete word each leaf can store the frequency (7, 3, 4, 15, 12, 11, 5, 9) in this case in the same level, all the silbilings are not the same if just typing in the prefix, trie can print out all the suggesting silbilings each node can has 26 (all lower case) children - pretty bad space complexity cpp: dynamically generate 26 nodes all the time \u00b6 struct TrieNode { TrieNode * next[ 26 ]; bool is_word; TrieNode( bool b = false) : is_word(b) { memset(next, 0 , sizeof (next)); // next store address instead of the value itself } }; class Trie { private: TrieNode * root; TrieNode * find (string key) { TrieNode * p = root; for ( int i = 0 ; i < key.size() && p != NULL; ++ i) { p = p -> next[key[i] - 'a' ]; } return p; } public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode * p = root; for ( int i = 0 ; i < word.size(); ++ i) { if (p -> next[word[i] - 'a' ] == NULL) // not assign any value yet p -> next[word[i] - 'a' ] = new TrieNode(); // only new when p = p -> next[word[i] - 'a' ]; } p -> is_word = true; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode * p = find(word); return p != NULL && p -> is_word; } /** Returns if there is any word in the trie that starts with the given * prefix. */ bool startsWith(string prefix) { return find(prefix) != NULL; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_3 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"208. implement trie (prefix tree)"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#property-for-trie-tree","text":"each node does not store complete word each path has a character, the word to current node is the path with all the characters each leaf node marks as end for telling it's a complete word each leaf can store the frequency (7, 3, 4, 15, 12, 11, 5, 9) in this case in the same level, all the silbilings are not the same if just typing in the prefix, trie can print out all the suggesting silbilings each node can has 26 (all lower case) children - pretty bad space complexity","title":"Property for Trie Tree"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#cpp-dynamically-generate-26-nodes-all-the-time","text":"struct TrieNode { TrieNode * next[ 26 ]; bool is_word; TrieNode( bool b = false) : is_word(b) { memset(next, 0 , sizeof (next)); // next store address instead of the value itself } }; class Trie { private: TrieNode * root; TrieNode * find (string key) { TrieNode * p = root; for ( int i = 0 ; i < key.size() && p != NULL; ++ i) { p = p -> next[key[i] - 'a' ]; } return p; } public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode * p = root; for ( int i = 0 ; i < word.size(); ++ i) { if (p -> next[word[i] - 'a' ] == NULL) // not assign any value yet p -> next[word[i] - 'a' ] = new TrieNode(); // only new when p = p -> next[word[i] - 'a' ]; } p -> is_word = true; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode * p = find(word); return p != NULL && p -> is_word; } /** Returns if there is any word in the trie that starts with the given * prefix. */ bool startsWith(string prefix) { return find(prefix) != NULL; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_3 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"cpp: dynamically generate 26 nodes all the time"},{"location":"Leetcode/295.-find-median-from-data-stream/","text":"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Analysis \u00b6 To find the median, we need to split data into two halfs, and then use (first half's last element + second half's first element) / 2 (even) or first half's last (odd) to find the median. First half's last should be the value that is greater or equal to all the values from the first half of the data, and the second half's first is less than all the elements following. To find such two elements, we can use priority queue. Use one queue for finding the large median (max heap), and use the other queue to find the smaller median (min heap). To make two queues with the size difference at most 1, we need to find a way to balance the two queues. Complexity: Time: add takes O(\\log{n}) O(\\log{n}) + find takes O(1) O(1) Space: two queues take O(n) O(n) Solution 1 [Recommend]: use global odd or even to determine median \u00b6 xxxx m yyyy q1: xxxx q2: yyyy xxxxm yyyy z // push from odd 1. xxxxzm yyyy -> xxxxxx yyyy -> xxxxx yyyyx -> xxxxx yyyyy -> m = (x + y) / 2 2. xxxxm zyyyy -> xxxxm yyyyy -> xxxxx yyyyy -> m = (x + y) / 2 xxxm yyyy z // push from even 1. xxxzm yyyy -> xxxx yyyyx -> xxxxm yyyy 2. xxxm yyyyz -> xxxx yyyyy -> xxxxm yyyy if there are even num of nodes then push to large then push the top of large to small // now it's odd else then push to small then push the top of small to large // now it's even Code \u00b6 class MedianFinder { private: priority_queue < double > small, large; bool even; public: /** initialize your data structure here. */ MedianFinder() { even = true; // 0 is even } void addNum( int num) { if (even) { // small.size() == large.size() large.push( - num); small.push( - large.top()); large.pop(); } else { // small.size() - large.size() == 1 small.push(num); large.push( - small.top()); small.pop(); } even = ! even; } double findMedian() { return ! even ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Solution 2: without even boolean \u00b6 Use two priority queues to store the streaming element. 2 small: 2 -> empty -> 2 large: -2 -> empty median: 2 2, 3 small: 2 -> 3,2 -> 2 large: empty -> -3 median: \\frac{2 - (-3)}{2} = 2.5 \\frac{2 - (-3)}{2} = 2.5 2, 3, 4 small: 2 -> 4, 2 -> 2 -> 3, 2 large: -3 -> -3, -4 -> -4 median: 3 Code \u00b6 class MedianFinder { private: priority_queue < long > small, large; public: /** initialize your data structure here. */ MedianFinder() {} void addNum( int num) { // blindly push in two pq small.push(num); large.push( - small.top()); // small is always greater than large in size, at most greater by one, equal is fine small.pop(); // leave the new element in large if (small.size() < large.size()) { small.push( - large.top()); large.pop(); // large has one more, so move it to small } } double findMedian() { return small.size() != large.size() ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Followups \u00b6 With all fall in between 0-100? Code O(100) O(100) \u00b6 class MedianFinder { private: int A[ 101 ], n; public: MedianFinder() { n = 0 ; memset(A, 0 , sizeof A); } void addNum( int num) { A[num] ++ ; n ++ ; } double findMedian() { int count = 0 , i = 0 ; while (count < n / 2 ) count += A[i ++ ]; int j = i; while (count < n / 2 + 1 ) count += A[j ++ ]; return (n % 2 == 1 ) ? j - 1 : (i + j - 2 ) / 2.0 ; } }; Further Thoughts: https://leetcode.com/articles/find-median-from-data-stream/ There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across: Buckets ! If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. @mitbbs8080 has an interesting implementation here . Reservoir Sampling . Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or reservoir) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a \" good \" size for your reservoir? Now, that's a whole other challenge. A good explanation for this can be found in this StackOverflow answer . Segment Trees are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations fast and in roughly the same amount of time , always . The only problem is that they are far from trivial to implement. Take a look at my introductory article on Segment Trees if you are interested. Order Statistic Trees are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the k^{th} k^{th} order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. GNU libstdc++ users are in luck! Take a look at this StackOverflow answer . \u21a9","title":"295. find median from data stream"},{"location":"Leetcode/295.-find-median-from-data-stream/#analysis","text":"To find the median, we need to split data into two halfs, and then use (first half's last element + second half's first element) / 2 (even) or first half's last (odd) to find the median. First half's last should be the value that is greater or equal to all the values from the first half of the data, and the second half's first is less than all the elements following. To find such two elements, we can use priority queue. Use one queue for finding the large median (max heap), and use the other queue to find the smaller median (min heap). To make two queues with the size difference at most 1, we need to find a way to balance the two queues. Complexity: Time: add takes O(\\log{n}) O(\\log{n}) + find takes O(1) O(1) Space: two queues take O(n) O(n)","title":"Analysis"},{"location":"Leetcode/295.-find-median-from-data-stream/#solution-1-recommend-use-global-odd-or-even-to-determine-median","text":"xxxx m yyyy q1: xxxx q2: yyyy xxxxm yyyy z // push from odd 1. xxxxzm yyyy -> xxxxxx yyyy -> xxxxx yyyyx -> xxxxx yyyyy -> m = (x + y) / 2 2. xxxxm zyyyy -> xxxxm yyyyy -> xxxxx yyyyy -> m = (x + y) / 2 xxxm yyyy z // push from even 1. xxxzm yyyy -> xxxx yyyyx -> xxxxm yyyy 2. xxxm yyyyz -> xxxx yyyyy -> xxxxm yyyy if there are even num of nodes then push to large then push the top of large to small // now it's odd else then push to small then push the top of small to large // now it's even","title":"Solution 1 [Recommend]: use global odd or even to determine median"},{"location":"Leetcode/295.-find-median-from-data-stream/#code","text":"class MedianFinder { private: priority_queue < double > small, large; bool even; public: /** initialize your data structure here. */ MedianFinder() { even = true; // 0 is even } void addNum( int num) { if (even) { // small.size() == large.size() large.push( - num); small.push( - large.top()); large.pop(); } else { // small.size() - large.size() == 1 small.push(num); large.push( - small.top()); small.pop(); } even = ! even; } double findMedian() { return ! even ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */","title":"Code"},{"location":"Leetcode/295.-find-median-from-data-stream/#solution-2-without-even-boolean","text":"Use two priority queues to store the streaming element. 2 small: 2 -> empty -> 2 large: -2 -> empty median: 2 2, 3 small: 2 -> 3,2 -> 2 large: empty -> -3 median: \\frac{2 - (-3)}{2} = 2.5 \\frac{2 - (-3)}{2} = 2.5 2, 3, 4 small: 2 -> 4, 2 -> 2 -> 3, 2 large: -3 -> -3, -4 -> -4 median: 3","title":"Solution 2: without even boolean"},{"location":"Leetcode/295.-find-median-from-data-stream/#code_1","text":"class MedianFinder { private: priority_queue < long > small, large; public: /** initialize your data structure here. */ MedianFinder() {} void addNum( int num) { // blindly push in two pq small.push(num); large.push( - small.top()); // small is always greater than large in size, at most greater by one, equal is fine small.pop(); // leave the new element in large if (small.size() < large.size()) { small.push( - large.top()); large.pop(); // large has one more, so move it to small } } double findMedian() { return small.size() != large.size() ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */","title":"Code"},{"location":"Leetcode/295.-find-median-from-data-stream/#followups","text":"With all fall in between 0-100?","title":"Followups"},{"location":"Leetcode/295.-find-median-from-data-stream/#code-o100o100","text":"class MedianFinder { private: int A[ 101 ], n; public: MedianFinder() { n = 0 ; memset(A, 0 , sizeof A); } void addNum( int num) { A[num] ++ ; n ++ ; } double findMedian() { int count = 0 , i = 0 ; while (count < n / 2 ) count += A[i ++ ]; int j = i; while (count < n / 2 + 1 ) count += A[j ++ ]; return (n % 2 == 1 ) ? j - 1 : (i + j - 2 ) / 2.0 ; } }; Further Thoughts: https://leetcode.com/articles/find-median-from-data-stream/ There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across: Buckets ! If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. @mitbbs8080 has an interesting implementation here . Reservoir Sampling . Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or reservoir) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a \" good \" size for your reservoir? Now, that's a whole other challenge. A good explanation for this can be found in this StackOverflow answer . Segment Trees are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations fast and in roughly the same amount of time , always . The only problem is that they are far from trivial to implement. Take a look at my introductory article on Segment Trees if you are interested. Order Statistic Trees are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the k^{th} k^{th} order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. GNU libstdc++ users are in luck! Take a look at this StackOverflow answer . \u21a9","title":"Code O(100)O(100)"},{"location":"Leetcode/32.-longest-valid-parentheses/","text":"int longestValidParentheses (string s) { if (s.length() <= 1 ) return 0 ; int curMax = 0 ; vector < int > longest(s.size(), 0 ); for ( int i = 1 ; i < s.length(); i ++ ){ if (s[i] == ')' ){ /* this block could be ignored because the else block has already calculated it if(s[i-1] == '('){ // valid parethese with previous one longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); } */ else { // if s[i-1] == ')', combine the previous length. int prevStart = i - longest[i - 1 ] - 1 ; // the one before the last start valid if (prevStart >= 0 && s[prevStart] == '(' ){ longest[i] = longest[i - 1 ] + 2 + ((prevStart - 1 >= 0 ) ? longest[prevStart - 1 ] : 0 ); curMax = max(longest[i],curMax); } } } //else if s[i] == '(', skip it, because longest[i] must be 0 } return curMax; } dp[i]: longest valid parentheses length ending with current [i] i - dp[i] + 1: start index of the previous valid one (dp[i-1]) why +2 : because the dp[prevStart-1] + ( + dp[i-1] + ), there are two elements","title":"32. longest valid parentheses"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/","text":"https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem public class Solution { public List < Integer > slidingWindowTemplateByHarryChaoyangHe(String s, String t) { //init a collection or int value to save the result according the question. List < Integer > result = new LinkedList <> (); if (t.length() > s.length()) return result; //create a hashmap to save the Characters of the target substring. //(K, V) = (Character, Frequence of the Characters) Map < Character, Integer > map = new HashMap <> (); for ( char c : t.toCharArray()){ map.put(c, map.getOrDefault(c, 0 ) + 1 ); } //maintain a counter to check whether match the target string. int counter = map.size(); //must be the map size, NOT the string size because the char may be duplicate. //Two Pointers: begin - left pointer of the window; end - right pointer of the window int begin = 0 , end = 0 ; //the length of the substring which match the target string. int len = Integer.MAX_VALUE; //loop at the begining of the source string while (end < s.length()){ char c = s.charAt(end); //get a character if ( map.containsKey(c) ){ map.put(c, map.get(c) - 1 ); // plus or minus one if (map.get(c) == 0 ) counter -- ; //modify the counter according the requirement(different condition). } end ++ ; //increase begin pointer to make it invalid/valid again while (counter == 0 /* counter condition. different question may have different condition */ ){ char tempc = s.charAt(begin); //***be careful here: choose the char at begin pointer, NOT the end pointer if (map.containsKey(tempc)){ map.put(tempc, map.get(tempc) + 1 ); //plus or minus one if (map.get(tempc) > 0 ) counter ++ ; //modify the counter according the requirement(different condition). } /* save / update(min/max) the result if find a target*/ // result collections or result int value begin ++ ; } } return result; } } 438. Find All Anagrams in a String \u00b6 Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". class Solution { public: vector < int > findAnagrams(string s, string p) { if (s.empty()) return {}; vector < int > res, m( 256 , 0 ); int left = 0 , right = 0 , cnt = p.size(), n = s.size(); for ( char c : p) ++ m[c]; while (right < n) { if (m[s[right ++ ]] -- >= 1 ) -- cnt; if (cnt == 0 ) res.push_back(left); if (right - left == p.size() && m[s[left ++ ]] ++ >= 0 ) ++ cnt; } } }; 76. Minimum Window Substring \u00b6 Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. class Solution { public: string minWindow(string s, string t) { unordered_map < char , int > m; for ( char c : t) { m[c] ++ ; } int sz = m.size(); string res; for ( int i = 0 , j = 0 , cnt = 0 ; i < s.size(); ++ i) { if (m[s[i]] == 1 ) cnt ++ ; m[s[i]] -- ; while (m[s[j]] < 0 ) { m[s[j ++ ]] ++ ; } if (cnt == sz) { if (res.empty() || res.size() > i - j + 1 ) res = s.substr(j, i - j + 1 ); } } return res; } }; 3. Longest Substring Without Repeating Characters \u00b6 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. class Solution { public: int lengthOfLongestSubstring(string s) { int start = 0 , end = 0 ; vector < int > v( 128 , 0 ); int res = 0 ; for ( int i = 0 , j = 0 ; i < s.size(); ++ i) { v[s[i]] ++ ; while (v[s[i]] > 1 ) { v[s[j ++ ]] -- ; } res = max(res, i - j + 1 ); } return res; } }; 30. Substring with Concatenation of All Words \u00b6 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } }; 30. Substring with Concatenation of All Words \u00b6 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } }; 159. Longest Substring with At Most Two Distinct Characters \u00b6 Given a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: tis \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: tis \"aabbb\" which its length is 5. Analysis \u00b6 Use left only Use map<char, int> to record the frequency of character in the range of left - i (inclusive). Once the keys is greater than 2, try moves left by 1 unit and update the map if the frequency is 0. Time: O(n), Space: O(1) because size if always 2 entry of key-value pair. class Solution { public: int lengthOfLongestSubstringTwoDistinct(string s) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { m[s[i]] ++ ; while (m.size() > 2 ) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } }; Use left and right Space is optimized, but a little unintuitive. Use two pointers to represent the window. If s[i] == s[i-1], there is no update to the count of distinct elements. If right is not equal to the current one, that means there is a update (+1) to the total count, so we stop and update our res with the current i - left (window is now left - i). Because it only allows two characters, we should skip the ith character and start from right + 1 as left. #include <bits/stdc++.h> using namespace std; int main () { cin >> s; int left = 0 , right = - 1 , res = 0 , sz = s.size(); for ( int i = 1 ; i < sz; ++ i) { if (s[i] == s[i - 1 ]) continue ; if (right >= 0 && s[right] != s[i]) { res = max(res, i - left); left = right + 1 ; } right = i - 1 ; } cout << max(res, sz - left); return 0 ; }","title":"438, 76, 3, 30, sliding window"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#438-find-all-anagrams-in-a-string","text":"Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". class Solution { public: vector < int > findAnagrams(string s, string p) { if (s.empty()) return {}; vector < int > res, m( 256 , 0 ); int left = 0 , right = 0 , cnt = p.size(), n = s.size(); for ( char c : p) ++ m[c]; while (right < n) { if (m[s[right ++ ]] -- >= 1 ) -- cnt; if (cnt == 0 ) res.push_back(left); if (right - left == p.size() && m[s[left ++ ]] ++ >= 0 ) ++ cnt; } } };","title":"438. Find All Anagrams in a String"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#76-minimum-window-substring","text":"Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. class Solution { public: string minWindow(string s, string t) { unordered_map < char , int > m; for ( char c : t) { m[c] ++ ; } int sz = m.size(); string res; for ( int i = 0 , j = 0 , cnt = 0 ; i < s.size(); ++ i) { if (m[s[i]] == 1 ) cnt ++ ; m[s[i]] -- ; while (m[s[j]] < 0 ) { m[s[j ++ ]] ++ ; } if (cnt == sz) { if (res.empty() || res.size() > i - j + 1 ) res = s.substr(j, i - j + 1 ); } } return res; } };","title":"76. Minimum Window Substring"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#3-longest-substring-without-repeating-characters","text":"Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. class Solution { public: int lengthOfLongestSubstring(string s) { int start = 0 , end = 0 ; vector < int > v( 128 , 0 ); int res = 0 ; for ( int i = 0 , j = 0 ; i < s.size(); ++ i) { v[s[i]] ++ ; while (v[s[i]] > 1 ) { v[s[j ++ ]] -- ; } res = max(res, i - j + 1 ); } return res; } };","title":"3. Longest Substring Without Repeating Characters"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#30-substring-with-concatenation-of-all-words","text":"You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } };","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#30-substring-with-concatenation-of-all-words_1","text":"You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } };","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#159-longest-substring-with-at-most-two-distinct-characters","text":"Given a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: tis \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: tis \"aabbb\" which its length is 5.","title":"159. Longest Substring with At Most Two Distinct Characters"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#analysis","text":"Use left only Use map<char, int> to record the frequency of character in the range of left - i (inclusive). Once the keys is greater than 2, try moves left by 1 unit and update the map if the frequency is 0. Time: O(n), Space: O(1) because size if always 2 entry of key-value pair. class Solution { public: int lengthOfLongestSubstringTwoDistinct(string s) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { m[s[i]] ++ ; while (m.size() > 2 ) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } }; Use left and right Space is optimized, but a little unintuitive. Use two pointers to represent the window. If s[i] == s[i-1], there is no update to the count of distinct elements. If right is not equal to the current one, that means there is a update (+1) to the total count, so we stop and update our res with the current i - left (window is now left - i). Because it only allows two characters, we should skip the ith character and start from right + 1 as left. #include <bits/stdc++.h> using namespace std; int main () { cin >> s; int left = 0 , right = - 1 , res = 0 , sz = s.size(); for ( int i = 1 ; i < sz; ++ i) { if (s[i] == s[i - 1 ]) continue ; if (right >= 0 && s[right] != s[i]) { res = max(res, i - left); left = right + 1 ; } right = i - 1 ; } cout << max(res, sz - left); return 0 ; }","title":"Analysis"},{"location":"Leetcode/72.-edit-distance/","text":"int dp_sol (string word1, string word2){ int m = word1.size(), n = word2.size(); vector < vector < int >> dp(m + 1 , vector < int > (n + 1 )); for ( int i = 0 ; i <= m; ++ i) { dp[i][ 0 ] = i; // can only remove all from word2[0:i] to form an empty word1 } for ( int i = 0 ; i <= n; ++ i) { dp[ 0 ][i] = i; // same as above } for ( int i = 1 ; i <= m; ++ i) { for ( int j = 1 ; j <= n; ++ j) { if (word1[i - 1 ] == word2[j - 1 ]) { // nothing needs to be changed, because they are the same dp[i][j] = dp[i - 1 ][j - 1 ]; } else { // now you can either remove previous one from word1, add is equal to remove one from word2, or replace current one (no change) dp[i][j] = min(dp[i - 1 ][j - 1 ], min(dp[i - 1 ][j], dp[i][j - 1 ])) + 1 ; // +1 for the current op } } } return dp[m][n]; } dp[i][j]: # of ops to transfer word1[0:i] to word2[0:j]","title":"72. edit distance"},{"location":"Leetcode/85.-maximal-rectangle/","text":"class Solution {public: int maximalRectangle(vector < vector < char > > & matrix) { if (matrix.empty()) return 0 ; const int m = matrix.size(); const int n = matrix[ 0 ].size(); int left[n], right[n], height[n]; fill_n(left,n, 0 ); fill_n(right,n,n); fill_n(height,n, 0 ); int maxA = 0 ; for ( int i = 0 ; i < m; i ++ ) { int cur_left = 0 , cur_right = n; for ( int j = 0 ; j < n; j ++ ) { // compute height (can do this from either side) if (matrix[i][j] == '1' ) height[j] ++ ; else height[j] = 0 ; } for ( int j = 0 ; j < n; j ++ ) { // compute left (from left to right) if (matrix[i][j] == '1' ) left[j] = max(left[j],cur_left); else {left[j] = 0 ; cur_left = j + 1 ;} } // compute right (from right to left) for ( int j = n - 1 ; j >= 0 ; j -- ) { if (matrix[i][j] == '1' ) right[j] = min(right[j],cur_right); else {right[j] = n; cur_right = j;} } // compute the area of rectangle (can do this from either side) for ( int j = 0 ; j < n; j ++ ) maxA = max(maxA,(right[j] - left[j]) * height[j]); } return maxA; } height[i] record the current number of countinous '1' in column i; left[i] record the left most index j which satisfies that for any index k from j to i, height[k] >= height[i]; right[i] record the right most index j which satifies that for any index k from i to j, height[k] >= height[i]; if j doesn't exist, then use size of matrix to represent j for right, use 0 to represent j for left matrix 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 height 0 0 0 1 0 0 0 0 0 1 2 1 0 0 0 1 2 3 2 1 0 left 0 0 0 3 0 0 0 0 0 2 3 2 0 0 0 1 2 3 2 1 0 right 7 7 7 4 7 7 7 // at index i from right to left, if height[i] >= height[i+1], set right[i]=i or keep going 7 7 5 4 5 7 7 7 6 5 4 5 4 7 result 0 0 0 1 0 0 0 0 0 3 2 3 0 0 0 5 6 3 6 5 0","title":"85. maximal rectangle"},{"location":"Leetcode/87.-scramble-string/","text":"Using cache + recursion \u00b6 class Solution { bool DP_helper(unordered_map < string, bool > & isScramblePair, string s1, string s2) { int i,len = s1.size(); bool res = false; if ( 0 == len) return true; else if ( 1 == len) return s1 == s2; else { if (isScramblePair.count(s1 + s2)) return isScramblePair[s1 + s2]; // checked before, return intermediate result directly if (s1 == s2) res = true; else { for (i = 1 ; i < len && ! res; ++ i) { //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr( 0 ,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr(i,len - i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr(len - i,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr( 0 ,len - i))); } } return isScramblePair[s1 + s2] = res; //save the intermediate results } } public: bool isScramble(string s1, string s2) { unordered_map < string, bool > isScramblePair; return DP_helper (isScramblePair, s1, s2); } }; A string can be rotated anyway. There are four things to compare between two strings: s1: 111i222len s2: 333i444len 111 && 333 222 && 444 or 111 && 444 222 && 333 DP bottom-up \u00b6 class Solution { public: bool isScramble(string s1, string s2) { int sSize = s1.size(), len, i, j, k; if ( 0 == sSize) return true; if ( 1 == sSize) return s1 == s2; bool isS[sSize + 1 ][sSize][sSize]; for (i = 0 ; i < sSize; ++ i) for (j = 0 ; j < sSize; ++ j) isS[ 1 ][i][j] = s1[i] == s2[j]; for (len = 2 ; len <= sSize; ++ len) for (i = 0 ; i <= sSize - len; ++ i) for (j = 0 ; j <= sSize - len; ++ j) { isS[len][i][j] = false; for (k = 1 ; k < len && ! isS[len][i][j]; ++ k) { isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len - k][i + k][j + k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i + len - k][j] && isS[len - k][i][j + k]); } } return isS[sSize][ 0 ][ 0 ]; } }; dp[len][i][j]: s1[i..i+len-1] is a scramble of s2[j..j+len-1] 1. init: all single char can match if they are the same (line 11) 2. dp[len][i][j] = (dp[k][i][j] && dp[len-k][i+k][j+k]) || (dp[k][i+len-k][j] && dp[len-k][i][j+k]) Time Complexity \u00b6 n^4 for all cases","title":"87. scramble string"},{"location":"Leetcode/87.-scramble-string/#using-cache-recursion","text":"class Solution { bool DP_helper(unordered_map < string, bool > & isScramblePair, string s1, string s2) { int i,len = s1.size(); bool res = false; if ( 0 == len) return true; else if ( 1 == len) return s1 == s2; else { if (isScramblePair.count(s1 + s2)) return isScramblePair[s1 + s2]; // checked before, return intermediate result directly if (s1 == s2) res = true; else { for (i = 1 ; i < len && ! res; ++ i) { //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr( 0 ,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr(i,len - i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr(len - i,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr( 0 ,len - i))); } } return isScramblePair[s1 + s2] = res; //save the intermediate results } } public: bool isScramble(string s1, string s2) { unordered_map < string, bool > isScramblePair; return DP_helper (isScramblePair, s1, s2); } }; A string can be rotated anyway. There are four things to compare between two strings: s1: 111i222len s2: 333i444len 111 && 333 222 && 444 or 111 && 444 222 && 333","title":"Using cache + recursion"},{"location":"Leetcode/87.-scramble-string/#dp-bottom-up","text":"class Solution { public: bool isScramble(string s1, string s2) { int sSize = s1.size(), len, i, j, k; if ( 0 == sSize) return true; if ( 1 == sSize) return s1 == s2; bool isS[sSize + 1 ][sSize][sSize]; for (i = 0 ; i < sSize; ++ i) for (j = 0 ; j < sSize; ++ j) isS[ 1 ][i][j] = s1[i] == s2[j]; for (len = 2 ; len <= sSize; ++ len) for (i = 0 ; i <= sSize - len; ++ i) for (j = 0 ; j <= sSize - len; ++ j) { isS[len][i][j] = false; for (k = 1 ; k < len && ! isS[len][i][j]; ++ k) { isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len - k][i + k][j + k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i + len - k][j] && isS[len - k][i][j + k]); } } return isS[sSize][ 0 ][ 0 ]; } }; dp[len][i][j]: s1[i..i+len-1] is a scramble of s2[j..j+len-1] 1. init: all single char can match if they are the same (line 11) 2. dp[len][i][j] = (dp[k][i][j] && dp[len-k][i+k][j+k]) || (dp[k][i+len-k][j] && dp[len-k][i][j+k])","title":"DP bottom-up"},{"location":"Leetcode/87.-scramble-string/#time-complexity","text":"n^4 for all cases","title":"Time Complexity"},{"location":"Leetcode/91.-decode-ways/","text":"Use array DP \u00b6 java \u00b6 public class Solution { public int numDecodings(String s) { if (s == null || s.length() == 0 ) { return 0 ; } int n = s.length(); int [] dp = new int [n + 1 ]; dp[ 0 ] = 1 ; // # of ways to decode for empty s dp[ 1 ] = s.charAt( 0 ) != '0' ? 1 : 0 ; // 0 cannot be leading element for a number for ( int i = 2 ; i <= n; i ++ ) { int first = Integer.valueOf(s.substring(i - 1 , i)); // s[i-1:i] int second = Integer.valueOf(s.substring(i - 2 , i)); // s[i-2:i] if (first >= 1 && first <= 9 ) { dp[i] += dp[i - 1 ]; } if (second >= 10 && second <= 26 ) { dp[i] += dp[i - 2 ]; } } return dp[n]; } } dp[i]: number of ways to decode 1. dp[i] += dp[i-1] if s[i-1:i] is valid (single digit: range from 0-9) 2. dp[i] += dp[i-2] if s[i-2:i] is valid (two digits: range from 10-26) cpp \u00b6 int numDecodings (string s) { int n = s.size(); vector < int > dp(n + 1 ); dp[n] = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) dp[i] = 0 ; else { dp[i] = dp[i + 1 ]; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) dp[i] += dp[i + 2 ]; } } return s.empty() ? 0 : dp[ 0 ]; } dp[i] += dp[i+2] if 1. s[i] == 1, so that any s[i+2] is valid, s[i:i+1] is in range 10-19 2. s[i] == 2 and s[i+1] < 7, so that s[i:i+1] is in range 20-26 if s[i] == 0, then dp[i] = 0, because 0 cannot be leading optimize with constant space \u00b6 class Solution { public: int numDecodings(string s) { int n = s.size(); int pre = 1 , prepre = 1 , curr = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) curr = 0 ; else { curr = pre; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) curr += prepre; } prepre = pre; pre = curr; curr = 1 ; } return s.empty() ? 0 : pre; } }; only needs two more states from current state, so 1. pre: s[i:i+1] 2. prepre: s[i:i+2]","title":"Use array DP"},{"location":"Leetcode/91.-decode-ways/#use-array-dp","text":"","title":"Use array DP"},{"location":"Leetcode/91.-decode-ways/#java","text":"public class Solution { public int numDecodings(String s) { if (s == null || s.length() == 0 ) { return 0 ; } int n = s.length(); int [] dp = new int [n + 1 ]; dp[ 0 ] = 1 ; // # of ways to decode for empty s dp[ 1 ] = s.charAt( 0 ) != '0' ? 1 : 0 ; // 0 cannot be leading element for a number for ( int i = 2 ; i <= n; i ++ ) { int first = Integer.valueOf(s.substring(i - 1 , i)); // s[i-1:i] int second = Integer.valueOf(s.substring(i - 2 , i)); // s[i-2:i] if (first >= 1 && first <= 9 ) { dp[i] += dp[i - 1 ]; } if (second >= 10 && second <= 26 ) { dp[i] += dp[i - 2 ]; } } return dp[n]; } } dp[i]: number of ways to decode 1. dp[i] += dp[i-1] if s[i-1:i] is valid (single digit: range from 0-9) 2. dp[i] += dp[i-2] if s[i-2:i] is valid (two digits: range from 10-26)","title":"java"},{"location":"Leetcode/91.-decode-ways/#cpp","text":"int numDecodings (string s) { int n = s.size(); vector < int > dp(n + 1 ); dp[n] = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) dp[i] = 0 ; else { dp[i] = dp[i + 1 ]; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) dp[i] += dp[i + 2 ]; } } return s.empty() ? 0 : dp[ 0 ]; } dp[i] += dp[i+2] if 1. s[i] == 1, so that any s[i+2] is valid, s[i:i+1] is in range 10-19 2. s[i] == 2 and s[i+1] < 7, so that s[i:i+1] is in range 20-26 if s[i] == 0, then dp[i] = 0, because 0 cannot be leading","title":"cpp"},{"location":"Leetcode/91.-decode-ways/#optimize-with-constant-space","text":"class Solution { public: int numDecodings(string s) { int n = s.size(); int pre = 1 , prepre = 1 , curr = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) curr = 0 ; else { curr = pre; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) curr += prepre; } prepre = pre; pre = curr; curr = 1 ; } return s.empty() ? 0 : pre; } }; only needs two more states from current state, so 1. pre: s[i:i+1] 2. prepre: s[i:i+2]","title":"optimize with constant space"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/","text":"java \u00b6 public class Solution { public List < TreeNode > generateTrees( int n) { return genTrees( 1 ,n); } public List < TreeNode > genTrees ( int start, int end) { List < TreeNode > list = new ArrayList < TreeNode > (); if (start > end) // invalid { list.add(null); return list; } if (start == end){ list.add(new TreeNode(start)); return list; } // start < end List < TreeNode > left,right; for ( int i = start;i <= end;i ++ ) { left = genTrees(start, i - 1 ); right = genTrees(i + 1 ,end); for (TreeNode lnode: left) { for (TreeNode rnode: right) { TreeNode root = new TreeNode(i); root.left = lnode; root.right = rnode; list.add(root); // root can choose any one from left or right } } } return list; } } start.... i .....end for all left from start to i - 1: for all right from i + 1 to end: root -> left = choose one from all left root -> right = choose one from all right c++ \u00b6 class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; return helper ( 1 , n); } vector < TreeNode *> helper( int start, int end) { if (start > end) return {nullptr}; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 ), right = helper(i + 1 , end); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return res; } }; with MEMO + DP class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; vector < vector < vector < TreeNode *>>> memo(n, vector < vector < TreeNode *>> (n)); return helper ( 1 , n, memo); } vector < TreeNode *> helper( int start, int end, vector < vector < vector < TreeNode *>>>& memo) { if (start > end) return {nullptr}; if ( ! memo[start - 1 ][end - 1 ].empty()) return memo[start - 1 ][end - 1 ]; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 , memo), right = helper(i + 1 , end, memo); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return memo[start - 1 ][end - 1 ] = res; } }; memo[i][j][k]: save current tree (root) with left starts from i - 1, right starts from j - 1","title":"95. unique binary search trees ii"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#java","text":"public class Solution { public List < TreeNode > generateTrees( int n) { return genTrees( 1 ,n); } public List < TreeNode > genTrees ( int start, int end) { List < TreeNode > list = new ArrayList < TreeNode > (); if (start > end) // invalid { list.add(null); return list; } if (start == end){ list.add(new TreeNode(start)); return list; } // start < end List < TreeNode > left,right; for ( int i = start;i <= end;i ++ ) { left = genTrees(start, i - 1 ); right = genTrees(i + 1 ,end); for (TreeNode lnode: left) { for (TreeNode rnode: right) { TreeNode root = new TreeNode(i); root.left = lnode; root.right = rnode; list.add(root); // root can choose any one from left or right } } } return list; } } start.... i .....end for all left from start to i - 1: for all right from i + 1 to end: root -> left = choose one from all left root -> right = choose one from all right","title":"java"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#c","text":"class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; return helper ( 1 , n); } vector < TreeNode *> helper( int start, int end) { if (start > end) return {nullptr}; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 ), right = helper(i + 1 , end); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return res; } }; with MEMO + DP class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; vector < vector < vector < TreeNode *>>> memo(n, vector < vector < TreeNode *>> (n)); return helper ( 1 , n, memo); } vector < TreeNode *> helper( int start, int end, vector < vector < vector < TreeNode *>>>& memo) { if (start > end) return {nullptr}; if ( ! memo[start - 1 ][end - 1 ].empty()) return memo[start - 1 ][end - 1 ]; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 , memo), right = helper(i + 1 , end, memo); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return memo[start - 1 ][end - 1 ] = res; } }; memo[i][j][k]: save current tree (root) with left starts from i - 1, right starts from j - 1","title":"c++"},{"location":"Leetcode/96.-unique-binary-search-trees/","text":"The problem can be solved in a dynamic programming way. I\u2019ll explain the intuition and formulas in the following. Given a sequence 1\u2026n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1\u2026(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)\u2026n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique , since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 \\<= i \\<= n: the number of unique BST , where the number i is the root of BST , and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root. i.e. G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree). i.e. G(0)=1, G(1)=1. Given a sequence 1\u2026n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. F(i, n) = G(i-1) * G(n-i) 1 \\<= i \\<= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \u2026 + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) \u2026 G(n-1). With the above explanation and formulas, here is the implementation in Java. public int numTrees ( int n) { int [] G = new int [n + 1 ]; G[ 0 ] = G[ 1 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) { G[i] += G[j - 1 ] * G[i - j]; } } return G[n]; } in cpp \u00b6 public int numTrees ( int n) { int G[n + 1 ]; fill_n(G, n + 1 , 0 ); G[ 0 ] = G[ 1 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) { G[i] += G[j - 1 ] * G[i - j]; } } return G[n]; }","title":"96. unique binary search trees"},{"location":"Leetcode/96.-unique-binary-search-trees/#in-cpp","text":"public int numTrees ( int n) { int G[n + 1 ]; fill_n(G, n + 1 , 0 ); G[ 0 ] = G[ 1 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) { G[i] += G[j - 1 ] * G[i - j]; } } return G[n]; }","title":"in cpp"},{"location":"Leetcode/97.-interleaving-string/","text":"class Solution { public: bool isInterleave(string s1, string s2, string s3) { int m = s1.size(), n = s2.size(), k = s3.size(); if (m + n != k) return false; bool dp[m + 1 ][n + 1 ]; memset(dp, false, sizeof dp); for ( int i = 0 ; i <= m; ++ i) { for ( int j = 0 ; j <= n; ++ j) { if (i == 0 && j == 0 ) dp[i][j] = true; else if (i == 0 ) dp[i][j] = dp[i][j - 1 ] && s2[j - 1 ] == s3[i + j - 1 ]; else if (j == 0 ) dp[i][j] = dp[i - 1 ][j] && s1[i - 1 ] == s3[i + j - 1 ]; else dp[i][j] = (dp[i - 1 ][j] && s1[i - 1 ] == s3[i + j - 1 ]) || (dp[i][j - 1 ] && s2[j - 1 ] == s3[i + j - 1 ]); } } return dp[m][n]; } }; dp[i][j]: from s1[0:i] and s2[0:j] can be combined to s3[0:i+j-1]","title":"97. interleaving string"},{"location":"Leetcode/dp-pattern/","text":"https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns Minimum (Maximum) Path to Reach a Target \u00b6 Given a target find minimum (maximum) cost / path / sum to reach the target. 746. Min Cost Climbing Stairs \u00b6 On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. dp[i] min cost to reach ith stair. for ( int i = 2 ; i <= n; ++ i) { dp[i] = min(dp[i - 1 ], dp[i - 2 ]) + (i == n ? 0 : cost[i]); // on last step, there is no need to proceed further. } return dp[n] with optimization int p1 = 0 , p2 = 0 ; for ( int i = 2 ; i <= cost.size(); ++ i) { int p = min(p1 + cost[i - 1 ], p2 + cost[i - 2 ]); p2 = p1; p1 = p; } return p1; 64. Minimum Path Sum \u00b6 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum. dp[i][j]: min sum to reach x=i,y=j, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] for ( int i = 1 ; i < n; ++ i) { for ( int j = 1 ; j < m; ++ j) { grid[i][j] = min(grid[i - 1 ][j], grid[i][j - 1 ]) + grid[i][j]; } } return grid[n - 1 ][m - 1 ] 322. Coin Change \u00b6 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin. dp[j]: min # of coins to be used for j amount for ( int j = 1 ; j <= amount; ++ j) { for ( int i = 0 ; i < coins.size(); ++ i) { // try all coins if (coins[i] <= j) { // only try the one that is less than total required dp[j] = min(dp[j], dp[j - coins[i]] + 1 ); } } } return dp[amount]; Why this cannot be solved by greedy algorithm? \u00b6 Exception: But for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set {1, 15, 25} and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice. In any case where there is no coin whose value, when added to the lowest denomination, is lower than twice that of the denomination immediately less than it, the greedy algorithm works. i.e. {1,2,3} works because [1,3] and [2,2] add to the same value however {1, 15, 25} doesn't work because (for the change 30) 15+15>25+1 931. Minimum Falling Path Sum \u00b6 Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. A[i][j]: min sum from all upper level to current level i and position j, to get the ans, just find the min on the last row int minFallingPathSum (vector < vector < int >>& A) { int m = A.size(), n = A[ 0 ].size(); int res = INT_MAX; for ( int i = 1 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { A[i][j] += min( {A[i - 1 ][j], A[i - 1 ][max( 0 , j - 1 )], A[i - 1 ][min(m - 1 , j + 1 )]}); } } for ( int i = 0 ; i < n; ++ i) res = min(res, A[m - 1 ][i]); return res; } 983. Minimum Cost For Tickets \u00b6 In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel. Note: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 dp[i]: min cost for ith day. Note: if there is no travel plan, the cost will stay the same as the i-1 th day. int mincostTickets (vector < int >& days, vector < int >& costs) { unordered_set < int > travel(begin(days), end(days)); int dp[ 366 ] = {}; for ( int i = 1 ; i < 366 ; ++ i) { if (travel.find(i) == travel.end()) dp[i] = dp[i - 1 ]; else dp[i] = min({ dp[i - 1 ] + costs[ 0 ], dp[max( 0 , i - 7 )] + costs[ 1 ], dp[max( 0 , i - 30 )] + costs[ 2 ]}); } return dp[ 365 ]; } 650. 2 Keys Keyboard \u00b6 Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. dp[i]: min steps to get to get i 'A' characters. int dp[n + 1 ]; memset(dp, 0 , sizeof dp); for ( int i = 2 ; i <= n; ++ i) { dp[i] = i; // initially assume copy one and paste one by one for ( int j = i - 1 ; j >= 1 ; -- j) { if (i % j == 0 ) { dp[i] = dp[j] + i / j; // j is the maximum, so no need to check the rest break ; } } } return dp[n]; Optimize int s = 0 ; for ( int d = 2 ; d <= n; d ++ ) { while (n % d == 0 ) { s += d; n /= d; } } return s; 279. Perfect Squares \u00b6 Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. dp[i]: min # of perfect squares to form i int numSquares ( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; } 1049. Last Stone Weight II \u00b6 We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 <= stones.length <= 30 1 <= stones[i] <= 100 int lastStoneWeightII (vector < int >& stones) { int n = stones.size(), sum = 0 ; for ( int s : stones) sum += s; vector < bool > dp(sum + 1 , false); dp[ 0 ] = true; for ( int i = 0 ; i < n; ++ i) { for ( int j = sum / 2 ; j >= stones[i]; -- j) dp[j] = dp[j] | dp[j - stones[i]]; } for ( int i = sum / 2 ; i >= 0 ; -- i) if (dp[i]) return sum - i - i; return sum; } 120. Triangle \u00b6 Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i]: min cost from bottom to i-th row int minimumTotal (vector < vector < int >>& triangle) { vector < int > dp(triangle.back()); int n = triangle.size(); for ( int i = n - 2 ; i >= 0 ; -- i) { // rows for ( int j = 0 ; j <= i; ++ j) { // num of elem in each row = i + 1 dp[j] = min(dp[j], dp[j + 1 ]) + triangle[i][j]; // left: dp[j], right: dp[j + 1] } } return dp[ 0 ]; } 474. Ones and Zeroes \u00b6 Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\". Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\". My dp[i][j] means with i zeros and j ones, what is the max strings to be chosen from the strs. In order to calculate it, we find there is a relationship between # of 1 and 0, which is # of 1 + # of 0 = string size, this pattern of constraint usually leads to a knapsack problem. We can visualize it with the problem of knapsack: choose current string means dp[i-# of zero for current string][j - # of one for current string] + 1. not choose current string means dp[i][j] which means there is nothing changed as previous state. Why it has to start from m, n and decrease to 1 (or making sure there is at least # of 0 or 1 spots left in our case)? Because it prevents invalid counting. As we can see, our dp[m][n] is going to be updated sz times, and before we calculate i - zero[k] and j - one[k], they has to be valid. If we start from 0 and increase to m, n, these values will never be updated beforehand. int findMaxForm (vector < string >& strs, int m, int n) { int sz = strs.size(); int one[sz], zero[sz]; for ( int i = 0 ; i < sz; ++ i) { int c1 = 0 , c2 = 0 ; for ( char c : strs[i]) { if (c == '1' ) c2 ++ ; if (c == '0' ) c1 ++ ; } zero[i] = c1, one[i] = c2; } int dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int k = 0 ; k < sz; ++ k) { for ( int i = m; i >= zero[k]; -- i) { for ( int j = n; j >= one[k]; -- j) { dp[i][j] = max(dp[i][j], dp[i - zero[k]][j - one[k]] + 1 ); } } } return dp[m][n]; } Distinct Ways \u00b6 Merging Intervals \u00b6 DP on Strings \u00b6 Decision Making \u00b6","title":"Dp pattern"},{"location":"Leetcode/dp-pattern/#minimum-maximum-path-to-reach-a-target","text":"Given a target find minimum (maximum) cost / path / sum to reach the target.","title":"Minimum (Maximum) Path to Reach a Target"},{"location":"Leetcode/dp-pattern/#746-min-cost-climbing-stairs","text":"On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. dp[i] min cost to reach ith stair. for ( int i = 2 ; i <= n; ++ i) { dp[i] = min(dp[i - 1 ], dp[i - 2 ]) + (i == n ? 0 : cost[i]); // on last step, there is no need to proceed further. } return dp[n] with optimization int p1 = 0 , p2 = 0 ; for ( int i = 2 ; i <= cost.size(); ++ i) { int p = min(p1 + cost[i - 1 ], p2 + cost[i - 2 ]); p2 = p1; p1 = p; } return p1;","title":"746. Min Cost Climbing Stairs"},{"location":"Leetcode/dp-pattern/#64-minimum-path-sum","text":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum. dp[i][j]: min sum to reach x=i,y=j, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] for ( int i = 1 ; i < n; ++ i) { for ( int j = 1 ; j < m; ++ j) { grid[i][j] = min(grid[i - 1 ][j], grid[i][j - 1 ]) + grid[i][j]; } } return grid[n - 1 ][m - 1 ]","title":"64. Minimum Path Sum"},{"location":"Leetcode/dp-pattern/#322-coin-change","text":"You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin. dp[j]: min # of coins to be used for j amount for ( int j = 1 ; j <= amount; ++ j) { for ( int i = 0 ; i < coins.size(); ++ i) { // try all coins if (coins[i] <= j) { // only try the one that is less than total required dp[j] = min(dp[j], dp[j - coins[i]] + 1 ); } } } return dp[amount];","title":"322. Coin Change"},{"location":"Leetcode/dp-pattern/#why-this-cannot-be-solved-by-greedy-algorithm","text":"Exception: But for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set {1, 15, 25} and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice. In any case where there is no coin whose value, when added to the lowest denomination, is lower than twice that of the denomination immediately less than it, the greedy algorithm works. i.e. {1,2,3} works because [1,3] and [2,2] add to the same value however {1, 15, 25} doesn't work because (for the change 30) 15+15>25+1","title":"Why this cannot be solved by greedy algorithm?"},{"location":"Leetcode/dp-pattern/#931-minimum-falling-path-sum","text":"Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. A[i][j]: min sum from all upper level to current level i and position j, to get the ans, just find the min on the last row int minFallingPathSum (vector < vector < int >>& A) { int m = A.size(), n = A[ 0 ].size(); int res = INT_MAX; for ( int i = 1 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { A[i][j] += min( {A[i - 1 ][j], A[i - 1 ][max( 0 , j - 1 )], A[i - 1 ][min(m - 1 , j + 1 )]}); } } for ( int i = 0 ; i < n; ++ i) res = min(res, A[m - 1 ][i]); return res; }","title":"931. Minimum Falling Path Sum"},{"location":"Leetcode/dp-pattern/#983-minimum-cost-for-tickets","text":"In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel. Note: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 dp[i]: min cost for ith day. Note: if there is no travel plan, the cost will stay the same as the i-1 th day. int mincostTickets (vector < int >& days, vector < int >& costs) { unordered_set < int > travel(begin(days), end(days)); int dp[ 366 ] = {}; for ( int i = 1 ; i < 366 ; ++ i) { if (travel.find(i) == travel.end()) dp[i] = dp[i - 1 ]; else dp[i] = min({ dp[i - 1 ] + costs[ 0 ], dp[max( 0 , i - 7 )] + costs[ 1 ], dp[max( 0 , i - 30 )] + costs[ 2 ]}); } return dp[ 365 ]; }","title":"983. Minimum Cost For Tickets"},{"location":"Leetcode/dp-pattern/#650-2-keys-keyboard","text":"Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. dp[i]: min steps to get to get i 'A' characters. int dp[n + 1 ]; memset(dp, 0 , sizeof dp); for ( int i = 2 ; i <= n; ++ i) { dp[i] = i; // initially assume copy one and paste one by one for ( int j = i - 1 ; j >= 1 ; -- j) { if (i % j == 0 ) { dp[i] = dp[j] + i / j; // j is the maximum, so no need to check the rest break ; } } } return dp[n]; Optimize int s = 0 ; for ( int d = 2 ; d <= n; d ++ ) { while (n % d == 0 ) { s += d; n /= d; } } return s;","title":"650. 2 Keys Keyboard"},{"location":"Leetcode/dp-pattern/#279-perfect-squares","text":"Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. dp[i]: min # of perfect squares to form i int numSquares ( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; }","title":"279. Perfect Squares"},{"location":"Leetcode/dp-pattern/#1049-last-stone-weight-ii","text":"We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 <= stones.length <= 30 1 <= stones[i] <= 100 int lastStoneWeightII (vector < int >& stones) { int n = stones.size(), sum = 0 ; for ( int s : stones) sum += s; vector < bool > dp(sum + 1 , false); dp[ 0 ] = true; for ( int i = 0 ; i < n; ++ i) { for ( int j = sum / 2 ; j >= stones[i]; -- j) dp[j] = dp[j] | dp[j - stones[i]]; } for ( int i = sum / 2 ; i >= 0 ; -- i) if (dp[i]) return sum - i - i; return sum; }","title":"1049. Last Stone Weight II"},{"location":"Leetcode/dp-pattern/#120-triangle","text":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i]: min cost from bottom to i-th row int minimumTotal (vector < vector < int >>& triangle) { vector < int > dp(triangle.back()); int n = triangle.size(); for ( int i = n - 2 ; i >= 0 ; -- i) { // rows for ( int j = 0 ; j <= i; ++ j) { // num of elem in each row = i + 1 dp[j] = min(dp[j], dp[j + 1 ]) + triangle[i][j]; // left: dp[j], right: dp[j + 1] } } return dp[ 0 ]; }","title":"120. Triangle"},{"location":"Leetcode/dp-pattern/#474-ones-and-zeroes","text":"Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\". Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\". My dp[i][j] means with i zeros and j ones, what is the max strings to be chosen from the strs. In order to calculate it, we find there is a relationship between # of 1 and 0, which is # of 1 + # of 0 = string size, this pattern of constraint usually leads to a knapsack problem. We can visualize it with the problem of knapsack: choose current string means dp[i-# of zero for current string][j - # of one for current string] + 1. not choose current string means dp[i][j] which means there is nothing changed as previous state. Why it has to start from m, n and decrease to 1 (or making sure there is at least # of 0 or 1 spots left in our case)? Because it prevents invalid counting. As we can see, our dp[m][n] is going to be updated sz times, and before we calculate i - zero[k] and j - one[k], they has to be valid. If we start from 0 and increase to m, n, these values will never be updated beforehand. int findMaxForm (vector < string >& strs, int m, int n) { int sz = strs.size(); int one[sz], zero[sz]; for ( int i = 0 ; i < sz; ++ i) { int c1 = 0 , c2 = 0 ; for ( char c : strs[i]) { if (c == '1' ) c2 ++ ; if (c == '0' ) c1 ++ ; } zero[i] = c1, one[i] = c2; } int dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int k = 0 ; k < sz; ++ k) { for ( int i = m; i >= zero[k]; -- i) { for ( int j = n; j >= one[k]; -- j) { dp[i][j] = max(dp[i][j], dp[i - zero[k]][j - one[k]] + 1 ); } } } return dp[m][n]; }","title":"474. Ones and Zeroes"},{"location":"Leetcode/dp-pattern/#distinct-ways","text":"","title":"Distinct Ways"},{"location":"Leetcode/dp-pattern/#merging-intervals","text":"","title":"Merging Intervals"},{"location":"Leetcode/dp-pattern/#dp-on-strings","text":"","title":"DP on Strings"},{"location":"Leetcode/dp-pattern/#decision-making","text":"","title":"Decision Making"},{"location":"LibreOJ/10000/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 1\u300d\u6d3b\u52a8\u5b89\u6392 https://loj.ac/problem/10000 Analysis \u00b6 \u7c7b\u4f3ccourse schedule, O(n\\log(n)) O(n\\log(n)) Code \u00b6 /* * \u6d3b\u52a8\u5b89\u6392.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; pair < int , int > arr[ 1010 ]; int main ( int argc, char * argv[]) { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> arr[i].second >> arr[i].first; } sort(arr, arr + n); int start = - 1 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (arr[i].second >= start) { // find new end time start = arr[i].first; ++ res; } } cout << res; return 0 ; }","title":"10000"},{"location":"LibreOJ/10000/#analysis","text":"\u7c7b\u4f3ccourse schedule, O(n\\log(n)) O(n\\log(n))","title":"Analysis"},{"location":"LibreOJ/10000/#code","text":"/* * \u6d3b\u52a8\u5b89\u6392.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; pair < int , int > arr[ 1010 ]; int main ( int argc, char * argv[]) { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> arr[i].second >> arr[i].first; } sort(arr, arr + n); int start = - 1 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (arr[i].second >= start) { // find new end time start = arr[i].first; ++ res; } } cout << res; return 0 ; }","title":"Code"},{"location":"LibreOJ/10001/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 2\u300d\u79cd\u6811 https://loj.ac/problem/10001 Analysis \u00b6 \u4ece\u524d\u5f80\u540e\u79cd\u6811\uff0c\u5982\u679c\u4e4b\u524d\u79cd\u8fc7\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5skip\u6389\u3002\u5982\u679c\u8fd8\u6709\u8981\u6c42\u6ca1\u6709\u8fbe\u6210\uff0c\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u7ee7\u7eed\u904d\u5386\uff0c\u6dfb\u52a0\u672a\u79cd\u7684\u5730\u65b9\u3002 e.g. x01000x010100101001 \u5728x x\u4e2d\u9700\u8981\u79cd\u4e09\u9897\u6811\uff1ab = 0, e = 5, t = 3 x01011x010100101001 b = 1, e = 6, t = 4 0x10110x10100101001 Time: O(h \\times max(e - a)) O(h \\times max(e - a)) Code \u00b6 /* * \u79cd\u6811.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; struct line { int b, e, t; } a[ 5010 ]; bool used[ 30010 ]; int main ( int argc, char * argv[]) { int n, h; cin >> n >> h; for ( int i = 0 ; i < h; ++ i) { cin >> a[i].b >> a[i].e >> a[i].t; } sort(a, a + h, []( const line & l, const line & r) { return l.e < r.e; }); // sort by finish time int res = 0 ; for ( int i = 0 ; i < h; ++ i) { int cnt = 0 ; for ( int j = a[i].b; j <= a[i].e; ++ j) { // first check if already satified if (used[j]) cnt ++ ; } if (cnt < a[i].t) { for ( int j = a[i].e; j >= a[i].b && cnt < a[i].t; -- j) { if ( ! used[j]) { used[j] = 1 ; cnt ++ ; res ++ ; } } } } cout << res; return 0 ; }","title":"10001"},{"location":"LibreOJ/10001/#analysis","text":"\u4ece\u524d\u5f80\u540e\u79cd\u6811\uff0c\u5982\u679c\u4e4b\u524d\u79cd\u8fc7\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5skip\u6389\u3002\u5982\u679c\u8fd8\u6709\u8981\u6c42\u6ca1\u6709\u8fbe\u6210\uff0c\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u7ee7\u7eed\u904d\u5386\uff0c\u6dfb\u52a0\u672a\u79cd\u7684\u5730\u65b9\u3002 e.g. x01000x010100101001 \u5728x x\u4e2d\u9700\u8981\u79cd\u4e09\u9897\u6811\uff1ab = 0, e = 5, t = 3 x01011x010100101001 b = 1, e = 6, t = 4 0x10110x10100101001 Time: O(h \\times max(e - a)) O(h \\times max(e - a))","title":"Analysis"},{"location":"LibreOJ/10001/#code","text":"/* * \u79cd\u6811.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; struct line { int b, e, t; } a[ 5010 ]; bool used[ 30010 ]; int main ( int argc, char * argv[]) { int n, h; cin >> n >> h; for ( int i = 0 ; i < h; ++ i) { cin >> a[i].b >> a[i].e >> a[i].t; } sort(a, a + h, []( const line & l, const line & r) { return l.e < r.e; }); // sort by finish time int res = 0 ; for ( int i = 0 ; i < h; ++ i) { int cnt = 0 ; for ( int j = a[i].b; j <= a[i].e; ++ j) { // first check if already satified if (used[j]) cnt ++ ; } if (cnt < a[i].t) { for ( int j = a[i].e; j >= a[i].b && cnt < a[i].t; -- j) { if ( ! used[j]) { used[j] = 1 ; cnt ++ ; res ++ ; } } } } cout << res; return 0 ; }","title":"Code"},{"location":"LibreOJ/10002/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 3\u300d\u55b7\u6c34\u88c5\u7f6e https://loj.ac/problem/10002 Analysis \u00b6 \u6bcf\u6b21\u8bb0\u5f55\u4e2d\u5fc3\u70b9\u7684\u4e24\u7aef\uff0c\u4e24\u7aef\u53ea\u80fd\u53d6\u84dd\u8272\u7684\u957f\u5ea6\uff0c\u56e0\u4e3a\u53ea\u6709\u84dd\u8272\u957f\u5ea6\u624d\u53ef\u4ee5\u4fdd\u8bc1\u6240\u6709\u7684\u70b9\u4ece\u4e2d\u5fc3\u70b9\u5230\u7ec8\u70b9\u662f\u5b8c\u5168cover\u5230\u7684\u3002\u7136\u540e\u6839\u636e\u5de6\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u6bcf\u6b21greedy\u53d6\u53ef\u4ee5cover\u5230\u7684\u6700\u53f3\u70b9\uff0c\u5f53\u53ef\u4ee5\u53d6\u5230\u7684\u6700\u53f3\u70b9\u6bd4\u5f53\u524d\u7684\u9762\u79ef\u7684\u957f\u5ea6\u8981\u5927\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4fbf\u505c\u6b62\u3002 Code \u00b6 /* * \u55b7\u6c34\u88c5\u7f6e.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int maxn = 2e4 + 5 ; int cnt; int n, L, W; struct line { double x, y; }; line lines[maxn]; bool cmp (line a, line b) { return a.x < b.x; } void read () { cin >> n >> L >> W; cnt = 0 ; int x, r; for ( int i = 1 ; i <= n; i ++ ) { cin >> x >> r; if (r <= W / 2 ) continue ; // skip if height cannot cover cnt ++ ; double len = sqrt(r * r - W * W / 4.0 ); // blue len lines[cnt].x = x - len; lines[cnt].y = x + len; } } void work () { sort(lines + 1 , lines + cnt + 1 , cmp); double last = 0 ; int ans = 0 ; while (last < L) { ans ++ ; double s = last; for ( int i = 1 ; i <= cnt; i ++ ) { if (lines[i].x <= s) { last = max(last, lines[i].y); } else { break ; } } if (last == s && s < L) { cout << - 1 << endl; return ; } } cout << ans << endl; } int main () { int k; cin >> k; for ( int j = 0 ; j < k; j ++ ) { read(); work(); } return 0 ; }","title":"10002"},{"location":"LibreOJ/10002/#analysis","text":"\u6bcf\u6b21\u8bb0\u5f55\u4e2d\u5fc3\u70b9\u7684\u4e24\u7aef\uff0c\u4e24\u7aef\u53ea\u80fd\u53d6\u84dd\u8272\u7684\u957f\u5ea6\uff0c\u56e0\u4e3a\u53ea\u6709\u84dd\u8272\u957f\u5ea6\u624d\u53ef\u4ee5\u4fdd\u8bc1\u6240\u6709\u7684\u70b9\u4ece\u4e2d\u5fc3\u70b9\u5230\u7ec8\u70b9\u662f\u5b8c\u5168cover\u5230\u7684\u3002\u7136\u540e\u6839\u636e\u5de6\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u6bcf\u6b21greedy\u53d6\u53ef\u4ee5cover\u5230\u7684\u6700\u53f3\u70b9\uff0c\u5f53\u53ef\u4ee5\u53d6\u5230\u7684\u6700\u53f3\u70b9\u6bd4\u5f53\u524d\u7684\u9762\u79ef\u7684\u957f\u5ea6\u8981\u5927\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4fbf\u505c\u6b62\u3002","title":"Analysis"},{"location":"LibreOJ/10002/#code","text":"/* * \u55b7\u6c34\u88c5\u7f6e.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int maxn = 2e4 + 5 ; int cnt; int n, L, W; struct line { double x, y; }; line lines[maxn]; bool cmp (line a, line b) { return a.x < b.x; } void read () { cin >> n >> L >> W; cnt = 0 ; int x, r; for ( int i = 1 ; i <= n; i ++ ) { cin >> x >> r; if (r <= W / 2 ) continue ; // skip if height cannot cover cnt ++ ; double len = sqrt(r * r - W * W / 4.0 ); // blue len lines[cnt].x = x - len; lines[cnt].y = x + len; } } void work () { sort(lines + 1 , lines + cnt + 1 , cmp); double last = 0 ; int ans = 0 ; while (last < L) { ans ++ ; double s = last; for ( int i = 1 ; i <= cnt; i ++ ) { if (lines[i].x <= s) { last = max(last, lines[i].y); } else { break ; } } if (last == s && s < L) { cout << - 1 << endl; return ; } } cout << ans << endl; } int main () { int k; cin >> k; for ( int j = 0 ; j < k; j ++ ) { read(); work(); } return 0 ; }","title":"Code"},{"location":"LibreOJ/10003/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 4\u300d\u52a0\u5de5\u751f\u4ea7\u8c03\u5ea6 https://loj.ac/problem/10003 Analysis \u00b6 \u56e0\u4e3aB\u4e00\u5b9a\u8981\u5728A\u4e4b\u540e\u624d\u53ef\u4ee5\u8fdb\u884c\uff0c\u6240\u4ee5\u603b\u65f6\u95f4\u6700\u5c0f\u7684\u8bdd\u8981\u5148\u628a\u9700\u8981A\u548c\u9700\u8981B\u7684\u5c0f\u7684\u65f6\u95f4\u653e\u5230\u6700\u524d\u9762\uff0c\u7136\u540e\u4f7f\u7528\u53cc\u6307\u9488\uff1a \u5982\u679c\u662fA\u90a3\u4e48\u4ece\u524d\u5f80\u540e\u6392\u5e8f \u5982\u679c\u662fB\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u6392\u5e8f Code \u00b6 #include <bits/stdc++.h> using namespace std; struct point { int i, minn, x, y; }; point a[ 1010 ]; int ans[ 1010 ]; const int inf = 0x3f3f3f3f ; int main () { int n; cin >> n; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].x; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].y; for ( int i = 1 ; i <= n; ++ i) { a[i].minn = min(a[i].x, a[i].y); // find the min a[i].i = i; } sort(a + 1 , a + n + 1 , []( const point & l, const point & r) { return l.minn < r.minn; }); int x = 1 , y = n; for ( int i = 1 ; i <= n; ++ i) { if (a[i].minn == a[i].x) // A should finish first ans[x ++ ] = a[i].i; else ans[y -- ] = a[i].i; } int timea = 0 , timeb = 0 , mina = inf, minb = inf; for ( int i = 1 ; i <= n; ++ i) { timea += a[i].x; timeb += a[i].y; mina = min(mina, a[i].x); minb = min(minb, a[i].y); } cout << max(timea + minb, timeb + mina) << endl; for ( int i = 1 ; i <= n; ++ i) cout << ans[i] << \" \" ; return 0 ; }","title":"10003"},{"location":"LibreOJ/10003/#analysis","text":"\u56e0\u4e3aB\u4e00\u5b9a\u8981\u5728A\u4e4b\u540e\u624d\u53ef\u4ee5\u8fdb\u884c\uff0c\u6240\u4ee5\u603b\u65f6\u95f4\u6700\u5c0f\u7684\u8bdd\u8981\u5148\u628a\u9700\u8981A\u548c\u9700\u8981B\u7684\u5c0f\u7684\u65f6\u95f4\u653e\u5230\u6700\u524d\u9762\uff0c\u7136\u540e\u4f7f\u7528\u53cc\u6307\u9488\uff1a \u5982\u679c\u662fA\u90a3\u4e48\u4ece\u524d\u5f80\u540e\u6392\u5e8f \u5982\u679c\u662fB\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u6392\u5e8f","title":"Analysis"},{"location":"LibreOJ/10003/#code","text":"#include <bits/stdc++.h> using namespace std; struct point { int i, minn, x, y; }; point a[ 1010 ]; int ans[ 1010 ]; const int inf = 0x3f3f3f3f ; int main () { int n; cin >> n; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].x; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].y; for ( int i = 1 ; i <= n; ++ i) { a[i].minn = min(a[i].x, a[i].y); // find the min a[i].i = i; } sort(a + 1 , a + n + 1 , []( const point & l, const point & r) { return l.minn < r.minn; }); int x = 1 , y = n; for ( int i = 1 ; i <= n; ++ i) { if (a[i].minn == a[i].x) // A should finish first ans[x ++ ] = a[i].i; else ans[y -- ] = a[i].i; } int timea = 0 , timeb = 0 , mina = inf, minb = inf; for ( int i = 1 ; i <= n; ++ i) { timea += a[i].x; timeb += a[i].y; mina = min(mina, a[i].x); minb = min(minb, a[i].y); } cout << max(timea + minb, timeb + mina) << endl; for ( int i = 1 ; i <= n; ++ i) cout << ans[i] << \" \" ; return 0 ; }","title":"Code"},{"location":"Python/class/","text":"del modname . the_answer # delete the attribute >>> class Complex: ... def __init__(self, realpart, imagpart) : ... self.r = realpart ... self.i = imagpart ... >>> x = Complex( 3.0 , - 4.5 ) >>> x.r, x.i ( 3.0 , - 4.5 )","title":"Class"},{"location":"Python/invoke-main/","text":"if __name__ == \"__main__\" : # execute only if run as a script main()","title":"Invoke main"},{"location":"Python/misc/","text":"Invoke Main \u00b6 if __name__ == \"__main__\" : # execute only if run as a script main () Initialize fix size list \u00b6 >>> lst = [ None ] * 5 >>> lst [ None , None , None , None , None ] for(int i = len; i >= 0; --i) \u00b6 range(10, 0, -1) Which gives [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]","title":"Misc"},{"location":"Python/misc/#invoke-main","text":"if __name__ == \"__main__\" : # execute only if run as a script main ()","title":"Invoke Main"},{"location":"Python/misc/#initialize-fix-size-list","text":">>> lst = [ None ] * 5 >>> lst [ None , None , None , None , None ]","title":"Initialize fix size list"},{"location":"Python/misc/#forint-i-len-i-0-i","text":"range(10, 0, -1) Which gives [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]","title":"for(int i = len; i &gt;= 0; --i)"},{"location":"c/malloc-lab/","text":"/* single word (4) or double word (8) alignment */ #define ALIGNMENT 8 /* rounds up to the nearest multiple of ALIGNMENT */ #define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7) #define INITCHUNKSIZE (1<<6) #define LISTLIMIT 20 #define REALLOC_BUFFER (1<<7)","title":"Malloc lab"},{"location":"c/parse-string-to-int/","text":"use atoi(s.c_str()); because it can handle leading zero (drop it). what it does is convert the s to char*.","title":"Parse string to int"},{"location":"iOS/dialog-flow/","text":"For chat bot \u00b6 with Apple ARKit","title":"Dialog flow"},{"location":"iOS/dialog-flow/#for-chat-bot","text":"with Apple ARKit","title":"For chat bot"},{"location":"iOS/exam-ii-review-part-one/","text":"Gesture \u00b6 Tap Double Tap Drag Flick Pinch Spread Press Press and tap Add gesture recognizer in code Single Tap // ViewController.m: Single Tap - ( void ) viewDidLoad { [super viewDidLoad]; UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; /* if double click doubleTap.numberOfTapsRequired = 2; */ [self.view addGestureRecognizer:singleTap]; } - ( void ) singleTapRecognized: (UITapGestureRecognizer * ) recognizer { self.msgLabel.text = @\"You single tapped me!\" ; } Single & Double Tap // double tap UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; [self.view addGestureRecognizer: singleTap]; UITapGestureRecognizer * doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (doubleTapRecognized:)]; doubleTap.numberOfTapsRequired = 2 ; [self.view addGestureRecognizer: doubleTap]; // Only recognize single taps if they're not the first of two [singleTap requireGestureRecognizerToFail: doubleTap]; Swipe: should add left and right separately UISwipeGestureRecognizer * swipeLeft = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeLeft.direction = UISwipeGestureRecognizerDirectionLeft; [self.view addGestureRecognizer:swipeLeft]; UISwipeGestureRecognizer * swipeRight = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeRight.direction = UISwipeGestureRecognizerDirectionRight; [self.view addGestureRecognizer:swipeRight]; Selector * accept a method name * not explicit call Animation: Core Animation \u00b6 View Properties * frame (position and size) * transform * alpha (transparency) * color * background color Block properties 1. can be pass around to methods or functions as if they were values. 2. is OC object, so can be added to collections like NSArray or NSDictionary 3. capture values from enclosing scope 4. used for callback function: code to be exec when finish task Syntax ^ { NSLog( @\"This is a block\" ); } int multiplier = 7 ; int ( ^ myBlock)( int ) = ^ ( int num) { return num * multiplier; } fade-in example - ( void ) fadeInStudent: (NSString * ) name{ // Alpha = 0 means the text is transparent self.nameLabel.alpha = 0 ; self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { // Fade in the text of the label self.nameLabel.alpha = 1 ; }]; } more examples: // fade in nameLabel - ( void ) animateStudent: (NSString * )name{ self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { self.nameLabel.alpha = 1 ; }]; } // fade out then fade in - ( void ) displayStudent: (NSString * )name{ [UIView animateWithDuration: 1.0 animations: ^ { // Fade out old text of label self.nameLabel.alpha = 0 ; } completion: ^ ( BOOL finished) { // Upon completion, call animateStudent [self animateStudent:name]; }]; } Accelerometer Gyroscope \u00b6 Motion Events * move * shake * tilt the device Some Properties* 1. made up of three accelerometers 2. give measurements in g-forces * no movement -- 1g 3. Shake: UIEvent 4. General Orientation: UIDevice 5. Cancel a motion event: An event is canceled if the shake motion is interrupted or if iOS determines that the motion is not valid after all \u2013 for example, if the shaking lasts too long. Use motionCancelled:withEvent:*** Handle Shake Event - ( BOOL ) canBecomeFirstResponder { return YES; } - ( void ) viewDidAppear: ( BOOL )animated{ [super viewDidAppear:animated]; [self becomeFirstResponder]; } - ( void ) motionEnded: (UIEventSubtype)motion withEvent: (UIEvent * )event{ if (motion == UIEventSubtypeMotionShake){ NSLog( @\"You shook me!\" ); } } Responding Changes in Orientation - ( void ) viewDidLoad { // Request to turn on accelerometer and begin receiving accelerometer events [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[NSNotificationCenter defaultCenter] addObserver:self selector: @selector (orientationChanged:) name:UIDeviceOrientationDidChangeNotification object:nil]; } - ( void ) orientationChanged: (NSNotification * ) notification{ // Respond to changes in device orientation UIDeviceOrientation currentOrientation = [[UIDevice currentDevice] orientation]; } - ( void ) viewDidDisappear: ( BOOL )animated{ // Request to stop receiving accelerometer events and turn off accelerometer [[NSNotificationCenter defaultCenter] removeObserver:self]; [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; } CMMotionManager obtain data * Pull: An app requests that updates start and then periodically samples the most recent measurement of motion data. * Push: An app specifies an update interval and implements a block for handling the data. Then, it requests that updates start, and passes Core Motion an operation queue and the block. Core Motion delivers each update to the block, which executes as a task in the operation queue. Pull is the recommended approach for most apps, especially games. It is generally more efficient and requires less code. Push is appropriate for data-collection apps and similar apps that cannot miss a single sample measurement. startDeviceMotionUpdates \u2013 the pull approach * After you call this method, Core Motion continuously updates the deviceMotion property of CMMotionManager with the latest refined measurements of accelerometer and gyroscope activity, as encapsulated in a CMDeviceMotion object. startDeviceMotionUpdatesToQueue:withHandler: \u2013 the push approach * Before you call this method, assign an update interval to the deviceMotionUpdateInterval property, create an instance of NSOperationQueue , and implement a block of the CMDeviceMotionHandler type that handles the accelerometer updates. * Then, call the startDeviceMotionUpdatesToQueue: withHandler: method on the motion-manager object, passing in the operation queue and the block. Audio \u00b6 File Formats (audio container) and Data Format (audio encoding) * AAC, HE-AAC, AMR, ALAC, iLBC, iMA4...: df * If space is not an issue, just encode everything with linear PCM. * Not only is this the fastest way for your audio to play, but you can play multiple sounds simultaneously without running into any CPU resource issues. * If space is an issue, most likely you\u2019ll want to use AAC encoding for your background music and IMA4 encoding for your sound effects. Bit Rate * When you lower the bytes per second, you lose quality as well. * If your file is mostly speech, you can probably get away with a lower bit rate. Sample Rates * usually 44,100Hz, because it's the same for CD audio. Audio Session * Playback is enabled and recording is disabled. \u2013 When the user moves the Silent switch (or Ring/Silent switch on iPhone) to the \u201csilent\u201d position, your audio is silenced. \u2013 When the user presses the Sleep/Wake button to lock the screen, or when the Auto-Lock period expires, your audio is silenced. \u2013 When your audio starts, other audio on the device \u2013 such as iPod audio that was already playing \u2013 is silenced. System Sound Service * System Sound Services is intended for user-interface sound effects and user alerts \u2013 It is not intended for sound effects in games * Alert sounds work best when kept short \u2013 According to Apple, preferably 2 seconds or less AVAudioPlayer * Play background music * Extremely slow: will be a noticeable delay * If play in bg, check no other sound is playing to prevent two layers of musics going at once * Phone call will interrupt the music Add Audio Framework * Add AudioToolbox.framework in project targets * Import // QuoteViewController.m #import <AudioToolbox/AudioToolbox.h> #import \"QuoteViewController.h\" @interface QuoteViewController () @property ( readonly ) SystemSoundID soundFileID; Examples Setup for Sound // QuoteViewController.m NSString * soundFilePath = [[NSBundle mainBundle] pathForResource: @\"Tada\" ofType: @\"wav\" ]; NSURL * soundURL = [NSURL fileURLWithPath:soundFilePath]; AudioServicesCreateSystemSoundID(( __bridge CFURLRef _Nonnull)(soundURL), & _soundFileID); // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play sound file AudioServicesPlaySystemSound(self.soundFileID); [self displayQuote:[self.model randomQuote]]; } Setup for Vibration // QuoteViewController.m - ( void ) doubleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Vibrate AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); [self displayQuote:[self.model randomQuote]]; } Create property using AVFoundation // QuoteViewController.m #import <AVFoundation/AVFoundation.h> // Other imports\u2026 @interface QuoteViewController () @property ( strong , nonatomic ) AVAudioPlayer * audioPlayer; // QuoteViewController.m NSString * path = [NSString stringWithFormat: @\"%@/tone.mp3\" , [[NSBundle mainBundle] resourcePath]]; NSURL * soundURL = [NSURL fileURLWithPath:path]; NSError * error; self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:soundURL error: & error]; [self.audioPlayer prepareToPlay]; // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play audio [self.audioPlayer play]; [self displayQuote:[self.model randomQuote]]; } Delegates \u00b6 Protocol * Is a declaration of a list of methods * Two kinds of methods: optional and required Delegation * Allow for one to one communication between two instances: the delegate and delegator * Delegator: Instance that send events to delegate * Delegate: Process events sent from the delegator * The delegator is typically a framework object (i.e. textfield, tableview, etc.), and the delegate is typically a custom controller object. Three Steps Processes 1. In your custom class, adopt the delegate's protocol. 2. Implement the appropriate protocol methods. 3. Connect the delegate outlet of the delegator (i.e. textfield, tableview, etc.) to your custom class. Summary * Allowing some objects to be relatively fixed and others highly customized. * Maximum software reuse and MVC design pattern. Demo: or but not both // ViewController.h @interface ViewController < ProtocolName > @end // ViewController.m @interface ViewController () < ProtocolName > @end @implementation ViewController @end Table Views \u00b6 iOS can have an unlimited # of rows iOS tables can only be one col wide Plain Table View * Row seperated into labeled sections and index appears vertically on right (index list) * Header and footer: row are grouped, doesn't include index * Highlight: * In both styles, a table row becomes highlighted briefly when a user taps a selectable item. * If a row selection results in navigation to a new screen, the selected row becomes highlighted briefly as the new screen slides into place. * When the user navigates back to the previous screen, the originally selected row again becomes highlighted briefly to remind the user of the earlier selection (it doesn\u2019t remain highlighted). * Four Predefined Styles 1. UITableViewCellStyleDefault : The default cell style includes an optional image in the left end of the row, followed by a left-aligned title. 2. UITableViewCellStyleSubtitle : The subtitle style includes an optional image in the left end of the row, followed by a left- aligned title on one line and a left- aligned subtitle on the line below. 3. UITableViewCellStyleValue1 : The value 1 style displays a left-aligned title with, on the same line, a rightaligned subtitle in a lighter font. 4. UITableViewCellStyleValue2`: The value 2 style displays a right-aligned title in a blue font, followed on the same line by a left-aligned subtitle in a black font. Images don\u2019t fit well in this style. Reusing Cell * When you call [tableView dequeuereusablecellwithidentifier:] you either: A. Get a cell that has previously been created and isn't currently being used OR B. Create a new cell of the class you specified Examples // ExampleTableViewController.m // Return the number of sections - (NSInteger) numberOfSectionsInTableView: (UITableView * )tableView{ return 1 ; } // Return number of rows in the section - (NSInteger) tableView: (UITableView * )tableView numberOfRowsInSection: (NSInteger)section{ return 100 ; } // Configuring Rows (cell) - (UITableViewCell * ) tableView: (UITableView * )tableView cellForRowAtIndexPath: (NSIndexPath * )indexPath{ static NSString * cellIdentifier = @\"TableCell\" ; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; // Configure the cell cell.textLabel.text = [NSString stringWithFormat: @\"Row %d\" , indexPath.row]; return cell; } Relationships btw View Controllers * If the relationship is a segue , the destination view controller is instantiated when the segue is triggered. * If the relationship represents containment , the child view controller is instantiated when its parent is instantiated. * If the controller is not the destination or child of another controller, it is never instantiated automatically. You must instantiate it from the storyboard programmatically. * Segues: When a segue is triggered, iOS takes the following actions: 1. It instantiates the destination view controller using the attribute values you provided in the storyboard. 2. It gives the source view controller an opportunity to configure the new controller. 3. It performs the transition configured in the segue. * Summary: containment for parent-child connection; segues for two views.","title":"Exam ii review part one"},{"location":"iOS/exam-ii-review-part-one/#gesture","text":"Tap Double Tap Drag Flick Pinch Spread Press Press and tap Add gesture recognizer in code Single Tap // ViewController.m: Single Tap - ( void ) viewDidLoad { [super viewDidLoad]; UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; /* if double click doubleTap.numberOfTapsRequired = 2; */ [self.view addGestureRecognizer:singleTap]; } - ( void ) singleTapRecognized: (UITapGestureRecognizer * ) recognizer { self.msgLabel.text = @\"You single tapped me!\" ; } Single & Double Tap // double tap UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; [self.view addGestureRecognizer: singleTap]; UITapGestureRecognizer * doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (doubleTapRecognized:)]; doubleTap.numberOfTapsRequired = 2 ; [self.view addGestureRecognizer: doubleTap]; // Only recognize single taps if they're not the first of two [singleTap requireGestureRecognizerToFail: doubleTap]; Swipe: should add left and right separately UISwipeGestureRecognizer * swipeLeft = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeLeft.direction = UISwipeGestureRecognizerDirectionLeft; [self.view addGestureRecognizer:swipeLeft]; UISwipeGestureRecognizer * swipeRight = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeRight.direction = UISwipeGestureRecognizerDirectionRight; [self.view addGestureRecognizer:swipeRight]; Selector * accept a method name * not explicit call","title":"Gesture"},{"location":"iOS/exam-ii-review-part-one/#animation-core-animation","text":"View Properties * frame (position and size) * transform * alpha (transparency) * color * background color Block properties 1. can be pass around to methods or functions as if they were values. 2. is OC object, so can be added to collections like NSArray or NSDictionary 3. capture values from enclosing scope 4. used for callback function: code to be exec when finish task Syntax ^ { NSLog( @\"This is a block\" ); } int multiplier = 7 ; int ( ^ myBlock)( int ) = ^ ( int num) { return num * multiplier; } fade-in example - ( void ) fadeInStudent: (NSString * ) name{ // Alpha = 0 means the text is transparent self.nameLabel.alpha = 0 ; self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { // Fade in the text of the label self.nameLabel.alpha = 1 ; }]; } more examples: // fade in nameLabel - ( void ) animateStudent: (NSString * )name{ self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { self.nameLabel.alpha = 1 ; }]; } // fade out then fade in - ( void ) displayStudent: (NSString * )name{ [UIView animateWithDuration: 1.0 animations: ^ { // Fade out old text of label self.nameLabel.alpha = 0 ; } completion: ^ ( BOOL finished) { // Upon completion, call animateStudent [self animateStudent:name]; }]; }","title":"Animation: Core Animation"},{"location":"iOS/exam-ii-review-part-one/#accelerometer-gyroscope","text":"Motion Events * move * shake * tilt the device Some Properties* 1. made up of three accelerometers 2. give measurements in g-forces * no movement -- 1g 3. Shake: UIEvent 4. General Orientation: UIDevice 5. Cancel a motion event: An event is canceled if the shake motion is interrupted or if iOS determines that the motion is not valid after all \u2013 for example, if the shaking lasts too long. Use motionCancelled:withEvent:*** Handle Shake Event - ( BOOL ) canBecomeFirstResponder { return YES; } - ( void ) viewDidAppear: ( BOOL )animated{ [super viewDidAppear:animated]; [self becomeFirstResponder]; } - ( void ) motionEnded: (UIEventSubtype)motion withEvent: (UIEvent * )event{ if (motion == UIEventSubtypeMotionShake){ NSLog( @\"You shook me!\" ); } } Responding Changes in Orientation - ( void ) viewDidLoad { // Request to turn on accelerometer and begin receiving accelerometer events [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[NSNotificationCenter defaultCenter] addObserver:self selector: @selector (orientationChanged:) name:UIDeviceOrientationDidChangeNotification object:nil]; } - ( void ) orientationChanged: (NSNotification * ) notification{ // Respond to changes in device orientation UIDeviceOrientation currentOrientation = [[UIDevice currentDevice] orientation]; } - ( void ) viewDidDisappear: ( BOOL )animated{ // Request to stop receiving accelerometer events and turn off accelerometer [[NSNotificationCenter defaultCenter] removeObserver:self]; [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; } CMMotionManager obtain data * Pull: An app requests that updates start and then periodically samples the most recent measurement of motion data. * Push: An app specifies an update interval and implements a block for handling the data. Then, it requests that updates start, and passes Core Motion an operation queue and the block. Core Motion delivers each update to the block, which executes as a task in the operation queue. Pull is the recommended approach for most apps, especially games. It is generally more efficient and requires less code. Push is appropriate for data-collection apps and similar apps that cannot miss a single sample measurement. startDeviceMotionUpdates \u2013 the pull approach * After you call this method, Core Motion continuously updates the deviceMotion property of CMMotionManager with the latest refined measurements of accelerometer and gyroscope activity, as encapsulated in a CMDeviceMotion object. startDeviceMotionUpdatesToQueue:withHandler: \u2013 the push approach * Before you call this method, assign an update interval to the deviceMotionUpdateInterval property, create an instance of NSOperationQueue , and implement a block of the CMDeviceMotionHandler type that handles the accelerometer updates. * Then, call the startDeviceMotionUpdatesToQueue: withHandler: method on the motion-manager object, passing in the operation queue and the block.","title":"Accelerometer Gyroscope"},{"location":"iOS/exam-ii-review-part-one/#audio","text":"File Formats (audio container) and Data Format (audio encoding) * AAC, HE-AAC, AMR, ALAC, iLBC, iMA4...: df * If space is not an issue, just encode everything with linear PCM. * Not only is this the fastest way for your audio to play, but you can play multiple sounds simultaneously without running into any CPU resource issues. * If space is an issue, most likely you\u2019ll want to use AAC encoding for your background music and IMA4 encoding for your sound effects. Bit Rate * When you lower the bytes per second, you lose quality as well. * If your file is mostly speech, you can probably get away with a lower bit rate. Sample Rates * usually 44,100Hz, because it's the same for CD audio. Audio Session * Playback is enabled and recording is disabled. \u2013 When the user moves the Silent switch (or Ring/Silent switch on iPhone) to the \u201csilent\u201d position, your audio is silenced. \u2013 When the user presses the Sleep/Wake button to lock the screen, or when the Auto-Lock period expires, your audio is silenced. \u2013 When your audio starts, other audio on the device \u2013 such as iPod audio that was already playing \u2013 is silenced. System Sound Service * System Sound Services is intended for user-interface sound effects and user alerts \u2013 It is not intended for sound effects in games * Alert sounds work best when kept short \u2013 According to Apple, preferably 2 seconds or less AVAudioPlayer * Play background music * Extremely slow: will be a noticeable delay * If play in bg, check no other sound is playing to prevent two layers of musics going at once * Phone call will interrupt the music Add Audio Framework * Add AudioToolbox.framework in project targets * Import // QuoteViewController.m #import <AudioToolbox/AudioToolbox.h> #import \"QuoteViewController.h\" @interface QuoteViewController () @property ( readonly ) SystemSoundID soundFileID; Examples Setup for Sound // QuoteViewController.m NSString * soundFilePath = [[NSBundle mainBundle] pathForResource: @\"Tada\" ofType: @\"wav\" ]; NSURL * soundURL = [NSURL fileURLWithPath:soundFilePath]; AudioServicesCreateSystemSoundID(( __bridge CFURLRef _Nonnull)(soundURL), & _soundFileID); // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play sound file AudioServicesPlaySystemSound(self.soundFileID); [self displayQuote:[self.model randomQuote]]; } Setup for Vibration // QuoteViewController.m - ( void ) doubleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Vibrate AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); [self displayQuote:[self.model randomQuote]]; } Create property using AVFoundation // QuoteViewController.m #import <AVFoundation/AVFoundation.h> // Other imports\u2026 @interface QuoteViewController () @property ( strong , nonatomic ) AVAudioPlayer * audioPlayer; // QuoteViewController.m NSString * path = [NSString stringWithFormat: @\"%@/tone.mp3\" , [[NSBundle mainBundle] resourcePath]]; NSURL * soundURL = [NSURL fileURLWithPath:path]; NSError * error; self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:soundURL error: & error]; [self.audioPlayer prepareToPlay]; // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play audio [self.audioPlayer play]; [self displayQuote:[self.model randomQuote]]; }","title":"Audio"},{"location":"iOS/exam-ii-review-part-one/#delegates","text":"Protocol * Is a declaration of a list of methods * Two kinds of methods: optional and required Delegation * Allow for one to one communication between two instances: the delegate and delegator * Delegator: Instance that send events to delegate * Delegate: Process events sent from the delegator * The delegator is typically a framework object (i.e. textfield, tableview, etc.), and the delegate is typically a custom controller object. Three Steps Processes 1. In your custom class, adopt the delegate's protocol. 2. Implement the appropriate protocol methods. 3. Connect the delegate outlet of the delegator (i.e. textfield, tableview, etc.) to your custom class. Summary * Allowing some objects to be relatively fixed and others highly customized. * Maximum software reuse and MVC design pattern. Demo: or but not both // ViewController.h @interface ViewController < ProtocolName > @end // ViewController.m @interface ViewController () < ProtocolName > @end @implementation ViewController @end","title":"Delegates"},{"location":"iOS/exam-ii-review-part-one/#table-views","text":"iOS can have an unlimited # of rows iOS tables can only be one col wide Plain Table View * Row seperated into labeled sections and index appears vertically on right (index list) * Header and footer: row are grouped, doesn't include index * Highlight: * In both styles, a table row becomes highlighted briefly when a user taps a selectable item. * If a row selection results in navigation to a new screen, the selected row becomes highlighted briefly as the new screen slides into place. * When the user navigates back to the previous screen, the originally selected row again becomes highlighted briefly to remind the user of the earlier selection (it doesn\u2019t remain highlighted). * Four Predefined Styles 1. UITableViewCellStyleDefault : The default cell style includes an optional image in the left end of the row, followed by a left-aligned title. 2. UITableViewCellStyleSubtitle : The subtitle style includes an optional image in the left end of the row, followed by a left- aligned title on one line and a left- aligned subtitle on the line below. 3. UITableViewCellStyleValue1 : The value 1 style displays a left-aligned title with, on the same line, a rightaligned subtitle in a lighter font. 4. UITableViewCellStyleValue2`: The value 2 style displays a right-aligned title in a blue font, followed on the same line by a left-aligned subtitle in a black font. Images don\u2019t fit well in this style. Reusing Cell * When you call [tableView dequeuereusablecellwithidentifier:] you either: A. Get a cell that has previously been created and isn't currently being used OR B. Create a new cell of the class you specified Examples // ExampleTableViewController.m // Return the number of sections - (NSInteger) numberOfSectionsInTableView: (UITableView * )tableView{ return 1 ; } // Return number of rows in the section - (NSInteger) tableView: (UITableView * )tableView numberOfRowsInSection: (NSInteger)section{ return 100 ; } // Configuring Rows (cell) - (UITableViewCell * ) tableView: (UITableView * )tableView cellForRowAtIndexPath: (NSIndexPath * )indexPath{ static NSString * cellIdentifier = @\"TableCell\" ; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; // Configure the cell cell.textLabel.text = [NSString stringWithFormat: @\"Row %d\" , indexPath.row]; return cell; } Relationships btw View Controllers * If the relationship is a segue , the destination view controller is instantiated when the segue is triggered. * If the relationship represents containment , the child view controller is instantiated when its parent is instantiated. * If the controller is not the destination or child of another controller, it is never instantiated automatically. You must instantiate it from the storyboard programmatically. * Segues: When a segue is triggered, iOS takes the following actions: 1. It instantiates the destination view controller using the attribute values you provided in the storyboard. 2. It gives the source view controller an opportunity to configure the new controller. 3. It performs the transition configured in the segue. * Summary: containment for parent-child connection; segues for two views.","title":"Table Views"},{"location":"iOS/exam-ii-review-part-two/","text":"On-class \u00b6 WebKit features (important) Multiple Storyboard prevent merge conflicts no swift to be tested no animation/accelerometer in coding Major Design pattern: delegation MVC Singleton (notification) Objective-C Data Types BOOL ID SELECTOR App States ARC vs. MRR: memory management Understand hw5 very well (code) Pass data/function between controllers: ?? blocks How to save data: ?? Creating a tableView (code) Delete cells Set delegate completion handler using blocks Scene & Segues \u00b6 Use blocks for communication between scenes (save or cancel) typedef returntype(^<#block name#>)(<#arguments#>); block properties should always be copy Two common styles: Show: left-to-right navigation Present Modally: full-screen cover Use prepareForSegue: to connect Set the completion handler: insert new quote into models; have table view reload data; dismiss view controller Data Persistence \u00b6 User Default: NSUserDefaults using key value (like NSDictionary ) Save files to the Document folder using plist Use SQLite Use Core Data Folder to save Documents Your application stores its data in Documents, with the exception of NSUserDefaults-based preference settings Library NSUserDefaults-based preference settings are stored in the Library/Preferences folder tmp Place to store temporary files that will not be backed up by iTunes, but your app has to be responsibility for deleting the files User Defaults No high performance No complex structure Not searchable NSString * const kCurrentIndexKey = @\"CurrentIndex\" ; - ( void ) save { NSUserDefaults * defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:[NSNumber numberWithInt:self.currentIndex] forKey:kCurrentIndexKey]; [defaults synchronize]; } - (NSNumber) read { NSNumber * readData = [[NSUserDefaults standardUserDefaults] objectForKey:kCurrentIndexKey]; return readData; } Use of const 1. Prevent mistype 2. Convenience to auto-complete 3. Declare outside of @interface and @implementation Inside Document Folder Accept types: Property List (xml) Text Files Archiving Objects -- NSCoding protocol NSString * documentsDirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[ 0 ]; // Create a file name for your file NSString * filename = @\"flashcards.plist\" ; // Generate the full file path _filePath = [NSString stringWithFormat: @\"%@/%@\" , documentsDirPath, filename]; NSLog( @\"file path %@\" , _filePath); NSArray * flashcardsFromDocumentsDir = [[NSArray alloc] initWithContentsOfFile:_filePath]; App life cycle \u00b6 App States * Not Running * Inactive (foreground) * Active (foreground) * Background * Suspended Memory \u00b6 Two Methods of application memory management 1. Manual retain-release: MRR 2. Automatic Reference Counting: ARC * Using reference-count * Invoke dealloc automatically MRR \u00b6 Cocoa's Policy * You own object you created: alloc new copy mutableCopy * Take ownership by using retain * When no longer need, relinquish it using release or autorelease (must relinquish object do not own) * \"Parent\" object maintain strong reference to \"children\", \"children\" have weak reference to \"parents\" Pratical Memory Management * Use accessor methods to set property values * Don't use accessor methods in initalizer and dealloc * Use weak reference to avoid retain cycles * Avoid dealloc object while using * Don't use dealloc to manage scarce resources * Collections own the objects they contain * Ownership policy is implemented using retain counts Retain Count * When create an object, RC (retain count) is 1 * When send a retain message, RC + 1 * When send a release message, RC - 1 * When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block. * If RC == 0 -> object dealloc ARC \u00b6 Insert retains and releases into code when compile Web View \u00b6 WebKit * Follow MVC framework * View: WebView * Object: WebFrameView and WebFrame * App Transport Security force to connect with web service through HTTPS Example: Read a pdf file - ( void ) viewDidLoad { [super viewDidLoad]; NSString * path = [[NSBundle mainBundle] pathForResource: @\"HIG\" ofType: @\"pdf\" ]; if (path){ NSData * pdfData = [NSData dataWithContentsOfFile:path]; [(UIWebView * )self.view loadData:pdfData MIMEType: @\"application/pdf\" textEncodingName: @\"utf-8\" baseURL:nil]; } } Read a url NSURL * url = [NSURL URLWithString: @\"https://www.apple.com\" ]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [self.myWebView loadRequest: request]; Cancel a loading request - ( void ) viewWillDisappear: ( BOOL )animated{ [super viewWillDisappear:animated]; if ([self.myWebView isLoading]){ [self.myWebView stopLoading]; } // Disconnect the delegate as the webview is hidden self.myWebView.delegate = nil; } Animation loading in WebView - ( void ) webViewDidStartLoad: (UIWebView * )webView{ [self.activityIndicator startAnimating]; } - ( void ) webViewDidFinishLoad: (UIWebView * )webView{ [self.activityIndicator stopAnimating]; } - ( void ) webView: (UIWebView * )webView didFailLoadWithError: (NSError * )error{ [self.activityIndicator stopAnimating]; } Notes A web view automatically converts telephone numbers that appear in web content to Phone links. You should not embed UIWebView or UITableView objects in UIScrollView objects. Table View Rewind \u00b6 Modifying Tables \u00b6 Delete table cells * Add navigation control * Enable edit button in viewDidLoad method * Use the public remove method in the model * Implement tableView: commitEditingStyle: forRowAtIndexPath method - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the row from the data source [self.model removeFlashcardAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view } }","title":"Exam ii review part two"},{"location":"iOS/exam-ii-review-part-two/#on-class","text":"WebKit features (important) Multiple Storyboard prevent merge conflicts no swift to be tested no animation/accelerometer in coding Major Design pattern: delegation MVC Singleton (notification) Objective-C Data Types BOOL ID SELECTOR App States ARC vs. MRR: memory management Understand hw5 very well (code) Pass data/function between controllers: ?? blocks How to save data: ?? Creating a tableView (code) Delete cells Set delegate completion handler using blocks","title":"On-class"},{"location":"iOS/exam-ii-review-part-two/#scene-segues","text":"Use blocks for communication between scenes (save or cancel) typedef returntype(^<#block name#>)(<#arguments#>); block properties should always be copy Two common styles: Show: left-to-right navigation Present Modally: full-screen cover Use prepareForSegue: to connect Set the completion handler: insert new quote into models; have table view reload data; dismiss view controller","title":"Scene &amp; Segues"},{"location":"iOS/exam-ii-review-part-two/#data-persistence","text":"User Default: NSUserDefaults using key value (like NSDictionary ) Save files to the Document folder using plist Use SQLite Use Core Data Folder to save Documents Your application stores its data in Documents, with the exception of NSUserDefaults-based preference settings Library NSUserDefaults-based preference settings are stored in the Library/Preferences folder tmp Place to store temporary files that will not be backed up by iTunes, but your app has to be responsibility for deleting the files User Defaults No high performance No complex structure Not searchable NSString * const kCurrentIndexKey = @\"CurrentIndex\" ; - ( void ) save { NSUserDefaults * defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:[NSNumber numberWithInt:self.currentIndex] forKey:kCurrentIndexKey]; [defaults synchronize]; } - (NSNumber) read { NSNumber * readData = [[NSUserDefaults standardUserDefaults] objectForKey:kCurrentIndexKey]; return readData; } Use of const 1. Prevent mistype 2. Convenience to auto-complete 3. Declare outside of @interface and @implementation Inside Document Folder Accept types: Property List (xml) Text Files Archiving Objects -- NSCoding protocol NSString * documentsDirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[ 0 ]; // Create a file name for your file NSString * filename = @\"flashcards.plist\" ; // Generate the full file path _filePath = [NSString stringWithFormat: @\"%@/%@\" , documentsDirPath, filename]; NSLog( @\"file path %@\" , _filePath); NSArray * flashcardsFromDocumentsDir = [[NSArray alloc] initWithContentsOfFile:_filePath];","title":"Data Persistence"},{"location":"iOS/exam-ii-review-part-two/#app-life-cycle","text":"App States * Not Running * Inactive (foreground) * Active (foreground) * Background * Suspended","title":"App life cycle"},{"location":"iOS/exam-ii-review-part-two/#memory","text":"Two Methods of application memory management 1. Manual retain-release: MRR 2. Automatic Reference Counting: ARC * Using reference-count * Invoke dealloc automatically","title":"Memory"},{"location":"iOS/exam-ii-review-part-two/#mrr","text":"Cocoa's Policy * You own object you created: alloc new copy mutableCopy * Take ownership by using retain * When no longer need, relinquish it using release or autorelease (must relinquish object do not own) * \"Parent\" object maintain strong reference to \"children\", \"children\" have weak reference to \"parents\" Pratical Memory Management * Use accessor methods to set property values * Don't use accessor methods in initalizer and dealloc * Use weak reference to avoid retain cycles * Avoid dealloc object while using * Don't use dealloc to manage scarce resources * Collections own the objects they contain * Ownership policy is implemented using retain counts Retain Count * When create an object, RC (retain count) is 1 * When send a retain message, RC + 1 * When send a release message, RC - 1 * When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block. * If RC == 0 -> object dealloc","title":"MRR"},{"location":"iOS/exam-ii-review-part-two/#arc","text":"Insert retains and releases into code when compile","title":"ARC"},{"location":"iOS/exam-ii-review-part-two/#web-view","text":"WebKit * Follow MVC framework * View: WebView * Object: WebFrameView and WebFrame * App Transport Security force to connect with web service through HTTPS Example: Read a pdf file - ( void ) viewDidLoad { [super viewDidLoad]; NSString * path = [[NSBundle mainBundle] pathForResource: @\"HIG\" ofType: @\"pdf\" ]; if (path){ NSData * pdfData = [NSData dataWithContentsOfFile:path]; [(UIWebView * )self.view loadData:pdfData MIMEType: @\"application/pdf\" textEncodingName: @\"utf-8\" baseURL:nil]; } } Read a url NSURL * url = [NSURL URLWithString: @\"https://www.apple.com\" ]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [self.myWebView loadRequest: request]; Cancel a loading request - ( void ) viewWillDisappear: ( BOOL )animated{ [super viewWillDisappear:animated]; if ([self.myWebView isLoading]){ [self.myWebView stopLoading]; } // Disconnect the delegate as the webview is hidden self.myWebView.delegate = nil; } Animation loading in WebView - ( void ) webViewDidStartLoad: (UIWebView * )webView{ [self.activityIndicator startAnimating]; } - ( void ) webViewDidFinishLoad: (UIWebView * )webView{ [self.activityIndicator stopAnimating]; } - ( void ) webView: (UIWebView * )webView didFailLoadWithError: (NSError * )error{ [self.activityIndicator stopAnimating]; } Notes A web view automatically converts telephone numbers that appear in web content to Phone links. You should not embed UIWebView or UITableView objects in UIScrollView objects.","title":"Web View"},{"location":"iOS/exam-ii-review-part-two/#table-view-rewind","text":"","title":"Table View Rewind"},{"location":"iOS/exam-ii-review-part-two/#modifying-tables","text":"Delete table cells * Add navigation control * Enable edit button in viewDidLoad method * Use the public remove method in the model * Implement tableView: commitEditingStyle: forRowAtIndexPath method - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the row from the data source [self.model removeFlashcardAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view } }","title":"Modifying Tables"},{"location":"iOS/ios-api/","text":"Taking picture and movie \u00b6 UIImagePickerController AV Foundation JSQMessageController for bubble DialogFlow for smart reply fabric.io submit app Analytics \u00b6 Mixpanel NSLocalization Deployment \u00b6 TestFlight: distribution","title":"Ios api"},{"location":"iOS/ios-api/#taking-picture-and-movie","text":"UIImagePickerController AV Foundation JSQMessageController for bubble DialogFlow for smart reply fabric.io submit app","title":"Taking picture and movie"},{"location":"iOS/ios-api/#analytics","text":"Mixpanel NSLocalization","title":"Analytics"},{"location":"iOS/ios-api/#deployment","text":"TestFlight: distribution","title":"Deployment"},{"location":"iOS/some-tools/","text":"dev.weev.it use for api dev \u00b6 Dialog Flow use for bot chat \u00b6 Vuforia \u00b6 Bing Speech API use for recognizing speech to string \u00b6","title":"Some tools"},{"location":"iOS/some-tools/#devweevit-use-for-api-dev","text":"","title":"dev.weev.it use for api dev"},{"location":"iOS/some-tools/#dialog-flow-use-for-bot-chat","text":"","title":"Dialog Flow use for bot chat"},{"location":"iOS/some-tools/#vuforia","text":"","title":"Vuforia"},{"location":"iOS/some-tools/#bing-speech-api-use-for-recognizing-speech-to-string","text":"","title":"Bing Speech API use for recognizing speech to string"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/","text":"Loss Function \u00b6 Multiclass SVM Loss: hinge loss \u00b6 S_{y_j} S_{y_j} is the predict right score (target score) S_j S_j is the predict wrong score (all the other) L_i = \\sum_{j \\neq y_i} max(0, S_j - S_{y_j} + 1) Total Loss is: L = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i L(W) = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i(f(x_i, W), y_i) To calculate the loss for predicting car: max(0, cat score - car score + 1) + max(0, frog score - car score + 1) = max(0, -2.6) + max(0, -1.9) = 0 after using the same method to calculate each of the classes, the averge is the result: (2.9 -> for cat + 0 -> for car + 12.9 -> for frog) / 3 = 5.27 Regularization \u00b6 \\lambda R(W) \\lambda R(W) This term makes sure to choose \"simpler\" W instead of complicated ones that only fit training data, so that the power is lower for each term (high penalty for using high power poly). Softmax Classifier (Multinomial Logistic Regression): cross-entropy loss \u00b6 score is the probabilities for each class, and the sum of all classes equals to one (100%). Loss for each category: L_i = -\\log P(Y = y_i | X = x_i) L_i = -\\log P(Y = y_i | X = x_i) P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} where s s is our model: s = f(x_i;W) s = f(x_i;W) plug in to the first equation: L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) The min loss is 0 and max loss is +inf Finding the lowest score (with respect to W) -- Optimization \u00b6 ramdon (never use) find the slope (using gradient: numberic for debugging and analytic for calculating) Gradient Descent \u00b6 while True : weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter update step_size is also the learning rate, it's the first thing to set Stochastic Gradient Descent (SGD) \u00b6 Use when there are a lot of training set, in each iteraion, take a samples data from the training set (typically 32/64/128/256) called minibatch while True : data_batch = sample_training_data(data, 256 ) weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update","title":"Cs231n lecture 3   loss function"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#loss-function","text":"","title":"Loss Function"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#multiclass-svm-loss-hinge-loss","text":"S_{y_j} S_{y_j} is the predict right score (target score) S_j S_j is the predict wrong score (all the other) L_i = \\sum_{j \\neq y_i} max(0, S_j - S_{y_j} + 1) Total Loss is: L = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i L(W) = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i(f(x_i, W), y_i) To calculate the loss for predicting car: max(0, cat score - car score + 1) + max(0, frog score - car score + 1) = max(0, -2.6) + max(0, -1.9) = 0 after using the same method to calculate each of the classes, the averge is the result: (2.9 -> for cat + 0 -> for car + 12.9 -> for frog) / 3 = 5.27","title":"Multiclass SVM Loss: hinge loss"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#regularization","text":"\\lambda R(W) \\lambda R(W) This term makes sure to choose \"simpler\" W instead of complicated ones that only fit training data, so that the power is lower for each term (high penalty for using high power poly).","title":"Regularization"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#softmax-classifier-multinomial-logistic-regression-cross-entropy-loss","text":"score is the probabilities for each class, and the sum of all classes equals to one (100%). Loss for each category: L_i = -\\log P(Y = y_i | X = x_i) L_i = -\\log P(Y = y_i | X = x_i) P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} where s s is our model: s = f(x_i;W) s = f(x_i;W) plug in to the first equation: L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) The min loss is 0 and max loss is +inf","title":"Softmax Classifier (Multinomial Logistic Regression): cross-entropy loss"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#finding-the-lowest-score-with-respect-to-w-optimization","text":"ramdon (never use) find the slope (using gradient: numberic for debugging and analytic for calculating)","title":"Finding the lowest score (with respect to W) -- Optimization"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#gradient-descent","text":"while True : weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter update step_size is also the learning rate, it's the first thing to set","title":"Gradient Descent"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#stochastic-gradient-descent-sgd","text":"Use when there are a lot of training set, in each iteraion, take a samples data from the training set (typically 32/64/128/256) called minibatch while True : data_batch = sample_training_data(data, 256 ) weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update","title":"Stochastic Gradient Descent (SGD)"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/","text":"Computation Graph \u00b6 Backpropagation: used for finding gradient \u00b6 e.g. f(x,y,z) = (x + y) z where x = -2, y = 5, z = -4 Notations: \u00b6 q = x + y \\frac{\\partial q}{\\partial x} = 1, \\frac{\\partial q}{\\partial y} = 1 f = qz \\frac{\\partial f}{\\partial q} = z, \\frac{\\partial f}{\\partial z} = q goal is to find: \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} In order to get all the targets, we start from the last node where \\frac{\\partial f}{\\partial f} = q = 1 \\frac{\\partial f}{\\partial f} = q = 1 Then find the following in sequences: 1. \\frac{\\partial f}{\\partial z} = q = 1 2. \\frac{\\partial f}{\\partial q} = z = -4 3. \\frac{\\partial f}{\\partial y} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial y} = -4 \\times 1 = -4 -- using chain rule 4. \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial x} = -4 \\times 1 = -4 -- using chain rule Using Chain rule: Use upstreaming compound and multiple with the local compound to derive the desire partial derivative For each node, we just need \"local gradient\" which is the new upstream for the next level node. Another Example \u00b6 Sigmoid Function \u00b6 Because we already know the gradient for sigmoid function, we can just replace the sigmoid gate with the analyic gradient result. Patterns in backward flow \u00b6 add gate: gradient distributor (split to two branches because of two terms) max gate (e.g. max(0,1)=1): gradient router (one gradient is 0 and another is the full value) mul gate: gradient switcher (multiple the other one to derive the current one) Using matrix representation (Vectorization) \u00b6 Jacobian Matrix for derivative for each vector. However, we don't need to calculate Jacobian matrix, because each x in the row only affect the result element in the same row. Thus the matrix is diagonal. L2 norm: f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 Partial in respect to each q_i: \\frac{\\partial f}{\\partial q_i} = 2q_i or \\nabla_q f = 2q Then calculate gradient for W, we can use chain rule: \\frac{\\partial f}{\\partial W_{i,j}} = \\sum_{k} \\frac{\\partial f}{\\partial q_k} \\frac{\\partial q_k}{\\partial W_{i,j}} = 2^k q_i x_j Implement forward and backword for different gates \u00b6 class MultiplyGate (object): def forward (x,y): return x * y def backward (dz): dx = self . y * dz # cache y dy = self . x * dz return [dx, dy] where [dx, dy] is: \\frac{\\partial L}{\\partial x}, \\frac{\\partial L}{\\partial y} and dz is: \\frac{\\partial L}{\\partial z}","title":"Cs231n lecture 4   introduction to neural networks"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#computation-graph","text":"","title":"Computation Graph"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#backpropagation-used-for-finding-gradient","text":"e.g. f(x,y,z) = (x + y) z where x = -2, y = 5, z = -4","title":"Backpropagation: used for finding gradient"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#notations","text":"q = x + y \\frac{\\partial q}{\\partial x} = 1, \\frac{\\partial q}{\\partial y} = 1 f = qz \\frac{\\partial f}{\\partial q} = z, \\frac{\\partial f}{\\partial z} = q goal is to find: \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} In order to get all the targets, we start from the last node where \\frac{\\partial f}{\\partial f} = q = 1 \\frac{\\partial f}{\\partial f} = q = 1 Then find the following in sequences: 1. \\frac{\\partial f}{\\partial z} = q = 1 2. \\frac{\\partial f}{\\partial q} = z = -4 3. \\frac{\\partial f}{\\partial y} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial y} = -4 \\times 1 = -4 -- using chain rule 4. \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial x} = -4 \\times 1 = -4 -- using chain rule Using Chain rule: Use upstreaming compound and multiple with the local compound to derive the desire partial derivative For each node, we just need \"local gradient\" which is the new upstream for the next level node.","title":"Notations:"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#another-example","text":"","title":"Another Example"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#sigmoid-function","text":"Because we already know the gradient for sigmoid function, we can just replace the sigmoid gate with the analyic gradient result.","title":"Sigmoid Function"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#patterns-in-backward-flow","text":"add gate: gradient distributor (split to two branches because of two terms) max gate (e.g. max(0,1)=1): gradient router (one gradient is 0 and another is the full value) mul gate: gradient switcher (multiple the other one to derive the current one)","title":"Patterns in backward flow"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#using-matrix-representation-vectorization","text":"Jacobian Matrix for derivative for each vector. However, we don't need to calculate Jacobian matrix, because each x in the row only affect the result element in the same row. Thus the matrix is diagonal. L2 norm: f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 Partial in respect to each q_i: \\frac{\\partial f}{\\partial q_i} = 2q_i or \\nabla_q f = 2q Then calculate gradient for W, we can use chain rule: \\frac{\\partial f}{\\partial W_{i,j}} = \\sum_{k} \\frac{\\partial f}{\\partial q_k} \\frac{\\partial q_k}{\\partial W_{i,j}} = 2^k q_i x_j","title":"Using matrix representation (Vectorization)"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#implement-forward-and-backword-for-different-gates","text":"class MultiplyGate (object): def forward (x,y): return x * y def backward (dz): dx = self . y * dz # cache y dy = self . x * dz return [dx, dy] where [dx, dy] is: \\frac{\\partial L}{\\partial x}, \\frac{\\partial L}{\\partial y} and dz is: \\frac{\\partial L}{\\partial z}","title":"Implement forward and backword for different gates"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/","text":"CNN is good for spacial structure Filter \u00b6 stride (3 in this case): number of steps to move for each progress dimentino size: n * n filter size: F Output size = (N - F)/stride+1 => e.g. stride size = 3 won't work 1. To make this case working, adding a border surrounded (padding) will make N divisable (now N is 9 instead of 7) 2. To make the size remain the same dimentionally, we also use padding. Conv Layer \u00b6 Accpets a volume of size W_1\\times H_1 \\times D_1 W_1\\times H_1 \\times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F (or filter dimension), the stride S, the amount of zero padding P. Produces a volume of size W_2 W_2 \\times \\times H_2 H_2 \\times \\times D_2 D_2 W_2 = (W_1 - F + 2P)/S + 1 W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/s + 1 H_2 = (H_1 - F + 2P)/s + 1 (width and height are the same size) D_2 = K D_2 = K With parameter sharing, it produces F \\times F \\times D_1 F \\times F \\times D_1 weights per filter, for a total of (F \\cdot F \\cdot D_1) * K (F \\cdot F \\cdot D_1) * K weights In the output volume, the d-th depth slice (of size W_2 \\times H_2 W_2 \\times H_2 ) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S S , and then offset by d-th bias Pooling Layer \u00b6 input depth would be the same, and width and height would be shrink down by a factor Max-Pooling Layer \u00b6 Choosing the maximum within each filter. Find the region that has fired with higher value from the other region. Summary \u00b6 Accepts a volume of size W1\u00d7H1\u00d7D1 Requires two hyperparameters: their spatial extent F, the stride S, Produces a volume of size W2\u00d7H2\u00d7D2 where: W_2=(W_1\u2212F)/S+1 W_2=(W_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 D_2=D_1 D_2=D_1 Introduces zero parameters since it computes a fixed function of the input For Pooling layers, it is not common to pad the input using zero-padding. It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with F=3,S=2 F=3,S=2 (also called overlapping pooling), and more commonly F=2,S=2 F=2,S=2 . Pooling sizes with larger receptive fields are too destructive. Fully Connected Layer (FC) \u00b6 Stretch out to 1-d array, usually on the last layer.","title":"Cs231n lecture 5   convolutional neural networks"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#filter","text":"stride (3 in this case): number of steps to move for each progress dimentino size: n * n filter size: F Output size = (N - F)/stride+1 => e.g. stride size = 3 won't work 1. To make this case working, adding a border surrounded (padding) will make N divisable (now N is 9 instead of 7) 2. To make the size remain the same dimentionally, we also use padding.","title":"Filter"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#conv-layer","text":"Accpets a volume of size W_1\\times H_1 \\times D_1 W_1\\times H_1 \\times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F (or filter dimension), the stride S, the amount of zero padding P. Produces a volume of size W_2 W_2 \\times \\times H_2 H_2 \\times \\times D_2 D_2 W_2 = (W_1 - F + 2P)/S + 1 W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/s + 1 H_2 = (H_1 - F + 2P)/s + 1 (width and height are the same size) D_2 = K D_2 = K With parameter sharing, it produces F \\times F \\times D_1 F \\times F \\times D_1 weights per filter, for a total of (F \\cdot F \\cdot D_1) * K (F \\cdot F \\cdot D_1) * K weights In the output volume, the d-th depth slice (of size W_2 \\times H_2 W_2 \\times H_2 ) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S S , and then offset by d-th bias","title":"Conv Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#pooling-layer","text":"input depth would be the same, and width and height would be shrink down by a factor","title":"Pooling Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#max-pooling-layer","text":"Choosing the maximum within each filter. Find the region that has fired with higher value from the other region.","title":"Max-Pooling Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#summary","text":"Accepts a volume of size W1\u00d7H1\u00d7D1 Requires two hyperparameters: their spatial extent F, the stride S, Produces a volume of size W2\u00d7H2\u00d7D2 where: W_2=(W_1\u2212F)/S+1 W_2=(W_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 D_2=D_1 D_2=D_1 Introduces zero parameters since it computes a fixed function of the input For Pooling layers, it is not common to pad the input using zero-padding. It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with F=3,S=2 F=3,S=2 (also called overlapping pooling), and more commonly F=2,S=2 F=2,S=2 . Pooling sizes with larger receptive fields are too destructive.","title":"Summary"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#fully-connected-layer-fc","text":"Stretch out to 1-d array, usually on the last layer.","title":"Fully Connected Layer (FC)"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/","text":"Overview \u00b6 One time setup: activation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamics: babysitting the learning process, parameter updates, hyperparameter optimization Evaluation: model ensembles Part 1 \u00b6 Activation functions Data preprocessing Weight initialization, Batch Normalization Babysitting the learning process Hyperparameter Optimization Activation Function \u00b6 Sigmoid \u00b6 \\sigma(x)=\\frac{1}{1+e^{-x}} \\sigma(x)=\\frac{1}{1+e^{-x}} if get high value -> approach to 1, low -> 0 problem 1: if too large, then the value is 1, or too small, then the value is 0 (killed gradient when saturated) problem 2: not zero-centered (gradient on w is always all positive or negative) which makes the parameter update inefficient problem 3: e^{-x} e^{-x} is computation expensive tanh \u00b6 tanh(x) tanh(x) in a range of [-1, 1] it's now zero centered (flip between - and + for same weight) problem 1: still kill gradient when saturated ReLU \u00b6 f(x)=max(0,x) f(x)=max(0,x) doesn't saturated in positive region computation efficient converge faster than sigmoid and tanh biologically plausible than sigmoid problem 1: not zero-centered problem 2: negative still saturated (annoyance, dead relu region) Leaky ReLU and Parametric Rectifier \u00b6 f(x)=max(0.01x, x) and f(x)=max(\\alpha x, x) Does not saturate Computationally efficient Converge much faster than sigmoid/tanh in practice will not \"die\" (no platu) Exponential Linear Unit (ELU) \u00b6 f(x)=x if x > 0 f(x)= alpha (exp(x)-1) if x <= 0 all benefits of ReLU closer to zero mean outputs negative sarturation regime compared with Leaky ReLU adds some robustness to noise problem 1: computation requires exp() Conclusion \u00b6 Use ReLU Try out Leaky ReLU/Maxout/ELU Try tanh but don't expect too much Don't use sigmoid Data Preprocessing \u00b6 for image, stick with zero-mean","title":"Cs231n lecture 6   training neural networks i"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#overview","text":"One time setup: activation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamics: babysitting the learning process, parameter updates, hyperparameter optimization Evaluation: model ensembles","title":"Overview"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#part-1","text":"Activation functions Data preprocessing Weight initialization, Batch Normalization Babysitting the learning process Hyperparameter Optimization","title":"Part 1"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#activation-function","text":"","title":"Activation Function"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#sigmoid","text":"\\sigma(x)=\\frac{1}{1+e^{-x}} \\sigma(x)=\\frac{1}{1+e^{-x}} if get high value -> approach to 1, low -> 0 problem 1: if too large, then the value is 1, or too small, then the value is 0 (killed gradient when saturated) problem 2: not zero-centered (gradient on w is always all positive or negative) which makes the parameter update inefficient problem 3: e^{-x} e^{-x} is computation expensive","title":"Sigmoid"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#tanh","text":"tanh(x) tanh(x) in a range of [-1, 1] it's now zero centered (flip between - and + for same weight) problem 1: still kill gradient when saturated","title":"tanh"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#relu","text":"f(x)=max(0,x) f(x)=max(0,x) doesn't saturated in positive region computation efficient converge faster than sigmoid and tanh biologically plausible than sigmoid problem 1: not zero-centered problem 2: negative still saturated (annoyance, dead relu region)","title":"ReLU"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#leaky-relu-and-parametric-rectifier","text":"f(x)=max(0.01x, x) and f(x)=max(\\alpha x, x) Does not saturate Computationally efficient Converge much faster than sigmoid/tanh in practice will not \"die\" (no platu)","title":"Leaky ReLU and Parametric Rectifier"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#exponential-linear-unit-elu","text":"f(x)=x if x > 0 f(x)= alpha (exp(x)-1) if x <= 0 all benefits of ReLU closer to zero mean outputs negative sarturation regime compared with Leaky ReLU adds some robustness to noise problem 1: computation requires exp()","title":"Exponential Linear Unit (ELU)"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#conclusion","text":"Use ReLU Try out Leaky ReLU/Maxout/ELU Try tanh but don't expect too much Don't use sigmoid","title":"Conclusion"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#data-preprocessing","text":"for image, stick with zero-mean","title":"Data Preprocessing"}]}