{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Peter's Tech Notes \u00b6 What's included \u00b6 Leetcode: some questions I have done (with analysis). Languages: C, Java, Python, Golang Machine Learning: course note for Stanford CS231n. Interview: notes for preparing interviews. Competitive Programming: Google Kick Start, LibreOJ, Acwing. Books: various algorithm books notes. Misc: miscellaneous (unorganized) No Longer Update \u00b6 Old gitbook cnblog iOS: no longer update Crypto: no longer update","title":"Welcome to Peter's Tech Notes"},{"location":"#welcome-to-peters-tech-notes","text":"","title":"Welcome to Peter's Tech Notes"},{"location":"#whats-included","text":"Leetcode: some questions I have done (with analysis). Languages: C, Java, Python, Golang Machine Learning: course note for Stanford CS231n. Interview: notes for preparing interviews. Competitive Programming: Google Kick Start, LibreOJ, Acwing. Books: various algorithm books notes. Misc: miscellaneous (unorganized)","title":"What's included"},{"location":"#no-longer-update","text":"Old gitbook cnblog iOS: no longer update Crypto: no longer update","title":"No Longer Update"},{"location":"about/","text":"About \u00b6 Hi, I'm Pete. I major in Computer Science and Engineering. Ping me AT peterchen.xyz.","title":"About"},{"location":"about/#about","text":"Hi, I'm Pete. I major in Computer Science and Engineering. Ping me AT peterchen.xyz.","title":"About"},{"location":"Acwing/1142.-%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/","text":"1142 \u7e41\u5fd9\u7684\u90fd\u5e02 \u00b6 \u57ce\u5e02C\u662f\u4e00\u4e2a\u975e\u5e38\u7e41\u5fd9\u7684\u5927\u90fd\u5e02\uff0c\u57ce\u5e02\u4e2d\u7684\u9053\u8def\u5341\u5206\u7684\u62e5\u6324\uff0c\u4e8e\u662f\u5e02\u957f\u51b3\u5b9a\u5bf9\u5176\u4e2d\u7684\u9053\u8def\u8fdb\u884c\u6539\u9020\u3002 \u57ce\u5e02C\u7684\u9053\u8def\u662f\u8fd9\u6837\u5206\u5e03\u7684\uff1a \u57ce\u5e02\u4e2d\u6709 n \u4e2a\u4ea4\u53c9\u8def\u53e3\uff0c\u7f16\u53f7\u662f 1\u223cn\uff0c\u6709\u4e9b\u4ea4\u53c9\u8def\u53e3\u4e4b\u95f4\u6709\u9053\u8def\u76f8\u8fde\uff0c\u4e24\u4e2a\u4ea4\u53c9\u8def\u53e3\u4e4b\u95f4\u6700\u591a\u6709\u4e00\u6761\u9053\u8def\u76f8\u8fde\u63a5\u3002 \u8fd9\u4e9b\u9053\u8def\u662f \u53cc\u5411 \u7684\uff0c\u4e14\u628a\u6240\u6709\u7684\u4ea4\u53c9\u8def\u53e3\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u8fde\u63a5\u8d77\u6765\u4e86\u3002 \u6bcf\u6761\u9053\u8def\u90fd\u6709\u4e00\u4e2a\u5206\u503c\uff0c\u5206\u503c\u8d8a\u5c0f\u8868\u793a\u8fd9\u4e2a\u9053\u8def\u8d8a\u7e41\u5fd9\uff0c\u8d8a\u9700\u8981\u8fdb\u884c\u6539\u9020\u3002 \u4f46\u662f\u5e02\u653f\u5e9c\u7684\u8d44\u91d1\u6709\u9650\uff0c\u5e02\u957f\u5e0c\u671b\u8fdb\u884c\u6539\u9020\u7684\u9053\u8def\u8d8a\u5c11\u8d8a\u597d\uff0c\u4e8e\u662f\u4ed6\u63d0\u51fa\u4e0b\u9762\u7684\u8981\u6c42\uff1a 1\uff0e\u6539\u9020\u7684\u90a3\u4e9b\u9053\u8def\u80fd\u591f\u628a\u6240\u6709\u7684\u4ea4\u53c9\u8def\u53e3\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u8fde\u901a\u8d77\u6765\u3002 2\uff0e\u5728\u6ee1\u8db3\u8981\u6c421\u7684\u60c5\u51b5\u4e0b\uff0c\u6539\u9020\u7684\u9053\u8def\u5c3d\u91cf\u5c11\u3002 3\uff0e\u5728\u6ee1\u8db3\u8981\u6c421\u30012\u7684\u60c5\u51b5\u4e0b\uff0c\u6539\u9020\u7684\u90a3\u4e9b\u9053\u8def\u4e2d\u5206\u503c\u6700\u5927\u503c\u5c3d\u91cf\u5c0f\u3002 \u4f5c\u4e3a\u5e02\u89c4\u5212\u5c40\u7684\u4f60\uff0c\u5e94\u5f53\u4f5c\u51fa\u6700\u4f73\u7684\u51b3\u7b56\uff0c\u9009\u62e9\u90a3\u4e9b\u9053\u8def\u5e94\u5f53\u88ab\u4fee\u5efa\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u6709\u4e24\u4e2a\u6574\u6570 n,m \u8868\u793a\u57ce\u5e02\u6709 n \u4e2a\u4ea4\u53c9\u8def\u53e3\uff0cm \u6761\u9053\u8def\u3002 \u63a5\u4e0b\u6765 m \u884c\u662f\u5bf9\u6bcf\u6761\u9053\u8def\u7684\u63cf\u8ff0\uff0c\u6bcf\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570u,v,c \u8868\u793a\u4ea4\u53c9\u8def\u53e3 u \u548c v \u4e4b\u95f4\u6709\u9053\u8def\u76f8\u8fde\uff0c\u5206\u503c\u4e3a c\u3002 \u8f93\u51fa\u683c\u5f0f \u4e24\u4e2a\u6574\u6570 s,max\uff0c\u8868\u793a\u4f60\u9009\u51fa\u4e86\u51e0\u6761\u9053\u8def\uff0c\u5206\u503c\u6700\u5927\u7684\u90a3\u6761\u9053\u8def\u7684\u5206\u503c\u662f\u591a\u5c11\u3002 \u6570\u636e\u8303\u56f4 1\u2264n\u2264300, 1\u2264m\u22648000, 1\u2264c\u226410000 \u8f93\u5165\u6837\u4f8b\uff1a 4 5 1 2 3 1 4 5 2 4 7 2 3 6 3 4 8 \u8f93\u51fa\u6837\u4f8b\uff1a 3 6 \u5206\u6790: \u4e8c\u5206+bfs \u00b6 \u9996\u5148\u6309\u7167\u8fb9\u6392\u5e8f\uff0c\u7136\u540e\u6bcf\u6b21\u7f29\u5c0f\u6570\u636e\u8303\u56f4\u68c0\u6d4b\u662f\u5426\u5269\u4e0b\u7684\u8fb9\u53ef\u4ee5\u8fde\u901a\u6240\u6709\u7684\u70b9\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(m \\times log(n)) O(m \\times log(n)) \u5206\u6790\uff1aKruskal \u00b6 \u9996\u5148\u6309\u7167\u8fb9\u6392\u5e8f\uff0c\u4ece\u5c0f\u5f80\u5927\u52a0\u8fb9\uff0c\u5f53cover\u5230\u6240\u6709\u70b9\u7684\u65f6\u5019\u7ed3\u675f\uff0c\u8fd4\u56de\u5f53\u524d\u7684\u6700\u540e\u52a0\u5165\u7684\u8fb9\u7684\u503c\uff0c\u590d\u6742\u5ea6: O(m \\times log(m)) O(m \\times log(m)) \u4ee3\u7801 \u00b6 #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 310 , M = 10010 ; int n, m; struct Edge { int a, b, w; bool operator < ( const Edge & t) const { return w < t.w; } }e[M]; int p[N]; int find ( int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main () { cin >> n >> m; for ( int i = 1 ; i <= n; i ++ ) p[i] = i; for ( int i = 0 ; i < m; i ++ ) { int a, b, w; cin >> a >> b >> w; e[i] = {a, b, w}; } sort(e, e + m); int res = 0 ; for ( int i = 0 ; i < m; i ++ ) { int a = find(e[i].a), b = find(e[i].b), w = e[i].w; if (a != b) // \u5047\u5982\u5df2\u7ecf\u8fde\u63a5\uff0c\u90a3\u4e48\u65e0\u9700\u7ee7\u7eed\u8fde\u63a5 { p[a] = b; res = w; } } cout << n - 1 << ' ' << res << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/148078/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"1142 \u7e41\u5fd9\u7684\u90fd\u5e02"},{"location":"Acwing/1142.-%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/#1142","text":"\u57ce\u5e02C\u662f\u4e00\u4e2a\u975e\u5e38\u7e41\u5fd9\u7684\u5927\u90fd\u5e02\uff0c\u57ce\u5e02\u4e2d\u7684\u9053\u8def\u5341\u5206\u7684\u62e5\u6324\uff0c\u4e8e\u662f\u5e02\u957f\u51b3\u5b9a\u5bf9\u5176\u4e2d\u7684\u9053\u8def\u8fdb\u884c\u6539\u9020\u3002 \u57ce\u5e02C\u7684\u9053\u8def\u662f\u8fd9\u6837\u5206\u5e03\u7684\uff1a \u57ce\u5e02\u4e2d\u6709 n \u4e2a\u4ea4\u53c9\u8def\u53e3\uff0c\u7f16\u53f7\u662f 1\u223cn\uff0c\u6709\u4e9b\u4ea4\u53c9\u8def\u53e3\u4e4b\u95f4\u6709\u9053\u8def\u76f8\u8fde\uff0c\u4e24\u4e2a\u4ea4\u53c9\u8def\u53e3\u4e4b\u95f4\u6700\u591a\u6709\u4e00\u6761\u9053\u8def\u76f8\u8fde\u63a5\u3002 \u8fd9\u4e9b\u9053\u8def\u662f \u53cc\u5411 \u7684\uff0c\u4e14\u628a\u6240\u6709\u7684\u4ea4\u53c9\u8def\u53e3\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u8fde\u63a5\u8d77\u6765\u4e86\u3002 \u6bcf\u6761\u9053\u8def\u90fd\u6709\u4e00\u4e2a\u5206\u503c\uff0c\u5206\u503c\u8d8a\u5c0f\u8868\u793a\u8fd9\u4e2a\u9053\u8def\u8d8a\u7e41\u5fd9\uff0c\u8d8a\u9700\u8981\u8fdb\u884c\u6539\u9020\u3002 \u4f46\u662f\u5e02\u653f\u5e9c\u7684\u8d44\u91d1\u6709\u9650\uff0c\u5e02\u957f\u5e0c\u671b\u8fdb\u884c\u6539\u9020\u7684\u9053\u8def\u8d8a\u5c11\u8d8a\u597d\uff0c\u4e8e\u662f\u4ed6\u63d0\u51fa\u4e0b\u9762\u7684\u8981\u6c42\uff1a 1\uff0e\u6539\u9020\u7684\u90a3\u4e9b\u9053\u8def\u80fd\u591f\u628a\u6240\u6709\u7684\u4ea4\u53c9\u8def\u53e3\u76f4\u63a5\u6216\u95f4\u63a5\u7684\u8fde\u901a\u8d77\u6765\u3002 2\uff0e\u5728\u6ee1\u8db3\u8981\u6c421\u7684\u60c5\u51b5\u4e0b\uff0c\u6539\u9020\u7684\u9053\u8def\u5c3d\u91cf\u5c11\u3002 3\uff0e\u5728\u6ee1\u8db3\u8981\u6c421\u30012\u7684\u60c5\u51b5\u4e0b\uff0c\u6539\u9020\u7684\u90a3\u4e9b\u9053\u8def\u4e2d\u5206\u503c\u6700\u5927\u503c\u5c3d\u91cf\u5c0f\u3002 \u4f5c\u4e3a\u5e02\u89c4\u5212\u5c40\u7684\u4f60\uff0c\u5e94\u5f53\u4f5c\u51fa\u6700\u4f73\u7684\u51b3\u7b56\uff0c\u9009\u62e9\u90a3\u4e9b\u9053\u8def\u5e94\u5f53\u88ab\u4fee\u5efa\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u6709\u4e24\u4e2a\u6574\u6570 n,m \u8868\u793a\u57ce\u5e02\u6709 n \u4e2a\u4ea4\u53c9\u8def\u53e3\uff0cm \u6761\u9053\u8def\u3002 \u63a5\u4e0b\u6765 m \u884c\u662f\u5bf9\u6bcf\u6761\u9053\u8def\u7684\u63cf\u8ff0\uff0c\u6bcf\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570u,v,c \u8868\u793a\u4ea4\u53c9\u8def\u53e3 u \u548c v \u4e4b\u95f4\u6709\u9053\u8def\u76f8\u8fde\uff0c\u5206\u503c\u4e3a c\u3002 \u8f93\u51fa\u683c\u5f0f \u4e24\u4e2a\u6574\u6570 s,max\uff0c\u8868\u793a\u4f60\u9009\u51fa\u4e86\u51e0\u6761\u9053\u8def\uff0c\u5206\u503c\u6700\u5927\u7684\u90a3\u6761\u9053\u8def\u7684\u5206\u503c\u662f\u591a\u5c11\u3002 \u6570\u636e\u8303\u56f4 1\u2264n\u2264300, 1\u2264m\u22648000, 1\u2264c\u226410000 \u8f93\u5165\u6837\u4f8b\uff1a 4 5 1 2 3 1 4 5 2 4 7 2 3 6 3 4 8 \u8f93\u51fa\u6837\u4f8b\uff1a 3 6","title":"1142 \u7e41\u5fd9\u7684\u90fd\u5e02"},{"location":"Acwing/1142.-%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/#bfs","text":"\u9996\u5148\u6309\u7167\u8fb9\u6392\u5e8f\uff0c\u7136\u540e\u6bcf\u6b21\u7f29\u5c0f\u6570\u636e\u8303\u56f4\u68c0\u6d4b\u662f\u5426\u5269\u4e0b\u7684\u8fb9\u53ef\u4ee5\u8fde\u901a\u6240\u6709\u7684\u70b9\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\uff1a O(m \\times log(n)) O(m \\times log(n))","title":"\u5206\u6790: \u4e8c\u5206+bfs"},{"location":"Acwing/1142.-%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/#kruskal","text":"\u9996\u5148\u6309\u7167\u8fb9\u6392\u5e8f\uff0c\u4ece\u5c0f\u5f80\u5927\u52a0\u8fb9\uff0c\u5f53cover\u5230\u6240\u6709\u70b9\u7684\u65f6\u5019\u7ed3\u675f\uff0c\u8fd4\u56de\u5f53\u524d\u7684\u6700\u540e\u52a0\u5165\u7684\u8fb9\u7684\u503c\uff0c\u590d\u6742\u5ea6: O(m \\times log(m)) O(m \\times log(m))","title":"\u5206\u6790\uff1aKruskal"},{"location":"Acwing/1142.-%E7%B9%81%E5%BF%99%E7%9A%84%E9%83%BD%E5%B8%82/#_1","text":"#include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 310 , M = 10010 ; int n, m; struct Edge { int a, b, w; bool operator < ( const Edge & t) const { return w < t.w; } }e[M]; int p[N]; int find ( int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main () { cin >> n >> m; for ( int i = 1 ; i <= n; i ++ ) p[i] = i; for ( int i = 0 ; i < m; i ++ ) { int a, b, w; cin >> a >> b >> w; e[i] = {a, b, w}; } sort(e, e + m); int res = 0 ; for ( int i = 0 ; i < m; i ++ ) { int a = find(e[i].a), b = find(e[i].b), w = e[i].w; if (a != b) // \u5047\u5982\u5df2\u7ecf\u8fde\u63a5\uff0c\u90a3\u4e48\u65e0\u9700\u7ee7\u7eed\u8fde\u63a5 { p[a] = b; res = w; } } cout << n - 1 << ' ' << res << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/148078/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u4ee3\u7801"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","text":"895. \u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 (LCIS) \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3aN\u7684\u6570\u5217\uff0c\u6c42\u6570\u503c\u4e25\u683c\u5355\u8c03\u9012\u589e\u7684\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u6700\u957f\u662f\u591a\u5c11\u3002 \u8f93\u5165\u683c\u5f0f \u00b6 \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\u3002 \u7b2c\u4e8c\u884c\u5305\u542bN\u4e2a\u6574\u6570\uff0c\u8868\u793a\u5b8c\u6574\u5e8f\u5217\u3002 \u8f93\u51fa\u683c\u5f0f \u00b6 \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5927\u957f\u5ea6\u3002 \u6570\u636e\u8303\u56f4 \u00b6 1\u2264N\u22641000\uff0c \u2212109\u2264\u6570\u5217\u4e2d\u7684\u6570\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a \u00b6 7 3 1 2 1 8 5 6 \u8f93\u51fa\u6837\u4f8b\uff1a \u00b6 4 DFS \u00b6 \u53ef\u8bb0\u5f55\u65b9\u6848\uff0c\u4f46\u662f\u4e0d\u591f\u9ad8\u6548 \uff08\u7a7a\u95f4\uff09 a: \u6570\u7ec4 k[i]: \u4ee5a[k[i]]\u4e3a\u7ed3\u5c3e\u7684\u6700\u957f\u5b50\u5e8f\u5217\u7684\u957f\u5ea6 \u7b54\u6848\u5373\uff1ak\u4e2d\u7684\u6700\u5927\u503c int n, a[ 105 ]; int k[ 105 ], ans; void dfs ( int len) { if (len > ans) ans = len; // \u627e\u4ece\u5f53\u524d\u6700\u957f\u7684\u5b50\u5e8f\u5217\u7684\u6700\u540e\u5230a\u7684\u7ed3\u5c3e\u4e2d--\u7b2c\u4e00\u4e2a\u6bd4\u5f53\u524d\u7ed3\u5c3e\u8981\u5927\u7684\u6570\u5b57\u7684index for ( int i = k[len] + 1 ; i <= n; ++ i) { if (a[i] > a[k[len]]) { k[len + 1 ] = i; dfs(len + 1 ); } } } // initial condition k[ 0 ] = 0 ; // \u957f\u5ea6\u4e3a0\u7684\u65f6\u5019\uff0c\u6700\u957f\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u662f0 a[ 0 ] = - ( 1 << 30 ); // -inf\u4f5c\u4e3a\u6570\u7ec4\u7684\u9996\u4e2a\u5143\u7d20\uff0c\u5373a[1]\u5fc5\u5b9a\u4f1a\u6210\u4e3a\u4e00\u4e2a\u957f\u5ea6\u4e3a1\u7684\u9012\u589e\u5b50\u5e8f\u5217 dfs( 0 ); // \u4ece\u957f\u5ea6\u4e3a0\u7684\u6570\u7ec4\u5f00\u59cb\u904d\u5386 Time: O(n^2) O(n^2) : \u6bcf\u6b21\u904d\u5386\u90fd\u9700\u8981\u8d70\u4e00\u4e2aforloop\uff0c\u6700\u574f\u60c5\u51b5\u662f\u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u9012\u589e\u7684\u5b50\u5e8f\u5217 Space: O(n) O(n) : n\u5c42\u904d\u5386\u548c\u5f00\u8f9f\u7684\u4e24\u4e2a\u65b0\u7684\u6570\u7ec4 DFS Enhanced \u00b6 \u4e0d\u4f7f\u7528k\u6570\u7ec4\uff0c\u56e0\u4e3a\u6bcf\u6b21\u53ea\u9700\u4f7f\u7528k[end]\u6765\u6bd4\u8f83k[end] ~ a[end]\u7684\u90e8\u5206\u4e2d\u6bd4a[k[end]]\u5927\u7684\u7b2c\u4e00\u4e2a\u6570\u5b57\u5373\u53ef int n, ans, a[ 105 ]; void dfs ( int len, int tail) { if (len > ans) ans = len; // \u627e\u4ece\u5f53\u524d\u6700\u957f\u7684\u5b50\u5e8f\u5217\u7684\u6700\u540e\u5230a\u7684\u7ed3\u5c3e\u4e2d--\u7b2c\u4e00\u4e2a\u6bd4\u5f53\u524d\u7ed3\u5c3e\u8981\u5927\u7684\u6570\u5b57\u7684index for ( int i = tail + 1 ; i <= n; ++ i) { if (a[i] > a[tail]) { dfs(tail + 1 , i); } } } // initial condition dfs( 0 , 0 ); // \u4ece\u957f\u5ea6\u4e3a0\u7684\u6570\u7ec4\u5f00\u59cb\u904d\u5386\uff0c\u540c\u65f6\u521d\u59cb\u957f\u5ea6\u4e3a0 Time: O(n^2) O(n^2) : \u6bcf\u6b21\u904d\u5386\u90fd\u9700\u8981\u8d70\u4e00\u4e2aforloop\uff0c\u6700\u574f\u60c5\u51b5\u662f\u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u9012\u589e\u7684\u5b50\u5e8f\u5217 Space: O(n) O(n) : n\u5c42\u904d\u5386\u548c\u5f00\u8f9f\u7684\u4e00\u4e2a\u65b0\u7684\u6570\u7ec4 DP \u00b6 \u627e\u5b50\u7ed3\u6784\uff1a\u5047\u8bbe\u7ed3\u5c3e\u4e3aa[i]\u7684\u6700\u957f\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u662ff[i]\uff0c\u90a3\u4e48\u7ed3\u5c3e\u4e3aa[i+1]\u7684\u6700\u957f\u5b50\u6570\u7ec4\u7684\uff0c\u6700\u540e\u7b54\u6848\u662ff[end] \u65b9\u6cd5\u4e00 \uff1a \u4ece\u524d\u5f80\u540e\uff0c\u6bcf\u6b21\u66f4\u65b0\u65b0\u7684\u5143\u7d20\u7684\u957f\u5ea6 f[ 0 ] = 0 ; for ( int i = 0 ; i < n; ++ i) for ( int j = i + 1 ; j <= n; ++ j) // \u4ece\u5f53\u524d\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u5f80\u540e\u627e\uff0c\u66f4\u65b0\u65b0\u7684\u4f4d\u7f6e\u7684\u6700\u5927\u5b50\u6570\u7ec4\u957f\u5ea6 if (a[j] > a[i]) f[j] = max(f[j], f[i] + 1 ); \u65b9\u6cd5\u4e8c \uff1a \u4ece\u540e\u5f80\u524d\uff0c\u6bcf\u6b21\u66f4\u65b0\u5f53\u524d\u5143\u7d20\u7684\u957f\u5ea6 f[ 0 ] = 0 ; for ( int i = 1 ; i <= n; ++ i) for ( int j = 0 ; j < i; ++ j) // \u4ece\u5f53\u524d\u7684\u4e0a\u4e00\u4e2a\u5143\u7d20\u5f80\u524d\u627e\uff0c\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u5b50\u6570\u7ec4\u957f\u5ea6 if (a[i] > a[j]) f[i] = max(f[i], f[j] + 1 );","title":"895. \u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 (LCIS)"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#895-lcis","text":"\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3aN\u7684\u6570\u5217\uff0c\u6c42\u6570\u503c\u4e25\u683c\u5355\u8c03\u9012\u589e\u7684\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u6700\u957f\u662f\u591a\u5c11\u3002","title":"895. \u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 (LCIS)"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#_1","text":"\u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\u3002 \u7b2c\u4e8c\u884c\u5305\u542bN\u4e2a\u6574\u6570\uff0c\u8868\u793a\u5b8c\u6574\u5e8f\u5217\u3002","title":"\u8f93\u5165\u683c\u5f0f"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#_2","text":"\u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5927\u957f\u5ea6\u3002","title":"\u8f93\u51fa\u683c\u5f0f"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#_3","text":"1\u2264N\u22641000\uff0c \u2212109\u2264\u6570\u5217\u4e2d\u7684\u6570\u2264109","title":"\u6570\u636e\u8303\u56f4"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#_4","text":"7 3 1 2 1 8 5 6","title":"\u8f93\u5165\u6837\u4f8b\uff1a"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#_5","text":"4","title":"\u8f93\u51fa\u6837\u4f8b\uff1a"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#dfs","text":"\u53ef\u8bb0\u5f55\u65b9\u6848\uff0c\u4f46\u662f\u4e0d\u591f\u9ad8\u6548 \uff08\u7a7a\u95f4\uff09 a: \u6570\u7ec4 k[i]: \u4ee5a[k[i]]\u4e3a\u7ed3\u5c3e\u7684\u6700\u957f\u5b50\u5e8f\u5217\u7684\u957f\u5ea6 \u7b54\u6848\u5373\uff1ak\u4e2d\u7684\u6700\u5927\u503c int n, a[ 105 ]; int k[ 105 ], ans; void dfs ( int len) { if (len > ans) ans = len; // \u627e\u4ece\u5f53\u524d\u6700\u957f\u7684\u5b50\u5e8f\u5217\u7684\u6700\u540e\u5230a\u7684\u7ed3\u5c3e\u4e2d--\u7b2c\u4e00\u4e2a\u6bd4\u5f53\u524d\u7ed3\u5c3e\u8981\u5927\u7684\u6570\u5b57\u7684index for ( int i = k[len] + 1 ; i <= n; ++ i) { if (a[i] > a[k[len]]) { k[len + 1 ] = i; dfs(len + 1 ); } } } // initial condition k[ 0 ] = 0 ; // \u957f\u5ea6\u4e3a0\u7684\u65f6\u5019\uff0c\u6700\u957f\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u662f0 a[ 0 ] = - ( 1 << 30 ); // -inf\u4f5c\u4e3a\u6570\u7ec4\u7684\u9996\u4e2a\u5143\u7d20\uff0c\u5373a[1]\u5fc5\u5b9a\u4f1a\u6210\u4e3a\u4e00\u4e2a\u957f\u5ea6\u4e3a1\u7684\u9012\u589e\u5b50\u5e8f\u5217 dfs( 0 ); // \u4ece\u957f\u5ea6\u4e3a0\u7684\u6570\u7ec4\u5f00\u59cb\u904d\u5386 Time: O(n^2) O(n^2) : \u6bcf\u6b21\u904d\u5386\u90fd\u9700\u8981\u8d70\u4e00\u4e2aforloop\uff0c\u6700\u574f\u60c5\u51b5\u662f\u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u9012\u589e\u7684\u5b50\u5e8f\u5217 Space: O(n) O(n) : n\u5c42\u904d\u5386\u548c\u5f00\u8f9f\u7684\u4e24\u4e2a\u65b0\u7684\u6570\u7ec4","title":"DFS"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#dfs-enhanced","text":"\u4e0d\u4f7f\u7528k\u6570\u7ec4\uff0c\u56e0\u4e3a\u6bcf\u6b21\u53ea\u9700\u4f7f\u7528k[end]\u6765\u6bd4\u8f83k[end] ~ a[end]\u7684\u90e8\u5206\u4e2d\u6bd4a[k[end]]\u5927\u7684\u7b2c\u4e00\u4e2a\u6570\u5b57\u5373\u53ef int n, ans, a[ 105 ]; void dfs ( int len, int tail) { if (len > ans) ans = len; // \u627e\u4ece\u5f53\u524d\u6700\u957f\u7684\u5b50\u5e8f\u5217\u7684\u6700\u540e\u5230a\u7684\u7ed3\u5c3e\u4e2d--\u7b2c\u4e00\u4e2a\u6bd4\u5f53\u524d\u7ed3\u5c3e\u8981\u5927\u7684\u6570\u5b57\u7684index for ( int i = tail + 1 ; i <= n; ++ i) { if (a[i] > a[tail]) { dfs(tail + 1 , i); } } } // initial condition dfs( 0 , 0 ); // \u4ece\u957f\u5ea6\u4e3a0\u7684\u6570\u7ec4\u5f00\u59cb\u904d\u5386\uff0c\u540c\u65f6\u521d\u59cb\u957f\u5ea6\u4e3a0 Time: O(n^2) O(n^2) : \u6bcf\u6b21\u904d\u5386\u90fd\u9700\u8981\u8d70\u4e00\u4e2aforloop\uff0c\u6700\u574f\u60c5\u51b5\u662f\u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u9012\u589e\u7684\u5b50\u5e8f\u5217 Space: O(n) O(n) : n\u5c42\u904d\u5386\u548c\u5f00\u8f9f\u7684\u4e00\u4e2a\u65b0\u7684\u6570\u7ec4","title":"DFS Enhanced"},{"location":"Acwing/895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/#dp","text":"\u627e\u5b50\u7ed3\u6784\uff1a\u5047\u8bbe\u7ed3\u5c3e\u4e3aa[i]\u7684\u6700\u957f\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u662ff[i]\uff0c\u90a3\u4e48\u7ed3\u5c3e\u4e3aa[i+1]\u7684\u6700\u957f\u5b50\u6570\u7ec4\u7684\uff0c\u6700\u540e\u7b54\u6848\u662ff[end] \u65b9\u6cd5\u4e00 \uff1a \u4ece\u524d\u5f80\u540e\uff0c\u6bcf\u6b21\u66f4\u65b0\u65b0\u7684\u5143\u7d20\u7684\u957f\u5ea6 f[ 0 ] = 0 ; for ( int i = 0 ; i < n; ++ i) for ( int j = i + 1 ; j <= n; ++ j) // \u4ece\u5f53\u524d\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u5f80\u540e\u627e\uff0c\u66f4\u65b0\u65b0\u7684\u4f4d\u7f6e\u7684\u6700\u5927\u5b50\u6570\u7ec4\u957f\u5ea6 if (a[j] > a[i]) f[j] = max(f[j], f[i] + 1 ); \u65b9\u6cd5\u4e8c \uff1a \u4ece\u540e\u5f80\u524d\uff0c\u6bcf\u6b21\u66f4\u65b0\u5f53\u524d\u5143\u7d20\u7684\u957f\u5ea6 f[ 0 ] = 0 ; for ( int i = 1 ; i <= n; ++ i) for ( int j = 0 ; j < i; ++ j) // \u4ece\u5f53\u524d\u7684\u4e0a\u4e00\u4e2a\u5143\u7d20\u5f80\u524d\u627e\uff0c\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u5b50\u6570\u7ec4\u957f\u5ea6 if (a[i] > a[j]) f[i] = max(f[i], f[j] + 1 );","title":"DP"},{"location":"Acwing/905.-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/","text":"905 \u533a\u95f4\u9009\u70b9 \u00b6 \u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8bf7\u4f60\u5728\u6570\u8f74\u4e0a\u9009\u62e9\u5c3d\u91cf\u5c11\u7684\u70b9\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u533a\u95f4\u5185\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u9009\u51fa\u7684\u70b9\u3002 \u8f93\u51fa\u9009\u62e9\u7684\u70b9\u7684\u6700\u5c0f\u6570\u91cf\u3002 \u4f4d\u4e8e\u533a\u95f4\u7aef\u70b9\u4e0a\u7684\u70b9\u4e5f\u7b97\u4f5c\u533a\u95f4\u5185\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6240\u9700\u7684\u70b9\u7684\u6700\u5c0f\u6570\u91cf\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 3 -1 1 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2 \u5206\u6790 \u00b6 1. \u6309\u7167\u533a\u95f4\u53f3\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f 2. \u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff0c\u5982\u679c\u5f53\u524d\u533a\u95f4\u5df2\u7ecf\u5305\u542b\u70b9\uff0c\u5219\u76f4\u63a5pass\uff0c\u5426\u5219\u9009\u62e9\u533a\u95f4\u7684\u6700\u53f3\u4fa7\u7aef\u70b9\uff08\u6700\u5927\u53ef\u80fd\u8986\u76d6\u66f4\u591a\u7684\u533a\u95f4\uff09\u3002 \u8bc1\u660e \u00b6 \u8bc1\u660eA == B\u53ef\u4ee5\u901a\u8fc7A <= B and B <= A 1. \u8bbecnt\u662f\u6211\u4eec\u7684\u89e3\uff0cans\u662f\u7b54\u6848\u7684\u6700\u4f18\u89e3\uff0c\u4ece\u800c\u5f97\u51facnt >= ans 2. \u5bf9\u4e8e\u6ca1\u6709\u4efb\u4f55\u4ea4\u9519\u7684\u533a\u95f4\uff0c\u81f3\u5c11\u9700\u8981cnt\u4e2a\u70b9\uff0cans >= cnt 3. cnt == ans Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { scanf( \"%d %d\" , & num[i].first, & num[i].second); } sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.second < r.second; }); int cMax = -2e9 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (num[i].first > cMax) { cMax = num[i].second; res ++ ; } } cout << res; }","title":"905 \u533a\u95f4\u9009\u70b9"},{"location":"Acwing/905.-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/#905","text":"\u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8bf7\u4f60\u5728\u6570\u8f74\u4e0a\u9009\u62e9\u5c3d\u91cf\u5c11\u7684\u70b9\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u533a\u95f4\u5185\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u9009\u51fa\u7684\u70b9\u3002 \u8f93\u51fa\u9009\u62e9\u7684\u70b9\u7684\u6700\u5c0f\u6570\u91cf\u3002 \u4f4d\u4e8e\u533a\u95f4\u7aef\u70b9\u4e0a\u7684\u70b9\u4e5f\u7b97\u4f5c\u533a\u95f4\u5185\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6240\u9700\u7684\u70b9\u7684\u6700\u5c0f\u6570\u91cf\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 3 -1 1 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2","title":"905 \u533a\u95f4\u9009\u70b9"},{"location":"Acwing/905.-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/#_1","text":"1. \u6309\u7167\u533a\u95f4\u53f3\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f 2. \u4ece\u524d\u5f80\u540e\u4f9d\u6b21\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff0c\u5982\u679c\u5f53\u524d\u533a\u95f4\u5df2\u7ecf\u5305\u542b\u70b9\uff0c\u5219\u76f4\u63a5pass\uff0c\u5426\u5219\u9009\u62e9\u533a\u95f4\u7684\u6700\u53f3\u4fa7\u7aef\u70b9\uff08\u6700\u5927\u53ef\u80fd\u8986\u76d6\u66f4\u591a\u7684\u533a\u95f4\uff09\u3002","title":"\u5206\u6790"},{"location":"Acwing/905.-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/#_2","text":"\u8bc1\u660eA == B\u53ef\u4ee5\u901a\u8fc7A <= B and B <= A 1. \u8bbecnt\u662f\u6211\u4eec\u7684\u89e3\uff0cans\u662f\u7b54\u6848\u7684\u6700\u4f18\u89e3\uff0c\u4ece\u800c\u5f97\u51facnt >= ans 2. \u5bf9\u4e8e\u6ca1\u6709\u4efb\u4f55\u4ea4\u9519\u7684\u533a\u95f4\uff0c\u81f3\u5c11\u9700\u8981cnt\u4e2a\u70b9\uff0cans >= cnt 3. cnt == ans","title":"\u8bc1\u660e"},{"location":"Acwing/905.-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/#code","text":"#include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { scanf( \"%d %d\" , & num[i].first, & num[i].second); } sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.second < r.second; }); int cMax = -2e9 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (num[i].first > cMax) { cMax = num[i].second; res ++ ; } } cout << res; }","title":"Code"},{"location":"Acwing/906.-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84/","text":"906 \u533a\u95f4\u5206\u7ec4 \u00b6 \u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8bf7\u4f60\u5c06\u8fd9\u4e9b\u533a\u95f4\u5206\u6210\u82e5\u5e72\u7ec4\uff0c\u4f7f\u5f97\u6bcf\u7ec4\u5185\u90e8\u7684\u533a\u95f4\u4e24\u4e24\u4e4b\u95f4\uff08\u5305\u62ec\u7aef\u70b9\uff09\u6ca1\u6709\u4ea4\u96c6\uff0c\u5e76\u4f7f\u5f97\u7ec4\u6570\u5c3d\u53ef\u80fd\u5c0f\u3002 \u8f93\u51fa\u6700\u5c0f\u7ec4\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u7ec4\u6570\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 3 -1 1 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2 \u5206\u6790 \u00b6 1. \u6240\u6709\u533a\u95f4\u6309\u7167\u5de6\u7aef\u70b9\u6392\u5e8f 2. \u4ece\u524d\u5f80\u540e\u5904\u7406\u6bcf\u4e2a\u533a\u95f4 1. \u5224\u65ad\u80fd\u5426\u5c06\u5176\u653e\u5165\u73b0\u5728\u7684\u67d0\u4e2a\u7ec4\u4e2dL[i] > Max_r\uff08\u5224\u65ad\u4e0a\u4e00\u4e2a\u533a\u95f4\u7684\u6700\u53f3\u662f\u5426\u5305\u542b\u5f53\u524d\u70b9\u7684\u6700\u5de6\u7aef\u70b9\uff09 2. \u66f4\u65b0\u5f53\u524d\u7684\u533a\u95f4\u7684\u6700\u53f3 Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) scanf( \"%d %d\" , & num[i].first, & num[i].second); sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.first < r.first; }); priority_queue < int , vector < int > , greater < int >> pq; // min Heap for ( int i = 0 ; i < n; ++ i) { auto r = num[i]; // need a new section since all the intervals in front all have an intersection with current one if (pq.empty() || pq.top() >= r.first) pq.push(r.second); // remove the smallest section and add the new one's end else { int t = pq.top(); pq.pop(); pq.push(r.second); } } cout << pq.size(); }","title":"906 \u533a\u95f4\u5206\u7ec4"},{"location":"Acwing/906.-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84/#906","text":"\u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8bf7\u4f60\u5c06\u8fd9\u4e9b\u533a\u95f4\u5206\u6210\u82e5\u5e72\u7ec4\uff0c\u4f7f\u5f97\u6bcf\u7ec4\u5185\u90e8\u7684\u533a\u95f4\u4e24\u4e24\u4e4b\u95f4\uff08\u5305\u62ec\u7aef\u70b9\uff09\u6ca1\u6709\u4ea4\u96c6\uff0c\u5e76\u4f7f\u5f97\u7ec4\u6570\u5c3d\u53ef\u80fd\u5c0f\u3002 \u8f93\u51fa\u6700\u5c0f\u7ec4\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6700\u5c0f\u7ec4\u6570\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 3 -1 1 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2","title":"906 \u533a\u95f4\u5206\u7ec4"},{"location":"Acwing/906.-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84/#_1","text":"1. \u6240\u6709\u533a\u95f4\u6309\u7167\u5de6\u7aef\u70b9\u6392\u5e8f 2. \u4ece\u524d\u5f80\u540e\u5904\u7406\u6bcf\u4e2a\u533a\u95f4 1. \u5224\u65ad\u80fd\u5426\u5c06\u5176\u653e\u5165\u73b0\u5728\u7684\u67d0\u4e2a\u7ec4\u4e2dL[i] > Max_r\uff08\u5224\u65ad\u4e0a\u4e00\u4e2a\u533a\u95f4\u7684\u6700\u53f3\u662f\u5426\u5305\u542b\u5f53\u524d\u70b9\u7684\u6700\u5de6\u7aef\u70b9\uff09 2. \u66f4\u65b0\u5f53\u524d\u7684\u533a\u95f4\u7684\u6700\u53f3","title":"\u5206\u6790"},{"location":"Acwing/906.-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84/#code","text":"#include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) scanf( \"%d %d\" , & num[i].first, & num[i].second); sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.first < r.first; }); priority_queue < int , vector < int > , greater < int >> pq; // min Heap for ( int i = 0 ; i < n; ++ i) { auto r = num[i]; // need a new section since all the intervals in front all have an intersection with current one if (pq.empty() || pq.top() >= r.first) pq.push(r.second); // remove the smallest section and add the new one's end else { int t = pq.top(); pq.pop(); pq.push(r.second); } } cout << pq.size(); }","title":"Code"},{"location":"Acwing/907.-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/","text":"\u533a\u95f4\u8986\u76d6 \u00b6 \u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\u4ee5\u53ca\u4e00\u4e2a\u7ebf\u6bb5\u533a\u95f4[s,t]\uff0c\u8bf7\u4f60\u9009\u62e9\u5c3d\u91cf\u5c11\u7684\u533a\u95f4\uff0c\u5c06\u6307\u5b9a\u7ebf\u6bb5\u533a\u95f4\u5b8c\u5168\u8986\u76d6\u3002 \u8f93\u51fa\u6700\u5c11\u533a\u95f4\u6570\uff0c\u5982\u679c\u65e0\u6cd5\u5b8c\u5168\u8986\u76d6\u5219\u8f93\u51fa-1\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570s\u548ct\uff0c\u8868\u793a\u7ed9\u5b9a\u7ebf\u6bb5\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u7b2c\u4e8c\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u7ed9\u5b9a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6240\u9700\u6700\u5c11\u533a\u95f4\u6570\u3002 \u5982\u679c\u65e0\u89e3\uff0c\u5219\u8f93\u51fa-1\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109, \u2212109\u2264s\u2264t\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 1 5 3 -1 3 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2 \u5206\u6790 \u00b6 \u6240\u6709\u533a\u95f4\u6309\u7167\u5de6\u7aef\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09 \u4ece\u524d\u5f80\u540e\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff0c\u9009\u62e9\u53f3\u7aef\u70b9\u6700\u5927\u7684\u533a\u95f4\uff0c\u5c06\u53f3\u7aef\u70b9\u8bb0\u505a start \uff0c\u4e0b\u4e00\u6b21\u67e5\u8be2\u7684\u65f6\u5019\u6bd4\u8f83 start Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n, s, t; cin >> s >> t; cin >> n; for ( int i = 0 ; i < n; ++ i) scanf( \"%d %d\" , & num[i].first, & num[i].second); sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.first < r.first; }); int res = 0 ; bool success = false ; for ( int i = 0 ; i < n; ++ i) { int j = i, r = -2e9 ; // find the largest right from all the interval that left is less than start while (j < n && num[j].first <= s) { r = max(r, num[j].second); j ++ ; } // if still less than s, meaning not possible if (r < s) { res = -1 ; break ; } res ++ ; // if current right already fullfilled the requirement if (r >= t) { success = true ; break ; } // update start to current furthest right s = r; i = j - 1 ; } if ( ! success) cout << -1 ; else cout << res; }","title":"\u533a\u95f4\u8986\u76d6"},{"location":"Acwing/907.-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/#_1","text":"\u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\u4ee5\u53ca\u4e00\u4e2a\u7ebf\u6bb5\u533a\u95f4[s,t]\uff0c\u8bf7\u4f60\u9009\u62e9\u5c3d\u91cf\u5c11\u7684\u533a\u95f4\uff0c\u5c06\u6307\u5b9a\u7ebf\u6bb5\u533a\u95f4\u5b8c\u5168\u8986\u76d6\u3002 \u8f93\u51fa\u6700\u5c11\u533a\u95f4\u6570\uff0c\u5982\u679c\u65e0\u6cd5\u5b8c\u5168\u8986\u76d6\u5219\u8f93\u51fa-1\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570s\u548ct\uff0c\u8868\u793a\u7ed9\u5b9a\u7ebf\u6bb5\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u7b2c\u4e8c\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u7ed9\u5b9a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u6240\u9700\u6700\u5c11\u533a\u95f4\u6570\u3002 \u5982\u679c\u65e0\u89e3\uff0c\u5219\u8f93\u51fa-1\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109, \u2212109\u2264s\u2264t\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 1 5 3 -1 3 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2","title":"\u533a\u95f4\u8986\u76d6"},{"location":"Acwing/907.-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/#_2","text":"\u6240\u6709\u533a\u95f4\u6309\u7167\u5de6\u7aef\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09 \u4ece\u524d\u5f80\u540e\u679a\u4e3e\u6bcf\u4e2a\u533a\u95f4\uff0c\u9009\u62e9\u53f3\u7aef\u70b9\u6700\u5927\u7684\u533a\u95f4\uff0c\u5c06\u53f3\u7aef\u70b9\u8bb0\u505a start \uff0c\u4e0b\u4e00\u6b21\u67e5\u8be2\u7684\u65f6\u5019\u6bd4\u8f83 start","title":"\u5206\u6790"},{"location":"Acwing/907.-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/#code","text":"#include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n, s, t; cin >> s >> t; cin >> n; for ( int i = 0 ; i < n; ++ i) scanf( \"%d %d\" , & num[i].first, & num[i].second); sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.first < r.first; }); int res = 0 ; bool success = false ; for ( int i = 0 ; i < n; ++ i) { int j = i, r = -2e9 ; // find the largest right from all the interval that left is less than start while (j < n && num[j].first <= s) { r = max(r, num[j].second); j ++ ; } // if still less than s, meaning not possible if (r < s) { res = -1 ; break ; } res ++ ; // if current right already fullfilled the requirement if (r >= t) { success = true ; break ; } // update start to current furthest right s = r; i = j - 1 ; } if ( ! success) cout << -1 ; else cout << res; }","title":"Code"},{"location":"Acwing/908.-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F/","text":"\u6700\u5927\u4e0d\u76f8\u4ea4\u533a\u95f4\u6570\u91cf \u00b6 \u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8bf7\u4f60\u5728\u6570\u8f74\u4e0a\u9009\u62e9\u82e5\u5e72\u533a\u95f4\uff0c\u4f7f\u5f97\u9009\u4e2d\u7684\u533a\u95f4\u4e4b\u95f4\u4e92\u4e0d\u76f8\u4ea4\uff08\u5305\u62ec\u7aef\u70b9\uff09\u3002 \u8f93\u51fa\u53ef\u9009\u53d6\u533a\u95f4\u7684\u6700\u5927\u6570\u91cf\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u53ef\u9009\u53d6\u533a\u95f4\u7684\u6700\u5927\u6570\u91cf\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 3 -1 1 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2 \u5206\u6790 \u00b6 \u6309\u7167\u533a\u95f4\u7684\u540e\u7aef\u70b9\u6392\u5e8f \u6309\u7167\u53f3\u7aef\u70b9\u627e\u4ea4\u96c6\uff0c\u5982\u679c\u6709\u4ea4\u96c6pass \u9009\u4e2d\u7684\u533a\u95f4\u4e2a\u6570\u5373\u7b54\u6848 Code (\u540c905) \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { scanf( \"%d %d\" , & num[i].first, & num[i].second); } sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.second < r.second; }); int cMax = -2e9 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (num[i].first > cMax) { cMax = num[i].second; res ++ ; } } cout << res; }","title":"\u6700\u5927\u4e0d\u76f8\u4ea4\u533a\u95f4\u6570\u91cf"},{"location":"Acwing/908.-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F/#_1","text":"\u7ed9\u5b9aN\u4e2a\u95ed\u533a\u95f4[ai,bi]\uff0c\u8bf7\u4f60\u5728\u6570\u8f74\u4e0a\u9009\u62e9\u82e5\u5e72\u533a\u95f4\uff0c\u4f7f\u5f97\u9009\u4e2d\u7684\u533a\u95f4\u4e4b\u95f4\u4e92\u4e0d\u76f8\u4ea4\uff08\u5305\u62ec\u7aef\u70b9\uff09\u3002 \u8f93\u51fa\u53ef\u9009\u53d6\u533a\u95f4\u7684\u6700\u5927\u6570\u91cf\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570N\uff0c\u8868\u793a\u533a\u95f4\u6570\u3002 \u63a5\u4e0b\u6765N\u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570ai,bi\uff0c\u8868\u793a\u4e00\u4e2a\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u53ef\u9009\u53d6\u533a\u95f4\u7684\u6700\u5927\u6570\u91cf\u3002 \u6570\u636e\u8303\u56f4 1\u2264N\u2264105, \u2212109\u2264ai\u2264bi\u2264109 \u8f93\u5165\u6837\u4f8b\uff1a 3 -1 1 2 4 3 5 \u8f93\u51fa\u6837\u4f8b\uff1a 2","title":"\u6700\u5927\u4e0d\u76f8\u4ea4\u533a\u95f4\u6570\u91cf"},{"location":"Acwing/908.-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F/#_2","text":"\u6309\u7167\u533a\u95f4\u7684\u540e\u7aef\u70b9\u6392\u5e8f \u6309\u7167\u53f3\u7aef\u70b9\u627e\u4ea4\u96c6\uff0c\u5982\u679c\u6709\u4ea4\u96c6pass \u9009\u4e2d\u7684\u533a\u95f4\u4e2a\u6570\u5373\u7b54\u6848","title":"\u5206\u6790"},{"location":"Acwing/908.-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F/#code-905","text":"#include <bits/stdc++.h> using namespace std; const int N = 1e5 + 10 ; pair < int , int > num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { scanf( \"%d %d\" , & num[i].first, & num[i].second); } sort(num, num + n, [](pair < int , int >& l, pair < int , int >& r) { return l.second < r.second; }); int cMax = -2e9 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (num[i].first > cMax) { cMax = num[i].second; res ++ ; } } cout << res; }","title":"Code (\u540c905)"},{"location":"Acwing/lca%E6%9C%80%E5%B0%8F%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","text":"\u7956\u5b59\u8be2\u95ee \u00b6 https://www.acwing.com/problem/content/1174/ \u9488\u5bf9\u591a\u4e2a\u8be2\u95ee\uff0c\u4f46\u662f\u975e\u52a8\u6001\u751f\u6210\u6811\u7684\u505a\u6cd5 \u4ee3\u7801 \u00b6 #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 40010 , M = N * 2 ; int n, m; int h[N], e[M], ne[M], idx; int depth[N], fa[N][ 16 ]; int q[N]; void add ( int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // \u5efa\u6811\u548c\u5411\u4e0a\u9012\u589e\u5e8f\u5217 void bfs ( int root) { memset(depth, 0x3f , sizeof depth); depth[ 0 ] = 0 , depth[root] = 1 ; int hh = 0 , tt = 0 ; q[ 0 ] = root; while (hh <= tt) { // queue.top() queue.pop() int t = q[hh ++ ]; for ( int i = h[t]; ~ i; i = ne[i]) { int j = e[i]; if (depth[j] > depth[t] + 1 ) { depth[j] = depth[t] + 1 ; q[ ++ tt] = j; fa[j][ 0 ] = t; for ( int k = 1 ; k <= 15 ; k ++ ) fa[j][k] = fa[fa[j][k - 1 ]][k - 1 ]; } } } } int lca ( int a, int b) { if (depth[a] < depth[b]) swap(a, b); // \u8df3\u5230\u540c\u5c42 for ( int k = 15 ; k >= 0 ; k -- ) if (depth[fa[a][k]] >= depth[b]) a = fa[a][k]; if (a == b) return a; // \u7ee7\u7eed\u4e0a\u8df3\u77e5\u9053\u76f8\u9047 for ( int k = 15 ; k >= 0 ; k -- ) if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } return fa[a][ 0 ]; } int main () { scanf( \"%d\" , & n); int root = 0 ; memset(h, -1 , sizeof h); for ( int i = 0 ; i < n; i ++ ) { int a, b; scanf( \"%d%d\" , & a, & b); if (b == -1 ) root = a; else add(a, b), add(b, a); } bfs(root); scanf( \"%d\" , & m); while (m -- ) { int a, b; scanf( \"%d%d\" , & a, & b); int p = lca(a, b); if (p == a) puts( \"1\" ); else if (p == b) puts( \"2\" ); else puts( \"0\" ); } return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/154772/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Lca\u6700\u5c0f\u516c\u5171\u7956\u5148"},{"location":"Acwing/lca%E6%9C%80%E5%B0%8F%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#_1","text":"https://www.acwing.com/problem/content/1174/ \u9488\u5bf9\u591a\u4e2a\u8be2\u95ee\uff0c\u4f46\u662f\u975e\u52a8\u6001\u751f\u6210\u6811\u7684\u505a\u6cd5","title":"\u7956\u5b59\u8be2\u95ee"},{"location":"Acwing/lca%E6%9C%80%E5%B0%8F%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#_2","text":"#include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 40010 , M = N * 2 ; int n, m; int h[N], e[M], ne[M], idx; int depth[N], fa[N][ 16 ]; int q[N]; void add ( int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // \u5efa\u6811\u548c\u5411\u4e0a\u9012\u589e\u5e8f\u5217 void bfs ( int root) { memset(depth, 0x3f , sizeof depth); depth[ 0 ] = 0 , depth[root] = 1 ; int hh = 0 , tt = 0 ; q[ 0 ] = root; while (hh <= tt) { // queue.top() queue.pop() int t = q[hh ++ ]; for ( int i = h[t]; ~ i; i = ne[i]) { int j = e[i]; if (depth[j] > depth[t] + 1 ) { depth[j] = depth[t] + 1 ; q[ ++ tt] = j; fa[j][ 0 ] = t; for ( int k = 1 ; k <= 15 ; k ++ ) fa[j][k] = fa[fa[j][k - 1 ]][k - 1 ]; } } } } int lca ( int a, int b) { if (depth[a] < depth[b]) swap(a, b); // \u8df3\u5230\u540c\u5c42 for ( int k = 15 ; k >= 0 ; k -- ) if (depth[fa[a][k]] >= depth[b]) a = fa[a][k]; if (a == b) return a; // \u7ee7\u7eed\u4e0a\u8df3\u77e5\u9053\u76f8\u9047 for ( int k = 15 ; k >= 0 ; k -- ) if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } return fa[a][ 0 ]; } int main () { scanf( \"%d\" , & n); int root = 0 ; memset(h, -1 , sizeof h); for ( int i = 0 ; i < n; i ++ ) { int a, b; scanf( \"%d%d\" , & a, & b); if (b == -1 ) root = a; else add(a, b), add(b, a); } bfs(root); scanf( \"%d\" , & m); while (m -- ) { int a, b; scanf( \"%d%d\" , & a, & b); int p = lca(a, b); if (p == a) puts( \"1\" ); else if (p == b) puts( \"2\" ); else puts( \"0\" ); } return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/154772/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u4ee3\u7801"},{"location":"Acwing/topological-sort/","text":"Topological Sort \u00b6 Definition \u00b6 DAG No cycle: if no cycle -> has to have a Topological Sort order. in degree and out degree \u00b6 Proof on DAG w/o cycle has to have a node with in degree of 0 \u00b6 Prove by contradiction assume there is a DAG w/o cycle where all the nodes' in degree is greater than 0. because each node has an in-node, we can follow the in node to expand backward, until we reach n nodes. However, for nth node, it also has a in node, which expand to n+1 th node. However, we only have n nodes, so that there is at least one nodes mentioned are the same. If two nodes are the same, then it has a cycle (if a path has two same nodes, then it's cycle for sure). 848. \u6709\u5411\u56fe\u7684\u62d3\u6251\u5e8f\u5217 \u00b6 https://www.acwing.com/problem/content/850/ #include <bits/stdc++.h> using namespace std; int main () { int n, m; cin >> n >> m; int degree[n + 1 ]; vector < int > graph[n + 1 ]; vector < int > order; memset(degree, 0 , sizeof degree); int x, y; queue < int > q; for ( int i = 0 ; i < m; ++ i) { cin >> x >> y; graph[x].push_back(y); degree[y] ++ ; } for ( int i = 1 ; i <= n; ++ i) if (degree[i] == 0 ) q.push(i); while ( ! q.empty()) { int t = q.front(); order.push_back(t); q.pop(); for ( int i = 0 ; i < graph[t].size(); ++ i) { if ( -- degree[graph[t][i]] == 0 ) q.push(graph[t][i]); } } if (order.size() == n) { for ( int i : order) cout << i << \" \" ; } else { cout << -1 ; } }","title":"Topological Sort"},{"location":"Acwing/topological-sort/#topological-sort","text":"","title":"Topological Sort"},{"location":"Acwing/topological-sort/#definition","text":"DAG No cycle: if no cycle -> has to have a Topological Sort order.","title":"Definition"},{"location":"Acwing/topological-sort/#in-degree-and-out-degree","text":"","title":"in degree and out degree"},{"location":"Acwing/topological-sort/#proof-on-dag-wo-cycle-has-to-have-a-node-with-in-degree-of-0","text":"Prove by contradiction assume there is a DAG w/o cycle where all the nodes' in degree is greater than 0. because each node has an in-node, we can follow the in node to expand backward, until we reach n nodes. However, for nth node, it also has a in node, which expand to n+1 th node. However, we only have n nodes, so that there is at least one nodes mentioned are the same. If two nodes are the same, then it has a cycle (if a path has two same nodes, then it's cycle for sure).","title":"Proof on DAG w/o cycle has to have a node with in degree of 0"},{"location":"Acwing/topological-sort/#848","text":"https://www.acwing.com/problem/content/850/ #include <bits/stdc++.h> using namespace std; int main () { int n, m; cin >> n >> m; int degree[n + 1 ]; vector < int > graph[n + 1 ]; vector < int > order; memset(degree, 0 , sizeof degree); int x, y; queue < int > q; for ( int i = 0 ; i < m; ++ i) { cin >> x >> y; graph[x].push_back(y); degree[y] ++ ; } for ( int i = 1 ; i <= n; ++ i) if (degree[i] == 0 ) q.push(i); while ( ! q.empty()) { int t = q.front(); order.push_back(t); q.pop(); for ( int i = 0 ; i < graph[t].size(); ++ i) { if ( -- degree[graph[t][i]] == 0 ) q.push(graph[t][i]); } } if (order.size() == n) { for ( int i : order) cout << i << \" \" ; } else { cout << -1 ; } }","title":"848. \u6709\u5411\u56fe\u7684\u62d3\u6251\u5e8f\u5217"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/","text":"Count # of 1 in binary \u00b6 https://www.acwing.com/problem/content/803/ Code \u00b6 #include <iostream> using namespace std; inline int lowbit( int x) { return x & - x; } int main() { int n; cin >> n; while (n -- ) { int x, res = 0 ; cin >> x; while (x) { x -= lowbit(x); res ++ ; } cout << res << ' ' ; } } a - b \u00b6 https://www.acwing.com/problem/content/794/ Code \u00b6 #include <iostream> #include <vector> using namespace std; bool cmp (vector < int > & A, vector < int > & B) { if (A.size() != B.size()) return A.size() > B.size(); // \u5927\u5c0f\u4e0d\u4e00\u81f4\uff0c\u957f\u7684\u5927 for ( int i = A.size() - 1 ; i >= 0 ; i -- ) if (A[i] != B[i]) // \u5de6\u6570\u7b2c\u4e00\u4e2a\u4e0d\u4e00\u6837\u7684\u5927\u5c0f\u51b3\u5b9a\u6570\u5b57\u5927\u5c0f return A[i] > B[i]; return true ; } vector < int > sub(vector < int > & A, vector < int > & B) { vector < int > C; for ( int i = 0 , t = 0 ; i < A.size(); i ++ ) { t = A[i] - t; // \u5f53\u524d\u6570\u51cf\u53bb\u501f\u4f4d\u7684\u6570 if (i < B.size()) t -= B[i]; // \u5982\u679cB\u6570\u7ec4\u6bd4A\u6570\u7ec4\u77ed\uff0c\u90a3\u4e48\u5269\u4f59\u503c\u51cf\u53bbB\u5f53\u524d\u4f4d C.push_back((t + 10 ) % 10 ); // \u5982\u679ct < 0\uff0c\u53d6t + 10\u7684\u503c\uff080-6 = -4\uff09\uff0c\u540c\u65f6\u501f\u4f4d\uff0c\u5982\u679ct >= 0\uff0c\u53d6%10\uff0c\uff085-3=2=2+10%10=2\uff09 if (t < 0 ) t = 1 ; // \u501f\u4f4d else t = 0 ; // \u4e0d\u5fc5\u501f\u4f4d } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a, b; vector < int > A, B; cin >> a >> b; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); for ( int i = b.size() - 1 ; i >= 0 ; i -- ) B.push_back(b[i] - '0' ); vector < int > C; if (cmp(A, B)) C = sub(A, B); else C = sub(B, A), cout << '-' ; for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/39793/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 a * b \u00b6 https://www.acwing.com/activity/content/code/content/39794/ Code \u00b6 #include <iostream> #include <vector> using namespace std; vector < int > mul(vector < int > & A, int b) { vector < int > C; int t = 0 ; for ( int i = 0 ; i < A.size() || t; i ++ ) { if (i < A.size()) t += A[i] * b; C.push_back(t % 10 ); t /= 10 ; } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); // \u53bb\u9664leading zeros return C; } int main() { string a; int b; cin >> a >> b; vector < int > A; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); auto C = mul(A, b); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) printf( \"%d\" , C[i]); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/39794/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 a / b \u00b6 https://www.acwing.com/activity/content/code/content/39795/ Code \u00b6 #include <iostream> #include <vector> #include <algorithm> using namespace std; vector < int > div(vector < int > & A, int b, int & r) { vector < int > C; r = 0 ; // reminder for ( int i = A.size() - 1 ; i >= 0 ; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a; vector < int > A; int B; cin >> a >> B; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); int r; auto C = div(A, B, r); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl << r << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/39795/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u7b97\u6cd5\u57fa\u7840\u8bfe"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#count-of-1-in-binary","text":"https://www.acwing.com/problem/content/803/","title":"Count # of 1 in binary"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code","text":"#include <iostream> using namespace std; inline int lowbit( int x) { return x & - x; } int main() { int n; cin >> n; while (n -- ) { int x, res = 0 ; cin >> x; while (x) { x -= lowbit(x); res ++ ; } cout << res << ' ' ; } }","title":"Code"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#a-b","text":"https://www.acwing.com/problem/content/794/","title":"a - b"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code_1","text":"#include <iostream> #include <vector> using namespace std; bool cmp (vector < int > & A, vector < int > & B) { if (A.size() != B.size()) return A.size() > B.size(); // \u5927\u5c0f\u4e0d\u4e00\u81f4\uff0c\u957f\u7684\u5927 for ( int i = A.size() - 1 ; i >= 0 ; i -- ) if (A[i] != B[i]) // \u5de6\u6570\u7b2c\u4e00\u4e2a\u4e0d\u4e00\u6837\u7684\u5927\u5c0f\u51b3\u5b9a\u6570\u5b57\u5927\u5c0f return A[i] > B[i]; return true ; } vector < int > sub(vector < int > & A, vector < int > & B) { vector < int > C; for ( int i = 0 , t = 0 ; i < A.size(); i ++ ) { t = A[i] - t; // \u5f53\u524d\u6570\u51cf\u53bb\u501f\u4f4d\u7684\u6570 if (i < B.size()) t -= B[i]; // \u5982\u679cB\u6570\u7ec4\u6bd4A\u6570\u7ec4\u77ed\uff0c\u90a3\u4e48\u5269\u4f59\u503c\u51cf\u53bbB\u5f53\u524d\u4f4d C.push_back((t + 10 ) % 10 ); // \u5982\u679ct < 0\uff0c\u53d6t + 10\u7684\u503c\uff080-6 = -4\uff09\uff0c\u540c\u65f6\u501f\u4f4d\uff0c\u5982\u679ct >= 0\uff0c\u53d6%10\uff0c\uff085-3=2=2+10%10=2\uff09 if (t < 0 ) t = 1 ; // \u501f\u4f4d else t = 0 ; // \u4e0d\u5fc5\u501f\u4f4d } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a, b; vector < int > A, B; cin >> a >> b; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); for ( int i = b.size() - 1 ; i >= 0 ; i -- ) B.push_back(b[i] - '0' ); vector < int > C; if (cmp(A, B)) C = sub(A, B); else C = sub(B, A), cout << '-' ; for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/39793/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#a-b_1","text":"https://www.acwing.com/activity/content/code/content/39794/","title":"a * b"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code_2","text":"#include <iostream> #include <vector> using namespace std; vector < int > mul(vector < int > & A, int b) { vector < int > C; int t = 0 ; for ( int i = 0 ; i < A.size() || t; i ++ ) { if (i < A.size()) t += A[i] * b; C.push_back(t % 10 ); t /= 10 ; } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); // \u53bb\u9664leading zeros return C; } int main() { string a; int b; cin >> a >> b; vector < int > A; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); auto C = mul(A, b); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) printf( \"%d\" , C[i]); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/39794/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#a-b_2","text":"https://www.acwing.com/activity/content/code/content/39795/","title":"a / b"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code_3","text":"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector < int > div(vector < int > & A, int b, int & r) { vector < int > C; r = 0 ; // reminder for ( int i = A.size() - 1 ; i >= 0 ; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a; vector < int > A; int B; cin >> a >> B; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); int r; auto C = div(A, B, r); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl << r << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/activity/content/code/content/39795/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/","text":"Book notes for Design Data Intensive Apps \u00b6 Foundations of Data Systems \u00b6 Reliable, Scalable, and Maintainable Applications \u00b6 Reliability : The system should continue to work correctly even in the face of adversity. Scalability : As the system grows (data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth. Maintainability : Over time, many different people will work on the system (engineering and operations, both maintain the current behavior and adapting the system to new use cases), and they should all be able to work on it productively . Reliability \u00b6 In reality, it's not feasible to tolerate all the possible kind of faults. Therefore, it is usually best to design fault-tolerance mechanisms that prevent faults from causing failures. Hardware Fault: hard disks crash (prevent: setup RAID config), RAM becomes faulty, power grid has a blackout, etc. Hardware faults usually as being random and independent (one would not cause the other). Software Errors: usually correlate with each other (tend to cause many more system failures than uncorrelated hardware faults). Human Errors Scalability \u00b6 Describe the system's ability to cope with increased load. Use load parameters to describe load. Example: Twitter Post tweet: 4.6k requests/sec on average and 12k requests/sec at peak Home timeline; 300k requests/sec So Twitter needs to handle the \"fan-out\" rate (# of requests to other services that we need to make in order to serve one incoming request). Approach 1: For post request, it's simply \"join\" two tables: select tweets. * , users. * from tweets join users on tweets.sender_id = users.id join follows on follows.followee_id = users.id where follows.follower_id = current_user Approach 2: For checking home timeline , we can maintain a cache. When a user makes a new post, look up all the people who follow that user, and insert the new tweet into each of their home timeline caches. The request to read the home timeline is then cheap, because its result has been computed ahead of time. Because the rate of post is much smaller than check home timeline , so it's more sensible to use approach 2. In reality, Twitter uses the combination of the above two methods: for celebrity they use approach 1, since each celebrity has a lot of followers and the cost for writing all the pieces to caches is numerous. Describe Performace \u00b6 Averge response time is not a good metric if you want to know your \"typical\" response time, because it doesn't tell you how many users actually experienced that delay. Usually it's better to use percentiles : sort the response by time in ascending time, and the median is the halfway point or called 50 th percentile . High percentiles of response time directly affect users' experience of the service. Amazon describes response time requirements for internal services in terms of the 99.9 th percentile, even though it only affects 1 in 1,000 requests.","title":"Book notes for `Design Data Intensive Apps`"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/#book-notes-for-design-data-intensive-apps","text":"","title":"Book notes for Design Data Intensive Apps"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/#foundations-of-data-systems","text":"","title":"Foundations of Data Systems"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/#reliable-scalable-and-maintainable-applications","text":"Reliability : The system should continue to work correctly even in the face of adversity. Scalability : As the system grows (data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth. Maintainability : Over time, many different people will work on the system (engineering and operations, both maintain the current behavior and adapting the system to new use cases), and they should all be able to work on it productively .","title":"Reliable, Scalable, and Maintainable Applications"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/#reliability","text":"In reality, it's not feasible to tolerate all the possible kind of faults. Therefore, it is usually best to design fault-tolerance mechanisms that prevent faults from causing failures. Hardware Fault: hard disks crash (prevent: setup RAID config), RAM becomes faulty, power grid has a blackout, etc. Hardware faults usually as being random and independent (one would not cause the other). Software Errors: usually correlate with each other (tend to cause many more system failures than uncorrelated hardware faults). Human Errors","title":"Reliability"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/#scalability","text":"Describe the system's ability to cope with increased load. Use load parameters to describe load. Example: Twitter Post tweet: 4.6k requests/sec on average and 12k requests/sec at peak Home timeline; 300k requests/sec So Twitter needs to handle the \"fan-out\" rate (# of requests to other services that we need to make in order to serve one incoming request). Approach 1: For post request, it's simply \"join\" two tables: select tweets. * , users. * from tweets join users on tweets.sender_id = users.id join follows on follows.followee_id = users.id where follows.follower_id = current_user Approach 2: For checking home timeline , we can maintain a cache. When a user makes a new post, look up all the people who follow that user, and insert the new tweet into each of their home timeline caches. The request to read the home timeline is then cheap, because its result has been computed ahead of time. Because the rate of post is much smaller than check home timeline , so it's more sensible to use approach 2. In reality, Twitter uses the combination of the above two methods: for celebrity they use approach 1, since each celebrity has a lot of followers and the cost for writing all the pieces to caches is numerous.","title":"Scalability"},{"location":"Books/Design-Data-Intensive-Apps-Part-1/#describe-performace","text":"Averge response time is not a good metric if you want to know your \"typical\" response time, because it doesn't tell you how many users actually experienced that delay. Usually it's better to use percentiles : sort the response by time in ascending time, and the median is the halfway point or called 50 th percentile . High percentiles of response time directly affect users' experience of the service. Amazon describes response time requirements for internal services in terms of the 99.9 th percentile, even though it only affects 1 in 1,000 requests.","title":"Describe Performace"},{"location":"Books/binomial-coefficient/","text":"Binomial Coefficient \u00b6 Definition \u00b6 The combinations of the five objects {a,b,c,d,e} taken three at a time are: abc, abd, abe, acd, ace, ade, bcd, bce, bde, cde Therefore, the number of combinations, which we denote by {n \\choose k} {n \\choose k} , is {n \\choose k} = \\frac{n(n - 1)...(n - k + 1)}{k(k - 1)...(1)} = \\frac{n!}{k!(n-k)!} {n \\choose k} = \\frac{n(n - 1)...(n - k + 1)}{k(k - 1)...(1)} = \\frac{n!}{k!(n-k)!} In particular, we have: {r \\choose 0} = 1 {r \\choose 0} = 1 , {r \\choose 1} = r {r \\choose 1} = r , {r \\choose 2} = \\frac{r(r - 1)}{2} {r \\choose 2} = \\frac{r(r - 1)}{2} Basic Techniques \u00b6 {n \\choose k} = {n \\choose n - k}, n \\geq 0 \\tag{1} {n \\choose k} = {n \\choose n - k}, n \\geq 0 \\tag{1} {r \\choose k} = \\frac{r}{k}{r - 1 \\choose k - 1}, k \\neq 0 \\tag{2} {r \\choose k} = \\frac{r}{k}{r - 1 \\choose k - 1}, k \\neq 0 \\tag{2} {r \\choose k} = {r - 1 \\choose k} + {r - 1 \\choose k - 1} \\tag{3} {r \\choose k} = {r - 1 \\choose k} + {r - 1 \\choose k - 1} \\tag{3} \\sum_{k = 0}^n {k \\choose m} = {0 \\choose m} + {1 \\choose m} + ... + {n \\choose m} = {n + 1 \\choose m + 1}, m \\geq 0, n \\geq 0 \\tag{4} \\sum_{k = 0}^n {k \\choose m} = {0 \\choose m} + {1 \\choose m} + ... + {n \\choose m} = {n + 1 \\choose m + 1}, m \\geq 0, n \\geq 0 \\tag{4} Summation Formulas \u00b6 Given equation (4), by letting m = 1, we can derive: {0 \\choose 1} + {1 \\choose 1} ... + {n \\choose 1} = 0 + 1 + ... + n = {n + 1 \\choose 2} = \\frac{(n + 1)n}{2} \\tag{5} {0 \\choose 1} + {1 \\choose 1} ... + {n \\choose 1} = 0 + 1 + ... + n = {n + 1 \\choose 2} = \\frac{(n + 1)n}{2} \\tag{5} Rearrange: 2{n + 1 \\choose 2} = n^2 + n \\implies n^2 = 2{n + 1 \\choose 2} - n = 2{n \\choose 2} + {n \\choose 1} \\tag{6} 2{n + 1 \\choose 2} = n^2 + n \\implies n^2 = 2{n + 1 \\choose 2} - n = 2{n \\choose 2} + {n \\choose 1} \\tag{6} Applying equation (6) to: \\sum_{k = 0}^{n} k^2 = \\sum_{k = 0}{n} (2{k \\choose 2} + {k \\choose 1}) = 2{n + 1 \\choose 3} + {n + 1 \\choose 2} \\tag{7} \\sum_{k = 0}^{n} k^2 = \\sum_{k = 0}{n} (2{k \\choose 2} + {k \\choose 1}) = 2{n + 1 \\choose 3} + {n + 1 \\choose 2} \\tag{7} By expanding equation (7): 1^2 + 2^2 + ... + n^2 = 2\\frac{(n + 1)n(n - 1)}{6} + \\frac{(n + 1)n}{2} = \\frac{1}{3}n(n + \\frac{1}{2})(n + 1) \\tag{8} 1^2 + 2^2 + ... + n^2 = 2\\frac{(n + 1)n(n - 1)}{6} + \\frac{(n + 1)n}{2} = \\frac{1}{3}n(n + \\frac{1}{2})(n + 1) \\tag{8} Sum of Products \u00b6 One important equation: \\sum_k{r \\choose k}{s \\choose n - k} = {r + s \\choose n} \\tag{9} \\sum_k{r \\choose k}{s \\choose n - k} = {r + s \\choose n} \\tag{9} Which can be interpret the right-hand side as the number of ways to select n people from among r men and s women; each term on the left is the number of ways to choose k of the men and n - k of women.","title":"Binomial Coefficient"},{"location":"Books/binomial-coefficient/#binomial-coefficient","text":"","title":"Binomial Coefficient"},{"location":"Books/binomial-coefficient/#definition","text":"The combinations of the five objects {a,b,c,d,e} taken three at a time are: abc, abd, abe, acd, ace, ade, bcd, bce, bde, cde Therefore, the number of combinations, which we denote by {n \\choose k} {n \\choose k} , is {n \\choose k} = \\frac{n(n - 1)...(n - k + 1)}{k(k - 1)...(1)} = \\frac{n!}{k!(n-k)!} {n \\choose k} = \\frac{n(n - 1)...(n - k + 1)}{k(k - 1)...(1)} = \\frac{n!}{k!(n-k)!} In particular, we have: {r \\choose 0} = 1 {r \\choose 0} = 1 , {r \\choose 1} = r {r \\choose 1} = r , {r \\choose 2} = \\frac{r(r - 1)}{2} {r \\choose 2} = \\frac{r(r - 1)}{2}","title":"Definition"},{"location":"Books/binomial-coefficient/#basic-techniques","text":"{n \\choose k} = {n \\choose n - k}, n \\geq 0 \\tag{1} {n \\choose k} = {n \\choose n - k}, n \\geq 0 \\tag{1} {r \\choose k} = \\frac{r}{k}{r - 1 \\choose k - 1}, k \\neq 0 \\tag{2} {r \\choose k} = \\frac{r}{k}{r - 1 \\choose k - 1}, k \\neq 0 \\tag{2} {r \\choose k} = {r - 1 \\choose k} + {r - 1 \\choose k - 1} \\tag{3} {r \\choose k} = {r - 1 \\choose k} + {r - 1 \\choose k - 1} \\tag{3} \\sum_{k = 0}^n {k \\choose m} = {0 \\choose m} + {1 \\choose m} + ... + {n \\choose m} = {n + 1 \\choose m + 1}, m \\geq 0, n \\geq 0 \\tag{4} \\sum_{k = 0}^n {k \\choose m} = {0 \\choose m} + {1 \\choose m} + ... + {n \\choose m} = {n + 1 \\choose m + 1}, m \\geq 0, n \\geq 0 \\tag{4}","title":"Basic Techniques"},{"location":"Books/binomial-coefficient/#summation-formulas","text":"Given equation (4), by letting m = 1, we can derive: {0 \\choose 1} + {1 \\choose 1} ... + {n \\choose 1} = 0 + 1 + ... + n = {n + 1 \\choose 2} = \\frac{(n + 1)n}{2} \\tag{5} {0 \\choose 1} + {1 \\choose 1} ... + {n \\choose 1} = 0 + 1 + ... + n = {n + 1 \\choose 2} = \\frac{(n + 1)n}{2} \\tag{5} Rearrange: 2{n + 1 \\choose 2} = n^2 + n \\implies n^2 = 2{n + 1 \\choose 2} - n = 2{n \\choose 2} + {n \\choose 1} \\tag{6} 2{n + 1 \\choose 2} = n^2 + n \\implies n^2 = 2{n + 1 \\choose 2} - n = 2{n \\choose 2} + {n \\choose 1} \\tag{6} Applying equation (6) to: \\sum_{k = 0}^{n} k^2 = \\sum_{k = 0}{n} (2{k \\choose 2} + {k \\choose 1}) = 2{n + 1 \\choose 3} + {n + 1 \\choose 2} \\tag{7} \\sum_{k = 0}^{n} k^2 = \\sum_{k = 0}{n} (2{k \\choose 2} + {k \\choose 1}) = 2{n + 1 \\choose 3} + {n + 1 \\choose 2} \\tag{7} By expanding equation (7): 1^2 + 2^2 + ... + n^2 = 2\\frac{(n + 1)n(n - 1)}{6} + \\frac{(n + 1)n}{2} = \\frac{1}{3}n(n + \\frac{1}{2})(n + 1) \\tag{8} 1^2 + 2^2 + ... + n^2 = 2\\frac{(n + 1)n(n - 1)}{6} + \\frac{(n + 1)n}{2} = \\frac{1}{3}n(n + \\frac{1}{2})(n + 1) \\tag{8}","title":"Summation Formulas"},{"location":"Books/binomial-coefficient/#sum-of-products","text":"One important equation: \\sum_k{r \\choose k}{s \\choose n - k} = {r + s \\choose n} \\tag{9} \\sum_k{r \\choose k}{s \\choose n - k} = {r + s \\choose n} \\tag{9} Which can be interpret the right-hand side as the number of ways to select n people from among r men and s women; each term on the left is the number of ways to choose k of the men and n - k of women.","title":"Sum of Products"},{"location":"Books/fibonacci-squence/","text":"Fibonacci Sequence \u00b6 What to prove \u00b6 If \\phi = (1 + \\sqrt{5}) / 2 \\phi = (1 + \\sqrt{5}) / 2 then F_n \\leq \\phi^{n - 1} F_n \\leq \\phi^{n - 1} and F_n = F_{n - 1} + F_{n - 2} F_n = F_{n - 1} + F_{n - 2} Steps using induction \u00b6 If n = 1 (base case), F_1 = 1 = \\phi^{0} = \\phi^{1-1} F_1 = 1 = \\phi^{0} = \\phi^{1-1} which is true. If P(1), P(2) ... P(n) P(1), P(2) ... P(n) are true and n > 1 n > 1 , we know in particular that P(n - 1) P(n - 1) and P(n) P(n) are true; so F_{n - 1} \\leq \\phi^{n - 2} F_{n - 1} \\leq \\phi^{n - 2} and F_n \\leq \\phi^{n - 1} F_n \\leq \\phi^{n - 1} . Adding these inequalities: F_{n + 1} = F_{n - 1} + F_n \\leq \\phi^{n - 2} + \\phi^{n - 1} = \\phi^{n - 2} (1 + \\phi) F_{n + 1} = F_{n - 1} + F_n \\leq \\phi^{n - 2} + \\phi^{n - 1} = \\phi^{n - 2} (1 + \\phi) The important property of the number \\phi \\phi is that: 1 + \\phi = \\phi^2 1 + \\phi = \\phi^2 Plugging this into the preious equation gives F_{n + 1} \\leq \\phi^n F_{n + 1} \\leq \\phi^n , so we prove the inductive step where if F_n F_n is true then F_{n + 1} F_{n + 1} is true. Relationship between F_m F_m and F_n F_n \u00b6 F_{n + 3} = F_{n + 2} + F_{n + 1} = F_{n + 1} + F_n + F_{n + 1} = 2F_{n + 1} + F_n F_{n + 3} = F_{n + 2} + F_{n + 1} = F_{n + 1} + F_n + F_{n + 1} = 2F_{n + 1} + F_n Similarly, we can derive F_{n + 4} F_{n + 4} F_{n + 4} = 3F_{n + 1} + 2F_n F_{n + 4} = 3F_{n + 1} + 2F_n In general: F_{n + m} = F_m F_{n + 1} + F_{m - 1} F_n \\tag{1} F_{n + m} = F_m F_{n + 1} + F_{m - 1} F_n \\tag{1} Assume m = (k - 1) n m = (k - 1) n , or m be a multiple of n in equation (1), we find inductively that: F_{m + n} = F_{nk} F_{m + n} = F_{nk} is multiple of F_n F_n , thus every third number is even, every fourth number is a multiple of 3, every fifth is a multiple of 5... Relative Prime if two numbers are relative prime, then the gcd is 1: gcd(F_n, F_{n + 1}) = 1 gcd(F_n, F_{n + 1}) = 1 Theorem A \u00b6 gcd(F_m, F_n) = F_{gcd(m, n)} \\tag{2} gcd(F_m, F_n) = F_{gcd(m, n)} \\tag{2}","title":"Fibonacci Sequence"},{"location":"Books/fibonacci-squence/#fibonacci-sequence","text":"","title":"Fibonacci Sequence"},{"location":"Books/fibonacci-squence/#what-to-prove","text":"If \\phi = (1 + \\sqrt{5}) / 2 \\phi = (1 + \\sqrt{5}) / 2 then F_n \\leq \\phi^{n - 1} F_n \\leq \\phi^{n - 1} and F_n = F_{n - 1} + F_{n - 2} F_n = F_{n - 1} + F_{n - 2}","title":"What to prove"},{"location":"Books/fibonacci-squence/#steps-using-induction","text":"If n = 1 (base case), F_1 = 1 = \\phi^{0} = \\phi^{1-1} F_1 = 1 = \\phi^{0} = \\phi^{1-1} which is true. If P(1), P(2) ... P(n) P(1), P(2) ... P(n) are true and n > 1 n > 1 , we know in particular that P(n - 1) P(n - 1) and P(n) P(n) are true; so F_{n - 1} \\leq \\phi^{n - 2} F_{n - 1} \\leq \\phi^{n - 2} and F_n \\leq \\phi^{n - 1} F_n \\leq \\phi^{n - 1} . Adding these inequalities: F_{n + 1} = F_{n - 1} + F_n \\leq \\phi^{n - 2} + \\phi^{n - 1} = \\phi^{n - 2} (1 + \\phi) F_{n + 1} = F_{n - 1} + F_n \\leq \\phi^{n - 2} + \\phi^{n - 1} = \\phi^{n - 2} (1 + \\phi) The important property of the number \\phi \\phi is that: 1 + \\phi = \\phi^2 1 + \\phi = \\phi^2 Plugging this into the preious equation gives F_{n + 1} \\leq \\phi^n F_{n + 1} \\leq \\phi^n , so we prove the inductive step where if F_n F_n is true then F_{n + 1} F_{n + 1} is true.","title":"Steps using induction"},{"location":"Books/fibonacci-squence/#relationship-between-f_mf_m-and-f_nf_n","text":"F_{n + 3} = F_{n + 2} + F_{n + 1} = F_{n + 1} + F_n + F_{n + 1} = 2F_{n + 1} + F_n F_{n + 3} = F_{n + 2} + F_{n + 1} = F_{n + 1} + F_n + F_{n + 1} = 2F_{n + 1} + F_n Similarly, we can derive F_{n + 4} F_{n + 4} F_{n + 4} = 3F_{n + 1} + 2F_n F_{n + 4} = 3F_{n + 1} + 2F_n In general: F_{n + m} = F_m F_{n + 1} + F_{m - 1} F_n \\tag{1} F_{n + m} = F_m F_{n + 1} + F_{m - 1} F_n \\tag{1} Assume m = (k - 1) n m = (k - 1) n , or m be a multiple of n in equation (1), we find inductively that: F_{m + n} = F_{nk} F_{m + n} = F_{nk} is multiple of F_n F_n , thus every third number is even, every fourth number is a multiple of 3, every fifth is a multiple of 5... Relative Prime if two numbers are relative prime, then the gcd is 1: gcd(F_n, F_{n + 1}) = 1 gcd(F_n, F_{n + 1}) = 1","title":"Relationship between F_mF_m and F_nF_n"},{"location":"Books/fibonacci-squence/#theorem-a","text":"gcd(F_m, F_n) = F_{gcd(m, n)} \\tag{2} gcd(F_m, F_n) = F_{gcd(m, n)} \\tag{2}","title":"Theorem A"},{"location":"Books/harmonic-numbers/","text":"Harmonic Numbers \u00b6 Definition \u00b6 H_n = 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + ... + \\frac{1}{n} = \\sum_{k=1}^{n} \\frac{1}{k}, n \\geq 0 \\tag{1} H_n = 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + ... + \\frac{1}{n} = \\sum_{k=1}^{n} \\frac{1}{k}, n \\geq 0 \\tag{1} Lower Bound \u00b6 H_{2^m} \\geq 1 + \\frac{m}{2} \\tag{2} H_{2^m} \\geq 1 + \\frac{m}{2} \\tag{2} Few important sum related to Harmonic Numbers \u00b6 \\sum_{k=1}^{n} H_k = (n + 1)H_n - n \\tag{3} \\sum_{k=1}^{n} H_k = (n + 1)H_n - n \\tag{3} Using Euler's Constant to approximate size of H_n H_n \u00b6 H_n = \\ln{n} + \\gamma + \\frac{1}{2n} - \\frac{1}{12n} + \\frac{1}{120n^4} - \\epsilon, 0 < \\epsilon < \\frac{1}{252n^6}, \\gamma = 0.5772156649 \\tag{4} H_n = \\ln{n} + \\gamma + \\frac{1}{2n} - \\frac{1}{12n} + \\frac{1}{120n^4} - \\epsilon, 0 < \\epsilon < \\frac{1}{252n^6}, \\gamma = 0.5772156649 \\tag{4} Where \\gamma \\gamma is Euler's constant.","title":"Harmonic Numbers"},{"location":"Books/harmonic-numbers/#harmonic-numbers","text":"","title":"Harmonic Numbers"},{"location":"Books/harmonic-numbers/#definition","text":"H_n = 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + ... + \\frac{1}{n} = \\sum_{k=1}^{n} \\frac{1}{k}, n \\geq 0 \\tag{1} H_n = 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + ... + \\frac{1}{n} = \\sum_{k=1}^{n} \\frac{1}{k}, n \\geq 0 \\tag{1}","title":"Definition"},{"location":"Books/harmonic-numbers/#lower-bound","text":"H_{2^m} \\geq 1 + \\frac{m}{2} \\tag{2} H_{2^m} \\geq 1 + \\frac{m}{2} \\tag{2}","title":"Lower Bound"},{"location":"Books/harmonic-numbers/#few-important-sum-related-to-harmonic-numbers","text":"\\sum_{k=1}^{n} H_k = (n + 1)H_n - n \\tag{3} \\sum_{k=1}^{n} H_k = (n + 1)H_n - n \\tag{3}","title":"Few important sum related to Harmonic Numbers"},{"location":"Books/harmonic-numbers/#using-eulers-constant-to-approximate-size-of-h_nh_n","text":"H_n = \\ln{n} + \\gamma + \\frac{1}{2n} - \\frac{1}{12n} + \\frac{1}{120n^4} - \\epsilon, 0 < \\epsilon < \\frac{1}{252n^6}, \\gamma = 0.5772156649 \\tag{4} H_n = \\ln{n} + \\gamma + \\frac{1}{2n} - \\frac{1}{12n} + \\frac{1}{120n^4} - \\epsilon, 0 < \\epsilon < \\frac{1}{252n^6}, \\gamma = 0.5772156649 \\tag{4} Where \\gamma \\gamma is Euler's constant.","title":"Using Euler's Constant to approximate size of H_nH_n"},{"location":"Books/lca/","text":"Lowest Common Ancestor Problem with Advanced Methods to Solve \u00b6 Tarjan Algorithm: offline \u00b6","title":"Lowest Common Ancestor Problem with Advanced Methods to Solve"},{"location":"Books/lca/#lowest-common-ancestor-problem-with-advanced-methods-to-solve","text":"","title":"Lowest Common Ancestor Problem with Advanced Methods to Solve"},{"location":"Books/lca/#tarjan-algorithm-offline","text":"","title":"Tarjan Algorithm: offline"},{"location":"Books/max-flow/","text":"Max Flow Problem \u00b6 Defination of Flow Network \u00b6 A flow network G = (V, E) G = (V, E) is a directed grarph in which each edge (u, v) \\in E (u, v) \\in E has a nonnegative capacity c(u, v) \\geq 0 c(u, v) \\geq 0 . We further require that if E contains an edge (u, v) (u, v) , then there is no edge (u, v) (u, v) in the reverse direction. Two Properties \u00b6 Capacity constraint: For all u, v \\in V u, v \\in V , we require 0 \\leq f(u, v) \\leq c(u,v) 0 \\leq f(u, v) \\leq c(u,v) . Flow conservation: For all u \\in V - {s, t} u \\in V - {s, t} , we require \\sum_{v \\in V}{f(v, u)} = \\sum_{v \\in V}{f(u, v)} \\sum_{v \\in V}{f(v, u)} = \\sum_{v \\in V}{f(u, v)} (sum of in == sum of out) reversed direction flow can be represented by adding a new node in the middle What is max flow? \u00b6 In the maximum flow problem, our task is to send as much flow as possible from the source to the sink. The weight of each edge is a capacity that restricts the flow that can go through the edge. In each intermediate node, the incoming and outgoing flow has to be equal. For example, the maximum size of a flow in the example graph is 7. The following picture shows how we can route the flow: Residual Networks \u00b6 Given flow network G G and a flow f f , the residual network G_f G_f consists of edges with capacities that represent how we can change the flow on edges of G G . As an algorithm manipulates the flow, with the goal of increasing the total flow, it might need to decrease the flow on a particular edge. Sending flow back along an edge is equiva- lent to decreasing the flow on the edge, which is a necessary operation in many algorithms. second graph is the residual network for the first one Augmenting paths \u00b6 Given a flow network G = (V, E) G = (V, E) and a flow f f , an augmenting path p is a simple path from s to t in the residual network where each edge is greater than 0. If there is a augmenting path, then the original flow isn't the max flow. If there is no augmenting path, then the original flow is the max flow.","title":"Max Flow Problem"},{"location":"Books/max-flow/#max-flow-problem","text":"","title":"Max Flow Problem"},{"location":"Books/max-flow/#defination-of-flow-network","text":"A flow network G = (V, E) G = (V, E) is a directed grarph in which each edge (u, v) \\in E (u, v) \\in E has a nonnegative capacity c(u, v) \\geq 0 c(u, v) \\geq 0 . We further require that if E contains an edge (u, v) (u, v) , then there is no edge (u, v) (u, v) in the reverse direction.","title":"Defination of Flow Network"},{"location":"Books/max-flow/#two-properties","text":"Capacity constraint: For all u, v \\in V u, v \\in V , we require 0 \\leq f(u, v) \\leq c(u,v) 0 \\leq f(u, v) \\leq c(u,v) . Flow conservation: For all u \\in V - {s, t} u \\in V - {s, t} , we require \\sum_{v \\in V}{f(v, u)} = \\sum_{v \\in V}{f(u, v)} \\sum_{v \\in V}{f(v, u)} = \\sum_{v \\in V}{f(u, v)} (sum of in == sum of out) reversed direction flow can be represented by adding a new node in the middle","title":"Two Properties"},{"location":"Books/max-flow/#what-is-max-flow","text":"In the maximum flow problem, our task is to send as much flow as possible from the source to the sink. The weight of each edge is a capacity that restricts the flow that can go through the edge. In each intermediate node, the incoming and outgoing flow has to be equal. For example, the maximum size of a flow in the example graph is 7. The following picture shows how we can route the flow:","title":"What is max flow?"},{"location":"Books/max-flow/#residual-networks","text":"Given flow network G G and a flow f f , the residual network G_f G_f consists of edges with capacities that represent how we can change the flow on edges of G G . As an algorithm manipulates the flow, with the goal of increasing the total flow, it might need to decrease the flow on a particular edge. Sending flow back along an edge is equiva- lent to decreasing the flow on the edge, which is a necessary operation in many algorithms. second graph is the residual network for the first one","title":"Residual Networks"},{"location":"Books/max-flow/#augmenting-paths","text":"Given a flow network G = (V, E) G = (V, E) and a flow f f , an augmenting path p is a simple path from s to t in the residual network where each edge is greater than 0. If there is a augmenting path, then the original flow isn't the max flow. If there is no augmenting path, then the original flow is the max flow.","title":"Augmenting paths"},{"location":"Books/minimal-spanning-tree/","text":"Minimal Spanning Tree \u00b6 Representation \u00b6 Growing MST \u00b6 Grows one edge a time. The generic method manages a set of edges A, maintaining the following loop invariant: Prior to each iteration, A is a subset of some MST At each step, we determine an edge (u, v) thatcan add to A without violating this invariant. Kruskal's Algorithm \u00b6 Kruskal\u2019s algorithm builds a minimum spanning tree by greedily adding edges to a graph that initially only contains the nodes of the original graph and no edges. The algorithm goes through the edges of the original graph ordered by their weights and always adds an edge to the new graph if the edge does not create a cycle . The algorithm maintains the components of the new graph. Initially, each node of the graph belongs to a separate component. Always when an edge is added to the graph, two components are joined. Finally, all nodes belong to the same component, and a minimum spanning tree has been found.","title":"Minimal Spanning Tree"},{"location":"Books/minimal-spanning-tree/#minimal-spanning-tree","text":"","title":"Minimal Spanning Tree"},{"location":"Books/minimal-spanning-tree/#representation","text":"","title":"Representation"},{"location":"Books/minimal-spanning-tree/#growing-mst","text":"Grows one edge a time. The generic method manages a set of edges A, maintaining the following loop invariant: Prior to each iteration, A is a subset of some MST At each step, we determine an edge (u, v) thatcan add to A without violating this invariant.","title":"Growing MST"},{"location":"Books/minimal-spanning-tree/#kruskals-algorithm","text":"Kruskal\u2019s algorithm builds a minimum spanning tree by greedily adding edges to a graph that initially only contains the nodes of the original graph and no edges. The algorithm goes through the edges of the original graph ordered by their weights and always adds an edge to the new graph if the edge does not create a cycle . The algorithm maintains the components of the new graph. Initially, each node of the graph belongs to a separate component. Always when an edge is added to the graph, two components are joined. Finally, all nodes belong to the same component, and a minimum spanning tree has been found.","title":"Kruskal's Algorithm"},{"location":"Books/shortest-path-problem/","text":"Shortest Path Problem \u00b6 Single Source shortest path problem \u00b6 Find the shortest src to a target dest: reversing the direction of the DAG -> find the shortest path starting from dest Find shortest path between u and v. Find shortest path for all pair u and v. Negative Edge \u00b6 If graph has cycle: short path isn't well defined. Dijkstra: has to be positive edge, can deal with cycle Bellman Ford: cannot have a cycle from src but can deal with negative edge (single source shortest path) Shortest path cannot contain a cycle Uniqueness \u00b6 Shortest paths are not necessary unique: Dijkstra \u00b6 More efficient than Bellman Ford but requires the edges are positive weight. The algorithm only traverse each node once, and greedily choose the shortest path to reach the current node (using priority queue). for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; q.push({ 0 ,x}); while ( ! q.empty()) { int a = q.top().second; q.pop(); if (processed[a]) continue ; processed[a] = true ; for ( auto u : adj[a]) { int b = u.first, w = u.second; if (distance[a] + w < distance[b]) { distance[b] = distance[a] + w; q.push({ - distance[b],b}); } } } Time: O(n + m log m) O(n + m log m) Bellman Ford \u00b6 Find the shortest path from one src to all the others. If there is a negative cycle, it will be able to detect it. for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { for ( auto e : edges) { int a, b, w; tie(a, b, w) = e; distance[b] = min(distance[b], distance[a] + w); } } for ( auto e : edge) { int a, b, w; tie(a, b, w) = e; if (distance[a] + w < distance[b]) return false ; // negative cycle } Time: O(m \\times n) O(m \\times n) n node with m edges Floyd-Warshall (find all shortest path for all pairs) \u00b6 First initialize the distance list with direct connected nodes' distance. for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { if (i == j) distance[i][j] = 0 ; else if (adj[i][j]) distance[i][j] = adj[i][j]; else distance[i][j] = INF; } } Then keep adding the intermediate nodes k, and base on the new graph update the distance list. for ( int k = 1 ; k <= n; k ++ ) { // added node for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]); } } } Time: O(n^3) O(n^3) for the second step","title":"Shortest Path Problem"},{"location":"Books/shortest-path-problem/#shortest-path-problem","text":"","title":"Shortest Path Problem"},{"location":"Books/shortest-path-problem/#single-source-shortest-path-problem","text":"Find the shortest src to a target dest: reversing the direction of the DAG -> find the shortest path starting from dest Find shortest path between u and v. Find shortest path for all pair u and v.","title":"Single Source shortest path problem"},{"location":"Books/shortest-path-problem/#negative-edge","text":"If graph has cycle: short path isn't well defined. Dijkstra: has to be positive edge, can deal with cycle Bellman Ford: cannot have a cycle from src but can deal with negative edge (single source shortest path) Shortest path cannot contain a cycle","title":"Negative Edge"},{"location":"Books/shortest-path-problem/#uniqueness","text":"Shortest paths are not necessary unique:","title":"Uniqueness"},{"location":"Books/shortest-path-problem/#dijkstra","text":"More efficient than Bellman Ford but requires the edges are positive weight. The algorithm only traverse each node once, and greedily choose the shortest path to reach the current node (using priority queue). for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; q.push({ 0 ,x}); while ( ! q.empty()) { int a = q.top().second; q.pop(); if (processed[a]) continue ; processed[a] = true ; for ( auto u : adj[a]) { int b = u.first, w = u.second; if (distance[a] + w < distance[b]) { distance[b] = distance[a] + w; q.push({ - distance[b],b}); } } } Time: O(n + m log m) O(n + m log m)","title":"Dijkstra"},{"location":"Books/shortest-path-problem/#bellman-ford","text":"Find the shortest path from one src to all the others. If there is a negative cycle, it will be able to detect it. for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { for ( auto e : edges) { int a, b, w; tie(a, b, w) = e; distance[b] = min(distance[b], distance[a] + w); } } for ( auto e : edge) { int a, b, w; tie(a, b, w) = e; if (distance[a] + w < distance[b]) return false ; // negative cycle } Time: O(m \\times n) O(m \\times n) n node with m edges","title":"Bellman Ford"},{"location":"Books/shortest-path-problem/#floyd-warshall-find-all-shortest-path-for-all-pairs","text":"First initialize the distance list with direct connected nodes' distance. for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { if (i == j) distance[i][j] = 0 ; else if (adj[i][j]) distance[i][j] = adj[i][j]; else distance[i][j] = INF; } } Then keep adding the intermediate nodes k, and base on the new graph update the distance list. for ( int k = 1 ; k <= n; k ++ ) { // added node for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]); } } } Time: O(n^3) O(n^3) for the second step","title":"Floyd-Warshall (find all shortest path for all pairs)"},{"location":"Google%20Kick%20Start/2020-round-a/","text":"2020 Round A \u00b6 Allocation \u00b6 There are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. Limits Time limit: 15 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 B \u2264 105. 1 \u2264 Ai \u2264 1000, for all i. Test set 1 1 \u2264 N \u2264 100. Test set 2 1 \u2264 N \u2264 105. Sample Input Output 3 4 100 20 90 40 90 4 50 30 30 10 10 3 300 999 999 999 Case #1: 2 Case #2: 3 Case #3: 0 In Sample Case #1, you have a budget of 100 dollars. You can buy the 1 st and 3 rd houses for 20 + 40 = 60 dollars. In Sample Case #2, you have a budget of 50 dollars. You can buy the 1 st , 3 rd and 4 th houses for 30 + 10 + 10 = 50 dollars. In Sample Case #3, you have a budget of 300 dollars. You cannot buy any houses (so the answer is 0). Analysis \u00b6 To buy the maxmimum amount of houses, we can greedy buy the ones with the smallest cost first, and until we reach to the point when there is no money left to buy the next higher cost house, we can stop. Prove by replacement: assume the solution is A = {a1, ..., ak} where ai represents the house cost you choose for the max amount. assume the optimal solution is O = {oi, ..., om} where oi represents the true solution. assume oj is not presented in A we want to prove that A == O pick an ai that is in A, and replace it with oj. oj is not in A, so oj is less than ai. since size of B is the same, the solution is still the most optimal one. keep doing this until there is A == O. Code \u00b6 sort with nlog n \u00b6 /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; vector < int > costs(N, 0 ); for ( int j = 0 ; j < N; ++ j) { cin >> costs[j]; } sort(costs.begin(), costs.end()); // nlog n int cnt = 0 ; for ( int k = 0 ; k < N; ++ k) if (B >= costs[k]) { B -= costs[k]; cnt ++ ; } else break ; cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; } count sort with n \u00b6 because 1 \u2264 Ai \u2264 1000, we can use count sort /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int n = 1010 ; int A[n]; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; memset(A, 0 , sizeof A); int v; for ( int i = 0 ; i < N; ++ i) { cin >> v; A[v] ++ ; } int cnt = 0 ; for ( int i = 1 ; B > 0 && i <= 1000 ; ++ i) { // i is house price int curr = min(B / i, A[i]); // case when there are less than you can buy cnt += curr; B -= curr * i; } cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; } Plates \u00b6 Dr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 K \u2264 30. 1 \u2264 P \u2264 N * K. The beauty values are between 1 and 100, inclusive. Test set 1 1 \u2264 N \u2264 3. Test set 2 1 \u2264 N \u2264 50. Sample Input Output 2 2 4 5 10 10 100 30 80 50 10 50 3 2 3 80 80 15 50 20 10 Case #1: 250 Case #2: 180 In Sample Case #1, Dr. Patel needs to pick P = 5 plates: He can pick the top 3 plates from the first stack (10 + 10 + 100 = 120). He can pick the top 2 plates from the second stack (80 + 50 = 130) . In total, the sum of beauty values is 250. In Sample Case #2, Dr. Patel needs to pick P = 3 plates: He can pick the top 2 plates from the first stack (80 + 80 = 160). He can pick no plates from the second stack. He can pick the top plate from the third stack (20). In total, the sum of beauty values is 180. Analysis \u00b6 dp[N][P]: from first n stacks, with p plates, the maximum beauty values dp[i][j] = max(dp[i][j], val[k] + dp[i - 1][p - k]) for choosing current stack's top k plates, you need to give up the previous stacks k plates, so the previous state is dp[i - 1][p - k] the answer is dp[N][P] Code \u00b6 /* * plates.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T; int N, K, P; // n: # of stacks, k: # of items for each stack, # total to be // borrowed cin >> T; for ( int t = 0 ; t < T; ++ t) { cin >> N >> K >> P; int dp[N + 1 ][P + 1 ]; // from 0-N, the max value for P plates memset(dp, 0 , sizeof dp); for ( int i = 1 ; i <= N; ++ i) { int val[K + 1 ]; memset(val, 0 , sizeof val); for ( int j = 1 ; j <= K; ++ j) { cin >> val[j]; } // calculate preSum for ( int k = 1 ; k <= K; ++ k) { val[k] = val[k - 1 ] + val[k]; } for ( int p = 1 ; p <= P; ++ p) { for ( int k = 0 ; k <= min(p, K); ++ k) { dp[i][p] = max(dp[i][p], val[k] + dp[i - 1 ][p - k]); } } } cout << \"Case #\" << t << \": \" << dp[N][P] << endl; } return 0 ; } Workout \u00b6 Tambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. For at most 10 test cases, 2 \u2264 N \u2264 105. For all other test cases, 2 \u2264 N \u2264 300. 1 \u2264 Mi \u2264 109. Mi < Mi+1 for all i. Test set 1 K = 1. Test set 2 1 \u2264 K \u2264 105. Samples Input 1 Output 1 1 3 1 100 200 230 Case #1: 50 Input 2 Output 2 3 5 2 10 13 15 16 17 5 6 9 10 20 26 30 8 3 1 2 3 4 5 6 7 10 Case #1: 2 Case #2: 3 Case #3: 1 Sample #1 In Case #1: Tambourine can add up to one session. The added sessions are marked in bold: 100 150 200 230. The difficulty is now 50. Sample #2 In Case #1: Tambourine can add up to two sessions. The added sessions are marked in bold: 10 11 13 15 16 17 18. The difficulty is now 2. In Case #2: Tambourine can add up to six sessions. The added sessions are marked in bold: 9 10 12 14 16 18 20 23 26 29 30. The difficulty is now 3. In Case #3: Tambourine can add up to three sessions. The added sessions are marked in bold: 1 2 3 4 5 6 7 8 9 10. The difficulty is now 1. Note that Tambourine only added two sessions. Analysis \u00b6 Priority Queue : Find an array that record the gaps every two sessions. Call it gaps[N-1]. To add one session, the new one should be between the one that has the greatest gap. However, we cannot do that all at once for the first greatest gap. Instead, we should do it \"greedily\". When adding the one, we need to find a way to get the updated max gap from the total gaps. In order to do so, we need to use priority queue. The top of the queue will store the maxmium gap. To keep update the gap, we don't want to manually modify the default gap, but to add a \"cnt\" which will be divied by the gap. When making the comparsion, the real gap value is gap default value / cnt. Binary Search : Our goal is to find the most difficult gap, and try to minimize it as much as possible. It now becomes a search problem. The gap is in between 1 ~ a[n-1]-a[0], and for each gap, we calculate the desire \"cuts\" to satisfy k. To calculate the desire \"cuts\", we should find the gap between each one, and then ceil(gap / most difficult gap) - 1 (check line 21 from solution 2). If the \"cuts\" is less than K, that means we have room to lower our difficulty by using the unused \"cuts\", so our search range is decreased by half from 1 ~ mb, else it will be mb + 1 ~ rb. Code \u00b6 Priority Queue \u00b6 #include <bits/stdc++.h> using namespace std; struct node { int sum, cnt; node() {} node( int sum, int cnt) : sum(sum) , cnt(cnt) { } bool operator < ( const node & b) const { int x = (sum / cnt) + (sum % cnt > 0 ); // sort by averged out by cnt int y = (b.sum / b.cnt) + (b.sum % b.cnt > 0 ); return x < y; } }; int main ( int argc, char * argv[]) { int T; int N, K; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> K; int m[N]; memset(m, 0 , sizeof m); for ( int n = 0 ; n < N; ++ n) { cin >> m[n]; } int gap[N - 1 ]; memset(gap, 0 , sizeof gap); for ( int i = 0 ; i < N - 1 ; ++ i) { gap[i] = m[i + 1 ] - m[i]; } if (K == 1 ) { sort(gap, gap + N - 1 ); if (N == 2 ) printf( \"Case #%d: %d \\n \" , i, (gap[ 0 ] + 1 ) / 2 ); else printf( \"Case #%d: %d \\n \" , i, max((gap[N - 2 ] + 1 ) / 2 , gap[N - 3 ])); } else { priority_queue < node > q; for ( int i = 0 ; i < N - 1 ; ++ i) { q.push(node(gap[i], 1 )); } for ( int i = 0 ; i < K; ++ i) { auto p = q.top(); q.pop(); q.push(node(p.sum, p.cnt + 1 )); // add one to split it } auto p = q.top(); int res = (p.sum / p.cnt) + (p.sum % p.cnt > 0 ); printf( \"Case #%d: %d \\n \" , i, res); } } return 0 ; } Binary search \u00b6 #include <bits/stdc++.h> using namespace std; #define ll long long #define ar array int n, k, a[ 100000 ]; void solve () { cin >> n >> k; // n: size of a, k: # of total insertions for ( int i = 0 ; i < n; ++ i) cin >> a[i]; int lb = 1 , rb = a[n - 1 ] - a[ 0 ]; // total difference while (lb < rb) { int mb = (lb + rb) / 2 ; // guess the most optimal difference is mb int k2 = 0 ; for ( int i = 1 ; i < n; ++ i) { int d = a[i] - a[i - 1 ]; k2 += (d + mb - 1 ) / mb - 1 ; // # of all inserted class if mb is the optimal } if (k2 <= k) // if less than k, we can potentially decrease the difficulity rb = mb; else // or we have to increase the difficulity lb = mb + 1 ; } cout << lb << \" \\n \" ; } int main () { ios :: sync_with_stdio( 0 ); cin.tie( 0 ); int t, i = 1 ; cin >> t; while (t -- ) { cout << \"Case #\" << i << \": \" ; solve(); ++ i; } } Bundling \u00b6 Pip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example: The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is 'RA'). The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is 'FIRE'). The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ''). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip's strings. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 2 \u2264 N \u2264 105. 2 \u2264 K \u2264 N. K divides N. Each of Pip's strings contain at least one character. Each string consists only of letters from A to Z. Test set 1 Each of Pip's strings contain at most 5 characters. Test set 2 The total number of characters in Pip's strings across all test cases is at most 2 \u00d7 106. Samples Input 1 2 2 2 KICK START 8 2 G G GO GO GOO GOO GOOO GOOO Output 1 Case #1: 0 Case #2: 10 Input 2 1 6 3 RAINBOW FIREBALL RANK RANDOM FIREWALL FIREFIGHTER Output 2 Case #1: 6 Sample #1 In Case #1, Pip can achieve a total score of 0 by make the groups: {KICK, START}, with a score of 0. In Case #2, Pip can achieve a total score of 10 by make the groups: {G, G}, with a score of 1. {GO, GO}, with a score of 2. {GOO, GOO}, with a score of 3. {GOOO, GOOO}, with a score of 4. Sample #2 In Case #1, Pip can achieve a total score of 6 by make the groups: {RAINBOW, RANK, RANDOM}, with a score of 2. {FIREBALL, FIREWALL, FIREFIGHTER}, with a score of 4. Analysis \u00b6 Assume each bundle has prefix as P_i P_i , and the CNT_i CNT_i represents the number of strings shares that prefix. Assign k string to the bundle, now we have CNT_i \\% k CNT_i \\% k string left. Do the same thing for preifx P_{i + 1} P_{i + 1} which has a CNT_{i+1} < CNT_i CNT_{i+1} < CNT_i , now we have CNT_{i + 1} \\% k CNT_{i + 1} \\% k left. Keep this procedure until CNT_j \\% k == 0 CNT_j \\% k == 0 which means all the string have assigned to a particular bundle. Now the problem becomes finding the total count. Split into n/k groups, and each group has k strings. Use trie to find the common prefix. Each trie node has 26 children nodes, and one cnt int for counting the number of prefix exist by the current node. Insert: insert into trie and update the cnt for each ending character node. Query: just search from the root of the trie and traverse through the last level of the trie, because all the nodes from root has a count that represent the occurance of word that is ended with node character. Code \u00b6 #include <bits/stdc++.h> using namespace std; #define endl \"\\n\" #define int long long const int N = 1e5 + 5 ; typedef struct data { data * bit[ 26 ]; int cnt = 0 ; }trie; trie * head; void insert (string & s) { trie * cur = head; for ( auto & it :s) { int b = it - 'A' ; if ( ! cur -> bit[b]) cur -> bit[b] = new trie(); // create new node if not exist cur = cur -> bit[b]; // proceed through next character cur -> cnt ++ ; // end with current character } } int n, k; string s[N]; int query (trie * cur) { if ( ! cur) return 0 ; int ans = (cur -> cnt / k); // there are k words each, so there are k times repeat counts for ( int i = 0 ; i <= 25 ; i ++ ) if (cur -> bit[i]) ans += query(cur -> bit[i]); // proceeds to next level and check the count return ans; } int main () { int t; cin >> t; int tc = 0 ; while (t -- ) { head = new trie(); tc ++ ; cin >> n >> k; for ( int i = 1 ; i <= n; i ++ ) { cin >> s[i]; insert(s[i]); } int ans = query(head); cout << \"Case #\" << tc << \": \" << ans << endl; } return 0 ; }","title":"2020 Round A"},{"location":"Google%20Kick%20Start/2020-round-a/#2020-round-a","text":"","title":"2020 Round A"},{"location":"Google%20Kick%20Start/2020-round-a/#allocation","text":"There are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. Limits Time limit: 15 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 B \u2264 105. 1 \u2264 Ai \u2264 1000, for all i. Test set 1 1 \u2264 N \u2264 100. Test set 2 1 \u2264 N \u2264 105. Sample Input Output 3 4 100 20 90 40 90 4 50 30 30 10 10 3 300 999 999 999 Case #1: 2 Case #2: 3 Case #3: 0 In Sample Case #1, you have a budget of 100 dollars. You can buy the 1 st and 3 rd houses for 20 + 40 = 60 dollars. In Sample Case #2, you have a budget of 50 dollars. You can buy the 1 st , 3 rd and 4 th houses for 30 + 10 + 10 = 50 dollars. In Sample Case #3, you have a budget of 300 dollars. You cannot buy any houses (so the answer is 0).","title":"Allocation"},{"location":"Google%20Kick%20Start/2020-round-a/#analysis","text":"To buy the maxmimum amount of houses, we can greedy buy the ones with the smallest cost first, and until we reach to the point when there is no money left to buy the next higher cost house, we can stop. Prove by replacement: assume the solution is A = {a1, ..., ak} where ai represents the house cost you choose for the max amount. assume the optimal solution is O = {oi, ..., om} where oi represents the true solution. assume oj is not presented in A we want to prove that A == O pick an ai that is in A, and replace it with oj. oj is not in A, so oj is less than ai. since size of B is the same, the solution is still the most optimal one. keep doing this until there is A == O.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020-round-a/#code","text":"","title":"Code"},{"location":"Google%20Kick%20Start/2020-round-a/#sort-with-nlog-n","text":"/* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; vector < int > costs(N, 0 ); for ( int j = 0 ; j < N; ++ j) { cin >> costs[j]; } sort(costs.begin(), costs.end()); // nlog n int cnt = 0 ; for ( int k = 0 ; k < N; ++ k) if (B >= costs[k]) { B -= costs[k]; cnt ++ ; } else break ; cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; }","title":"sort with nlog n"},{"location":"Google%20Kick%20Start/2020-round-a/#count-sort-with-n","text":"because 1 \u2264 Ai \u2264 1000, we can use count sort /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int n = 1010 ; int A[n]; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; memset(A, 0 , sizeof A); int v; for ( int i = 0 ; i < N; ++ i) { cin >> v; A[v] ++ ; } int cnt = 0 ; for ( int i = 1 ; B > 0 && i <= 1000 ; ++ i) { // i is house price int curr = min(B / i, A[i]); // case when there are less than you can buy cnt += curr; B -= curr * i; } cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; }","title":"count sort with n"},{"location":"Google%20Kick%20Start/2020-round-a/#plates","text":"Dr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 K \u2264 30. 1 \u2264 P \u2264 N * K. The beauty values are between 1 and 100, inclusive. Test set 1 1 \u2264 N \u2264 3. Test set 2 1 \u2264 N \u2264 50. Sample Input Output 2 2 4 5 10 10 100 30 80 50 10 50 3 2 3 80 80 15 50 20 10 Case #1: 250 Case #2: 180 In Sample Case #1, Dr. Patel needs to pick P = 5 plates: He can pick the top 3 plates from the first stack (10 + 10 + 100 = 120). He can pick the top 2 plates from the second stack (80 + 50 = 130) . In total, the sum of beauty values is 250. In Sample Case #2, Dr. Patel needs to pick P = 3 plates: He can pick the top 2 plates from the first stack (80 + 80 = 160). He can pick no plates from the second stack. He can pick the top plate from the third stack (20). In total, the sum of beauty values is 180.","title":"Plates"},{"location":"Google%20Kick%20Start/2020-round-a/#analysis_1","text":"dp[N][P]: from first n stacks, with p plates, the maximum beauty values dp[i][j] = max(dp[i][j], val[k] + dp[i - 1][p - k]) for choosing current stack's top k plates, you need to give up the previous stacks k plates, so the previous state is dp[i - 1][p - k] the answer is dp[N][P]","title":"Analysis"},{"location":"Google%20Kick%20Start/2020-round-a/#code_1","text":"/* * plates.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T; int N, K, P; // n: # of stacks, k: # of items for each stack, # total to be // borrowed cin >> T; for ( int t = 0 ; t < T; ++ t) { cin >> N >> K >> P; int dp[N + 1 ][P + 1 ]; // from 0-N, the max value for P plates memset(dp, 0 , sizeof dp); for ( int i = 1 ; i <= N; ++ i) { int val[K + 1 ]; memset(val, 0 , sizeof val); for ( int j = 1 ; j <= K; ++ j) { cin >> val[j]; } // calculate preSum for ( int k = 1 ; k <= K; ++ k) { val[k] = val[k - 1 ] + val[k]; } for ( int p = 1 ; p <= P; ++ p) { for ( int k = 0 ; k <= min(p, K); ++ k) { dp[i][p] = max(dp[i][p], val[k] + dp[i - 1 ][p - k]); } } } cout << \"Case #\" << t << \": \" << dp[N][P] << endl; } return 0 ; }","title":"Code"},{"location":"Google%20Kick%20Start/2020-round-a/#workout","text":"Tambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. For at most 10 test cases, 2 \u2264 N \u2264 105. For all other test cases, 2 \u2264 N \u2264 300. 1 \u2264 Mi \u2264 109. Mi < Mi+1 for all i. Test set 1 K = 1. Test set 2 1 \u2264 K \u2264 105. Samples Input 1 Output 1 1 3 1 100 200 230 Case #1: 50 Input 2 Output 2 3 5 2 10 13 15 16 17 5 6 9 10 20 26 30 8 3 1 2 3 4 5 6 7 10 Case #1: 2 Case #2: 3 Case #3: 1 Sample #1 In Case #1: Tambourine can add up to one session. The added sessions are marked in bold: 100 150 200 230. The difficulty is now 50. Sample #2 In Case #1: Tambourine can add up to two sessions. The added sessions are marked in bold: 10 11 13 15 16 17 18. The difficulty is now 2. In Case #2: Tambourine can add up to six sessions. The added sessions are marked in bold: 9 10 12 14 16 18 20 23 26 29 30. The difficulty is now 3. In Case #3: Tambourine can add up to three sessions. The added sessions are marked in bold: 1 2 3 4 5 6 7 8 9 10. The difficulty is now 1. Note that Tambourine only added two sessions.","title":"Workout"},{"location":"Google%20Kick%20Start/2020-round-a/#analysis_2","text":"Priority Queue : Find an array that record the gaps every two sessions. Call it gaps[N-1]. To add one session, the new one should be between the one that has the greatest gap. However, we cannot do that all at once for the first greatest gap. Instead, we should do it \"greedily\". When adding the one, we need to find a way to get the updated max gap from the total gaps. In order to do so, we need to use priority queue. The top of the queue will store the maxmium gap. To keep update the gap, we don't want to manually modify the default gap, but to add a \"cnt\" which will be divied by the gap. When making the comparsion, the real gap value is gap default value / cnt. Binary Search : Our goal is to find the most difficult gap, and try to minimize it as much as possible. It now becomes a search problem. The gap is in between 1 ~ a[n-1]-a[0], and for each gap, we calculate the desire \"cuts\" to satisfy k. To calculate the desire \"cuts\", we should find the gap between each one, and then ceil(gap / most difficult gap) - 1 (check line 21 from solution 2). If the \"cuts\" is less than K, that means we have room to lower our difficulty by using the unused \"cuts\", so our search range is decreased by half from 1 ~ mb, else it will be mb + 1 ~ rb.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020-round-a/#code_2","text":"","title":"Code"},{"location":"Google%20Kick%20Start/2020-round-a/#priority-queue","text":"#include <bits/stdc++.h> using namespace std; struct node { int sum, cnt; node() {} node( int sum, int cnt) : sum(sum) , cnt(cnt) { } bool operator < ( const node & b) const { int x = (sum / cnt) + (sum % cnt > 0 ); // sort by averged out by cnt int y = (b.sum / b.cnt) + (b.sum % b.cnt > 0 ); return x < y; } }; int main ( int argc, char * argv[]) { int T; int N, K; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> K; int m[N]; memset(m, 0 , sizeof m); for ( int n = 0 ; n < N; ++ n) { cin >> m[n]; } int gap[N - 1 ]; memset(gap, 0 , sizeof gap); for ( int i = 0 ; i < N - 1 ; ++ i) { gap[i] = m[i + 1 ] - m[i]; } if (K == 1 ) { sort(gap, gap + N - 1 ); if (N == 2 ) printf( \"Case #%d: %d \\n \" , i, (gap[ 0 ] + 1 ) / 2 ); else printf( \"Case #%d: %d \\n \" , i, max((gap[N - 2 ] + 1 ) / 2 , gap[N - 3 ])); } else { priority_queue < node > q; for ( int i = 0 ; i < N - 1 ; ++ i) { q.push(node(gap[i], 1 )); } for ( int i = 0 ; i < K; ++ i) { auto p = q.top(); q.pop(); q.push(node(p.sum, p.cnt + 1 )); // add one to split it } auto p = q.top(); int res = (p.sum / p.cnt) + (p.sum % p.cnt > 0 ); printf( \"Case #%d: %d \\n \" , i, res); } } return 0 ; }","title":"Priority Queue"},{"location":"Google%20Kick%20Start/2020-round-a/#binary-search","text":"#include <bits/stdc++.h> using namespace std; #define ll long long #define ar array int n, k, a[ 100000 ]; void solve () { cin >> n >> k; // n: size of a, k: # of total insertions for ( int i = 0 ; i < n; ++ i) cin >> a[i]; int lb = 1 , rb = a[n - 1 ] - a[ 0 ]; // total difference while (lb < rb) { int mb = (lb + rb) / 2 ; // guess the most optimal difference is mb int k2 = 0 ; for ( int i = 1 ; i < n; ++ i) { int d = a[i] - a[i - 1 ]; k2 += (d + mb - 1 ) / mb - 1 ; // # of all inserted class if mb is the optimal } if (k2 <= k) // if less than k, we can potentially decrease the difficulity rb = mb; else // or we have to increase the difficulity lb = mb + 1 ; } cout << lb << \" \\n \" ; } int main () { ios :: sync_with_stdio( 0 ); cin.tie( 0 ); int t, i = 1 ; cin >> t; while (t -- ) { cout << \"Case #\" << i << \": \" ; solve(); ++ i; } }","title":"Binary search"},{"location":"Google%20Kick%20Start/2020-round-a/#bundling","text":"Pip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example: The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is 'RA'). The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is 'FIRE'). The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ''). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip's strings. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 2 \u2264 N \u2264 105. 2 \u2264 K \u2264 N. K divides N. Each of Pip's strings contain at least one character. Each string consists only of letters from A to Z. Test set 1 Each of Pip's strings contain at most 5 characters. Test set 2 The total number of characters in Pip's strings across all test cases is at most 2 \u00d7 106. Samples Input 1 2 2 2 KICK START 8 2 G G GO GO GOO GOO GOOO GOOO Output 1 Case #1: 0 Case #2: 10 Input 2 1 6 3 RAINBOW FIREBALL RANK RANDOM FIREWALL FIREFIGHTER Output 2 Case #1: 6 Sample #1 In Case #1, Pip can achieve a total score of 0 by make the groups: {KICK, START}, with a score of 0. In Case #2, Pip can achieve a total score of 10 by make the groups: {G, G}, with a score of 1. {GO, GO}, with a score of 2. {GOO, GOO}, with a score of 3. {GOOO, GOOO}, with a score of 4. Sample #2 In Case #1, Pip can achieve a total score of 6 by make the groups: {RAINBOW, RANK, RANDOM}, with a score of 2. {FIREBALL, FIREWALL, FIREFIGHTER}, with a score of 4.","title":"Bundling"},{"location":"Google%20Kick%20Start/2020-round-a/#analysis_3","text":"Assume each bundle has prefix as P_i P_i , and the CNT_i CNT_i represents the number of strings shares that prefix. Assign k string to the bundle, now we have CNT_i \\% k CNT_i \\% k string left. Do the same thing for preifx P_{i + 1} P_{i + 1} which has a CNT_{i+1} < CNT_i CNT_{i+1} < CNT_i , now we have CNT_{i + 1} \\% k CNT_{i + 1} \\% k left. Keep this procedure until CNT_j \\% k == 0 CNT_j \\% k == 0 which means all the string have assigned to a particular bundle. Now the problem becomes finding the total count. Split into n/k groups, and each group has k strings. Use trie to find the common prefix. Each trie node has 26 children nodes, and one cnt int for counting the number of prefix exist by the current node. Insert: insert into trie and update the cnt for each ending character node. Query: just search from the root of the trie and traverse through the last level of the trie, because all the nodes from root has a count that represent the occurance of word that is ended with node character.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020-round-a/#code_3","text":"#include <bits/stdc++.h> using namespace std; #define endl \"\\n\" #define int long long const int N = 1e5 + 5 ; typedef struct data { data * bit[ 26 ]; int cnt = 0 ; }trie; trie * head; void insert (string & s) { trie * cur = head; for ( auto & it :s) { int b = it - 'A' ; if ( ! cur -> bit[b]) cur -> bit[b] = new trie(); // create new node if not exist cur = cur -> bit[b]; // proceed through next character cur -> cnt ++ ; // end with current character } } int n, k; string s[N]; int query (trie * cur) { if ( ! cur) return 0 ; int ans = (cur -> cnt / k); // there are k words each, so there are k times repeat counts for ( int i = 0 ; i <= 25 ; i ++ ) if (cur -> bit[i]) ans += query(cur -> bit[i]); // proceeds to next level and check the count return ans; } int main () { int t; cin >> t; int tc = 0 ; while (t -- ) { head = new trie(); tc ++ ; cin >> n >> k; for ( int i = 1 ; i <= n; i ++ ) { cin >> s[i]; insert(s[i]); } int ans = query(head); cout << \"Case #\" << tc << \": \" << ans << endl; } return 0 ; }","title":"Code"},{"location":"Google%20Kick%20Start/2020-round-b/","text":"2020 Round B \u00b6 Bike Tour \u00b6 Problem Li has planned a bike tour through the mountains of Switzerland. His tour consists of N checkpoints, numbered from 1 to N in the order he will visit them. The i-th checkpoint has a height of Hi. A checkpoint is a peak if: It is not the 1 st checkpoint or the N-th checkpoint, and The height of the checkpoint is strictly greater than the checkpoint immediately before it and the checkpoint immediately after it. Please help Li find out the number of peaks. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Hi. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of peaks in Li's bike tour. Limits Time limit: 10 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 Hi \u2264 100. Test set 1 3 \u2264 N \u2264 5. Test set 2 3 \u2264 N \u2264 100. Sample Input Output 4 3 10 20 14 4 7 7 7 7 5 10 90 20 90 10 3 10 3 10 Case #1: 1 Case #2: 0 Case #3: 2 Case #4: 0 In sample case #1, the 2 nd checkpoint is a peak. In sample case #2, there are no peaks. In sample case #3, the 2 nd and 4 th checkpoint are peaks. In sample case #4, there are no peaks. Analysis \u00b6 In order to satisfy the requirement, on a peak, it has to be greater than two neighbours points -> it turns out we can just check for every points between 1 to n - 1, if nums[i] > nums[i - 1] && nums[i] > nums[i + 1], then we increment the counter by 1. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 // Problem : Bike Tour // Contest : Google Coding Competitions - Round B 2020 - Kick Start 2020 // URL : https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc8/00000000002d82e6 // Memory Limit : 1024 MB // Time Limit : 10000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) #include <bits/stdc++.h> using namespace std; int nums[ 110 ]; int main () { int T, n; cin >> T; for ( int t = 0 ; t < T; ++ t){ cin >> n; int cnt = 0 ; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; for ( int i = 1 ; i < n - 1 ; ++ i) { if (nums[i] > nums[i - 1 ] && nums[i] > nums[i + 1 ]) cnt ++ ; } printf( \"Case #%d: %d \\n \" , t + 1 , cnt); } } Bus Routes \u00b6 Problem Bucket is planning to make a very long journey across the countryside by bus. Her journey consists of N bus routes, numbered from 1 to N in the order she must take them. The buses themselves are very fast, but do not run often. The i-th bus route only runs every Xi days. More specifically, she can only take the i-th bus on day Xi, 2Xi, 3Xi and so on. Since the buses are very fast, she can take multiple buses on the same day. Bucket must finish her journey by day D, but she would like to start the journey as late as possible. What is the latest day she could take the first bus, and still finish her journey by day D? It is guaranteed that it is possible for Bucket to finish her journey by day D. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and D. Then, another line follows containing N integers, the i-th one is Xi. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the latest day she could take the first bus, and still finish her journey by day D. Limits Time limit: 10 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 Xi \u2264 D. 1 \u2264 N \u2264 1000. It is guaranteed that it is possible for Bucket to finish her journey by day D. Test set 1 1 \u2264 D \u2264 100. Test set 2 1 \u2264 D \u2264 10^12. Sample Input Output 3 3 10 3 7 2 4 100 11 10 5 50 1 1 1 Case #1: 6 Case #2: 99 Case #3: 1 In Sample Case #1, there are N = 3 bus routes and Bucket must arrive by day D = 10. She could: Take the 1 st bus on day 6 (X1 = 3), Take the 2 nd bus on day 7 (X2 = 7) and Take the 3 rd bus on day 8 (X3 = 2). In Sample Case #2, there are N = 4 bus routes and Bucket must arrive by day D = 100. She could: Take the 1 st bus on day 99 (X1 = 11), Take the 2 nd bus on day 100 (X2 = 10), Take the 3 rd bus on day 100 (X3 = 5) and Take the 4 th bus on day 100 (X4 = 50), In Sample Case #3, there is N = 1 bus route and Bucket must arrive by day D = 1. She could: Take the 1 st bus on day 1 (X1 = 1). Analysis \u00b6 Decouple the question: the question is asking from day 1 to day D (could be very big), what is the maximum number that from current number to D, all the num[i] can be divisible. From the example, we can find we can greedy search from day D backward to day 1. However, we can still do faster than that. We can use binary search to decrease the search space by half everytime we find a valid day, say day mid. 1. if day mid works, then we can discard 1 to day mid - 1. 2. if day mid isn't working, then we should discard day mid to day D. Now the problem becomes how to efficiently check if day works. We find if day x won't work for a num[i], the minimal steps to increase x is by adding the modulus reminder to current day. e.g. to make 3 + x divisible by 4, the smallest x is 1 (getting 1 by 4 - 3 % 4). We can do so for all the days from num[0] until to the last nums. Finally, we just need to check if the answer is less or equal than our range. Time: O(log_2{D} \\times n) O(log_2{D} \\times n) Space: O(1) O(1) Code \u00b6 // Problem : Bus Routes // Contest : Google Coding Competitions - Round B 2020 - Kick Start 2020 // URL : // https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc8/00000000002d83bf // Memory Limit : 1024 MB // Time Limit : 10000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) #include <bits/stdc++.h> using namespace std; typedef long long ll; int T, n; ll d; ll num[ 1010 ]; bool works (ll mid) { for ( int i = 0 ; i < n; ++ i) { if (mid % num[i] != 0 ) mid += (num[i] - mid % num[i]); } return mid <= d; } int main () { cin >> T; for ( int t = 1 ; t <= T; ++ t) { cin >> n >> d; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; ll l = 0 , r = d; while (l < r) { ll m = (l + r + 1 ) >> 1 ; if (works(m)) l = m; else r = m - 1 ; } printf( \"Case #%d: %llu \\n \" , t, l); } return 0 ; } Robot Path Decoding \u00b6 Problem Your country's space agency has just landed a rover on a new planet, which can be thought of as a grid of squares containing 109 columns (numbered starting from 1 from west to east) and 109 rows (numbered starting from 1 from north to south). Let (w, h) denote the square in the w-th column and the h-th row. The rover begins on the square (1, 1). The rover can be maneuvered around on the surface of the planet by sending it a program, which is a string of characters representing movements in the four cardinal directions. The robot executes each character of the string in order: N: Move one unit north. S: Move one unit south. E: Move one unit east. W: Move one unit west. There is also a special instruction X(Y), where X is a number between 2 and 9 inclusive and Y is a non-empty subprogram. This denotes that the robot should repeat the subprogram Y a total of X times. For example: 2(NWE) is equivalent to NWENWE. 3(S2(E)) is equivalent to SEESEESEE. EEEE4(N)2(SS) is equivalent to EEEENNNNSSSS. Since the planet is a torus, the first and last columns are adjacent, so moving east from column 109 will move the rover to column 1 and moving south from row 109 will move the rover to row 1. Similarly, moving west from column 1 will move the rover to column 109 and moving north from row 1 will move the rover to row 109. Given a program that the robot will execute, determine the final position of the robot after it has finished all its movements. Input The first line of the input gives the number of test cases, T. T lines follow. Each line contains a single string: the program sent to the rover. Output For each test case, output one line containing Case #x: w h, where x is the test case number (starting from 1) and w h is the final square (w, h) the rover finishes in. Limits Time limit: 10 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. The string represents a valid program. The length of each program is between 1 and 2000 characters inclusive. Test set 1 The total number of moves the robot will make in a single test case is at most 104. Test set 2 No additional constraints. Sample Input 4 SSSEEE N N3(S)N2(E)N 2(3(NW)2(W2(EE)W)) Output Case #1: 4 4 Case #2: 1 1000000000 Case #3: 3 1 Case #4: 3 999999995 In Sample Case #1, the rover moves three units south, then three units east. In Sample Case #2, the rover moves one unit north. Since the planet is a torus, this moves it into row 109. In Sample Case #3, the program given to the rover is equivalent to NSSSNEEN. In Sample Case #4, the program given to the rover is equivalent to NWNWNWWEEEEWWEEEEWNWNWNWWEEEEWWEEEEW. Analysis \u00b6 By observation,","title":"2020 Round B"},{"location":"Google%20Kick%20Start/2020-round-b/#2020-round-b","text":"","title":"2020 Round B"},{"location":"Google%20Kick%20Start/2020-round-b/#bike-tour","text":"Problem Li has planned a bike tour through the mountains of Switzerland. His tour consists of N checkpoints, numbered from 1 to N in the order he will visit them. The i-th checkpoint has a height of Hi. A checkpoint is a peak if: It is not the 1 st checkpoint or the N-th checkpoint, and The height of the checkpoint is strictly greater than the checkpoint immediately before it and the checkpoint immediately after it. Please help Li find out the number of peaks. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Hi. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the number of peaks in Li's bike tour. Limits Time limit: 10 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 Hi \u2264 100. Test set 1 3 \u2264 N \u2264 5. Test set 2 3 \u2264 N \u2264 100. Sample Input Output 4 3 10 20 14 4 7 7 7 7 5 10 90 20 90 10 3 10 3 10 Case #1: 1 Case #2: 0 Case #3: 2 Case #4: 0 In sample case #1, the 2 nd checkpoint is a peak. In sample case #2, there are no peaks. In sample case #3, the 2 nd and 4 th checkpoint are peaks. In sample case #4, there are no peaks.","title":"Bike Tour"},{"location":"Google%20Kick%20Start/2020-round-b/#analysis","text":"In order to satisfy the requirement, on a peak, it has to be greater than two neighbours points -> it turns out we can just check for every points between 1 to n - 1, if nums[i] > nums[i - 1] && nums[i] > nums[i + 1], then we increment the counter by 1. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Google%20Kick%20Start/2020-round-b/#code","text":"// Problem : Bike Tour // Contest : Google Coding Competitions - Round B 2020 - Kick Start 2020 // URL : https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc8/00000000002d82e6 // Memory Limit : 1024 MB // Time Limit : 10000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) #include <bits/stdc++.h> using namespace std; int nums[ 110 ]; int main () { int T, n; cin >> T; for ( int t = 0 ; t < T; ++ t){ cin >> n; int cnt = 0 ; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; for ( int i = 1 ; i < n - 1 ; ++ i) { if (nums[i] > nums[i - 1 ] && nums[i] > nums[i + 1 ]) cnt ++ ; } printf( \"Case #%d: %d \\n \" , t + 1 , cnt); } }","title":"Code"},{"location":"Google%20Kick%20Start/2020-round-b/#bus-routes","text":"Problem Bucket is planning to make a very long journey across the countryside by bus. Her journey consists of N bus routes, numbered from 1 to N in the order she must take them. The buses themselves are very fast, but do not run often. The i-th bus route only runs every Xi days. More specifically, she can only take the i-th bus on day Xi, 2Xi, 3Xi and so on. Since the buses are very fast, she can take multiple buses on the same day. Bucket must finish her journey by day D, but she would like to start the journey as late as possible. What is the latest day she could take the first bus, and still finish her journey by day D? It is guaranteed that it is possible for Bucket to finish her journey by day D. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and D. Then, another line follows containing N integers, the i-th one is Xi. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the latest day she could take the first bus, and still finish her journey by day D. Limits Time limit: 10 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 Xi \u2264 D. 1 \u2264 N \u2264 1000. It is guaranteed that it is possible for Bucket to finish her journey by day D. Test set 1 1 \u2264 D \u2264 100. Test set 2 1 \u2264 D \u2264 10^12. Sample Input Output 3 3 10 3 7 2 4 100 11 10 5 50 1 1 1 Case #1: 6 Case #2: 99 Case #3: 1 In Sample Case #1, there are N = 3 bus routes and Bucket must arrive by day D = 10. She could: Take the 1 st bus on day 6 (X1 = 3), Take the 2 nd bus on day 7 (X2 = 7) and Take the 3 rd bus on day 8 (X3 = 2). In Sample Case #2, there are N = 4 bus routes and Bucket must arrive by day D = 100. She could: Take the 1 st bus on day 99 (X1 = 11), Take the 2 nd bus on day 100 (X2 = 10), Take the 3 rd bus on day 100 (X3 = 5) and Take the 4 th bus on day 100 (X4 = 50), In Sample Case #3, there is N = 1 bus route and Bucket must arrive by day D = 1. She could: Take the 1 st bus on day 1 (X1 = 1).","title":"Bus Routes"},{"location":"Google%20Kick%20Start/2020-round-b/#analysis_1","text":"Decouple the question: the question is asking from day 1 to day D (could be very big), what is the maximum number that from current number to D, all the num[i] can be divisible. From the example, we can find we can greedy search from day D backward to day 1. However, we can still do faster than that. We can use binary search to decrease the search space by half everytime we find a valid day, say day mid. 1. if day mid works, then we can discard 1 to day mid - 1. 2. if day mid isn't working, then we should discard day mid to day D. Now the problem becomes how to efficiently check if day works. We find if day x won't work for a num[i], the minimal steps to increase x is by adding the modulus reminder to current day. e.g. to make 3 + x divisible by 4, the smallest x is 1 (getting 1 by 4 - 3 % 4). We can do so for all the days from num[0] until to the last nums. Finally, we just need to check if the answer is less or equal than our range. Time: O(log_2{D} \\times n) O(log_2{D} \\times n) Space: O(1) O(1)","title":"Analysis"},{"location":"Google%20Kick%20Start/2020-round-b/#code_1","text":"// Problem : Bus Routes // Contest : Google Coding Competitions - Round B 2020 - Kick Start 2020 // URL : // https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc8/00000000002d83bf // Memory Limit : 1024 MB // Time Limit : 10000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) #include <bits/stdc++.h> using namespace std; typedef long long ll; int T, n; ll d; ll num[ 1010 ]; bool works (ll mid) { for ( int i = 0 ; i < n; ++ i) { if (mid % num[i] != 0 ) mid += (num[i] - mid % num[i]); } return mid <= d; } int main () { cin >> T; for ( int t = 1 ; t <= T; ++ t) { cin >> n >> d; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; ll l = 0 , r = d; while (l < r) { ll m = (l + r + 1 ) >> 1 ; if (works(m)) l = m; else r = m - 1 ; } printf( \"Case #%d: %llu \\n \" , t, l); } return 0 ; }","title":"Code"},{"location":"Google%20Kick%20Start/2020-round-b/#robot-path-decoding","text":"Problem Your country's space agency has just landed a rover on a new planet, which can be thought of as a grid of squares containing 109 columns (numbered starting from 1 from west to east) and 109 rows (numbered starting from 1 from north to south). Let (w, h) denote the square in the w-th column and the h-th row. The rover begins on the square (1, 1). The rover can be maneuvered around on the surface of the planet by sending it a program, which is a string of characters representing movements in the four cardinal directions. The robot executes each character of the string in order: N: Move one unit north. S: Move one unit south. E: Move one unit east. W: Move one unit west. There is also a special instruction X(Y), where X is a number between 2 and 9 inclusive and Y is a non-empty subprogram. This denotes that the robot should repeat the subprogram Y a total of X times. For example: 2(NWE) is equivalent to NWENWE. 3(S2(E)) is equivalent to SEESEESEE. EEEE4(N)2(SS) is equivalent to EEEENNNNSSSS. Since the planet is a torus, the first and last columns are adjacent, so moving east from column 109 will move the rover to column 1 and moving south from row 109 will move the rover to row 1. Similarly, moving west from column 1 will move the rover to column 109 and moving north from row 1 will move the rover to row 109. Given a program that the robot will execute, determine the final position of the robot after it has finished all its movements. Input The first line of the input gives the number of test cases, T. T lines follow. Each line contains a single string: the program sent to the rover. Output For each test case, output one line containing Case #x: w h, where x is the test case number (starting from 1) and w h is the final square (w, h) the rover finishes in. Limits Time limit: 10 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. The string represents a valid program. The length of each program is between 1 and 2000 characters inclusive. Test set 1 The total number of moves the robot will make in a single test case is at most 104. Test set 2 No additional constraints. Sample Input 4 SSSEEE N N3(S)N2(E)N 2(3(NW)2(W2(EE)W)) Output Case #1: 4 4 Case #2: 1 1000000000 Case #3: 3 1 Case #4: 3 999999995 In Sample Case #1, the rover moves three units south, then three units east. In Sample Case #2, the rover moves one unit north. Since the planet is a torus, this moves it into row 109. In Sample Case #3, the program given to the rover is equivalent to NSSSNEEN. In Sample Case #4, the program given to the rover is equivalent to NWNWNWWEEEEWWEEEEWNWNWNWWEEEEWWEEEEW.","title":"Robot Path Decoding"},{"location":"Google%20Kick%20Start/2020-round-b/#analysis_2","text":"By observation,","title":"Analysis"},{"location":"Google%20Kick%20Start/past-interview-minesweeper/","text":"Past Interview: Design a Minesweeper \u00b6 https://techdevguide.witgoogle.com/resources/coding-question-minesweeper/#code-challenge Problem Statement \u00b6 Given a matrix: 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 9 1 0 0 1 2 2 1 0 0 1 9 1 0 0 1 1 1 0 where 9 indicates mine, 0 to 8 represents the number of mines in the 8 directions. The game start with a matrix with all \"-\", and if player clicks any position that is 0, it will keep expanding until to all the boundary: 0 0 0 0 0 < clicked this point 0 0 0 0 0 1 1 1 0 0 - - 1 0 0 - - 2 1 0 - - - 1 0 - - - 1 0 You are given a Matrix class: template < typename T > class Matrix { void resize ( int rows, int cols); T & at ( int row, int col); int rows (); int cols (); }; Your task is to design the play function. Analysis \u00b6 construct the initial matrix: to start with the initial configuration, we need some considerations for the number of mines m and the matrix size n . An important part of this question is figuring out a way to place the mines. The most naive implementation is to pick two random numbers (row and column) and place a mine there, but this will cause the board to have less mines than expected if the same coordinates are picked twice. Re-trying if the picked coordinates already have a mine fixes the immediate problem, but will take a very long time for cases such as a 100x100 board with 9999 mines. mimic user play: for each spot, there are three states: visable or not -> mine or not -> 0 (need to keep expanding) or 1 to 8 for the 0 case, we can use recursion to do the expanding. Code: link \u00b6 #include <stdlib.h> #include <iostream> #include <vector> template < typename T > class Matrix { public : void resize( int rows, int cols) { data_.resize(rows * cols); rows_ = rows; cols_ = cols; } T & at( int row, int col) { return data_.at(row * cols_ + col); } int rows() const { return rows_; } int cols() const { return cols_; } private : std :: vector < T > data_; int rows_ = 0 ; int cols_ = 0 ; }; constexpr int kMine = 9 ; using std :: min; using std :: max; class MineField { private : struct Cell { int value = 0 ; bool visible = false ; }; Matrix < Cell > field; public : MineField( int rows, int cols, int num_mines) { field.resize(rows, cols); int mines_placed = 0 ; while (mines_placed < num_mines) { int row = rand() % rows; int col = rand() % cols; if (field.at(row, col).value == kMine) { continue ; } mines_placed ++ ; for ( int i = max( 0 , row - 1 ); i <= min(rows - 1 , row + 1 ); ++ i) { for ( int j = max( 0 , col - 1 ); j <= min(cols - 1 , col + 1 ); ++ j) { if (i == row && j == col) { field.at(i, j).value = kMine; } else if (field.at(i, j).value != kMine) { field.at(i, j).value ++ ; } } } } } bool OnClick( int row, int col) { if (row < 0 || row >= field.rows() || col < 0 || col >= field.cols()) { return false ; } if (field.at(row, col).visible) { return false ; } field.at(row, col).visible = true ; if (field.at(row, col).value == kMine) { std :: cout << \"BOOM!\" << std :: endl << std :: endl; return true ; } if (field.at(row, col).value != 0 ) { return false ; } OnClick(row - 1 , col); OnClick(row + 1 , col); OnClick(row, col - 1 ); OnClick(row, col + 1 ); return false ; } void Print( bool show_hidden) { for ( int i = 0 ; i < field.rows(); ++ i) { for ( int j = 0 ; j < field.cols(); ++ j) { if (field.at(i, j).visible || show_hidden) { std :: cout << field.at(i, j).value << \" \" ; } else { std :: cout << \". \" ; } } std :: cout << std :: endl; } std :: cout << std :: endl; } }; int main () { srand( 1 ); MineField mine_field( 10 , 10 , 7 ); mine_field.Print( true ); mine_field.OnClick( 5 , 1 ); mine_field.Print( false ); mine_field.OnClick( 2 , 6 ); mine_field.Print( false ); mine_field.OnClick( 9 , 3 ); mine_field.Print( false ); mine_field.OnClick( 0 , 0 ); mine_field.Print( false ); mine_field.OnClick( 3 , 5 ); mine_field.Print( false ); return 0 ; }","title":"Past Interview: Design a Minesweeper"},{"location":"Google%20Kick%20Start/past-interview-minesweeper/#past-interview-design-a-minesweeper","text":"https://techdevguide.witgoogle.com/resources/coding-question-minesweeper/#code-challenge","title":"Past Interview: Design a Minesweeper"},{"location":"Google%20Kick%20Start/past-interview-minesweeper/#problem-statement","text":"Given a matrix: 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 9 1 0 0 1 2 2 1 0 0 1 9 1 0 0 1 1 1 0 where 9 indicates mine, 0 to 8 represents the number of mines in the 8 directions. The game start with a matrix with all \"-\", and if player clicks any position that is 0, it will keep expanding until to all the boundary: 0 0 0 0 0 < clicked this point 0 0 0 0 0 1 1 1 0 0 - - 1 0 0 - - 2 1 0 - - - 1 0 - - - 1 0 You are given a Matrix class: template < typename T > class Matrix { void resize ( int rows, int cols); T & at ( int row, int col); int rows (); int cols (); }; Your task is to design the play function.","title":"Problem Statement"},{"location":"Google%20Kick%20Start/past-interview-minesweeper/#analysis","text":"construct the initial matrix: to start with the initial configuration, we need some considerations for the number of mines m and the matrix size n . An important part of this question is figuring out a way to place the mines. The most naive implementation is to pick two random numbers (row and column) and place a mine there, but this will cause the board to have less mines than expected if the same coordinates are picked twice. Re-trying if the picked coordinates already have a mine fixes the immediate problem, but will take a very long time for cases such as a 100x100 board with 9999 mines. mimic user play: for each spot, there are three states: visable or not -> mine or not -> 0 (need to keep expanding) or 1 to 8 for the 0 case, we can use recursion to do the expanding.","title":"Analysis"},{"location":"Google%20Kick%20Start/past-interview-minesweeper/#code-link","text":"#include <stdlib.h> #include <iostream> #include <vector> template < typename T > class Matrix { public : void resize( int rows, int cols) { data_.resize(rows * cols); rows_ = rows; cols_ = cols; } T & at( int row, int col) { return data_.at(row * cols_ + col); } int rows() const { return rows_; } int cols() const { return cols_; } private : std :: vector < T > data_; int rows_ = 0 ; int cols_ = 0 ; }; constexpr int kMine = 9 ; using std :: min; using std :: max; class MineField { private : struct Cell { int value = 0 ; bool visible = false ; }; Matrix < Cell > field; public : MineField( int rows, int cols, int num_mines) { field.resize(rows, cols); int mines_placed = 0 ; while (mines_placed < num_mines) { int row = rand() % rows; int col = rand() % cols; if (field.at(row, col).value == kMine) { continue ; } mines_placed ++ ; for ( int i = max( 0 , row - 1 ); i <= min(rows - 1 , row + 1 ); ++ i) { for ( int j = max( 0 , col - 1 ); j <= min(cols - 1 , col + 1 ); ++ j) { if (i == row && j == col) { field.at(i, j).value = kMine; } else if (field.at(i, j).value != kMine) { field.at(i, j).value ++ ; } } } } } bool OnClick( int row, int col) { if (row < 0 || row >= field.rows() || col < 0 || col >= field.cols()) { return false ; } if (field.at(row, col).visible) { return false ; } field.at(row, col).visible = true ; if (field.at(row, col).value == kMine) { std :: cout << \"BOOM!\" << std :: endl << std :: endl; return true ; } if (field.at(row, col).value != 0 ) { return false ; } OnClick(row - 1 , col); OnClick(row + 1 , col); OnClick(row, col - 1 ); OnClick(row, col + 1 ); return false ; } void Print( bool show_hidden) { for ( int i = 0 ; i < field.rows(); ++ i) { for ( int j = 0 ; j < field.cols(); ++ j) { if (field.at(i, j).visible || show_hidden) { std :: cout << field.at(i, j).value << \" \" ; } else { std :: cout << \". \" ; } } std :: cout << std :: endl; } std :: cout << std :: endl; } }; int main () { srand( 1 ); MineField mine_field( 10 , 10 , 7 ); mine_field.Print( true ); mine_field.OnClick( 5 , 1 ); mine_field.Print( false ); mine_field.OnClick( 2 , 6 ); mine_field.Print( false ); mine_field.OnClick( 9 , 3 ); mine_field.Print( false ); mine_field.OnClick( 0 , 0 ); mine_field.Print( false ); mine_field.OnClick( 3 , 5 ); mine_field.Print( false ); return 0 ; }","title":"Code: link"},{"location":"Interview/Internet%20Protocol/","text":"Internet Protocol (\u8ba1\u7b97\u673a\u7f51\u7edc) \u00b6 https://www.guru99.com/router-vs-switch-difference.html#:~:text=Router%20operations%20revolve%20around%20IP,restricted%20to%20wired%20network%20connections . How Router Works? \u00b6 A router connects multiple networks and tracks network traffic between them. It has one connection to the internet and one connection to your private local network. Moreover, many routers contain built-in switches that allow you to connect multiple wired devices. Many routers also contain wireless radios that allows you to connect Wi-Fi devices. How Switch work? \u00b6 A network switch is also called bridging hub, switching, or MAC bridge. Switches devices use MAC addresses to forward data to the right destination. Operating system at the data link layer uses packet switching to receive, process, and forward data. A switch offers support to handle the data and knows the particular addresses to send the message. It can decide which computer is the message intended for and send the message directly to the right computer. The efficiency of the switch can be improved by providing a faster network speed. Difference between Router and Switch \u00b6 Here are some important differences between the Router and Switch: Router Switch Routers operate at Layer 3 (Network) of the OSI model. Network switches operate at layer two (Data Link Layer) of the OSI model. Router will offer NAT, NetFlow and QoS Services Switch will not offer such services. Store IP address in the routing table and maintain an address on its own. Store MAC address in a lookup table and maintain an address on its own. However, Switch can learn the MAC address. Networking device 2/4/8 ports. A switch is a multi-port bridge. 24/48 ports. Less Duplex In Full Duplex, So, no Collision occurs. The speed limit is 1-10 Mbps for wireless and 100 Mbps for wired connection. The speed limit for the switch is 10/100Mbps. Helps users to take the faster routing decision Likely to take a more complicated routing decision The router can perform NAT Switches can't perform NAT In various types of network environments (MAN/ WAN), the router works faster compares to Switch. In a LAN environment, a switch is faster than Router. In Router, every port has its own broadcast domain. The switch has one broadcast domain except VLAN implemented. Router operations revolve around IP Addresses. Switches work with MAC addresses as it operates within the confines of a single network. Routers can work within both wired and wireless network situations. Switches are restricted to wired network connections.","title":"Internet Protocol (\u8ba1\u7b97\u673a\u7f51\u7edc)"},{"location":"Interview/Internet%20Protocol/#internet-protocol","text":"https://www.guru99.com/router-vs-switch-difference.html#:~:text=Router%20operations%20revolve%20around%20IP,restricted%20to%20wired%20network%20connections .","title":"Internet Protocol (\u8ba1\u7b97\u673a\u7f51\u7edc)"},{"location":"Interview/Internet%20Protocol/#how-router-works","text":"A router connects multiple networks and tracks network traffic between them. It has one connection to the internet and one connection to your private local network. Moreover, many routers contain built-in switches that allow you to connect multiple wired devices. Many routers also contain wireless radios that allows you to connect Wi-Fi devices.","title":"How Router Works?"},{"location":"Interview/Internet%20Protocol/#how-switch-work","text":"A network switch is also called bridging hub, switching, or MAC bridge. Switches devices use MAC addresses to forward data to the right destination. Operating system at the data link layer uses packet switching to receive, process, and forward data. A switch offers support to handle the data and knows the particular addresses to send the message. It can decide which computer is the message intended for and send the message directly to the right computer. The efficiency of the switch can be improved by providing a faster network speed.","title":"How Switch work?"},{"location":"Interview/Internet%20Protocol/#difference-between-router-and-switch","text":"Here are some important differences between the Router and Switch: Router Switch Routers operate at Layer 3 (Network) of the OSI model. Network switches operate at layer two (Data Link Layer) of the OSI model. Router will offer NAT, NetFlow and QoS Services Switch will not offer such services. Store IP address in the routing table and maintain an address on its own. Store MAC address in a lookup table and maintain an address on its own. However, Switch can learn the MAC address. Networking device 2/4/8 ports. A switch is a multi-port bridge. 24/48 ports. Less Duplex In Full Duplex, So, no Collision occurs. The speed limit is 1-10 Mbps for wireless and 100 Mbps for wired connection. The speed limit for the switch is 10/100Mbps. Helps users to take the faster routing decision Likely to take a more complicated routing decision The router can perform NAT Switches can't perform NAT In various types of network environments (MAN/ WAN), the router works faster compares to Switch. In a LAN environment, a switch is faster than Router. In Router, every port has its own broadcast domain. The switch has one broadcast domain except VLAN implemented. Router operations revolve around IP Addresses. Switches work with MAC addresses as it operates within the confines of a single network. Routers can work within both wired and wireless network situations. Switches are restricted to wired network connections.","title":"Difference between Router and Switch"},{"location":"Interview/all-valid-permutations-of-parentheses/","text":"All Vaid Permutation of Parentheses \u00b6 Get all valid permutations of l pairs of (), m pairs of <> and n pairs of {}, subject to the priority restriction: {} higher than <> higher than (). Assumptions l, m, n >= 0 l + m + n >= 0 Examples l = 1, m = 1, n = 0, all the valid permutations are [\"()<>\", \"<()>\", \"<>()\"]. l = 2, m = 0, n = 1, all the valid permutations are [\u201c()(){}\u201d, \u201c(){()}\u201d, \u201c(){}()\u201d, \u201c{()()}\u201d, \u201c{()}()\u201d, \u201c{}()()\u201d]. Analysis \u00b6 Use a stack to preserve the priority (lower index means lower priority, and higher priority parenthese should surround the lower priority parenthese). check if is open parenthese if yes, check if is enclosed by higher priority (or empty) and push into the stack if no, check if previous one is the corresponding open parenthese and delete the previous open parenthese index from stack Java Code \u00b6 public class Solution { private static final char [] PS = new char [] { '(' , ')' , '<' , '>' , '{' , '}' }; public List < String > validParenthesesIII ( int l, int m, int n) { int [] remain = new int [] {l, l, m, m, n, n}; int targetLen = 2 * l + 2 * m + 2 * n; StringBuilder cur = new StringBuilder(); Deque < Integer > stack = new LinkedList < Integer > (); List < String > result = new ArrayList < String > (); helper(cur, stack, remain, targetLen, result); return result; } private void helper (StringBuilder cur, Deque < Integer > stack, int [] remain, int targetLen, List < String > result) { // need to use all parentheses if (cur. length () == targetLen) { result. add (cur. toString ()); return ; } for ( int i = 0 ; i < remain. length ; ++ i) { if (i % 2 == 0 ) { // ( < or { // top of stack has a lower priority -> need to be surrounded by higher priority parenthese if (remain [ i ] > 0 && (stack. isEmpty () || stack. peekFirst () > i)) { cur. append (PS [ i ] ); stack. offerFirst (i); remain [ i ]-- ; helper(cur, stack, remain, targetLen, result); cur. deleteCharAt (cur. length () - 1 ); stack. pollFirst (); remain [ i ]++ ; } } else { // ) > or } // only update the cur if previous / top of the stack is the corresponding open parentheses if ( ! stack. isEmpty () && stack. peekFirst () == i - 1 ) { cur. append (PS [ i ] ); stack. pollFirst (); remain [ i ]-- ; helper(cur, stack, remain, targetLen, result); cur. deleteCharAt (cur. length () - 1 ); stack. offerFirst (i - 1 ); remain [ i ]++ ; } } } } }","title":"All Vaid Permutation of Parentheses"},{"location":"Interview/all-valid-permutations-of-parentheses/#all-vaid-permutation-of-parentheses","text":"Get all valid permutations of l pairs of (), m pairs of <> and n pairs of {}, subject to the priority restriction: {} higher than <> higher than (). Assumptions l, m, n >= 0 l + m + n >= 0 Examples l = 1, m = 1, n = 0, all the valid permutations are [\"()<>\", \"<()>\", \"<>()\"]. l = 2, m = 0, n = 1, all the valid permutations are [\u201c()(){}\u201d, \u201c(){()}\u201d, \u201c(){}()\u201d, \u201c{()()}\u201d, \u201c{()}()\u201d, \u201c{}()()\u201d].","title":"All Vaid Permutation of Parentheses"},{"location":"Interview/all-valid-permutations-of-parentheses/#analysis","text":"Use a stack to preserve the priority (lower index means lower priority, and higher priority parenthese should surround the lower priority parenthese). check if is open parenthese if yes, check if is enclosed by higher priority (or empty) and push into the stack if no, check if previous one is the corresponding open parenthese and delete the previous open parenthese index from stack","title":"Analysis"},{"location":"Interview/all-valid-permutations-of-parentheses/#java-code","text":"public class Solution { private static final char [] PS = new char [] { '(' , ')' , '<' , '>' , '{' , '}' }; public List < String > validParenthesesIII ( int l, int m, int n) { int [] remain = new int [] {l, l, m, m, n, n}; int targetLen = 2 * l + 2 * m + 2 * n; StringBuilder cur = new StringBuilder(); Deque < Integer > stack = new LinkedList < Integer > (); List < String > result = new ArrayList < String > (); helper(cur, stack, remain, targetLen, result); return result; } private void helper (StringBuilder cur, Deque < Integer > stack, int [] remain, int targetLen, List < String > result) { // need to use all parentheses if (cur. length () == targetLen) { result. add (cur. toString ()); return ; } for ( int i = 0 ; i < remain. length ; ++ i) { if (i % 2 == 0 ) { // ( < or { // top of stack has a lower priority -> need to be surrounded by higher priority parenthese if (remain [ i ] > 0 && (stack. isEmpty () || stack. peekFirst () > i)) { cur. append (PS [ i ] ); stack. offerFirst (i); remain [ i ]-- ; helper(cur, stack, remain, targetLen, result); cur. deleteCharAt (cur. length () - 1 ); stack. pollFirst (); remain [ i ]++ ; } } else { // ) > or } // only update the cur if previous / top of the stack is the corresponding open parentheses if ( ! stack. isEmpty () && stack. peekFirst () == i - 1 ) { cur. append (PS [ i ] ); stack. pollFirst (); remain [ i ]-- ; helper(cur, stack, remain, targetLen, result); cur. deleteCharAt (cur. length () - 1 ); stack. offerFirst (i - 1 ); remain [ i ]++ ; } } } } }","title":"Java Code"},{"location":"Interview/array/","text":"Array Deduplication 1 \u00b6 Given a sorted integer array, remove duplicate elements. For each group of elements with the same value keep only one of them. Do this in-place, using the left side of the original array and maintain the relative order of the elements of the array. Return the array after deduplication. {1, 2, 2, 3, 3, 3} \u2192 {1, 2, 3} keep one if there is a duplication Analysis \u00b6 idx: (0, idx] is the processed array (return array[0:idx]) condition 1: check if equal to previous element condition 2: put the non-duplicated element into the correct spot Code \u00b6 class Solution { public : vector < int > dedup(vector < int > array) { // write your solution here if (array.empty()) return {}; int idx = 1 ; for ( int i = 1 ; i < array.size(); ++ i) { if (array[i] == array[i - 1 ]) continue ; array[idx ++ ] = array[i]; // 1,2,2: first 2 will be placed but not the second 2 } return vector < int > (array.begin(), array.begin() + idx); } }; Array Deduplication 2 \u00b6 Given a sorted integer array, remove duplicate elements. For each group of elements with the same value keep at most two of them. Do this in-place, using the left side of the original array and maintain the relative order of the elements of the array. Return the array after deduplication. {1, 2, 2, 3, 3, 3} \u2192 {1, 2, 2, 3, 3} keep two duplicated Analysis \u00b6 idx: (0, idx] is the processed array (return array[0:idx]) condition 1: check if equal to last two from the top of the stack condition 2: put the non-duplicated element into the correct spot e.g. {1,2,2,3,3,3} i = 2 => 1, 2, 2 (keep second 2, since i - 2 = 0 -> num[0] != num[2]) i = 5 => 1, 2, 2, 3, 3 (discard the third 3, since i - 2 = 3 -> num[3] == num[5]) Code \u00b6 class Solution { public : vector < int > dedup(vector < int > array) { // write your solution here if (array.size() <= 2 ) return array; int j = 2 ; for ( int i = 2 ; i < array.size(); ++ i) { if (array[i] != array[j - 2 ]) continue ; else array[j ++ ] = array[i]; } return vector < int > (array.begin(), array.begin() + j); } }; Array Deduplication 3 \u00b6 Given a sorted integer array, remove duplicate elements. For each group of elements with the same value do not keep any of them . Do this in-place, using the left side of the original array and and maintain the relative order of the elements of the array. Return the array after deduplication. {1, 2, 2, 3, 3, 3} \u2192 {1} {1,1,2,3,3,5,5,5,2} -> {2,2} Analysis \u00b6 If the top of stack is equal to current element, set the flag to true AND don't update the stack. If the flag is true and current element isn't the same as the top of the stack, unset the flag and use the current element as the new top of the stack, since the old top has a duplicated element already. If the current element isn't equal to the top of stack and the flag isn't true, we can normally proceed it to put the current element at the top of the stack. The meaning of flag is for checking any ongoing element other than current duplicated element on the stack, we keep it on the stack temporarily and replace it with the first element that is not equal to the duplicated element. Finally, if the flag is true, it means we should discard the last element since it is duplicate but we still keep it on the stack. Code \u00b6 class Solution { public : vector < int > dedup(vector < int > array) { // write your solution here if (array.size() <= 1 ) return array; int j = 0 ; bool flag = false ; for ( int i = 1 ; i < array.size(); ++ i) { if (array[i] == array[j]) flag = true ; else if (flag) { array[j] = array[i]; flag = false ; } else array[ ++ j] = array[i]; } if (flag) j -- ; return vector < int > (array.begin(), array.begin() + j + 1 ); } }; Array Deduplication 4 \u00b6 Given an unsorted integer array, remove adjacent duplicate elements repeatedly, from left to right. For each group of elements with the same value do not keep any of them. Do this in-place, using the left side of the original array. Return the array after deduplication. Assumptions The given array is not null Examples {1, 2, 3, 3, 3, 2, 2} \u2192 {1, 2, 2, 2} \u2192 {1}, return {1} Analysis \u00b6 Now the job is consectively deduplicate with the top of the stack. check if current top is equal to current element, if not equal, put the current element onto the stack. if equal to the top, then we need to consectively deduplicate the same adjacent elements, and pop the element from the top of the stack ( slow-- ). Code \u00b6 class Solution { public : vector < int > dedup(vector < int > a) { int slow = 0 , fast = 0 , n = a.size(); while (fast < n) { if (slow == 0 || a[slow - 1 ] != a[fast]) a[slow ++ ] = a[fast ++ ]; else { int curr = fast + 1 ; while (curr < n && a[curr] == a[fast]) curr ++ ; slow -- ; fast = curr; } } return vector < int > (a.begin(), a.begin() + slow); } };","title":"Array"},{"location":"Interview/array/#array-deduplication-1","text":"Given a sorted integer array, remove duplicate elements. For each group of elements with the same value keep only one of them. Do this in-place, using the left side of the original array and maintain the relative order of the elements of the array. Return the array after deduplication. {1, 2, 2, 3, 3, 3} \u2192 {1, 2, 3} keep one if there is a duplication","title":"Array Deduplication 1"},{"location":"Interview/array/#analysis","text":"idx: (0, idx] is the processed array (return array[0:idx]) condition 1: check if equal to previous element condition 2: put the non-duplicated element into the correct spot","title":"Analysis"},{"location":"Interview/array/#code","text":"class Solution { public : vector < int > dedup(vector < int > array) { // write your solution here if (array.empty()) return {}; int idx = 1 ; for ( int i = 1 ; i < array.size(); ++ i) { if (array[i] == array[i - 1 ]) continue ; array[idx ++ ] = array[i]; // 1,2,2: first 2 will be placed but not the second 2 } return vector < int > (array.begin(), array.begin() + idx); } };","title":"Code"},{"location":"Interview/array/#array-deduplication-2","text":"Given a sorted integer array, remove duplicate elements. For each group of elements with the same value keep at most two of them. Do this in-place, using the left side of the original array and maintain the relative order of the elements of the array. Return the array after deduplication. {1, 2, 2, 3, 3, 3} \u2192 {1, 2, 2, 3, 3} keep two duplicated","title":"Array Deduplication 2"},{"location":"Interview/array/#analysis_1","text":"idx: (0, idx] is the processed array (return array[0:idx]) condition 1: check if equal to last two from the top of the stack condition 2: put the non-duplicated element into the correct spot e.g. {1,2,2,3,3,3} i = 2 => 1, 2, 2 (keep second 2, since i - 2 = 0 -> num[0] != num[2]) i = 5 => 1, 2, 2, 3, 3 (discard the third 3, since i - 2 = 3 -> num[3] == num[5])","title":"Analysis"},{"location":"Interview/array/#code_1","text":"class Solution { public : vector < int > dedup(vector < int > array) { // write your solution here if (array.size() <= 2 ) return array; int j = 2 ; for ( int i = 2 ; i < array.size(); ++ i) { if (array[i] != array[j - 2 ]) continue ; else array[j ++ ] = array[i]; } return vector < int > (array.begin(), array.begin() + j); } };","title":"Code"},{"location":"Interview/array/#array-deduplication-3","text":"Given a sorted integer array, remove duplicate elements. For each group of elements with the same value do not keep any of them . Do this in-place, using the left side of the original array and and maintain the relative order of the elements of the array. Return the array after deduplication. {1, 2, 2, 3, 3, 3} \u2192 {1} {1,1,2,3,3,5,5,5,2} -> {2,2}","title":"Array Deduplication 3"},{"location":"Interview/array/#analysis_2","text":"If the top of stack is equal to current element, set the flag to true AND don't update the stack. If the flag is true and current element isn't the same as the top of the stack, unset the flag and use the current element as the new top of the stack, since the old top has a duplicated element already. If the current element isn't equal to the top of stack and the flag isn't true, we can normally proceed it to put the current element at the top of the stack. The meaning of flag is for checking any ongoing element other than current duplicated element on the stack, we keep it on the stack temporarily and replace it with the first element that is not equal to the duplicated element. Finally, if the flag is true, it means we should discard the last element since it is duplicate but we still keep it on the stack.","title":"Analysis"},{"location":"Interview/array/#code_2","text":"class Solution { public : vector < int > dedup(vector < int > array) { // write your solution here if (array.size() <= 1 ) return array; int j = 0 ; bool flag = false ; for ( int i = 1 ; i < array.size(); ++ i) { if (array[i] == array[j]) flag = true ; else if (flag) { array[j] = array[i]; flag = false ; } else array[ ++ j] = array[i]; } if (flag) j -- ; return vector < int > (array.begin(), array.begin() + j + 1 ); } };","title":"Code"},{"location":"Interview/array/#array-deduplication-4","text":"Given an unsorted integer array, remove adjacent duplicate elements repeatedly, from left to right. For each group of elements with the same value do not keep any of them. Do this in-place, using the left side of the original array. Return the array after deduplication. Assumptions The given array is not null Examples {1, 2, 3, 3, 3, 2, 2} \u2192 {1, 2, 2, 2} \u2192 {1}, return {1}","title":"Array Deduplication 4"},{"location":"Interview/array/#analysis_3","text":"Now the job is consectively deduplicate with the top of the stack. check if current top is equal to current element, if not equal, put the current element onto the stack. if equal to the top, then we need to consectively deduplicate the same adjacent elements, and pop the element from the top of the stack ( slow-- ).","title":"Analysis"},{"location":"Interview/array/#code_3","text":"class Solution { public : vector < int > dedup(vector < int > a) { int slow = 0 , fast = 0 , n = a.size(); while (fast < n) { if (slow == 0 || a[slow - 1 ] != a[fast]) a[slow ++ ] = a[fast ++ ]; else { int curr = fast + 1 ; while (curr < n && a[curr] == a[fast]) curr ++ ; slow -- ; fast = curr; } } return vector < int > (a.begin(), a.begin() + slow); } };","title":"Code"},{"location":"Interview/balanced-search-trees/","text":"Balanced Search Trees \u00b6 2-3 tree \u00b6 Each node can either have 2 or 3 children (so it's not a binary tree) AND all leaves are at the same level The 2-3 Tree properties must always hold after we are done with the operation, so that the tree remains balanced. Thus, we must ensure that all leaves are at the same level, two-key nodes have three children, one-key nodes have two children, and we can\u2019t have any number other than 1 or 2 keys in one node. Note that each node can have either 1 (with 2 children) value or 2 (with 3 children) values. See illustration: Define a 2-3 tree \u00b6 #ifndef _TRI_NODE #define _TRI_NODE template < class ItemType > class TriNode { private : ItemType smallItem, largeItem; // Data portion TriNode < ItemType >* leftChildPtr; TriNode < ItemType >* midChildPtr; TriNode < ItemType >* rightChildPtr; public : TriNode(); TriNode( const ItemType & anItem); TriNode( const ItemType & anItem, TriNode < ItemType >* leftPtr, TriNode < ItemType >* midPtr, TriNode < ItemType >* rightPtr); bool isLeaf () const ; bool isTwoNode () const ; bool isThreeNode () const ; ItemType getSmallItem () const ; ItemType getLargeItem () const ; void setSamllItem ( const ItemType & anItem); void setLargeItem ( const ItemType & anItem); TriNode < ItemType >* getLeftChildPtr() const ; TriNode < ItemType >* getMidChildPtr() const ; TriNode < ItemType >* getRightChildPtr() const ; void setLeftChildPtr (TriNode < ItemType >* leftPtr); void setMidChildPtr (TriNode < ItemType >* midPtr); void setRightChildPtr (TriNode < ItemType >* rightPtr); }; // end TriNode #include \"TriNode\" #endif Insertion \u00b6 check if the place to be inserted is single node, if yes, make it to two nodes if it is already two nodes, promote the middle node to its parent if parent is full, recursively promote to its parent again if current node after promote (will always create an additional node for current parent) has more than the nodes it could have on the current level, split the root into two parts: left and right, and the mid will be promoted to its parent again. psuedo code Insert 39: Insert 38: Deletion \u00b6 psuedo code Traverse \u00b6 // Traverses a nonempty 2-3 tree in sorted order. inorder( 23 Tree : TwoThreeTree) : void if ( 23 Tree \u2019 s root node r is a leaf) Visit the data item(s) else if (r has two data items) { inorder(left subtree of 23 Tree \u2019 s root) Visit the first data item inorder(middle subtree of 23 Tree \u2019 s root) Visit the second data item inorder(right subtree of 23 Tree \u2019 s root) } else // r has one data item { inorder(left subtree of 23 Tree \u2019 s root) Visit the data item inorder(right subtree of 23 Tree \u2019 s root) }","title":"Balanced Search Trees"},{"location":"Interview/balanced-search-trees/#balanced-search-trees","text":"","title":"Balanced Search Trees"},{"location":"Interview/balanced-search-trees/#2-3-tree","text":"Each node can either have 2 or 3 children (so it's not a binary tree) AND all leaves are at the same level The 2-3 Tree properties must always hold after we are done with the operation, so that the tree remains balanced. Thus, we must ensure that all leaves are at the same level, two-key nodes have three children, one-key nodes have two children, and we can\u2019t have any number other than 1 or 2 keys in one node. Note that each node can have either 1 (with 2 children) value or 2 (with 3 children) values. See illustration:","title":"2-3 tree"},{"location":"Interview/balanced-search-trees/#define-a-2-3-tree","text":"#ifndef _TRI_NODE #define _TRI_NODE template < class ItemType > class TriNode { private : ItemType smallItem, largeItem; // Data portion TriNode < ItemType >* leftChildPtr; TriNode < ItemType >* midChildPtr; TriNode < ItemType >* rightChildPtr; public : TriNode(); TriNode( const ItemType & anItem); TriNode( const ItemType & anItem, TriNode < ItemType >* leftPtr, TriNode < ItemType >* midPtr, TriNode < ItemType >* rightPtr); bool isLeaf () const ; bool isTwoNode () const ; bool isThreeNode () const ; ItemType getSmallItem () const ; ItemType getLargeItem () const ; void setSamllItem ( const ItemType & anItem); void setLargeItem ( const ItemType & anItem); TriNode < ItemType >* getLeftChildPtr() const ; TriNode < ItemType >* getMidChildPtr() const ; TriNode < ItemType >* getRightChildPtr() const ; void setLeftChildPtr (TriNode < ItemType >* leftPtr); void setMidChildPtr (TriNode < ItemType >* midPtr); void setRightChildPtr (TriNode < ItemType >* rightPtr); }; // end TriNode #include \"TriNode\" #endif","title":"Define a 2-3 tree"},{"location":"Interview/balanced-search-trees/#insertion","text":"check if the place to be inserted is single node, if yes, make it to two nodes if it is already two nodes, promote the middle node to its parent if parent is full, recursively promote to its parent again if current node after promote (will always create an additional node for current parent) has more than the nodes it could have on the current level, split the root into two parts: left and right, and the mid will be promoted to its parent again. psuedo code Insert 39: Insert 38:","title":"Insertion"},{"location":"Interview/balanced-search-trees/#deletion","text":"psuedo code","title":"Deletion"},{"location":"Interview/balanced-search-trees/#traverse","text":"// Traverses a nonempty 2-3 tree in sorted order. inorder( 23 Tree : TwoThreeTree) : void if ( 23 Tree \u2019 s root node r is a leaf) Visit the data item(s) else if (r has two data items) { inorder(left subtree of 23 Tree \u2019 s root) Visit the first data item inorder(middle subtree of 23 Tree \u2019 s root) Visit the second data item inorder(right subtree of 23 Tree \u2019 s root) } else // r has one data item { inorder(left subtree of 23 Tree \u2019 s root) Visit the data item inorder(right subtree of 23 Tree \u2019 s root) }","title":"Traverse"},{"location":"Interview/behavior-questions/","text":"Behavior Questions \u00b6 Rule of thumb \u00b6 Don't confront your interviewers How to talk when you have nothing to say, say nothing never criticize your previous employers calm and reasonable Say something for a reason Praise someone Criticie someone (how?) CART: clarify, assumption, result, test cases Q1: tell me about yourself \u00b6 Don't just say yourself Name, edu Skills: primary programming language, projects, experiences, past internship. Thank you Other variants: - tell me your weakness (e.g. weakness: cannot do multiple things at the same time. in the future, learn how to prioritize and analyze dependencies.) - 2 nd chance problems - Retrospection - E.g. Biggest failure during your college/work - Key points: how to avoid/address the same problems in the future. Q2: when you have different opinions from your colleagues \u00b6 Scenarios Communication how when where keep in mind: say something for a reason, praise and criticize someone what if? backup solutions how to express yourself? (e.g. how to do prep for meetings, 1 on 1?) e.g. we might have difference knowledge base, so I will try to share our knowledge together. focus on things but not on people Q3: When you have limited time avaliable to finish your project. Quality vs. Speed \u00b6 consider tradeoffs for different tasks, use a quantative way to analyze the data variant 1: provide an e.g. scenario in which you made a quick decision under pressure variant 2: write an email to your manager on how to explain why you missed the deadline Q4: what is your career plan for the next 5 years \u00b6 show self-motivation, start from small/short term goal to big/long term goal. Q5: please tell me one of the most challenging projects you have accomplished \u00b6 technical challenge + human resource (team work, work with mentor, verify tasks, etc.) variant: mistake you have done first tell what you have done wrong Q6: do you have any questions for me \u00b6 tech stack, I may have some similar skills what's your most challenge project Others \u00b6 1, \u5f00\u4f1a\u4e4b\u524d\uff0c\u4e00\u5b9a\u51c6\u5907\u597d 2\uff0c\u4e00\u5b9a\u8981\u7cfb\u7edf\u6027\u7684\u601d\u8003\uff0cconstruction way thinking 3\uff0c\u628a\u505a\u4e8b\u50cf\u7f16\u7a0b\u4e00\u6837\u89c4\u5212 4\uff0c\u5343\u4e07\u4e0d\u8981\u548c\u9762\u8bd5\u5b98\u603c\uff0c\u6709\u53ef\u80fd\u662f\u538b\u529b\u6d4b\u8bd5\uff01\uff01 5\uff0c*** \u5f53\u6ca1\u6709\u4efb\u4f55nice\u7684\u8bdd\u53bb\u8bf4\u7684\u65f6\u5019\uff0c\u9009\u62e9\u4e0d\u8981\u8bf4 6\uff0c\u4ecb\u7ecd\u81ea\u5df1\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u53ea\u8bf4\u81ea\u5df1\uff0c\u6709\u4e0d\u5c11\u5751\uff01\uff01\uff081\uff09\u540d\u5b57\uff0c\u548c\u6559\u80b2\u80cc\u666f 2\uff09\u4ecb\u7ecd\u4e3b\u8981\u7684\u6280\u80fd\u80cc\u666f 3\uff09Thank you\uff09 7\uff0c\u4ecb\u7ecd\u5f31\u70b9\uff1f 8\uff0c \u89c2\u70b9\u4e0d\u540c\uff1f\u5148\u542c\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u540c\uff0c\u7136\u540e\u5bf9\u6bd4\u4e0d\u540c\uff0c\u7136\u540e\u518d\u5206\u6790\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u4e00\u5b9a\u4e0d\u80fd\u4e00\u5f00\u59cb\u5c31\u7ed9\u51fa\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u8fd9\u6837\u592a\u5bf9\u7acb\u4e86\uff01\uff01 9\uff0c\u6279\u8bc4\u4e00\u4ef6\u4e8b\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u6279\u8bc4\u8fd9\u4ef6\u4e8b\uff0c\u8868\u626c\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u8868\u626c\u8fd9\u4e2a\u4eba\uff08\u6279\u8bc4\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u7ed9\u4eba\u7559\u9762\u5b50\uff01\uff0910 \uff0c \u4efb\u4f55\u4e8b\u60c5\u90fd\u6709trade off\uff0c\u8981\u91cf\u5316\u5206\u6790 11\uff0c\u63a5\u4e0b\u67655\u5e74\u7684\u5de5\u4f5c\u8ba1\u5212\uff1f\u4e00\u5b9a\u8981\u4f53\u73b0\u51faself motivated 12\uff0cmost challenging \uff1f 13\uff0c\u5f53\u53d1\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u8bda\u6073\u7684\u544a\u8bc9\u9762\u8bd5\u5b98\uff0c\u54ea\u91cc\u9519\uff0c\u54ea\u91cc\u5bf9\uff01\uff01 14\uff0cmanager\u5347\u4ec0\u4e48\u6837\u7684\u4eba\uff1f\u628a\u6700\u91cd\u8981\u7684\u5de5\u4f5c\u7ed9\u8c01\uff0c\u8c01\u5c31\u4f1a\u5347\u804c 15\uff0c\u597d\u7684reputation\u662f\u4e00\u6b21\u6b21\u6210\u529f\u79ef\u7d2f\u8d77\u6765\u7684\uff01\uff01 16\uff0c\u5f53\u5728stressful situation\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u5411\u7740\u81ea\u5df1\u4ef7\u503c\u89c2\u7684\u65b9\u5411 17\uff0c\u9ad8\u5c14\u592b\u7403\u95ee\u9898\uff1fC\uff1a\u5728\u54ea\u513f\uff0c\u5c3a\u5bf8 A\uff1a\u7cbe\u5ea6\u8981\u6c42 R\uff1a\u5982\u4f55\u89e3\u51b3 T\uff1a\u600e\u4e48\u53bb\u9a8c\u8bc1 18\uff0c\u7528\u529b\uff0c\u7528\u8111\uff0c\u7528\u5fc3 19\uff0c work with smart people\uff0charderrrrrr\uff08\u673a\u4f1a\u4e0d\u80fd\u63a7\u5236\uff0c\u4f46\u662f\u52aa\u529b\u53ef\u4ee5\uff01\uff0920\uff0c\u4e00\u5b9a\u8981\u5bf9\u5f97\u8d77\u522b\u4eba\u7684\u4fe1\u4efb ***** 21\uff0c\u300a\u6052\u5fc3\u300b22\uff0c\u56f0\u96be\u7684\u65f6\u5019\u6709\u591a\u4eba\u613f\u610f\u5e2e\u52a9\u4f60\uff0c\u505a\u4e8b\u7684\u65f6\u5019\uff0c\u6709\u591a\u5c11\u4eba\u8ffd\u968f\u4f60 23\uff0cleadership\u7684\u5206\u91cf\u5f88\u91cd\uff0c\u7528reputation\u53bb\u5efa\u7acb*** 24\uff0c\u62a2\u7740\u4e70\u5355\uff0c\u4e5f\u633a\u597d\u768425\uff0c\u5343\u4e07\u4e0d\u8981\u635f\u574f\u522b\u4eba\u7684\u6838\u5fc3\u5229\u76ca\uff0126\uff0c\u4e00\u5b9a\u8981\u63d0\u4f9b\u5efa\u8bbe\u6027\u610f\u89c1\uff0c\u8fd9\u6837\u80fd\u5e2e\u522b\u4eba\u53d8\u5f97\u66f4\u597d 27\uff0c1day\uff1a\u611f\u8c22\u4fe1 1week\uff1a\u8d8a\u4e00\u4e2a\u4f1a\uff0c\u8ba8\u8bba\u4e00\u4e0b\u81ea\u5df1\u7684\u90e8\u5206 1month\uff1a\u5c3d\u91cf\u62a5\u559c\uff0c\u8bf4\u81ea\u5df1\u7684\u6210\u7ee9\uff0c\u76ee\u6807 1year\uff1a\u4e70\u4e00\u4e2a\u7cbe\u7f8e\u7684thanks card\uff0c\u63d0\u51fa\u5347\u804c\u7684\u8bc9\u6c42 28\uff0c\u4ec0\u4e48\u95ee\u9898\u662f\u597d\u95ee\u9898\uff1f29\uff0c***\u4e00\u5b9a\u8981\u627e\u7684mentor\uff08\u7ed9\u81ea\u5df1\u5efa\u8bbe\u6027\u610f\u89c1\u7684\u4eba\uff0930\uff0c\u53cd\u601d\uff0c\u8ba1\u5212\uff0c\u884c\u52a8 31\uff0cBetter Person","title":"Behavior Questions"},{"location":"Interview/behavior-questions/#behavior-questions","text":"","title":"Behavior Questions"},{"location":"Interview/behavior-questions/#rule-of-thumb","text":"Don't confront your interviewers How to talk when you have nothing to say, say nothing never criticize your previous employers calm and reasonable Say something for a reason Praise someone Criticie someone (how?) CART: clarify, assumption, result, test cases","title":"Rule of thumb"},{"location":"Interview/behavior-questions/#q1-tell-me-about-yourself","text":"Don't just say yourself Name, edu Skills: primary programming language, projects, experiences, past internship. Thank you Other variants: - tell me your weakness (e.g. weakness: cannot do multiple things at the same time. in the future, learn how to prioritize and analyze dependencies.) - 2 nd chance problems - Retrospection - E.g. Biggest failure during your college/work - Key points: how to avoid/address the same problems in the future.","title":"Q1: tell me about yourself"},{"location":"Interview/behavior-questions/#q2-when-you-have-different-opinions-from-your-colleagues","text":"Scenarios Communication how when where keep in mind: say something for a reason, praise and criticize someone what if? backup solutions how to express yourself? (e.g. how to do prep for meetings, 1 on 1?) e.g. we might have difference knowledge base, so I will try to share our knowledge together. focus on things but not on people","title":"Q2: when you have different opinions from your colleagues"},{"location":"Interview/behavior-questions/#q3-when-you-have-limited-time-avaliable-to-finish-your-project-quality-vs-speed","text":"consider tradeoffs for different tasks, use a quantative way to analyze the data variant 1: provide an e.g. scenario in which you made a quick decision under pressure variant 2: write an email to your manager on how to explain why you missed the deadline","title":"Q3: When you have limited time avaliable to finish your project. Quality vs. Speed"},{"location":"Interview/behavior-questions/#q4-what-is-your-career-plan-for-the-next-5-years","text":"show self-motivation, start from small/short term goal to big/long term goal.","title":"Q4: what is your career plan for the next 5 years"},{"location":"Interview/behavior-questions/#q5-please-tell-me-one-of-the-most-challenging-projects-you-have-accomplished","text":"technical challenge + human resource (team work, work with mentor, verify tasks, etc.) variant: mistake you have done first tell what you have done wrong","title":"Q5: please tell me one of the most challenging projects you have accomplished"},{"location":"Interview/behavior-questions/#q6-do-you-have-any-questions-for-me","text":"tech stack, I may have some similar skills what's your most challenge project","title":"Q6: do you have any questions for me"},{"location":"Interview/behavior-questions/#others","text":"1, \u5f00\u4f1a\u4e4b\u524d\uff0c\u4e00\u5b9a\u51c6\u5907\u597d 2\uff0c\u4e00\u5b9a\u8981\u7cfb\u7edf\u6027\u7684\u601d\u8003\uff0cconstruction way thinking 3\uff0c\u628a\u505a\u4e8b\u50cf\u7f16\u7a0b\u4e00\u6837\u89c4\u5212 4\uff0c\u5343\u4e07\u4e0d\u8981\u548c\u9762\u8bd5\u5b98\u603c\uff0c\u6709\u53ef\u80fd\u662f\u538b\u529b\u6d4b\u8bd5\uff01\uff01 5\uff0c*** \u5f53\u6ca1\u6709\u4efb\u4f55nice\u7684\u8bdd\u53bb\u8bf4\u7684\u65f6\u5019\uff0c\u9009\u62e9\u4e0d\u8981\u8bf4 6\uff0c\u4ecb\u7ecd\u81ea\u5df1\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u53ea\u8bf4\u81ea\u5df1\uff0c\u6709\u4e0d\u5c11\u5751\uff01\uff01\uff081\uff09\u540d\u5b57\uff0c\u548c\u6559\u80b2\u80cc\u666f 2\uff09\u4ecb\u7ecd\u4e3b\u8981\u7684\u6280\u80fd\u80cc\u666f 3\uff09Thank you\uff09 7\uff0c\u4ecb\u7ecd\u5f31\u70b9\uff1f 8\uff0c \u89c2\u70b9\u4e0d\u540c\uff1f\u5148\u542c\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u540c\uff0c\u7136\u540e\u5bf9\u6bd4\u4e0d\u540c\uff0c\u7136\u540e\u518d\u5206\u6790\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u4e00\u5b9a\u4e0d\u80fd\u4e00\u5f00\u59cb\u5c31\u7ed9\u51fa\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u8fd9\u6837\u592a\u5bf9\u7acb\u4e86\uff01\uff01 9\uff0c\u6279\u8bc4\u4e00\u4ef6\u4e8b\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u6279\u8bc4\u8fd9\u4ef6\u4e8b\uff0c\u8868\u626c\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u8868\u626c\u8fd9\u4e2a\u4eba\uff08\u6279\u8bc4\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u7ed9\u4eba\u7559\u9762\u5b50\uff01\uff0910 \uff0c \u4efb\u4f55\u4e8b\u60c5\u90fd\u6709trade off\uff0c\u8981\u91cf\u5316\u5206\u6790 11\uff0c\u63a5\u4e0b\u67655\u5e74\u7684\u5de5\u4f5c\u8ba1\u5212\uff1f\u4e00\u5b9a\u8981\u4f53\u73b0\u51faself motivated 12\uff0cmost challenging \uff1f 13\uff0c\u5f53\u53d1\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u8bda\u6073\u7684\u544a\u8bc9\u9762\u8bd5\u5b98\uff0c\u54ea\u91cc\u9519\uff0c\u54ea\u91cc\u5bf9\uff01\uff01 14\uff0cmanager\u5347\u4ec0\u4e48\u6837\u7684\u4eba\uff1f\u628a\u6700\u91cd\u8981\u7684\u5de5\u4f5c\u7ed9\u8c01\uff0c\u8c01\u5c31\u4f1a\u5347\u804c 15\uff0c\u597d\u7684reputation\u662f\u4e00\u6b21\u6b21\u6210\u529f\u79ef\u7d2f\u8d77\u6765\u7684\uff01\uff01 16\uff0c\u5f53\u5728stressful situation\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u5411\u7740\u81ea\u5df1\u4ef7\u503c\u89c2\u7684\u65b9\u5411 17\uff0c\u9ad8\u5c14\u592b\u7403\u95ee\u9898\uff1fC\uff1a\u5728\u54ea\u513f\uff0c\u5c3a\u5bf8 A\uff1a\u7cbe\u5ea6\u8981\u6c42 R\uff1a\u5982\u4f55\u89e3\u51b3 T\uff1a\u600e\u4e48\u53bb\u9a8c\u8bc1 18\uff0c\u7528\u529b\uff0c\u7528\u8111\uff0c\u7528\u5fc3 19\uff0c work with smart people\uff0charderrrrrr\uff08\u673a\u4f1a\u4e0d\u80fd\u63a7\u5236\uff0c\u4f46\u662f\u52aa\u529b\u53ef\u4ee5\uff01\uff0920\uff0c\u4e00\u5b9a\u8981\u5bf9\u5f97\u8d77\u522b\u4eba\u7684\u4fe1\u4efb ***** 21\uff0c\u300a\u6052\u5fc3\u300b22\uff0c\u56f0\u96be\u7684\u65f6\u5019\u6709\u591a\u4eba\u613f\u610f\u5e2e\u52a9\u4f60\uff0c\u505a\u4e8b\u7684\u65f6\u5019\uff0c\u6709\u591a\u5c11\u4eba\u8ffd\u968f\u4f60 23\uff0cleadership\u7684\u5206\u91cf\u5f88\u91cd\uff0c\u7528reputation\u53bb\u5efa\u7acb*** 24\uff0c\u62a2\u7740\u4e70\u5355\uff0c\u4e5f\u633a\u597d\u768425\uff0c\u5343\u4e07\u4e0d\u8981\u635f\u574f\u522b\u4eba\u7684\u6838\u5fc3\u5229\u76ca\uff0126\uff0c\u4e00\u5b9a\u8981\u63d0\u4f9b\u5efa\u8bbe\u6027\u610f\u89c1\uff0c\u8fd9\u6837\u80fd\u5e2e\u522b\u4eba\u53d8\u5f97\u66f4\u597d 27\uff0c1day\uff1a\u611f\u8c22\u4fe1 1week\uff1a\u8d8a\u4e00\u4e2a\u4f1a\uff0c\u8ba8\u8bba\u4e00\u4e0b\u81ea\u5df1\u7684\u90e8\u5206 1month\uff1a\u5c3d\u91cf\u62a5\u559c\uff0c\u8bf4\u81ea\u5df1\u7684\u6210\u7ee9\uff0c\u76ee\u6807 1year\uff1a\u4e70\u4e00\u4e2a\u7cbe\u7f8e\u7684thanks card\uff0c\u63d0\u51fa\u5347\u804c\u7684\u8bc9\u6c42 28\uff0c\u4ec0\u4e48\u95ee\u9898\u662f\u597d\u95ee\u9898\uff1f29\uff0c***\u4e00\u5b9a\u8981\u627e\u7684mentor\uff08\u7ed9\u81ea\u5df1\u5efa\u8bbe\u6027\u610f\u89c1\u7684\u4eba\uff0930\uff0c\u53cd\u601d\uff0c\u8ba1\u5212\uff0c\u884c\u52a8 31\uff0cBetter Person","title":"Others"},{"location":"Interview/binary-search/","text":"Binary Search \u00b6 2 Principles: Guarantee that the search space decreases over time (after each iteration). // prevent while \"true\" Guarantee that the target (if exist) cannot be ruled out accidentally, when we change the value of Left or Right. while (l <= r): 1 element can get in while (l < r): 1 element cannot get in l = l + 1: eleminate l for next iteration l = l: check if 1 element will cause inf Classic Binary Search \u00b6 int binarySearch (vector < int >& a, int target) { int left = 0 , right = a.size() - 1 ; while (left <= right) { // <= int mid = left + right >> 1 ; if (a[mid] == target) return mid; else if (a[mid] < target) left = mid + 1 ; else right = mid - 1 ; } return -1 ; } 2D Space Binary Search \u00b6 1 3 4 6 7 9 10 11 14 17 19 20 target = 11 index = col * row - 1 col = index / size of col row = index % size of col int l = 0 , r = col * row - 1 ; while (l <= r) { int m = (l + r) >> 1 ; int x = m / col, y = m % col; if (a[x][y] == target) return true ; else if (a[x][y] < target) l = m + 1 ; else r = m - 1 ; } return false ; Closest Element to Target \u00b6 target == 4 [1,2,3,8,9] -> return 3's index which is 2 while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { return m; } else if (a[m] < target) { l = m; } else { r = m; } } // return the one that is close to target, because there are two elements if (target - a[l] < a[r] - target) return l; else return r; First target \u00b6 target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { r = m; // r = m - 1 -> wrong } else if (a[m] < target) { l = m; // l = m + 1 -> right } else { r = m; // r = m - 1 -> right } } if (target == a[l]) // return the left that is equal to target, because it goes from left to right return l; if (target == a[r]) return r; else return -1 ; Last target (variant for previous one) \u00b6 target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { l = m; // now change to l } else if (a[m] < target) { l = m; } else { r = m; } } if (target == a[r]) // return the right that is equal to target, because it goes from right to left return l; if (target == a[l]) return r; else return -1 ; Closest k Elements \u00b6 how to return the index of k elements that are closest elements to the target k = 3, target = 5, a = [1,2,3,8,9] return 2,3,8 Solution 1: 1. run binary search to find L and R, where L is the largest value that is smaller than target 2. if l is close to target, l--; else r++ Complexity: O(log(n) + k), what if k \\approx \\approx n? Complexity will be O(n) int largestSmallerEqual (vector < int > arr, int target) { int left = 0 , right = arr.size() - 1 ; while (left < right - 1 ) { int mid = left + right >> 1 ; if (arr[mid] <= target) { left = mid; } else { right = mid; } } if (arr[right] <= target) return right; if (arr[left] <= target) return left; return -1 ; } vector < int > kClosest(vector < int > arr, int target, int k) { int left = largestSmallerEqual(arr, target); int right = left + 1 ; vector < int > res(k); for ( int i = 0 ; i < k; ++ i) { if (right >= arr.size() || left >= 0 && target - arr[left] <= arr[right] - target) { res[i] = arr[left -- ]; } else { res[i] = arr[right ++ ]; } } return res; } Solution 2: binary search to find L and R using offset to form two more arrays: leftArray = {3 2 1} rightArray = {4 5} then use the method introduced later to find the median. Don't need to preprocess the offset beforehand, but just to update when visited. Solution 3: Moving the sliding window to get the least sum diff. To get the minimal, it has to be the mid point of the sliding window. case 1: x - A[mid] < A[mid + k] - x, need to move window go left -------x----A[mid]-----------------A[mid + k]---------- case 2: x - A[mid] < A[mid + k] - x, need to move window go left again -------A[mid]----x-----------------A[mid + k]---------- case 3: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]------------------x---A[mid + k]---------- case 4: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]---------------------A[mid + k]----x------ vector < int > kClosest(vector < int > a, int x, int k) { int n = a.size(); int l = 0 , r = n - k; while (l < r) { int m = (l + 0l l + r) >> 1 ; if (x - a[m] > a[m + k] - x) l = m + 1 ; else r = m; } auto res = vector < int > (a.begin() + l, a.begin() + l + k ); // this sort is unecessary if there is no requirement for what order to be returned // sort(res.begin(), res.end(), [&](const int l, const int r) { // return abs(l - x) < abs(r - x); // }); return res; } Smallest element that is greater than target \u00b6 sss eee bbb -> same as first target, because we want to find the first b case 1: if input[m] < target: l = m + 1 // l = m also work case 2: if input[m] == target: l = m + 1 // l = m also work case 3: if input[m] > target: r = m // r = m - 1 is wrong, becasue it will wipe out the first b while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] > target) { r = m; } else if (a[m] <= target) { // or just else l = m; } } if (a[l] > target) return l; if (a[r] < target) return r; return -1 ; Kth smallest in two sorted arrays \u00b6 how to find the median how to find k-th smallest element from them A[] = {2,5,7,10,13} B[] = {1,3,4,13,20,29} k = 5 output = 5 solution 1: two pointer, i++ if a[i] < b[j] else j++, stop until k steps -> O(k) solution 2: binary search Binary Search with Unknown Size \u00b6 dict = {1 3 5 6 .... 1000000}, target = 9999 Assumption: - No dict.size() - if dict.get(index) == null, then we know the size of dict is < index. solution 1: 1. keep jumping out with size = size * 2. until dict.get(index) == null 2. do binary search from 0 to current size Followup: Why not size = size * 10? Which one is better? Don't say an answer (if you don't know yet), but say let's analyze together.","title":"Binary Search"},{"location":"Interview/binary-search/#binary-search","text":"2 Principles: Guarantee that the search space decreases over time (after each iteration). // prevent while \"true\" Guarantee that the target (if exist) cannot be ruled out accidentally, when we change the value of Left or Right. while (l <= r): 1 element can get in while (l < r): 1 element cannot get in l = l + 1: eleminate l for next iteration l = l: check if 1 element will cause inf","title":"Binary Search"},{"location":"Interview/binary-search/#classic-binary-search","text":"int binarySearch (vector < int >& a, int target) { int left = 0 , right = a.size() - 1 ; while (left <= right) { // <= int mid = left + right >> 1 ; if (a[mid] == target) return mid; else if (a[mid] < target) left = mid + 1 ; else right = mid - 1 ; } return -1 ; }","title":"Classic Binary Search"},{"location":"Interview/binary-search/#2d-space-binary-search","text":"1 3 4 6 7 9 10 11 14 17 19 20 target = 11 index = col * row - 1 col = index / size of col row = index % size of col int l = 0 , r = col * row - 1 ; while (l <= r) { int m = (l + r) >> 1 ; int x = m / col, y = m % col; if (a[x][y] == target) return true ; else if (a[x][y] < target) l = m + 1 ; else r = m - 1 ; } return false ;","title":"2D Space Binary Search"},{"location":"Interview/binary-search/#closest-element-to-target","text":"target == 4 [1,2,3,8,9] -> return 3's index which is 2 while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { return m; } else if (a[m] < target) { l = m; } else { r = m; } } // return the one that is close to target, because there are two elements if (target - a[l] < a[r] - target) return l; else return r;","title":"Closest Element to Target"},{"location":"Interview/binary-search/#first-target","text":"target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { r = m; // r = m - 1 -> wrong } else if (a[m] < target) { l = m; // l = m + 1 -> right } else { r = m; // r = m - 1 -> right } } if (target == a[l]) // return the left that is equal to target, because it goes from left to right return l; if (target == a[r]) return r; else return -1 ;","title":"First target"},{"location":"Interview/binary-search/#last-target-variant-for-previous-one","text":"target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { l = m; // now change to l } else if (a[m] < target) { l = m; } else { r = m; } } if (target == a[r]) // return the right that is equal to target, because it goes from right to left return l; if (target == a[l]) return r; else return -1 ;","title":"Last target (variant for previous one)"},{"location":"Interview/binary-search/#closest-k-elements","text":"how to return the index of k elements that are closest elements to the target k = 3, target = 5, a = [1,2,3,8,9] return 2,3,8 Solution 1: 1. run binary search to find L and R, where L is the largest value that is smaller than target 2. if l is close to target, l--; else r++ Complexity: O(log(n) + k), what if k \\approx \\approx n? Complexity will be O(n) int largestSmallerEqual (vector < int > arr, int target) { int left = 0 , right = arr.size() - 1 ; while (left < right - 1 ) { int mid = left + right >> 1 ; if (arr[mid] <= target) { left = mid; } else { right = mid; } } if (arr[right] <= target) return right; if (arr[left] <= target) return left; return -1 ; } vector < int > kClosest(vector < int > arr, int target, int k) { int left = largestSmallerEqual(arr, target); int right = left + 1 ; vector < int > res(k); for ( int i = 0 ; i < k; ++ i) { if (right >= arr.size() || left >= 0 && target - arr[left] <= arr[right] - target) { res[i] = arr[left -- ]; } else { res[i] = arr[right ++ ]; } } return res; } Solution 2: binary search to find L and R using offset to form two more arrays: leftArray = {3 2 1} rightArray = {4 5} then use the method introduced later to find the median. Don't need to preprocess the offset beforehand, but just to update when visited. Solution 3: Moving the sliding window to get the least sum diff. To get the minimal, it has to be the mid point of the sliding window. case 1: x - A[mid] < A[mid + k] - x, need to move window go left -------x----A[mid]-----------------A[mid + k]---------- case 2: x - A[mid] < A[mid + k] - x, need to move window go left again -------A[mid]----x-----------------A[mid + k]---------- case 3: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]------------------x---A[mid + k]---------- case 4: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]---------------------A[mid + k]----x------ vector < int > kClosest(vector < int > a, int x, int k) { int n = a.size(); int l = 0 , r = n - k; while (l < r) { int m = (l + 0l l + r) >> 1 ; if (x - a[m] > a[m + k] - x) l = m + 1 ; else r = m; } auto res = vector < int > (a.begin() + l, a.begin() + l + k ); // this sort is unecessary if there is no requirement for what order to be returned // sort(res.begin(), res.end(), [&](const int l, const int r) { // return abs(l - x) < abs(r - x); // }); return res; }","title":"Closest k Elements"},{"location":"Interview/binary-search/#smallest-element-that-is-greater-than-target","text":"sss eee bbb -> same as first target, because we want to find the first b case 1: if input[m] < target: l = m + 1 // l = m also work case 2: if input[m] == target: l = m + 1 // l = m also work case 3: if input[m] > target: r = m // r = m - 1 is wrong, becasue it will wipe out the first b while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] > target) { r = m; } else if (a[m] <= target) { // or just else l = m; } } if (a[l] > target) return l; if (a[r] < target) return r; return -1 ;","title":"Smallest element that is greater than target"},{"location":"Interview/binary-search/#kth-smallest-in-two-sorted-arrays","text":"how to find the median how to find k-th smallest element from them A[] = {2,5,7,10,13} B[] = {1,3,4,13,20,29} k = 5 output = 5 solution 1: two pointer, i++ if a[i] < b[j] else j++, stop until k steps -> O(k) solution 2: binary search","title":"Kth smallest in two sorted arrays"},{"location":"Interview/binary-search/#binary-search-with-unknown-size","text":"dict = {1 3 5 6 .... 1000000}, target = 9999 Assumption: - No dict.size() - if dict.get(index) == null, then we know the size of dict is < index. solution 1: 1. keep jumping out with size = size * 2. until dict.get(index) == null 2. do binary search from 0 to current size Followup: Why not size = size * 10? Which one is better? Don't say an answer (if you don't know yet), but say let's analyze together.","title":"Binary Search with Unknown Size"},{"location":"Interview/choose-k-cards-and-find-the-maximum/","text":"Choose k cards and find the maximum \u00b6 There are two players playing alternatively, and there is a deck of cards. Each player can pick 1~3 cards from the top of the deck. Find the maximum card value that player one get. e.g. [8,1,1,1,1] -> p1 pick 1, p2 picks 1,1,1. finally p1 pick 8 which is the highest point it can get. DP[i] = max(sum( 0 , i) - DP[i -1 ], sum( 0 , i) - DP[i -2 ], sum( 0 , i) - DP[i -3 ]) = sum( 0 , i) - min(DP[i -1 ], DP[i -2 ], DP[i -3 ])","title":"Choose k cards and find the maximum"},{"location":"Interview/choose-k-cards-and-find-the-maximum/#choose-k-cards-and-find-the-maximum","text":"There are two players playing alternatively, and there is a deck of cards. Each player can pick 1~3 cards from the top of the deck. Find the maximum card value that player one get. e.g. [8,1,1,1,1] -> p1 pick 1, p2 picks 1,1,1. finally p1 pick 8 which is the highest point it can get. DP[i] = max(sum( 0 , i) - DP[i -1 ], sum( 0 , i) - DP[i -2 ], sum( 0 , i) - DP[i -3 ]) = sum( 0 , i) - min(DP[i -1 ], DP[i -2 ], DP[i -3 ])","title":"Choose k cards and find the maximum"},{"location":"Interview/count-array-count-inversion-of-an-array/","text":"Count Array Inversion \u00b6 How to make the Time Complexity into O(n \\times \\log n) O(n \\times \\log n) Analysis \u00b6 B[i] represents number of element in A[i-j] that is less than B[i] \u4f7f\u7528\u8c01\u5c0f\u79fb\u8c01: Code \u00b6 #include <cstdio> #include <algorithm> using namespace std; typedef long long LL; const int N = 500010 ; int n, m; int a[N], b[N]; int find ( int x) { int l = 1 , r = m; while (l < r) { int mid = l + r >> 1 ; if (b[mid] >= x) r = mid; else l = mid + 1 ; } return l; } int tr[N]; void add ( int x) { for ( int i = x; i <= m; i += i & - i) tr[i] ++ ; } int sum ( int x) { int res = 0 ; for ( int i = x; i; i -= i & - i) res += tr[i]; return res; } int main () { scanf( \"%d\" , & n); for ( int i = 1 ; i <= n; i ++ ) scanf( \"%d\" , & a[i]), b[i] = a[i]; sort(b + 1 , b + n + 1 ); m = 1 ; for ( int i = 2 ; i <= n; i ++ ) if (b[i] != b[m]) b[ ++ m] = b[i]; LL res = 0 ; for ( int i = 1 ; i <= n; i ++ ) { int x = find(a[i]); res += sum(m) - sum(x); add(x); } printf( \"%lld\" , res); return 0 ; } \u4f5c\u8005\uff1a\u6ed1\u7a3d _\u03c9\uff89 \u94fe\u63a5\uff1a https : //www.acwing.com/file_system/file/content/whole/index/content/504568/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Count Array Inversion"},{"location":"Interview/count-array-count-inversion-of-an-array/#count-array-inversion","text":"How to make the Time Complexity into O(n \\times \\log n) O(n \\times \\log n)","title":"Count Array Inversion"},{"location":"Interview/count-array-count-inversion-of-an-array/#analysis","text":"B[i] represents number of element in A[i-j] that is less than B[i] \u4f7f\u7528\u8c01\u5c0f\u79fb\u8c01:","title":"Analysis"},{"location":"Interview/count-array-count-inversion-of-an-array/#code","text":"#include <cstdio> #include <algorithm> using namespace std; typedef long long LL; const int N = 500010 ; int n, m; int a[N], b[N]; int find ( int x) { int l = 1 , r = m; while (l < r) { int mid = l + r >> 1 ; if (b[mid] >= x) r = mid; else l = mid + 1 ; } return l; } int tr[N]; void add ( int x) { for ( int i = x; i <= m; i += i & - i) tr[i] ++ ; } int sum ( int x) { int res = 0 ; for ( int i = x; i; i -= i & - i) res += tr[i]; return res; } int main () { scanf( \"%d\" , & n); for ( int i = 1 ; i <= n; i ++ ) scanf( \"%d\" , & a[i]), b[i] = a[i]; sort(b + 1 , b + n + 1 ); m = 1 ; for ( int i = 2 ; i <= n; i ++ ) if (b[i] != b[m]) b[ ++ m] = b[i]; LL res = 0 ; for ( int i = 1 ; i <= n; i ++ ) { int x = find(a[i]); res += sum(m) - sum(x); add(x); } printf( \"%lld\" , res); return 0 ; } \u4f5c\u8005\uff1a\u6ed1\u7a3d _\u03c9\uff89 \u94fe\u63a5\uff1a https : //www.acwing.com/file_system/file/content/whole/index/content/504568/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Interview/design-heap-or-priority-queue/","text":"Property for a heap (min heap for example) \u00b6 Complete Tree root = i => left = i * 2 + 1, right = i * 2 + 2 left/right = i => root = (i - 1) / 2 the transferred array (0-based) is unique => the transferred tree is unique Any child is greater than its parent (top one/root node is the smallest one) Left and Right child don't have any relationship (not bst) -> cannot search in O(N \\times log(N)) O(N \\times log(N)) Advantage of using an array: root -> children and child -> root or child -> grandfather easily Operations \u00b6 Trickle Up (offer/push) adding new element to the tail while ((i - 1 ) / 2 >= 0 && arr[i] < arr[(i - 1 ) / 2 ]) { swap(arr[i], arr[(i - 1 ) / 2 ]); i = (i - 1 ) / 2 ; } Trickle Down (poll/pop) remove the root of the tree #define (left) (i * 2 + 1) #define (right) (i * 2 + 2) int i = 0 ; while (left < arr.size() && (arr[i] > arr[left] || arr[i] > arr[right])) { int tmp; if (arr[left] < arr[right]) tmp = left; else tmp = right; swap(arr[i], arr[tmp]); i = tmp; } Heap Sort \u00b6 sort the array by regarding the array as a heap: keep \"polling/pop\" and place the biggest/smallest one to the front heapify (trickle down from n to 0): O(n) O(n) n times poll/pop: O(n \\times log(n)) O(n \\times log(n)) However, it's not a preferrable sorting algorithm runtime overhead poor locality (a lot of swap that addresses are not nearby) hard to parallelize/distribute","title":"Property for a heap (min heap for example)"},{"location":"Interview/design-heap-or-priority-queue/#property-for-a-heap-min-heap-for-example","text":"Complete Tree root = i => left = i * 2 + 1, right = i * 2 + 2 left/right = i => root = (i - 1) / 2 the transferred array (0-based) is unique => the transferred tree is unique Any child is greater than its parent (top one/root node is the smallest one) Left and Right child don't have any relationship (not bst) -> cannot search in O(N \\times log(N)) O(N \\times log(N)) Advantage of using an array: root -> children and child -> root or child -> grandfather easily","title":"Property for a heap (min heap for example)"},{"location":"Interview/design-heap-or-priority-queue/#operations","text":"Trickle Up (offer/push) adding new element to the tail while ((i - 1 ) / 2 >= 0 && arr[i] < arr[(i - 1 ) / 2 ]) { swap(arr[i], arr[(i - 1 ) / 2 ]); i = (i - 1 ) / 2 ; } Trickle Down (poll/pop) remove the root of the tree #define (left) (i * 2 + 1) #define (right) (i * 2 + 2) int i = 0 ; while (left < arr.size() && (arr[i] > arr[left] || arr[i] > arr[right])) { int tmp; if (arr[left] < arr[right]) tmp = left; else tmp = right; swap(arr[i], arr[tmp]); i = tmp; }","title":"Operations"},{"location":"Interview/design-heap-or-priority-queue/#heap-sort","text":"sort the array by regarding the array as a heap: keep \"polling/pop\" and place the biggest/smallest one to the front heapify (trickle down from n to 0): O(n) O(n) n times poll/pop: O(n \\times log(n)) O(n \\times log(n)) However, it's not a preferrable sorting algorithm runtime overhead poor locality (a lot of swap that addresses are not nearby) hard to parallelize/distribute","title":"Heap Sort"},{"location":"Interview/divide-two-integer/","text":"Notes for a mock interview \u00b6 self intro infrastructure engineer in search ml infrastructure, inside tools for testing and developments service owner for search slogan service team search feature - for users and other engineering teams drive the team of search quality - responsible organize and manage the developments and teams - details impact, complexity for what you have done technically!! millions level users and high qps, autoscaling and analysis tech stacks - details Why do you want to change your company? food truck search problem \u6ca1\u542c\u6e05\u695a \u2192 double check What is the biggest bug/mistake you have committed in your work? broken for the owned service details - main service -> microservice, parameters - coordination of the dependency of push process for different time zone - Why - deep analysis What - 3.1 how do you solve the problem - oncall wake up 2AM - push and rollback in time 3.2 what do you learnt and what to do in the future - use the centralized timezone - how do you enforce? What are the actions? - change the whole process, share calendar, ping on slack and calendar, link on other events, mark and account for the completeness - work and cooperate with diverse working environment - proactively communication Literal point 0 insight point 1 - why your interviewer asked this question? Passion to join company? insight point 2 - think about in depth what he wants to know? What can you bring to our company? \u8f6c\u4e13\u4e1a\u7684\u95ee\u4e3a\u5565\u8f6c\u7801\u5e94\u8be5\u600e\u4e48\u56de\u7b54\u2029?? insight point 1 - passion + motivation \u21d2 100 / 3 100 -3-3-3-3-3 \u2026.. 10^10 / 1 Given two int value a and b, find a/b Notice: you can not use \"/\" operation. 4 / 3 = 1 --- 1 4 / 3 = 1 x * 3 = closet number to 4 but smaller than 4 < 0 sign 1 or both > 0 sign 1, -1 Math.abs(a) Math.abs(b) if (a == 0) { return 0; } min = 1, max = dividend mid = (max - min) / 2 + min mid * divisor = number > dividend max = mid; mid * divisor = number < dividend min = mid + 1 until we make min == max min will be the closest we can and smaller than dividend dividend = 4, divsior = 3 min = 1, max = 4 mid = (4 - 1) >> 1 + min = 2; number = 2 * 3 = 6 > 4 max = mid = 2 min = 1, max = 2 mid = 1 number = 1 * 3 = 3 < 4 min = mid + 1 = 2; min = 2, max = 2 we get result as 2 we check 2, 2 * 3 = 6 we will return 2 - 1 = 1 min = mid max = mid - 1 min =1 , max = 4 mid = 2 max = 2 - 1 min = 1, max = 1 public int divide(int dividend, int divisor) { if (divisior == 0) { throw new Exception(\u201cdivisor cannot be 0\u201d); } if (dividend == 0 || dividend < divisor) { return 0; } int min = 1, max = dividend; while (min < max) { // when min equals max, end it int mid = (max - min) >> 1 + min; // get mid value int number = mid * divisor; // calculate possible value if (number == dividend) { // we find it, so we directly return it return mid; } else if (number > dividend) { // it looks max = mid - 1; } else { min = mid; } } return min; } dividend = 10, divisor = 5 min = 1, max = 10 mid = 5 5 * 5 = 25 > 10 min = 1, max = 4 mid = 2 5 * 2 = 10 = 10 return 2 dividend = 4, divisor = 3 dividend = 0 return 0 divisor = 0 throw out of exception 1 / 2 dividend < divisor 0 dividend = 11 divisor = 3 min: 1 max: 11 mid = 6 * 3 = 18 > 11 min: 1 max: 5 mid = 3 * 3 = 9 < 11 min: 3 max: 5 mid = 4 * 3 = 12 > 11 min: 3 max: 3 mid = 3 * 3 = 9 < 11 mi 1 -- dividend log(dividend) O(1) in the worst case, 1 2 ^ 32 ---> 2^31 ---> 10^10 / 10^9 = 10 1 0 1 0 search range - [1, 2^4] min: 1 to max: 10^10 log(a/b) = loga - logb Clarification & Assumptions: b = 0? Why throw an exception in this case? - this is runtime error NullPointerException ArrayIndexOutOfBoundException IlegalArumentException IlegalStateException ArithmeticException (\"divisor can not be 0\") types of a,b - int, overflow? the result will never overflow? MIN_VALUE = -2^31 MAX_VALUE = 2^31 - 1 MIN_VALUE / -1 = ? What is the result type? int positive/negative for a,b? -7 / 4 = -1 or -2 Result: Binary Search Application \u52a8\u624b\u8fc7\u4f8b\u5b50\uff0c---> 1. \u903b\u8f91\u7684\u5173\u952e\u90e8\u5206 \u6574\u7406\u6e05\u695a \u5404\u79cdcase\uff0c\u7269\u7406\u610f\u4e49\uff0c 2. \u89e3\u91ca\u4f60\u7684high level\uff0cdetail\u7684\u903b\u8f91 4 / 3 1 2 3 4 3 6 9 12 min mid max 2*3 =6 min,max high level - \u4e3a\u4ec0\u4e48\u80fd\u7528binary search \u628aBinary Search\u7684\u8981\u70b9\u8bb2\u6e05\u695a 1. search range \u2192 [min, max] 2. search range reduce size each round \u2192 while loop()\u80fd\u8fdb\u5f97\u53bb\u548c\u8df3\u7684\u51fa\u6765 [1, 2] min max mid case 1 max = mid - 1 case 2 min = mid Test cover all possible code branches 10 / 3 = 3","title":"Notes for a mock interview"},{"location":"Interview/divide-two-integer/#notes-for-a-mock-interview","text":"self intro infrastructure engineer in search ml infrastructure, inside tools for testing and developments service owner for search slogan service team search feature - for users and other engineering teams drive the team of search quality - responsible organize and manage the developments and teams - details impact, complexity for what you have done technically!! millions level users and high qps, autoscaling and analysis tech stacks - details Why do you want to change your company? food truck search problem \u6ca1\u542c\u6e05\u695a \u2192 double check What is the biggest bug/mistake you have committed in your work? broken for the owned service details - main service -> microservice, parameters - coordination of the dependency of push process for different time zone - Why - deep analysis What - 3.1 how do you solve the problem - oncall wake up 2AM - push and rollback in time 3.2 what do you learnt and what to do in the future - use the centralized timezone - how do you enforce? What are the actions? - change the whole process, share calendar, ping on slack and calendar, link on other events, mark and account for the completeness - work and cooperate with diverse working environment - proactively communication Literal point 0 insight point 1 - why your interviewer asked this question? Passion to join company? insight point 2 - think about in depth what he wants to know? What can you bring to our company? \u8f6c\u4e13\u4e1a\u7684\u95ee\u4e3a\u5565\u8f6c\u7801\u5e94\u8be5\u600e\u4e48\u56de\u7b54\u2029?? insight point 1 - passion + motivation \u21d2 100 / 3 100 -3-3-3-3-3 \u2026.. 10^10 / 1 Given two int value a and b, find a/b Notice: you can not use \"/\" operation. 4 / 3 = 1 --- 1 4 / 3 = 1 x * 3 = closet number to 4 but smaller than 4 < 0 sign 1 or both > 0 sign 1, -1 Math.abs(a) Math.abs(b) if (a == 0) { return 0; } min = 1, max = dividend mid = (max - min) / 2 + min mid * divisor = number > dividend max = mid; mid * divisor = number < dividend min = mid + 1 until we make min == max min will be the closest we can and smaller than dividend dividend = 4, divsior = 3 min = 1, max = 4 mid = (4 - 1) >> 1 + min = 2; number = 2 * 3 = 6 > 4 max = mid = 2 min = 1, max = 2 mid = 1 number = 1 * 3 = 3 < 4 min = mid + 1 = 2; min = 2, max = 2 we get result as 2 we check 2, 2 * 3 = 6 we will return 2 - 1 = 1 min = mid max = mid - 1 min =1 , max = 4 mid = 2 max = 2 - 1 min = 1, max = 1 public int divide(int dividend, int divisor) { if (divisior == 0) { throw new Exception(\u201cdivisor cannot be 0\u201d); } if (dividend == 0 || dividend < divisor) { return 0; } int min = 1, max = dividend; while (min < max) { // when min equals max, end it int mid = (max - min) >> 1 + min; // get mid value int number = mid * divisor; // calculate possible value if (number == dividend) { // we find it, so we directly return it return mid; } else if (number > dividend) { // it looks max = mid - 1; } else { min = mid; } } return min; } dividend = 10, divisor = 5 min = 1, max = 10 mid = 5 5 * 5 = 25 > 10 min = 1, max = 4 mid = 2 5 * 2 = 10 = 10 return 2 dividend = 4, divisor = 3 dividend = 0 return 0 divisor = 0 throw out of exception 1 / 2 dividend < divisor 0 dividend = 11 divisor = 3 min: 1 max: 11 mid = 6 * 3 = 18 > 11 min: 1 max: 5 mid = 3 * 3 = 9 < 11 min: 3 max: 5 mid = 4 * 3 = 12 > 11 min: 3 max: 3 mid = 3 * 3 = 9 < 11 mi 1 -- dividend log(dividend) O(1) in the worst case, 1 2 ^ 32 ---> 2^31 ---> 10^10 / 10^9 = 10 1 0 1 0 search range - [1, 2^4] min: 1 to max: 10^10 log(a/b) = loga - logb Clarification & Assumptions: b = 0? Why throw an exception in this case? - this is runtime error NullPointerException ArrayIndexOutOfBoundException IlegalArumentException IlegalStateException ArithmeticException (\"divisor can not be 0\") types of a,b - int, overflow? the result will never overflow? MIN_VALUE = -2^31 MAX_VALUE = 2^31 - 1 MIN_VALUE / -1 = ? What is the result type? int positive/negative for a,b? -7 / 4 = -1 or -2 Result: Binary Search Application \u52a8\u624b\u8fc7\u4f8b\u5b50\uff0c---> 1. \u903b\u8f91\u7684\u5173\u952e\u90e8\u5206 \u6574\u7406\u6e05\u695a \u5404\u79cdcase\uff0c\u7269\u7406\u610f\u4e49\uff0c 2. \u89e3\u91ca\u4f60\u7684high level\uff0cdetail\u7684\u903b\u8f91 4 / 3 1 2 3 4 3 6 9 12 min mid max 2*3 =6 min,max high level - \u4e3a\u4ec0\u4e48\u80fd\u7528binary search \u628aBinary Search\u7684\u8981\u70b9\u8bb2\u6e05\u695a 1. search range \u2192 [min, max] 2. search range reduce size each round \u2192 while loop()\u80fd\u8fdb\u5f97\u53bb\u548c\u8df3\u7684\u51fa\u6765 [1, 2] min max mid case 1 max = mid - 1 case 2 min = mid Test cover all possible code branches 10 / 3 = 3","title":"Notes for a mock interview"},{"location":"Interview/dynamic-programming-1/","text":"Dynamic Programming 1 \u00b6 what to do when asking a DP question \u00b6 base case induction rule: DP[i] physical meaning find global min/max \u00b6 recusion: DFS -> permute all possible outcomes -> optimal BFS - heap Greedy - need proof DP Q0: largest sum of a subarray \u00b6 {1, 2, 4, -1, -2, 10, 1} => {1, 2, 4, -1, -2, 10} with max sum of 14 Q1: maximal product: cutting rope \u00b6 Given a rope, cut the rope so that the product of total length is max","title":"Dynamic Programming 1"},{"location":"Interview/dynamic-programming-1/#dynamic-programming-1","text":"","title":"Dynamic Programming 1"},{"location":"Interview/dynamic-programming-1/#what-to-do-when-asking-a-dp-question","text":"base case induction rule: DP[i] physical meaning","title":"what to do when asking a DP question"},{"location":"Interview/dynamic-programming-1/#find-global-minmax","text":"recusion: DFS -> permute all possible outcomes -> optimal BFS - heap Greedy - need proof DP","title":"find global min/max"},{"location":"Interview/dynamic-programming-1/#q0-largest-sum-of-a-subarray","text":"{1, 2, 4, -1, -2, 10, 1} => {1, 2, 4, -1, -2, 10} with max sum of 14","title":"Q0: largest sum of a subarray"},{"location":"Interview/dynamic-programming-1/#q1-maximal-product-cutting-rope","text":"Given a rope, cut the rope so that the product of total length is max","title":"Q1: maximal product: cutting rope"},{"location":"Interview/dynamic-programming-4/","text":"Dynamic Programming 4 \u00b6 Q1 Longest increasing subarray and subsequence \u00b6 Subarray \u00b6 Given an unsorted array, find the length of the longest subarray in which the numbers are in ascending order. For example: if the input array is {7, 2, 3, 1, 5, 8, 9, 6}, the subarray with the most numbers in ascending order is {1, 5, 8, 9} and the expected output is 4. Using DP \u00b6 M[i]: length of the longest increasing subarray where the last element in the subarray is num[i]. induction rule: M[i] = M[i-1] if num[i] <= num[i-1] M[i] = M[i-1] + 1 else Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N], n; int main () { cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; int gMax = 0 ; int dp[n]; memset(dp, 0 , sizeof dp); dp[ 0 ] = 1 ; for ( int i = 1 ; i < n; ++ i) { if (num[i - 1 ] < num[i]) dp[i] = dp[i - 1 ] + 1 ; else dp[i] = 1 ; gMax = max(gMax, dp[i]); } cout << gMax; return 0 ; } Using greedy search \u00b6 Keep a global max to store the answer, and a local max to store the current max. - if num[i] > num[i-1]: local max ++, global max = max(global max, local max) - else: local max = 0 - return global max Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N], n; int main () { cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; int lMax = 1 , gMax = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i) { if (num[i] < num[i + 1 ]) gMax = max( ++ lMax, gMax); else lMax = 1 ; } cout << gMax; return 0 ; } Subsequence \u00b6 Given an unsorted array, find the length of the longest subsequence in which the numbers are in ascending order. For example: if the input array is {7, 2, 3, 1, 5, 8, 9, 6}, the subarray with the most numbers in ascending order is {2, 3, 5, 8, 9} and the expected output is 5. Using DP \u00b6 M[i]: longest length of the subsequence ending with num[i] induction rule: keep i-- to find the first element j from 0 to i - 1 that is less than num[i], and update M[i] = M[j] + 1 Code \u00b6 class Solution { public : int longest(vector < int > arr) { // write your solution here int n = arr.size(), res = 0 ; vector < int > m(n, 0 ); for ( int i = 0 ; i < arr.size(); ++ i) { int lMax = 0 ; for ( int j = 0 ; j < i; ++ j) { if (arr[j] < arr[i]) lMax = max(lMax, m[j]); } m[i] = lMax + 1 ; res = max(res, m[i]); } return res; } }; Using DP + Bsearch \u00b6 Keep an array called lowest_ending , lowest_ending[i] represents the LIS with length of i and the last element in the LIS is num[i]. So we can just return the size of the lowest_ending as the answer. - Induction rule for updating lowest_ending array: - if lowest_ending[i - 1] < num[i] -- meaning lowest_ending[i] = num[i] because all the element in the front are less than num[i] - else: find the first lowest_ending[j] >= num[i] , so that we can update the lowest_ending[j] = num[i] Code \u00b6 #include <iostream> using namespace std; const int N = 1010 ; int n, cnt; int w[N], f[N]; // w stores the input, f stores the lowest ending int main () { cin >> n; for ( int i = 0 ; i < n; i ++ ) cin >> w[i]; f[cnt ++ ] = w[ 0 ]; for ( int i = 1 ; i < n; i ++ ) { if (w[i] > f[cnt -1 ]) f[cnt ++ ] = w[i]; else { int l = 0 , r = cnt - 1 ; while (l < r) { int mid = (l + r) >> 1 ; if (f[mid] >= w[i]) r = mid; else l = mid + 1 ; } f[r] = w[i]; } } cout << cnt << endl; return 0 ; } \u4f5c\u8005\uff1a VictorWu \u94fe\u63a5\uff1a https : //www.acwing.com/solution/content/4807/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Subsequence return the path \u00b6 In addition to return the max lenght, return one of the path. Using a index array to represent the previous element's index \u00b6 pre[i]: last element's index in subsequence where the last element of the subsequence is num[i]. use the same method to get the length, but when updating the length also update the lastIdx that should point to the last element of the LIS. when recovering the path, use: cpp res[i] = arr[lastIdx]; lastIdx = pre[lastIdx]; to update. Code \u00b6 class Solution { public : vector < int > longest(vector < int > arr) { // write your solution here int n = arr.size(), gMax = 0 , lastIdx = -1 ; vector < int > pre(n, -1 ); vector < int > m(n, 0 ); for ( int i = 0 ; i < n; ++ i) { int lMax = 0 , preIdx = i; for ( int j = 0 ; j < i; ++ j) { if (arr[j] < arr[i]) { if (lMax < m[j]) { preIdx = j; lMax = m[j]; } } } m[i] = lMax + 1 ; pre[i] = preIdx; if (gMax < m[i]) { gMax = m[i]; lastIdx = i; } } vector < int > res(gMax); for ( int i = gMax - 1 ; i >= 0 ; -- i) { res[i] = arr[lastIdx]; lastIdx = pre[lastIdx]; } return res; } }; Q2 Find subset of points to form positive slope \u00b6 Given an array of coordinates of 2D points, how to find the largest subset of points in which any pair of points can form a line with positive slope. Conversion to LIS problem \u00b6 In order to form a positive slope line: y = kx + b, where k has to be greater than 0. Using math, k = \\frac{\\delta x}{\\delta y} k = \\frac{\\delta x}{\\delta y} . \\frac{x_1 - x_2}{y_1 - y_2} > 0 \\frac{x_1 - x_2}{y_1 - y_2} > 0 : meaning if x_1 < x_2 x_1 < x_2 then y_1 < y_2 y_1 < y_2 . Base on the above oberservation, we can first sort (ascending order) the points based on x value, so that we can choose any element points[i].x - points[j].x > 0 if i > j. Now the problem is reduced into how to choose j such that points[i].y - points[j].y > 0, which is equal to find the LIS of points.y in the sorted array. Code \u00b6 class Solution { public : int largest(vector < pair < int , int > > points) { sort(points.begin(), points.end(), [](pair < int , int >& l, pair < int , int >& r){ return l.first < r.first || (l.first == r.first && l.second > r.second); }); vector < int > lowest_end; // record the lowest possible ending lis where the length is idx for ( int i = 0 ; i < points.size(); ++ i) { int sz = lower_bound(lowest_end.begin(), lowest_end.end(), points[i].second) - lowest_end.begin(); if (sz >= lowest_end.size()) lowest_end.push_back(points[i].second); else lowest_end[sz] = points[i].second; } return lowest_end.size() == 1 ? 0 : lowest_end.size(); } }; Q3 Cutting wood \u00b6 2-D DP: interval \u00b6 DP[i][j]: minimal cost from A[i] to A[j] (inclusive) DP[i][j] = A[j] - A[i] + (DP[i][x] + DP[x][j]) -> where x - i is the length of the current cut","title":"Dynamic Programming 4"},{"location":"Interview/dynamic-programming-4/#dynamic-programming-4","text":"","title":"Dynamic Programming 4"},{"location":"Interview/dynamic-programming-4/#q1-longest-increasing-subarray-and-subsequence","text":"","title":"Q1 Longest increasing subarray and subsequence"},{"location":"Interview/dynamic-programming-4/#subarray","text":"Given an unsorted array, find the length of the longest subarray in which the numbers are in ascending order. For example: if the input array is {7, 2, 3, 1, 5, 8, 9, 6}, the subarray with the most numbers in ascending order is {1, 5, 8, 9} and the expected output is 4.","title":"Subarray"},{"location":"Interview/dynamic-programming-4/#using-dp","text":"M[i]: length of the longest increasing subarray where the last element in the subarray is num[i]. induction rule: M[i] = M[i-1] if num[i] <= num[i-1] M[i] = M[i-1] + 1 else","title":"Using DP"},{"location":"Interview/dynamic-programming-4/#code","text":"#include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N], n; int main () { cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; int gMax = 0 ; int dp[n]; memset(dp, 0 , sizeof dp); dp[ 0 ] = 1 ; for ( int i = 1 ; i < n; ++ i) { if (num[i - 1 ] < num[i]) dp[i] = dp[i - 1 ] + 1 ; else dp[i] = 1 ; gMax = max(gMax, dp[i]); } cout << gMax; return 0 ; }","title":"Code"},{"location":"Interview/dynamic-programming-4/#using-greedy-search","text":"Keep a global max to store the answer, and a local max to store the current max. - if num[i] > num[i-1]: local max ++, global max = max(global max, local max) - else: local max = 0 - return global max","title":"Using greedy search"},{"location":"Interview/dynamic-programming-4/#code_1","text":"#include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N], n; int main () { cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; int lMax = 1 , gMax = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i) { if (num[i] < num[i + 1 ]) gMax = max( ++ lMax, gMax); else lMax = 1 ; } cout << gMax; return 0 ; }","title":"Code"},{"location":"Interview/dynamic-programming-4/#subsequence","text":"Given an unsorted array, find the length of the longest subsequence in which the numbers are in ascending order. For example: if the input array is {7, 2, 3, 1, 5, 8, 9, 6}, the subarray with the most numbers in ascending order is {2, 3, 5, 8, 9} and the expected output is 5.","title":"Subsequence"},{"location":"Interview/dynamic-programming-4/#using-dp_1","text":"M[i]: longest length of the subsequence ending with num[i] induction rule: keep i-- to find the first element j from 0 to i - 1 that is less than num[i], and update M[i] = M[j] + 1","title":"Using DP"},{"location":"Interview/dynamic-programming-4/#code_2","text":"class Solution { public : int longest(vector < int > arr) { // write your solution here int n = arr.size(), res = 0 ; vector < int > m(n, 0 ); for ( int i = 0 ; i < arr.size(); ++ i) { int lMax = 0 ; for ( int j = 0 ; j < i; ++ j) { if (arr[j] < arr[i]) lMax = max(lMax, m[j]); } m[i] = lMax + 1 ; res = max(res, m[i]); } return res; } };","title":"Code"},{"location":"Interview/dynamic-programming-4/#using-dp-bsearch","text":"Keep an array called lowest_ending , lowest_ending[i] represents the LIS with length of i and the last element in the LIS is num[i]. So we can just return the size of the lowest_ending as the answer. - Induction rule for updating lowest_ending array: - if lowest_ending[i - 1] < num[i] -- meaning lowest_ending[i] = num[i] because all the element in the front are less than num[i] - else: find the first lowest_ending[j] >= num[i] , so that we can update the lowest_ending[j] = num[i]","title":"Using DP + Bsearch"},{"location":"Interview/dynamic-programming-4/#code_3","text":"#include <iostream> using namespace std; const int N = 1010 ; int n, cnt; int w[N], f[N]; // w stores the input, f stores the lowest ending int main () { cin >> n; for ( int i = 0 ; i < n; i ++ ) cin >> w[i]; f[cnt ++ ] = w[ 0 ]; for ( int i = 1 ; i < n; i ++ ) { if (w[i] > f[cnt -1 ]) f[cnt ++ ] = w[i]; else { int l = 0 , r = cnt - 1 ; while (l < r) { int mid = (l + r) >> 1 ; if (f[mid] >= w[i]) r = mid; else l = mid + 1 ; } f[r] = w[i]; } } cout << cnt << endl; return 0 ; } \u4f5c\u8005\uff1a VictorWu \u94fe\u63a5\uff1a https : //www.acwing.com/solution/content/4807/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Interview/dynamic-programming-4/#subsequence-return-the-path","text":"In addition to return the max lenght, return one of the path.","title":"Subsequence return the path"},{"location":"Interview/dynamic-programming-4/#using-a-index-array-to-represent-the-previous-elements-index","text":"pre[i]: last element's index in subsequence where the last element of the subsequence is num[i]. use the same method to get the length, but when updating the length also update the lastIdx that should point to the last element of the LIS. when recovering the path, use: cpp res[i] = arr[lastIdx]; lastIdx = pre[lastIdx]; to update.","title":"Using a index array to represent the previous element's index"},{"location":"Interview/dynamic-programming-4/#code_4","text":"class Solution { public : vector < int > longest(vector < int > arr) { // write your solution here int n = arr.size(), gMax = 0 , lastIdx = -1 ; vector < int > pre(n, -1 ); vector < int > m(n, 0 ); for ( int i = 0 ; i < n; ++ i) { int lMax = 0 , preIdx = i; for ( int j = 0 ; j < i; ++ j) { if (arr[j] < arr[i]) { if (lMax < m[j]) { preIdx = j; lMax = m[j]; } } } m[i] = lMax + 1 ; pre[i] = preIdx; if (gMax < m[i]) { gMax = m[i]; lastIdx = i; } } vector < int > res(gMax); for ( int i = gMax - 1 ; i >= 0 ; -- i) { res[i] = arr[lastIdx]; lastIdx = pre[lastIdx]; } return res; } };","title":"Code"},{"location":"Interview/dynamic-programming-4/#q2-find-subset-of-points-to-form-positive-slope","text":"Given an array of coordinates of 2D points, how to find the largest subset of points in which any pair of points can form a line with positive slope.","title":"Q2 Find subset of points to form positive slope"},{"location":"Interview/dynamic-programming-4/#conversion-to-lis-problem","text":"In order to form a positive slope line: y = kx + b, where k has to be greater than 0. Using math, k = \\frac{\\delta x}{\\delta y} k = \\frac{\\delta x}{\\delta y} . \\frac{x_1 - x_2}{y_1 - y_2} > 0 \\frac{x_1 - x_2}{y_1 - y_2} > 0 : meaning if x_1 < x_2 x_1 < x_2 then y_1 < y_2 y_1 < y_2 . Base on the above oberservation, we can first sort (ascending order) the points based on x value, so that we can choose any element points[i].x - points[j].x > 0 if i > j. Now the problem is reduced into how to choose j such that points[i].y - points[j].y > 0, which is equal to find the LIS of points.y in the sorted array.","title":"Conversion to LIS problem"},{"location":"Interview/dynamic-programming-4/#code_5","text":"class Solution { public : int largest(vector < pair < int , int > > points) { sort(points.begin(), points.end(), [](pair < int , int >& l, pair < int , int >& r){ return l.first < r.first || (l.first == r.first && l.second > r.second); }); vector < int > lowest_end; // record the lowest possible ending lis where the length is idx for ( int i = 0 ; i < points.size(); ++ i) { int sz = lower_bound(lowest_end.begin(), lowest_end.end(), points[i].second) - lowest_end.begin(); if (sz >= lowest_end.size()) lowest_end.push_back(points[i].second); else lowest_end[sz] = points[i].second; } return lowest_end.size() == 1 ? 0 : lowest_end.size(); } };","title":"Code"},{"location":"Interview/dynamic-programming-4/#q3-cutting-wood","text":"","title":"Q3 Cutting wood"},{"location":"Interview/dynamic-programming-4/#2-d-dp-interval","text":"DP[i][j]: minimal cost from A[i] to A[j] (inclusive) DP[i][j] = A[j] - A[i] + (DP[i][x] + DP[x][j]) -> where x - i is the length of the current cut","title":"2-D DP: interval"},{"location":"Interview/final-java/","text":"Final Exam \u00b6 Q1. Recruiting Event Schedules \u00b6 Our company is organizing a series of university recruiting events. Each day, we host an event at one university, but sometimes we want to take a break for one day before moving on to the next university. Given a sequence of universities, print all possible schedules of the recruiting events. Input: a string of universities. Each university is represented as a single capital letter. Output: all possible schedules. A lowercase letter \u201cx\u201d means we take a break. Example Input: String = \u201cABC\u201d Output: ABC ABxC AxBC AxBxC Analysis \u00b6 High Level: DFS, where each node has two branches: choose x or not There are n levels, and the last level has 2^n 2^n nodes, which means the time complexity is O(2^n) O(2^n) , and space complexity is O(n) O(n) Code \u00b6 package test ; public class RecruitingEventSchedules { private void dfs (String input, StringBuilder curr, int idx) { if (idx == input. length ()) { System. out . println (curr); return ; } // without x curr. append (input. charAt (idx)); dfs(input, curr, idx + 1 ); curr. deleteCharAt (curr. length () - 1 ); // with x if (curr. length () <= 0 ) return ; curr. append ( 'x' ); curr. append (input. charAt (idx)); dfs(input, curr, idx + 1 ); curr. deleteCharAt (curr. length () - 1 ); curr. deleteCharAt (curr. length () - 1 ); } public static void main (String [] args) { // TODO Auto-generated method stub String t1 = \"ABC\" ; String t2 = \"A\" ; String t3 = \"\" ; RecruitingEventSchedules sol = new RecruitingEventSchedules(); /* * ABC ABxC AxBC AxBxC */ sol. dfs (t1, new StringBuilder(), 0 ); sol. dfs (t2, new StringBuilder(), 0 ); // A sol. dfs (t3, new StringBuilder(), 0 ); // \"\" } } Q2. Cousins in a Binary Tree \u00b6 In a binary tree, two nodes are cousins of each other if they are at the same level and have different parents. For example, in the following tree: 6 / \\ 3 5 / \\ / \\ 7 8 1 2 7 and 1 are cousins. 3 and 5 are not cousins. 7 and 5 are not cousins. Given a binary tree and two nodes, determine if the two nodes are cousins or not. Analysis: BFS method \u00b6 Assumption: if two nodes both don't exist, return false High Level: Using BFS to do a level-order traversal, then make judgement base on the 1. same parent or not, 2. same level or not. Time Complexity: O(n) O(n) Space Complexity: O(n) O(n) Code in Cpp: BFS \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isCousins(TreeNode * root, int x, int y) { queue < TreeNode *> q({root}); while ( ! q.empty()) { int sz = q.size(); bool left = false , right = false ; while (sz -- ) { TreeNode * curr = q.front(); q.pop(); if (curr -> val == x) left = true ; if (curr -> val == y) right = true ; if (left && right) return true ; if (curr -> left) q.push(curr -> left); if (curr -> right) q.push(curr -> right); // check if sharing same parent for next level, so that on current level we don't need to do a same check again if (curr -> left && curr -> right) { if (curr -> left -> val == x && curr -> right -> val == y) return false ; else if (curr -> right -> val == x && curr -> left -> val == y) return false ; } } } return false ; } }; Analysis: LCA method \u00b6 Assumption: if two nodes both don't exist, return false High Level: using LCA to find if two nodes share the same ancestor, and then check the level Base case: DFS finish but not be able to find the node -> root == null then return special value -1, DFS current node is one of node a OR node b -> return current level. Recursive Rule: do a Post-order traversal, grab the level of two nodes and check current level, two nodes levels. Return: only return the level that has found the LCA. Code: LCA \u00b6 public boolean findCusion(TreeNode root, TreeNode a, TreeNode b) { if (root == null || a == null || b == null) return false ; boolean[] res = new boolean[]{ false }; dfs(root, a, b, 0 , res); return res[ 0 ]; } public int dfs(TreeNode root, TreeNode a, TreeNode b, int level, boolean[] res) { if (root == null) return -1 ; if (root == a || root == b) return level; int left = dfs(root.left, a, b, level + 1 , res); int right = dfs(root.right, a, b, level + 1 , res); if (left == right && left - level > 1 ) res[ 0 ] = true ; return left == -1 ? right : left; } Q3. Packing Up the Swags \u00b6 Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Analysis \u00b6 Assumption: for n = 0, return 0 High Level: using DP to record all the previous calculated configuration for 0 to n - 1, and find the smallest one among them to contruct current one Recursive Rule: dp[i] = min(dp[i - sqrt(i)] to dp[i - 1]) + 1 Notice: don't forget the case when n == perfect square number, in this case, set it to 1 Code: Cpp \u00b6 class Solution { public : int numSquares( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; } }; Q4. Infinite Loop Around the Dinner Table \u00b6 After the event, our company will take the students out for dinner. The restaurant has a large round table that can fit the whole party. We want to know if we can arrange the students so that the names of all students around the table form an \u201cinfinite loop.\u201d For each pair of neighboring students s1 and s2, the last letter of s1\u2019s name must be identical to the first letter of s2\u2019s name. For example, \u201cALICE\u201d and \u201cERIC\u201d can sit together, but \u201cALICE\u201d and \u201cBOB\u201d cannot. Given an array of names, determine if it is possible to arrange the students at the round table in this way. Input: an array of names. Each name contains capital letters only. Output: true or false. Example Input: String[] = {\u201cALICE\u201d, \u201cCHARLES\u201d, \u201cERIC\u201d, \u201cSOPHIA\u201d} Output: true Analysis: Check cycle in graph \u00b6 Assumption: each string has a length >= 1, if length is 1, then start == end. High Level: DFS/BFS to check the cycle in the graph. If the graph has a cycle AND all the nodes has visited, then return true. Build Graph: each node is a letter, and it's a DAG. E.g. \"ABC\" then \"A\" points to \"C\", for two letters: \"ABC\" and \"CBF\", then the graph will look like A -> C -> F Analysis: Permutation \u00b6 High Level: because the final configuration has to be one of the permutation of the current array, we can just check all the permutation. Time Complexity: O(n!) O(n!) Space Compleity: O(n) O(n) Code: Permutation \u00b6 public boolean canChain (String [] strArr) { return helper(strArr, 1 ); } public boolean helper (String [] strArr, int index) { if (index == strArr. length ) return canConnect(strArr [ index - 1] , strArr [0] ); // head -> tail for ( int i = index; i < strArr. length ; ++ i) { if (canConnect(strArr [ index [ i - 1] , strArr [ i ] )) { swap(strArr, index, i); if (helper(strArr, index + 1 )) return true ; swap(strArr, i, index); } } return false ; } private boolean canConnect (String s1, String s2) { return s1. charAt (s1. length () - 1 ) == s2. charAt ( 0 ); }","title":"Final Exam"},{"location":"Interview/final-java/#final-exam","text":"","title":"Final Exam"},{"location":"Interview/final-java/#q1-recruiting-event-schedules","text":"Our company is organizing a series of university recruiting events. Each day, we host an event at one university, but sometimes we want to take a break for one day before moving on to the next university. Given a sequence of universities, print all possible schedules of the recruiting events. Input: a string of universities. Each university is represented as a single capital letter. Output: all possible schedules. A lowercase letter \u201cx\u201d means we take a break. Example Input: String = \u201cABC\u201d Output: ABC ABxC AxBC AxBxC","title":"Q1. Recruiting Event Schedules"},{"location":"Interview/final-java/#analysis","text":"High Level: DFS, where each node has two branches: choose x or not There are n levels, and the last level has 2^n 2^n nodes, which means the time complexity is O(2^n) O(2^n) , and space complexity is O(n) O(n)","title":"Analysis"},{"location":"Interview/final-java/#code","text":"package test ; public class RecruitingEventSchedules { private void dfs (String input, StringBuilder curr, int idx) { if (idx == input. length ()) { System. out . println (curr); return ; } // without x curr. append (input. charAt (idx)); dfs(input, curr, idx + 1 ); curr. deleteCharAt (curr. length () - 1 ); // with x if (curr. length () <= 0 ) return ; curr. append ( 'x' ); curr. append (input. charAt (idx)); dfs(input, curr, idx + 1 ); curr. deleteCharAt (curr. length () - 1 ); curr. deleteCharAt (curr. length () - 1 ); } public static void main (String [] args) { // TODO Auto-generated method stub String t1 = \"ABC\" ; String t2 = \"A\" ; String t3 = \"\" ; RecruitingEventSchedules sol = new RecruitingEventSchedules(); /* * ABC ABxC AxBC AxBxC */ sol. dfs (t1, new StringBuilder(), 0 ); sol. dfs (t2, new StringBuilder(), 0 ); // A sol. dfs (t3, new StringBuilder(), 0 ); // \"\" } }","title":"Code"},{"location":"Interview/final-java/#q2-cousins-in-a-binary-tree","text":"In a binary tree, two nodes are cousins of each other if they are at the same level and have different parents. For example, in the following tree: 6 / \\ 3 5 / \\ / \\ 7 8 1 2 7 and 1 are cousins. 3 and 5 are not cousins. 7 and 5 are not cousins. Given a binary tree and two nodes, determine if the two nodes are cousins or not.","title":"Q2. Cousins in a Binary Tree"},{"location":"Interview/final-java/#analysis-bfs-method","text":"Assumption: if two nodes both don't exist, return false High Level: Using BFS to do a level-order traversal, then make judgement base on the 1. same parent or not, 2. same level or not. Time Complexity: O(n) O(n) Space Complexity: O(n) O(n)","title":"Analysis: BFS method"},{"location":"Interview/final-java/#code-in-cpp-bfs","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isCousins(TreeNode * root, int x, int y) { queue < TreeNode *> q({root}); while ( ! q.empty()) { int sz = q.size(); bool left = false , right = false ; while (sz -- ) { TreeNode * curr = q.front(); q.pop(); if (curr -> val == x) left = true ; if (curr -> val == y) right = true ; if (left && right) return true ; if (curr -> left) q.push(curr -> left); if (curr -> right) q.push(curr -> right); // check if sharing same parent for next level, so that on current level we don't need to do a same check again if (curr -> left && curr -> right) { if (curr -> left -> val == x && curr -> right -> val == y) return false ; else if (curr -> right -> val == x && curr -> left -> val == y) return false ; } } } return false ; } };","title":"Code in Cpp: BFS"},{"location":"Interview/final-java/#analysis-lca-method","text":"Assumption: if two nodes both don't exist, return false High Level: using LCA to find if two nodes share the same ancestor, and then check the level Base case: DFS finish but not be able to find the node -> root == null then return special value -1, DFS current node is one of node a OR node b -> return current level. Recursive Rule: do a Post-order traversal, grab the level of two nodes and check current level, two nodes levels. Return: only return the level that has found the LCA.","title":"Analysis: LCA method"},{"location":"Interview/final-java/#code-lca","text":"public boolean findCusion(TreeNode root, TreeNode a, TreeNode b) { if (root == null || a == null || b == null) return false ; boolean[] res = new boolean[]{ false }; dfs(root, a, b, 0 , res); return res[ 0 ]; } public int dfs(TreeNode root, TreeNode a, TreeNode b, int level, boolean[] res) { if (root == null) return -1 ; if (root == a || root == b) return level; int left = dfs(root.left, a, b, level + 1 , res); int right = dfs(root.right, a, b, level + 1 , res); if (left == right && left - level > 1 ) res[ 0 ] = true ; return left == -1 ? right : left; }","title":"Code: LCA"},{"location":"Interview/final-java/#q3-packing-up-the-swags","text":"Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9.","title":"Q3. Packing Up the Swags"},{"location":"Interview/final-java/#analysis_1","text":"Assumption: for n = 0, return 0 High Level: using DP to record all the previous calculated configuration for 0 to n - 1, and find the smallest one among them to contruct current one Recursive Rule: dp[i] = min(dp[i - sqrt(i)] to dp[i - 1]) + 1 Notice: don't forget the case when n == perfect square number, in this case, set it to 1","title":"Analysis"},{"location":"Interview/final-java/#code-cpp","text":"class Solution { public : int numSquares( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; } };","title":"Code: Cpp"},{"location":"Interview/final-java/#q4-infinite-loop-around-the-dinner-table","text":"After the event, our company will take the students out for dinner. The restaurant has a large round table that can fit the whole party. We want to know if we can arrange the students so that the names of all students around the table form an \u201cinfinite loop.\u201d For each pair of neighboring students s1 and s2, the last letter of s1\u2019s name must be identical to the first letter of s2\u2019s name. For example, \u201cALICE\u201d and \u201cERIC\u201d can sit together, but \u201cALICE\u201d and \u201cBOB\u201d cannot. Given an array of names, determine if it is possible to arrange the students at the round table in this way. Input: an array of names. Each name contains capital letters only. Output: true or false. Example Input: String[] = {\u201cALICE\u201d, \u201cCHARLES\u201d, \u201cERIC\u201d, \u201cSOPHIA\u201d} Output: true","title":"Q4. Infinite Loop Around the Dinner Table"},{"location":"Interview/final-java/#analysis-check-cycle-in-graph","text":"Assumption: each string has a length >= 1, if length is 1, then start == end. High Level: DFS/BFS to check the cycle in the graph. If the graph has a cycle AND all the nodes has visited, then return true. Build Graph: each node is a letter, and it's a DAG. E.g. \"ABC\" then \"A\" points to \"C\", for two letters: \"ABC\" and \"CBF\", then the graph will look like A -> C -> F","title":"Analysis: Check cycle in graph"},{"location":"Interview/final-java/#analysis-permutation","text":"High Level: because the final configuration has to be one of the permutation of the current array, we can just check all the permutation. Time Complexity: O(n!) O(n!) Space Compleity: O(n) O(n)","title":"Analysis: Permutation"},{"location":"Interview/final-java/#code-permutation","text":"public boolean canChain (String [] strArr) { return helper(strArr, 1 ); } public boolean helper (String [] strArr, int index) { if (index == strArr. length ) return canConnect(strArr [ index - 1] , strArr [0] ); // head -> tail for ( int i = index; i < strArr. length ; ++ i) { if (canConnect(strArr [ index [ i - 1] , strArr [ i ] )) { swap(strArr, index, i); if (helper(strArr, index + 1 )) return true ; swap(strArr, i, index); } } return false ; } private boolean canConnect (String s1, String s2) { return s1. charAt (s1. length () - 1 ) == s2. charAt ( 0 ); }","title":"Code: Permutation"},{"location":"Interview/find-longest-substring-at-most-k-characters/","text":"Find longest substring at most k characters \u00b6 E.G. s=\"ddfaaaabbbca\", k=2 return 7 (longest substring size with at most k characters) Verification/Clarification \u00b6 signacture: int solve(string, int) k > 0 and if k > distinct chars size then return string.size() Analysis \u00b6 Use a sliding window to capture all the substring with distinct chars <= k keep current distinct elements keep two pointers left and right move right+1 and update current keep moving left until curr is greater than k now left - right has k distinct elements, so update global count return global length Code \u00b6 #include <bits/stdc++.h> using namespace std; int main () { string s; int k; cin >> k; cin >> s; int res = 0 , curr = 0 ; int cnt[ 26 ]; memset(cnt, 0 , sizeof cnt); int n = s.size(); for ( int i = 0 , j = 0 ; i < n; ++ i) { // j is left, i is right if (cnt[s[i] - 'a' ] ++ == 0 ) curr ++ ; // keep track of the distinct element in [j:i] while (curr > k) { if ( -- cnt[s[j] - 'a' ] == 0 ) curr -- ; ++ j; } res = max(res, i - j + 1 ); } cout << res; return 0 ; } Followup \u00b6 What if is a stream of data? How to decrease space complexity? Manage duplcates:","title":"Find longest substring at most k characters"},{"location":"Interview/find-longest-substring-at-most-k-characters/#find-longest-substring-at-most-k-characters","text":"E.G. s=\"ddfaaaabbbca\", k=2 return 7 (longest substring size with at most k characters)","title":"Find longest substring at most k characters"},{"location":"Interview/find-longest-substring-at-most-k-characters/#verificationclarification","text":"signacture: int solve(string, int) k > 0 and if k > distinct chars size then return string.size()","title":"Verification/Clarification"},{"location":"Interview/find-longest-substring-at-most-k-characters/#analysis","text":"Use a sliding window to capture all the substring with distinct chars <= k keep current distinct elements keep two pointers left and right move right+1 and update current keep moving left until curr is greater than k now left - right has k distinct elements, so update global count return global length","title":"Analysis"},{"location":"Interview/find-longest-substring-at-most-k-characters/#code","text":"#include <bits/stdc++.h> using namespace std; int main () { string s; int k; cin >> k; cin >> s; int res = 0 , curr = 0 ; int cnt[ 26 ]; memset(cnt, 0 , sizeof cnt); int n = s.size(); for ( int i = 0 , j = 0 ; i < n; ++ i) { // j is left, i is right if (cnt[s[i] - 'a' ] ++ == 0 ) curr ++ ; // keep track of the distinct element in [j:i] while (curr > k) { if ( -- cnt[s[j] - 'a' ] == 0 ) curr -- ; ++ j; } res = max(res, i - j + 1 ); } cout << res; return 0 ; }","title":"Code"},{"location":"Interview/find-longest-substring-at-most-k-characters/#followup","text":"What if is a stream of data? How to decrease space complexity? Manage duplcates:","title":"Followup"},{"location":"Interview/find-minimum-in-rotated-sorted-array/","text":"LaiCode 23: fina minimum in rotated sorted array \u00b6 Idea \u00b6 Two Situations: 2 4 5 6 0 1: mid (5) > r (1) -> l-mid is sorted and pivot is on the right -> if [right] < [left] then min is not on the l-mid -> search mid+1 - right (mid cannot be the minimum). 6 0 1 2 4 5: mid (1) < r -> right is sorted -> l-mid is what to be searched (minimum is located) -> mid can be the minimum (e.g. 6 7 | 1 2 4 5) // Assume array != null, array.length >= 2 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ r ] ; } strict -> loose 1. left <= right: 1 element can still jump in to the while loop 2. left < right: >= 2 elements 3. left < right - 1: >= 3 elements Two elements left (l < r - 1) \u00b6 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r - 1 ) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ l ] < array [ r ] ? array [ l ] : array [ r ] ; }","title":"Find minimum in rotated sorted array"},{"location":"Interview/find-minimum-in-rotated-sorted-array/#laicode-23-fina-minimum-in-rotated-sorted-array","text":"","title":"LaiCode 23: fina minimum in rotated sorted array"},{"location":"Interview/find-minimum-in-rotated-sorted-array/#idea","text":"Two Situations: 2 4 5 6 0 1: mid (5) > r (1) -> l-mid is sorted and pivot is on the right -> if [right] < [left] then min is not on the l-mid -> search mid+1 - right (mid cannot be the minimum). 6 0 1 2 4 5: mid (1) < r -> right is sorted -> l-mid is what to be searched (minimum is located) -> mid can be the minimum (e.g. 6 7 | 1 2 4 5) // Assume array != null, array.length >= 2 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ r ] ; } strict -> loose 1. left <= right: 1 element can still jump in to the while loop 2. left < right: >= 2 elements 3. left < right - 1: >= 3 elements","title":"Idea"},{"location":"Interview/find-minimum-in-rotated-sorted-array/#two-elements-left-l-r-1","text":"public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r - 1 ) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ l ] < array [ r ] ? array [ l ] : array [ r ] ; }","title":"Two elements left (l &lt; r - 1)"},{"location":"Interview/first-non-repeating-character-in-stream/","text":"First non repeating character in stream \u00b6 Given a stream of characters, find the first non-repeating character from stream. You need to tell the first non-repeating character in O(1) time at any moment. Implement two methods of the class: read() - read one character from the stream firstNonRepeating() - return the first non-repoeating character from the stream at any time when calling the method, return null if there does not exist such characters Examples: read: a b c a c c b firstNonRepeating: a a a b b b null https://app.laicode.io/app/problem/288 Analysis \u00b6 High Level: Need to keep record of all the unique charecter seen so far * in time order -> linkedlist to keep the order Need to delete the character when there is a duplicate one from the stream -> hashmap to track the relationship between the unique character and its position in the linkedlist Need to add unique character if not been seen so far -> a hashset to keep record all the unique character Code \u00b6 public class Solution { static class Node { Node prev; Node next; Character ch; Node(Character ch) { this . ch = ch; } } // only the char appears once can be appended to the linkedlist private Node head, tail; private HashMap < Character, Node > singled; private HashSet < Character > repeated; public Solution () { // Initialize the class. tail = new Node( null ); tail. next = tail. prev = tail; head = tail; singled = new HashMap < Character, Node > (); repeated = new HashSet < Character > (); } public void read ( char ch) { // appears more than once if (repeated. contains (ch)) { return ; } Node node = singled. get (ch); if (node == null ) { // doesn't exist in the map -> never appear node = new Node(ch); append(node); } else { // appear once remove(node); } } private void append (Node node) { // add to the linkedlist and the map singled. put (node. ch , node); tail. next = node; node. prev = tail; node. next = head; // circle Linkedlist tail = tail. next ; } private void remove (Node node) { // remove from the linkedlist and the map and add to the set (in the future don't accept any) node. prev . next = node. next ; node. next . prev = node. prev ; if (node == tail) { tail = node. prev ; } node. prev = node. next = null ; repeated. add (node. ch ); singled. remove (node. ch ); } public Character firstNonRepeating () { // Implement this method here. if (head == tail) return null ; return head. next . ch ; } }","title":"First non repeating character in stream"},{"location":"Interview/first-non-repeating-character-in-stream/#first-non-repeating-character-in-stream","text":"Given a stream of characters, find the first non-repeating character from stream. You need to tell the first non-repeating character in O(1) time at any moment. Implement two methods of the class: read() - read one character from the stream firstNonRepeating() - return the first non-repoeating character from the stream at any time when calling the method, return null if there does not exist such characters Examples: read: a b c a c c b firstNonRepeating: a a a b b b null https://app.laicode.io/app/problem/288","title":"First non repeating character in stream"},{"location":"Interview/first-non-repeating-character-in-stream/#analysis","text":"High Level: Need to keep record of all the unique charecter seen so far * in time order -> linkedlist to keep the order Need to delete the character when there is a duplicate one from the stream -> hashmap to track the relationship between the unique character and its position in the linkedlist Need to add unique character if not been seen so far -> a hashset to keep record all the unique character","title":"Analysis"},{"location":"Interview/first-non-repeating-character-in-stream/#code","text":"public class Solution { static class Node { Node prev; Node next; Character ch; Node(Character ch) { this . ch = ch; } } // only the char appears once can be appended to the linkedlist private Node head, tail; private HashMap < Character, Node > singled; private HashSet < Character > repeated; public Solution () { // Initialize the class. tail = new Node( null ); tail. next = tail. prev = tail; head = tail; singled = new HashMap < Character, Node > (); repeated = new HashSet < Character > (); } public void read ( char ch) { // appears more than once if (repeated. contains (ch)) { return ; } Node node = singled. get (ch); if (node == null ) { // doesn't exist in the map -> never appear node = new Node(ch); append(node); } else { // appear once remove(node); } } private void append (Node node) { // add to the linkedlist and the map singled. put (node. ch , node); tail. next = node; node. prev = tail; node. next = head; // circle Linkedlist tail = tail. next ; } private void remove (Node node) { // remove from the linkedlist and the map and add to the set (in the future don't accept any) node. prev . next = node. next ; node. next . prev = node. prev ; if (node == tail) { tail = node. prev ; } node. prev = node. next = null ; repeated. add (node. ch ); singled. remove (node. ch ); } public Character firstNonRepeating () { // Implement this method here. if (head == tail) return null ; return head. next . ch ; } }","title":"Code"},{"location":"Interview/graph/","text":"Graph \u00b6 Tree vs Graph \u00b6 Graph can have cycle while tree cannot Graph can be not connected, which tree cannot Analyze Time Complexiy \u00b6 G = V + E V: vertex, E: edge min edge = 0 (not connected) max edge = V^2 V^2 (each vertex can connect to all the other in directed graph) O(N) = O(V^2) O(N) = O(V^2) DFS vs BFS: space less than BFS \u00b6 1.5 Given an input array with integers, how to split the array into k subarray, such that each subarray shares the same sum. e.g. input[N] = {3,-1,4,6,-8,1,1}, and k = 3 output = {3,-1} {4,6,-8} {1,1} with all sum is equal to two 1.6 Given an input array with integers, how to split the array into k subarrays (subarray may NOT be adjacent to each other), such that each subarray shares the same sum E.g. input[N] = { 3 -1,1 1 1 2 2 2 4, 6, -8, 1, 1 }. and k == 3. Output = {3,-1} {4, 6, - 8} {1, 1} which all have a sum that is equal to two.","title":"Graph"},{"location":"Interview/graph/#graph","text":"","title":"Graph"},{"location":"Interview/graph/#tree-vs-graph","text":"Graph can have cycle while tree cannot Graph can be not connected, which tree cannot","title":"Tree vs Graph"},{"location":"Interview/graph/#analyze-time-complexiy","text":"G = V + E V: vertex, E: edge min edge = 0 (not connected) max edge = V^2 V^2 (each vertex can connect to all the other in directed graph) O(N) = O(V^2) O(N) = O(V^2)","title":"Analyze Time Complexiy"},{"location":"Interview/graph/#dfs-vs-bfs-space-less-than-bfs","text":"1.5 Given an input array with integers, how to split the array into k subarray, such that each subarray shares the same sum. e.g. input[N] = {3,-1,4,6,-8,1,1}, and k = 3 output = {3,-1} {4,6,-8} {1,1} with all sum is equal to two 1.6 Given an input array with integers, how to split the array into k subarrays (subarray may NOT be adjacent to each other), such that each subarray shares the same sum E.g. input[N] = { 3 -1,1 1 1 2 2 2 4, 6, -8, 1, 1 }. and k == 3. Output = {3,-1} {4, 6, - 8} {1, 1} which all have a sum that is equal to two.","title":"DFS vs BFS: space less than BFS"},{"location":"Interview/greedy-algorithm/","text":"Greedy Algorithm \u00b6 Coin: goal is to minimize the total number of coins cannot be solved by using greedy \u00b6 Given a list of all avalible coins = {c_1, c_2, c_3, ..., c_k} {c_1, c_2, c_3, ..., c_k} and each coin can be used as many times as we want, what is the minimum number of coins needed? NOTE: this problem cannot be solved by greedy algorithm! We can prove that a greedy algorithm does not work by showing a counterexample where the algorithm gives a wrong answer. In this problem we can easily find a counterexample: if the coins are {1,3,4} and the target sum is 6, the greedy algorithm produces the solution 4 + 1 + 1 while the optimal solution is 3 + 3. Schedulin: goal is to maximize the number of jobs \u00b6 Given a list of intervals, your job is to find the maximum of intervals from the list that do not intersect with any two. E.G. [1,3],[2,5],[3,9],[6,8] => choose either [[1,3], [3,9]] or [[2,5],[6,8]] will work (notice that you can have multiple answers, but we are looking for the maxmium count/number but not each configurations). To solve this classic problem, we can sort each interval by its' ending timestamp, then starting from the left (earliest ending time) we choose the intervals that do not intersection will previous right most boundary. LC646. Maximum Length of Pair Chain, LC253. Meeting Room II Task and deadlines: goal is to maximize the total points/scores \u00b6 Given a list of tasks with durations and deadlines, your job is to find the maximum points from scheduling these tasks. To calculate score: d(deadline) - x(finish time). E.G. To solve this problem, instead of sorting by ending/deadline, we just need to sort by durations. We have to include all the intervals in this case, so the first thing is to make sure shorter tasks get finished earlier so that they won't \"lagged back\" the remaining tasks, since the score depends the completion time of each interval. From here, we can find that the answer doesn't depend on deadline at all (if we assume score can be negative).","title":"Greedy Algorithm"},{"location":"Interview/greedy-algorithm/#greedy-algorithm","text":"","title":"Greedy Algorithm"},{"location":"Interview/greedy-algorithm/#coin-goal-is-to-minimize-the-total-number-of-coins-cannot-be-solved-by-using-greedy","text":"Given a list of all avalible coins = {c_1, c_2, c_3, ..., c_k} {c_1, c_2, c_3, ..., c_k} and each coin can be used as many times as we want, what is the minimum number of coins needed? NOTE: this problem cannot be solved by greedy algorithm! We can prove that a greedy algorithm does not work by showing a counterexample where the algorithm gives a wrong answer. In this problem we can easily find a counterexample: if the coins are {1,3,4} and the target sum is 6, the greedy algorithm produces the solution 4 + 1 + 1 while the optimal solution is 3 + 3.","title":"Coin: goal is to minimize the total number of coins cannot be solved by using greedy"},{"location":"Interview/greedy-algorithm/#schedulin-goal-is-to-maximize-the-number-of-jobs","text":"Given a list of intervals, your job is to find the maximum of intervals from the list that do not intersect with any two. E.G. [1,3],[2,5],[3,9],[6,8] => choose either [[1,3], [3,9]] or [[2,5],[6,8]] will work (notice that you can have multiple answers, but we are looking for the maxmium count/number but not each configurations). To solve this classic problem, we can sort each interval by its' ending timestamp, then starting from the left (earliest ending time) we choose the intervals that do not intersection will previous right most boundary. LC646. Maximum Length of Pair Chain, LC253. Meeting Room II","title":"Schedulin: goal is to maximize the number of jobs"},{"location":"Interview/greedy-algorithm/#task-and-deadlines-goal-is-to-maximize-the-total-pointsscores","text":"Given a list of tasks with durations and deadlines, your job is to find the maximum points from scheduling these tasks. To calculate score: d(deadline) - x(finish time). E.G. To solve this problem, instead of sorting by ending/deadline, we just need to sort by durations. We have to include all the intervals in this case, so the first thing is to make sure shorter tasks get finished earlier so that they won't \"lagged back\" the remaining tasks, since the score depends the completion time of each interval. From here, we can find that the answer doesn't depend on deadline at all (if we assume score can be negative).","title":"Task and deadlines: goal is to maximize the total points/scores"},{"location":"Interview/gs/","text":"Goldman Sachs \u00b6 Balanced Array \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> num[i]; } int presum[n]; memset(presum, 0 , sizeof presum); for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) presum[i] = num[i]; else presum[i] += num[i] + presum[i - 1 ]; } for ( int i = 0 ; i < n; ++ i ) { if (presum[i] - num[i] == presum[n - 1 ] - presum[i]) { cout << i << endl; return 0 ; } } cout << -1 ; }","title":"Goldman Sachs"},{"location":"Interview/gs/#goldman-sachs","text":"","title":"Goldman Sachs"},{"location":"Interview/gs/#balanced-array","text":"#include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> num[i]; } int presum[n]; memset(presum, 0 , sizeof presum); for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) presum[i] = num[i]; else presum[i] += num[i] + presum[i - 1 ]; } for ( int i = 0 ; i < n; ++ i ) { if (presum[i] - num[i] == presum[n - 1 ] - presum[i]) { cout << i << endl; return 0 ; } } cout << -1 ; }","title":"Balanced Array"},{"location":"Interview/hashmap/","text":"Hashmap \u00b6 Terms \u00b6 Collision : when two keys' hash values are the same, they are going to map to the two same location in the array. Load Factor : assume your hash table has size m, which means that there is room for up to m items in it. But we also care about how many elements we are actually storing in the array right now \u2014 we denote this number by s. The ratio alpha = \\frac{s}{m} alpha = \\frac{s}{m} is called the load factor of the hash table. When it is small, there is a lot of room in the table. If it ever exceeds 1, we are guaranteed that a collision must have occurre. Typically, load factor maintains the ratio of number of <key, value> pairs / number of buckets. Usually it's under \u00bd. This array has a loading factor of 7/13. Hashing Function : So how many random keys do we need to draw until we expect to see our first collision? There are m possible indices of h(k) we can draw, and if any two draws have the same index, then we have a collision. This is exactly an instance of the Birthday Paradox, so we would expect our first collision to occur around key number \\theta(\\sqrt{m}) \\theta(\\sqrt{m}) . In other words, even if we think that the keys are drawn randomly (which should be pretty friendly to the hash table), the first collisions should occur around load factor \\alpha = \\theta(\\sqrt{m}) \\alpha = \\theta(\\sqrt{m}) . This is all the more reason why we will need to deal with collisions below. Modulo Arithmetic: h(k) = k h(k) = k mod m m the problem is that it might get very clustered key items in particular digits (e.g. m = 10 then all the if all numbers has the same last two digits will fall into the same key). Solution: choose a large prime number. Chaining : using a linkedlist to store all the collide values, do a linear scan to check if exist in the linkedlist. Time Complexity: assume the size of each linkedlist is l_i l_i , and we have s s elements in total, then the possibability for a given element to fall on l_i l_i is l_i / s l_i / s , it will take \\theta(l_i) \\theta(l_i) to find in the linkedlist. Thus the total time complexity is \\theta (\\frac{1}{s} \\times \\sum_i l_i^{2}) \\theta (\\frac{1}{s} \\times \\sum_i l_i^{2}) Probing or Open Addressing : use only one list to store all the values, and find the next avaliable location for inserting if there is a collision. Linear Probing: if position i is occupied, then try i + 1, i + 2... until find the first free place. In practice it's a bad idea: assume you have filled 0, ..., m / 2 positions in the list. The possibability of filling next element that will fall in 0, ..., m / 2 is \u00bd, which will take m/2 + 1 operations to find the next avaliable place. TODO: add open addressing Designing Thread Safe Lookup table (hashmap or std::map<T,T> ) \u00b6 One solution to prevent data racing is by adding mutex lock everytime we want to do any operation. Can we do better? There are three common ways of implementing an associateive container like lookup table: A balanced binary tree, such as red-black tree (have to lock the root, which has no difference than locking the entire tree) A sorted array (still have to lock the entire array) A hash table ( we can just lock the bucket we are accessing! ) Example implementation \u00b6 template < typename Key, typename Value, typename Hash = std :: hash < Key >> class threadsafe_lookup_table { private : class bucket_type { public : Value value_for(Key const & key, Value const & default_value) const { std :: shared_lock < std :: shared_mutex > lock(mutex); bucket_iterator const found_entry = find_entry_for(key); return (found_entry == data.end()) ? default_value : found_entry -> second; } void add_or_update_mapping(Key const & key, Value const & value) { std :: unique_lock < std :: shared_mutex > lock(mutex); bucket_iterator const found_entry = find_entry_for(key); return (found_entry == data.end()) ? default_value : found_entry -> second; } void remove_mapping(Key const & key) { std :: unique_lock < std :: shared_mutex > lock(mutex); bucket_iterator const found_entry = find_entry_for(key); if (found_entry != data.end()) data.erase(found_entry); } private : typedef std :: pair < Key, Value > bucket_value; typedef std :: list < bucket_value > bucket_data; typedef typename bucket_data :: iterator bucket_iterator; bucket_data data; mutable std :: shared_mutex mutex; bucket_iterator find_entry_for (Key const & key) const { return std :: find_if( data.begin(), data.end(), [ & ](bucket_value const & item) { return item.first == key; }); } }; std :: vector < std :: unique_lock < bucket_type >> buckets; Hash hasher; bucket_type & get_bucket (Key const & key) const { std :: size_t const bucket_index = hasher(key) % buckets.size(); return * buckets[bucket_index]; } public : typedef Key key_type; typedef Value mapped_type; typedef Hash hash_type; threadsafe_lookup_table( unsigned num_buckets = 19 , // arbitary prime number Hash const & hasher_ = Hash()) : buckets(num_buckets), hasher(hasher_) { for ( unsigned i = 0 ; i < num_buckets; ++ i) { buckets[i].reset(new bucket_type); } } threadsafe_lookup_table(threadsafe_lookup_table const & other) = delete; threadsafe_lookup_table & operator = (threadsafe_lookup_table const & other) = delete; Value value_for (Key const & key, Value const & default_value = Value()) const { return get_bucket(key).value_for(key, default_value); } void add_or_update_mapping (Key const & key, Value const & value) { get_bucket(key).add_or_update_mapping(key, value); } void remove_mapping (Key const & key) { get_bucket(key).remove_mapping(key); } };","title":"Hashmap"},{"location":"Interview/hashmap/#hashmap","text":"","title":"Hashmap"},{"location":"Interview/hashmap/#terms","text":"Collision : when two keys' hash values are the same, they are going to map to the two same location in the array. Load Factor : assume your hash table has size m, which means that there is room for up to m items in it. But we also care about how many elements we are actually storing in the array right now \u2014 we denote this number by s. The ratio alpha = \\frac{s}{m} alpha = \\frac{s}{m} is called the load factor of the hash table. When it is small, there is a lot of room in the table. If it ever exceeds 1, we are guaranteed that a collision must have occurre. Typically, load factor maintains the ratio of number of <key, value> pairs / number of buckets. Usually it's under \u00bd. This array has a loading factor of 7/13. Hashing Function : So how many random keys do we need to draw until we expect to see our first collision? There are m possible indices of h(k) we can draw, and if any two draws have the same index, then we have a collision. This is exactly an instance of the Birthday Paradox, so we would expect our first collision to occur around key number \\theta(\\sqrt{m}) \\theta(\\sqrt{m}) . In other words, even if we think that the keys are drawn randomly (which should be pretty friendly to the hash table), the first collisions should occur around load factor \\alpha = \\theta(\\sqrt{m}) \\alpha = \\theta(\\sqrt{m}) . This is all the more reason why we will need to deal with collisions below. Modulo Arithmetic: h(k) = k h(k) = k mod m m the problem is that it might get very clustered key items in particular digits (e.g. m = 10 then all the if all numbers has the same last two digits will fall into the same key). Solution: choose a large prime number. Chaining : using a linkedlist to store all the collide values, do a linear scan to check if exist in the linkedlist. Time Complexity: assume the size of each linkedlist is l_i l_i , and we have s s elements in total, then the possibability for a given element to fall on l_i l_i is l_i / s l_i / s , it will take \\theta(l_i) \\theta(l_i) to find in the linkedlist. Thus the total time complexity is \\theta (\\frac{1}{s} \\times \\sum_i l_i^{2}) \\theta (\\frac{1}{s} \\times \\sum_i l_i^{2}) Probing or Open Addressing : use only one list to store all the values, and find the next avaliable location for inserting if there is a collision. Linear Probing: if position i is occupied, then try i + 1, i + 2... until find the first free place. In practice it's a bad idea: assume you have filled 0, ..., m / 2 positions in the list. The possibability of filling next element that will fall in 0, ..., m / 2 is \u00bd, which will take m/2 + 1 operations to find the next avaliable place. TODO: add open addressing","title":"Terms"},{"location":"Interview/hashmap/#designing-thread-safe-lookup-table-hashmap-or-stdmaptt","text":"One solution to prevent data racing is by adding mutex lock everytime we want to do any operation. Can we do better? There are three common ways of implementing an associateive container like lookup table: A balanced binary tree, such as red-black tree (have to lock the root, which has no difference than locking the entire tree) A sorted array (still have to lock the entire array) A hash table ( we can just lock the bucket we are accessing! )","title":"Designing Thread Safe Lookup table (hashmap or std::map&lt;T,T&gt;)"},{"location":"Interview/hashmap/#example-implementation","text":"template < typename Key, typename Value, typename Hash = std :: hash < Key >> class threadsafe_lookup_table { private : class bucket_type { public : Value value_for(Key const & key, Value const & default_value) const { std :: shared_lock < std :: shared_mutex > lock(mutex); bucket_iterator const found_entry = find_entry_for(key); return (found_entry == data.end()) ? default_value : found_entry -> second; } void add_or_update_mapping(Key const & key, Value const & value) { std :: unique_lock < std :: shared_mutex > lock(mutex); bucket_iterator const found_entry = find_entry_for(key); return (found_entry == data.end()) ? default_value : found_entry -> second; } void remove_mapping(Key const & key) { std :: unique_lock < std :: shared_mutex > lock(mutex); bucket_iterator const found_entry = find_entry_for(key); if (found_entry != data.end()) data.erase(found_entry); } private : typedef std :: pair < Key, Value > bucket_value; typedef std :: list < bucket_value > bucket_data; typedef typename bucket_data :: iterator bucket_iterator; bucket_data data; mutable std :: shared_mutex mutex; bucket_iterator find_entry_for (Key const & key) const { return std :: find_if( data.begin(), data.end(), [ & ](bucket_value const & item) { return item.first == key; }); } }; std :: vector < std :: unique_lock < bucket_type >> buckets; Hash hasher; bucket_type & get_bucket (Key const & key) const { std :: size_t const bucket_index = hasher(key) % buckets.size(); return * buckets[bucket_index]; } public : typedef Key key_type; typedef Value mapped_type; typedef Hash hash_type; threadsafe_lookup_table( unsigned num_buckets = 19 , // arbitary prime number Hash const & hasher_ = Hash()) : buckets(num_buckets), hasher(hasher_) { for ( unsigned i = 0 ; i < num_buckets; ++ i) { buckets[i].reset(new bucket_type); } } threadsafe_lookup_table(threadsafe_lookup_table const & other) = delete; threadsafe_lookup_table & operator = (threadsafe_lookup_table const & other) = delete; Value value_for (Key const & key, Value const & default_value = Value()) const { return get_bucket(key).value_for(key, default_value); } void add_or_update_mapping (Key const & key, Value const & value) { get_bucket(key).add_or_update_mapping(key, value); } void remove_mapping (Key const & key) { get_bucket(key).remove_mapping(key); } };","title":"Example implementation"},{"location":"Interview/k-sum-problem/","text":"K sum problem \u00b6 Find X-elements from an array such that their sum is equal to a target value \u00b6 things to clarify : 1. return value or return true/false or return index 2. data size 3. duplication (assume no duplication) 4. sorted vs unsorted 5. data type: int 6. optimize for time or optimize for space P1: 2Sum \u00b6 https://leetcode.com/problems/two-sum/ Solution 1 -- use hashmap \u00b6 class Solution { public : vector < int > twoSum(vector < int >& nums, int target) { unordered_map < int , int > checker; // val => index for ( int i = 0 ; i < nums.size(); ++ i) { int com = target - nums[i]; // find comlement if (checker.find(com) != checker.end()) return {i, checker[com]}; checker[nums[i]] = i; } return {}; } }; Time: O(n) O(n) Space: O(n) O(n) Solution 2 (input array is sorted) -- two pointers \u00b6 class Solution { public : bool twoSum(vector < int >& nums, int target) { // return true if exit, else false; for ( int i = 0 , j = nums.size() - 1 ; i < j;) { int curr = nums[i] + nums[j]; if (curr == target) return true ; else if (curr > target) j -- ; else i ++ ; } return false ; } }; Time: O(n) O(n) Space: O(n) O(n) for sorting (aux array for merge sort, if using quick sort it will be O(1) O(1) ) Solution 4 (unsorted, but goal is optimize for space, and the input array is mutable ) \u00b6 class Solution { public : bool twoSum(vector < int >& nums, int target) { // return true if exit, else false; for ( int i = 0 ; i < nums.size(); ++ i) for ( int j = 0 ; j < nums.size(); ++ j) if (nums[i] + nums[j] == target) return true ; return false ; } }; Time: O(n^2) O(n^2) Space: O(1) O(1) Variant 1: with duplicate and return all the index pairs \u00b6 class Solution { public : vector < vector < int >> allPairs(vector < int > array, int target) { unordered_map < int , vector < int >> idx; vector < vector < int >> res; for ( int i = 0 ; i < array.size(); ++ i) { // O(n) if (idx.count(target - array[i])) for ( int j : idx[target - array[i]]) // O(n) res.push_back({j, i}); idx[array[i]].push_back(i); } return res; } }; Time: O(n^2) O(n^2) Space: O(n) O(n) Variant 2: with duplicate and only return the unique pairs (not index) \u00b6 class Solution { public : vector < vector < int >> allPairs(vector < int > array, int target) { // write your solution here unordered_set < int > st; vector < vector < int >> res; bool counted = true ; for ( int a : array) { // 2 * a = target if (a + a == target && st.count(a)) { if (counted) { res.push_back({a, a}); counted = false ; } } // a + b = target else if ( ! st.count(a) && st.count(target - a)) res.push_back({a, target - a}); st.insert(a); } return res; } }; e.g. if array = [2,2,2,3], target = 4, we just return [2,2] Time: O(n) O(n) Space: O(n) O(n) P2: 3Sum \u00b6 Assume: 1. no duplicate 2. optimize for time 3. data size is small enough to fit into memory 4. unsorted Solution 1: reuse 2Sum \u00b6 assume there the triplet is x + y + z = target, and x < y < z (since they are no duplicate). start with x (try all element from a[0] - a[n]), try find y + z such that y + z = target - x Use 2Sum to find the y + z Time: O(n^2) O(n^2) -> outter loop + inner O(n) O(n) 2Sum Space: O(n) O(n) Solution 2: sort then two pointers \u00b6 class Solution { public : vector < vector < int >> allTriples(vector < int > array, int target) { // write your solution here vector < vector < int >> res; int n = array.size(); sort(array.begin(), array.end()); for ( int i = 0 ; i < n - 2 ; ++ i) { if (i > 0 && array[i] == array[i - 1 ]) continue ; // skip duplicate int curr = array[i], l = i + 1 , r = n - 1 ; while (l < r) { if (curr + array[l] + array[r] == target) { res.push_back({curr, array[l], array[r]}); l ++ , r -- ; while (l < r && array[l] == array[l - 1 ]) l ++ ; while (l < r && array[r] == array[r + 1 ]) r -- ; } else if (curr + array[l] + array[r] < target) l ++ ; else r -- ; } } return res; } }; Time: O(n^2) O(n^2) Space: O(1) O(1) -- optimized space thus preferred 4Sum \u00b6 Assume: 1. input is immutable 2. optimize for time 3. unsorted 4. fit into memory 5. no duplicate 6. return true/false Solution 1: two outter forloop then include a 2Sum \u00b6 assume a_1 + a_2 + a_3 + a_4 == target a_1 + a_2 + a_3 + a_4 == target , then fix a_1 a_1 and a_2 a_2 from two outter loops. Use 2Sum to find the pair such that the sum == target - a_1 - a_2 sum == target - a_1 - a_2 pseudocode: define map<key = sum, value = <<two index>,<two index>, ... >> for(i) for(j) curr pair<i, j>, pair_sum = a[i] + a[j] if target - pair_sum is in the map AND <i, j> is different from all the values pairs: return true Time: O(n^3) O(n^3) -- the inner check could take O(n) O(n) times Space: O(n) O(n) -- each distinct i, j can have its own target value Solution 2: 4Sum = 2Sum + 2Sum \u00b6 a_1 + a_2 + a_3 + a_4 = target a_1 + a_2 + a_3 + a_4 = target , since there is no duplicate, we can assume a_1 < a_2 < a_3 < a_4 a_1 < a_2 < a_3 < a_4 . By using this property, we can just ignore the case when idx for latter element is smaller than prevous element's idx. class Solution { public : bool exist(vector < int > array, int target) { // write your solution here unordered_map < int , vector < int >> idx; int n = array.size(); for ( int i = 1 ; i < n; ++ i) // right for ( int j = 0 ; j < i; ++ j) // left if ( ! idx.count(array[i] + array[j])) idx[array[i] + array[j]] = {j, i}; // save <j, i> as j is always less than i for ( int i = 0 ; i < n; ++ i) // left for ( int j = i + 1 ; j < n; ++ j) { // right int curr = target - (array[i] + array[j]); if (idx.count(curr) && idx[curr][ 1 ] < i) return true ; } return false ; } };","title":"K sum problem"},{"location":"Interview/k-sum-problem/#k-sum-problem","text":"","title":"K sum problem"},{"location":"Interview/k-sum-problem/#find-x-elements-from-an-array-such-that-their-sum-is-equal-to-a-target-value","text":"things to clarify : 1. return value or return true/false or return index 2. data size 3. duplication (assume no duplication) 4. sorted vs unsorted 5. data type: int 6. optimize for time or optimize for space","title":"Find X-elements from an array such that their sum is equal to a target value"},{"location":"Interview/k-sum-problem/#p1-2sum","text":"https://leetcode.com/problems/two-sum/","title":"P1: 2Sum"},{"location":"Interview/k-sum-problem/#solution-1-use-hashmap","text":"class Solution { public : vector < int > twoSum(vector < int >& nums, int target) { unordered_map < int , int > checker; // val => index for ( int i = 0 ; i < nums.size(); ++ i) { int com = target - nums[i]; // find comlement if (checker.find(com) != checker.end()) return {i, checker[com]}; checker[nums[i]] = i; } return {}; } }; Time: O(n) O(n) Space: O(n) O(n)","title":"Solution 1 -- use hashmap"},{"location":"Interview/k-sum-problem/#solution-2-input-array-is-sorted-two-pointers","text":"class Solution { public : bool twoSum(vector < int >& nums, int target) { // return true if exit, else false; for ( int i = 0 , j = nums.size() - 1 ; i < j;) { int curr = nums[i] + nums[j]; if (curr == target) return true ; else if (curr > target) j -- ; else i ++ ; } return false ; } }; Time: O(n) O(n) Space: O(n) O(n) for sorting (aux array for merge sort, if using quick sort it will be O(1) O(1) )","title":"Solution 2 (input array is sorted) -- two pointers"},{"location":"Interview/k-sum-problem/#solution-4-unsorted-but-goal-is-optimize-for-space-and-the-input-array-is-mutable","text":"class Solution { public : bool twoSum(vector < int >& nums, int target) { // return true if exit, else false; for ( int i = 0 ; i < nums.size(); ++ i) for ( int j = 0 ; j < nums.size(); ++ j) if (nums[i] + nums[j] == target) return true ; return false ; } }; Time: O(n^2) O(n^2) Space: O(1) O(1)","title":"Solution 4 (unsorted, but goal is optimize for space, and the input array is mutable)"},{"location":"Interview/k-sum-problem/#variant-1-with-duplicate-and-return-all-the-index-pairs","text":"class Solution { public : vector < vector < int >> allPairs(vector < int > array, int target) { unordered_map < int , vector < int >> idx; vector < vector < int >> res; for ( int i = 0 ; i < array.size(); ++ i) { // O(n) if (idx.count(target - array[i])) for ( int j : idx[target - array[i]]) // O(n) res.push_back({j, i}); idx[array[i]].push_back(i); } return res; } }; Time: O(n^2) O(n^2) Space: O(n) O(n)","title":"Variant 1: with duplicate and return all the index pairs"},{"location":"Interview/k-sum-problem/#variant-2-with-duplicate-and-only-return-the-unique-pairs-not-index","text":"class Solution { public : vector < vector < int >> allPairs(vector < int > array, int target) { // write your solution here unordered_set < int > st; vector < vector < int >> res; bool counted = true ; for ( int a : array) { // 2 * a = target if (a + a == target && st.count(a)) { if (counted) { res.push_back({a, a}); counted = false ; } } // a + b = target else if ( ! st.count(a) && st.count(target - a)) res.push_back({a, target - a}); st.insert(a); } return res; } }; e.g. if array = [2,2,2,3], target = 4, we just return [2,2] Time: O(n) O(n) Space: O(n) O(n)","title":"Variant 2: with duplicate and only return the unique pairs (not index)"},{"location":"Interview/k-sum-problem/#p2-3sum","text":"Assume: 1. no duplicate 2. optimize for time 3. data size is small enough to fit into memory 4. unsorted","title":"P2: 3Sum"},{"location":"Interview/k-sum-problem/#solution-1-reuse-2sum","text":"assume there the triplet is x + y + z = target, and x < y < z (since they are no duplicate). start with x (try all element from a[0] - a[n]), try find y + z such that y + z = target - x Use 2Sum to find the y + z Time: O(n^2) O(n^2) -> outter loop + inner O(n) O(n) 2Sum Space: O(n) O(n)","title":"Solution 1: reuse 2Sum"},{"location":"Interview/k-sum-problem/#solution-2-sort-then-two-pointers","text":"class Solution { public : vector < vector < int >> allTriples(vector < int > array, int target) { // write your solution here vector < vector < int >> res; int n = array.size(); sort(array.begin(), array.end()); for ( int i = 0 ; i < n - 2 ; ++ i) { if (i > 0 && array[i] == array[i - 1 ]) continue ; // skip duplicate int curr = array[i], l = i + 1 , r = n - 1 ; while (l < r) { if (curr + array[l] + array[r] == target) { res.push_back({curr, array[l], array[r]}); l ++ , r -- ; while (l < r && array[l] == array[l - 1 ]) l ++ ; while (l < r && array[r] == array[r + 1 ]) r -- ; } else if (curr + array[l] + array[r] < target) l ++ ; else r -- ; } } return res; } }; Time: O(n^2) O(n^2) Space: O(1) O(1) -- optimized space thus preferred","title":"Solution 2: sort then two pointers"},{"location":"Interview/k-sum-problem/#4sum","text":"Assume: 1. input is immutable 2. optimize for time 3. unsorted 4. fit into memory 5. no duplicate 6. return true/false","title":"4Sum"},{"location":"Interview/k-sum-problem/#solution-1-two-outter-forloop-then-include-a-2sum","text":"assume a_1 + a_2 + a_3 + a_4 == target a_1 + a_2 + a_3 + a_4 == target , then fix a_1 a_1 and a_2 a_2 from two outter loops. Use 2Sum to find the pair such that the sum == target - a_1 - a_2 sum == target - a_1 - a_2 pseudocode: define map<key = sum, value = <<two index>,<two index>, ... >> for(i) for(j) curr pair<i, j>, pair_sum = a[i] + a[j] if target - pair_sum is in the map AND <i, j> is different from all the values pairs: return true Time: O(n^3) O(n^3) -- the inner check could take O(n) O(n) times Space: O(n) O(n) -- each distinct i, j can have its own target value","title":"Solution 1: two outter forloop then include a 2Sum"},{"location":"Interview/k-sum-problem/#solution-2-4sum-2sum-2sum","text":"a_1 + a_2 + a_3 + a_4 = target a_1 + a_2 + a_3 + a_4 = target , since there is no duplicate, we can assume a_1 < a_2 < a_3 < a_4 a_1 < a_2 < a_3 < a_4 . By using this property, we can just ignore the case when idx for latter element is smaller than prevous element's idx. class Solution { public : bool exist(vector < int > array, int target) { // write your solution here unordered_map < int , vector < int >> idx; int n = array.size(); for ( int i = 1 ; i < n; ++ i) // right for ( int j = 0 ; j < i; ++ j) // left if ( ! idx.count(array[i] + array[j])) idx[array[i] + array[j]] = {j, i}; // save <j, i> as j is always less than i for ( int i = 0 ; i < n; ++ i) // left for ( int j = i + 1 ; j < n; ++ j) { // right int curr = target - (array[i] + array[j]); if (idx.count(curr) && idx[curr][ 1 ] < i) return true ; } return false ; } };","title":"Solution 2: 4Sum = 2Sum + 2Sum"},{"location":"Interview/keep-distance-for-identical-elements/","text":"Keep distance for identical elements \u00b6 Given an integer k, arrange the sequence of integers [1, 1, 2, 2, 3, 3, ...., k - 1, k - 1, k, k], such that the output integer array satisfy this condition: Between each two i's, they are exactly i integers (for example: between the two 1s, there is one number, between the two 2's there are two numbers). If there does not exist such sequence, return null. Assumptions: k is guaranteed to be > 0 Examples: k = 3, The output = { 2, 3, 1, 2, 1, 3 }. Analysis \u00b6 The problem can reduce to how to place each element from [1 to k], among all the permutation, find the correct one(s). res: resulting array, since each element can only appear twice, the size is 2 * k used: array to keep track of how many times the element is used (0: haven't used, 1: used once, 2: used twice) base case: if the pointer has reach the end of the res array, then our res array is all filled -> return true; recursive function: try all the number in the used array (not 2), place first element if not yet placed OR place the second element with the distance i in front of the current idx. Time Complexity: O(n!) O(n!) Space Complexity: O(n) O(n) Code \u00b6 public static class Solution { public int [] keepDistance ( int k) { int [] res = new int [2 * k ] ; int [] used = new int [ k + 1] ; return helper(res, 0 , used) ? res : null ; } private boolean helper ( int [] res, int idx, int [] used) { if (idx == res. length ) return true ; for ( int i = 1 ; i < used. length ; ++ i) { // case 1: unused -> just place it // case 2: used once, find if current idx can be placed (check if has a distance equal to the i) if (used [ i ] == 0 || (used [ i ] == 1 && idx > i && res [ idx - i - 1] == i)) { res [ idx ] = i; used [ i ]++ ; if (helper(res, idx + 1 , used)) return true ; used [ i ]-- ; } } return false ; } }","title":"Keep distance for identical elements"},{"location":"Interview/keep-distance-for-identical-elements/#keep-distance-for-identical-elements","text":"Given an integer k, arrange the sequence of integers [1, 1, 2, 2, 3, 3, ...., k - 1, k - 1, k, k], such that the output integer array satisfy this condition: Between each two i's, they are exactly i integers (for example: between the two 1s, there is one number, between the two 2's there are two numbers). If there does not exist such sequence, return null. Assumptions: k is guaranteed to be > 0 Examples: k = 3, The output = { 2, 3, 1, 2, 1, 3 }.","title":"Keep distance for identical elements"},{"location":"Interview/keep-distance-for-identical-elements/#analysis","text":"The problem can reduce to how to place each element from [1 to k], among all the permutation, find the correct one(s). res: resulting array, since each element can only appear twice, the size is 2 * k used: array to keep track of how many times the element is used (0: haven't used, 1: used once, 2: used twice) base case: if the pointer has reach the end of the res array, then our res array is all filled -> return true; recursive function: try all the number in the used array (not 2), place first element if not yet placed OR place the second element with the distance i in front of the current idx. Time Complexity: O(n!) O(n!) Space Complexity: O(n) O(n)","title":"Analysis"},{"location":"Interview/keep-distance-for-identical-elements/#code","text":"public static class Solution { public int [] keepDistance ( int k) { int [] res = new int [2 * k ] ; int [] used = new int [ k + 1] ; return helper(res, 0 , used) ? res : null ; } private boolean helper ( int [] res, int idx, int [] used) { if (idx == res. length ) return true ; for ( int i = 1 ; i < used. length ; ++ i) { // case 1: unused -> just place it // case 2: used once, find if current idx can be placed (check if has a distance equal to the i) if (used [ i ] == 0 || (used [ i ] == 1 && idx > i && res [ idx - i - 1] == i)) { res [ idx ] = i; used [ i ]++ ; if (helper(res, idx + 1 , used)) return true ; used [ i ]-- ; } } return false ; } }","title":"Code"},{"location":"Interview/knight-dialer/","text":"Knight Dialer \u00b6 e.g. input: 1 output: 10 e.g. input: 2 output: 20 1: 6, 8 2: 7, 9 3: 4, 8 4: 3, 9, 0 5: - 6: 1, 7, 0 7: 2, 6 8: 1, 3 9: 4, 2 0: 4, 6 e.g. input: 3 output: 48 DFS with memo \u00b6 Time Complexity: O(n) -> size of memo, Space Complexity: O(n), But call stack is very large. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 , MAX = 10010 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; int res = 0 , n; int memo[ 10 ][MAX]; int dfs ( int pos, int hops) { if (memo[pos][hops] != 0 ) return memo[pos][hops]; int cnt = 0 ; for ( char i : nxt[pos]) { cnt += dfs(i - '0' , hops - 1 ); } return memo[pos][hops] = cnt; } void solve () { for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int pos = 0 ; pos < 10 ; ++ pos) res += dfs(pos, n - 1 ); } int main () { cin >> n; solve(); cout << res % mod; return 0 ; } DP with 2D matrix \u00b6 memo[pos][hops]: # of solution when ends in \"pos\" in \"hops\" hops. base case: memo[x][0] = 1 #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll memo[ 10 ][n]; for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += memo[nei - '0' ][hops - 1 ]; } memo[pos][hops] = cnt; } } for ( int i = 0 ; i < 10 ; ++ i) { res += memo[i][n - 1 ]; } cout << res % mod; return 0 ; } DP with constant space \u00b6 only need to record last state, so just two array is fine. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll prev[ 10 ], curr[ 10 ]; for ( int i = 0 ; i < 10 ; ++ i) prev[i] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += prev[nei - '0' ]; } curr[pos] = cnt; } for ( int pos = 0 ; pos < 10 ; ++ pos) { prev[pos] = curr[pos]; curr[pos] = 0 ; } } for ( int i = 0 ; i < 10 ; ++ i) { res += prev[i]; } cout << res % mod; return 0 ; }","title":"Knight Dialer"},{"location":"Interview/knight-dialer/#knight-dialer","text":"e.g. input: 1 output: 10 e.g. input: 2 output: 20 1: 6, 8 2: 7, 9 3: 4, 8 4: 3, 9, 0 5: - 6: 1, 7, 0 7: 2, 6 8: 1, 3 9: 4, 2 0: 4, 6 e.g. input: 3 output: 48","title":"Knight Dialer"},{"location":"Interview/knight-dialer/#dfs-with-memo","text":"Time Complexity: O(n) -> size of memo, Space Complexity: O(n), But call stack is very large. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 , MAX = 10010 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; int res = 0 , n; int memo[ 10 ][MAX]; int dfs ( int pos, int hops) { if (memo[pos][hops] != 0 ) return memo[pos][hops]; int cnt = 0 ; for ( char i : nxt[pos]) { cnt += dfs(i - '0' , hops - 1 ); } return memo[pos][hops] = cnt; } void solve () { for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int pos = 0 ; pos < 10 ; ++ pos) res += dfs(pos, n - 1 ); } int main () { cin >> n; solve(); cout << res % mod; return 0 ; }","title":"DFS with memo"},{"location":"Interview/knight-dialer/#dp-with-2d-matrix","text":"memo[pos][hops]: # of solution when ends in \"pos\" in \"hops\" hops. base case: memo[x][0] = 1 #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll memo[ 10 ][n]; for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += memo[nei - '0' ][hops - 1 ]; } memo[pos][hops] = cnt; } } for ( int i = 0 ; i < 10 ; ++ i) { res += memo[i][n - 1 ]; } cout << res % mod; return 0 ; }","title":"DP with 2D matrix"},{"location":"Interview/knight-dialer/#dp-with-constant-space","text":"only need to record last state, so just two array is fine. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll prev[ 10 ], curr[ 10 ]; for ( int i = 0 ; i < 10 ; ++ i) prev[i] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += prev[nei - '0' ]; } curr[pos] = cnt; } for ( int pos = 0 ; pos < 10 ; ++ pos) { prev[pos] = curr[pos]; curr[pos] = 0 ; } } for ( int i = 0 ; i < 10 ; ++ i) { res += prev[i]; } cout << res % mod; return 0 ; }","title":"DP with constant space"},{"location":"Interview/kth-problem/","text":"Closest Number In Binary Search Tree \u00b6 In a binary search tree, find k nodes containing the closest numbers to the given target number. return them in sorted array Assumptions: The given root is not null. There are no duplicate keys in the binary search tree. Examples: 5 / \\ 2 11 / \\ 6 14 closest number to 4 is 5 closest number to 10 is 11 closest number to 6 is 6 How is the binary tree represented? We use the level order traversal sequence with a special symbol \"#\" denoting the null node. For Example: The sequence [1, 2, 3, #, #, 4] represents the following binary tree: 1 / \\ 2 3 / 4 Analysis \u00b6 Because it is a binary search tree, if we do in order traversal, then we can get the sequence in ascending order. Imagine we have a sliding window (implemented as a queue), and we keep pushing in the element whose absolute value with target is less than current top's absolute value. Code \u00b6 /** * public class TreeNode { * public int key; * public TreeNode left; * public TreeNode right; * public TreeNode(int key) { * this.key = key; * } * } */ public class Solution { private void helper (TreeNode node, double target, int k, Queue < Integer > queue) { if (node == null ) return ; helper(node. left , target, k, queue); // in order traverse the left if (queue. size () < k) // window isn't full yet queue. offer (node. key ); else { // use current node as the right end of the sliding window if (Math. abs (target - node. key ) < Math. abs (target - queue. peek ())) { queue. poll (); queue. offer (node. key ) } else // not use current node return ; } helper(node. right , target, k, queue); // in order traverse the right } public int [] closestKValues (TreeNode root, double target, int k) { if (k <= 0 ) return new int [0] ; Queue < Integer > queue = new ArrayDeque <> (k); // sliding window helper(root, target, k, queue); int [] result = new int [ queue. size () ] ; for ( int i = 0 ; i < result. length ; i ++ ) result [ i ] = queue. poll (); return result; } }","title":"Kth problem"},{"location":"Interview/kth-problem/#closest-number-in-binary-search-tree","text":"In a binary search tree, find k nodes containing the closest numbers to the given target number. return them in sorted array Assumptions: The given root is not null. There are no duplicate keys in the binary search tree. Examples: 5 / \\ 2 11 / \\ 6 14 closest number to 4 is 5 closest number to 10 is 11 closest number to 6 is 6 How is the binary tree represented? We use the level order traversal sequence with a special symbol \"#\" denoting the null node. For Example: The sequence [1, 2, 3, #, #, 4] represents the following binary tree: 1 / \\ 2 3 / 4","title":"Closest Number In Binary Search Tree"},{"location":"Interview/kth-problem/#analysis","text":"Because it is a binary search tree, if we do in order traversal, then we can get the sequence in ascending order. Imagine we have a sliding window (implemented as a queue), and we keep pushing in the element whose absolute value with target is less than current top's absolute value.","title":"Analysis"},{"location":"Interview/kth-problem/#code","text":"/** * public class TreeNode { * public int key; * public TreeNode left; * public TreeNode right; * public TreeNode(int key) { * this.key = key; * } * } */ public class Solution { private void helper (TreeNode node, double target, int k, Queue < Integer > queue) { if (node == null ) return ; helper(node. left , target, k, queue); // in order traverse the left if (queue. size () < k) // window isn't full yet queue. offer (node. key ); else { // use current node as the right end of the sliding window if (Math. abs (target - node. key ) < Math. abs (target - queue. peek ())) { queue. poll (); queue. offer (node. key ) } else // not use current node return ; } helper(node. right , target, k, queue); // in order traverse the right } public int [] closestKValues (TreeNode root, double target, int k) { if (k <= 0 ) return new int [0] ; Queue < Integer > queue = new ArrayDeque <> (k); // sliding window helper(root, target, k, queue); int [] result = new int [ queue. size () ] ; for ( int i = 0 ; i < result. length ; i ++ ) result [ i ] = queue. poll (); return result; } }","title":"Code"},{"location":"Interview/linked-list/","text":"Linked List \u00b6 Define \u00b6 Logically consecutive list, but physically not consecutive Principle \u00b6 never lose the control of the head pointer of the linkedlist when want to dereference a ListNode, make sure it is not NULL Q1: reverse Linkedlist \u00b6 Need two pointers: one for previous, one for curr; reverse is simply change the direction Recursion \u00b6 ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL ; return res; } Iterative \u00b6 class Solution { public : ListNode * reverseList(ListNode * head) { if ( ! head) return NULL ; auto a = head, b = a -> next; while (b) { auto c = b -> next; b -> next = a; a = b; b = c; } head -> next = NULL ; return a; } }; Q2: insert into sorted linkedlist \u00b6 ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; } Q3: reorganize linkedlist \u00b6 Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL ; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL ; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; } Q4: partition list \u00b6 L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Linked List"},{"location":"Interview/linked-list/#linked-list","text":"","title":"Linked List"},{"location":"Interview/linked-list/#define","text":"Logically consecutive list, but physically not consecutive","title":"Define"},{"location":"Interview/linked-list/#principle","text":"never lose the control of the head pointer of the linkedlist when want to dereference a ListNode, make sure it is not NULL","title":"Principle"},{"location":"Interview/linked-list/#q1-reverse-linkedlist","text":"Need two pointers: one for previous, one for curr; reverse is simply change the direction","title":"Q1: reverse Linkedlist"},{"location":"Interview/linked-list/#recursion","text":"ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL ; return res; }","title":"Recursion"},{"location":"Interview/linked-list/#iterative","text":"class Solution { public : ListNode * reverseList(ListNode * head) { if ( ! head) return NULL ; auto a = head, b = a -> next; while (b) { auto c = b -> next; b -> next = a; a = b; b = c; } head -> next = NULL ; return a; } };","title":"Iterative"},{"location":"Interview/linked-list/#q2-insert-into-sorted-linkedlist","text":"ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; }","title":"Q2: insert into sorted linkedlist"},{"location":"Interview/linked-list/#q3-reorganize-linkedlist","text":"Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL ; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL ; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; }","title":"Q3: reorganize linkedlist"},{"location":"Interview/linked-list/#q4-partition-list","text":"L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Q4: partition list"},{"location":"Interview/lowest-common-ancester/","text":"Lowest Common Ancester Problems \u00b6 Variant 1: input is a BST \u00b6 https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ To utilize the property of BST, we should keep elimate either the right or the left subtree of the input tree: If p and q are all on the right subtree, that means root -> left is less than the min value of p and q -> so we don't need to search the root -> left subtree If p and q are all on the left subtree, that means root -> right is greater than the max value of p and q -> so we don't need to search the root -> right subtree If p is in root -> left subtree and p is in root -> right subtree (order doesn't matter), then we juet need to find the first root that satisfy this situation -> return current root Time: O(log_2{n}) O(log_2{n}) Code \u00b6 TreeNode * lowestCommonAncestor (TreeNode * root, TreeNode * p, TreeNode * q) { while ( 1 ) { if (root -> val < min(p -> val, q -> val)) root = root -> right; else if (root -> val > max(p -> val, q -> val)) root = root -> left; else break ; } return root; } Variant 2: input is a binary tree \u00b6 If the two nodes are all existed in the binary tree, then if we start from the root of the tree 1. if find one -> two is somewhere deeper than one , so one is the LCA 2. if find two -> one is somewhere deeper than two , so two is the LCA Now the problem reduced to how to find the two nodes from the binay tree. Time: O(n) O(n) Stack Space: O(height) O(height) Code \u00b6 class Solution { public : TreeNode * solve(TreeNode * root, TreeNode * one, TreeNode * two) { if ( ! root || root == one || two == root) return root; TreeNode * left = solve(root -> left, one, two); TreeNode * right = solve(root -> right, one, two); if (left && right) return root; // both exist, so current root is the LCA return left ? left : right; // return the one that is found } }; Variant 3: TreeNode has a parent pointer \u00b6 \u8fd9\u4e2a\u9898\u76ee\u5206\u6790\u4e00\u4e0b\u53ef\u4ee5\u770b\u51fa\u548c\u6811\u5e76\u6ca1\u6709\u4ec0\u4e48\u5173\u7cfb\uff0c\u6211\u4eec\u628aparent\u6307\u9488\u770b\u6210next\uff0c\u8fd9\u4e2a\u9898\u76ee\u5c31\u53d8\u6210\u4e86\u7ed9\u4f60\u4e24\u6761\u94fe\u8868\uff0c\u8fd4\u56de\u4ed6\u4eec\u7684\u4ea4\u70b9\uff0c\u82e5\u6ca1\u6709\u8fd4\u56denull \u6240\u4ee5\uff0c\u6211\u4eec\u5176\u5b9e\u4e0d\u9700\u8981\u53bb\u8ba1\u7b97\u4ed6\u4eec\u5230\u4ea4\u70b9\u7684\u9ad8\u5ea6\u5dee\uff0c\u6211\u4eec\u628a\u8fd9\u4e24\u4e2a\u8282\u70b9\u6210\u4e3aa\u548cb\uff0c\u4ea4\u70b9\u79f0\u4e3ai\uff0c\u94fe\u8868\u7ed3\u5c3e\u79f0\u4e3ae\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e24\u6761\u94fe\u8868\u7684\u957f\u5ea6\u5dee\u5c31\u662fi\u5230a\u548cb\u7684\u957f\u5ea6\u5dee\uff0c\u6240\u4ee5\u5f53\u8d70\u5230\u672b\u5c3e\u65f6\uff0c\u6211\u4eec\u8ba9\u4ed6\u4ece\u53e6\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u90e8\u5f00\u59cb\u7ee7\u7eed\u904d\u5386\uff0c\u53ea\u8981\u6709\u4ea4\u70b9\uff0c\u4ed6\u4eec\u4e00\u5b9a\u4f1a\u78b0\u5728\u4e00\u8d77 changeOne \u548c changeTwo \u5728\u8fd9\u91cc\u4f7f\u5f97\u53ea\u4f1a\u8d70\u4e00\u6b21\uff0c\u907f\u514d\u6ca1\u6709\u76f8\u4ea4\u65f6\u8fdb\u53bb\u6b7b\u5faa\u73af Code 1 \u00b6 /** * public class TreeNodeP { * public int key; * public TreeNodeP left; * public TreeNodeP right; * public TreeNodeP parent; * public TreeNodeP(int key, TreeNodeP parent) { * this.key = key; * this.parent = parent; * } * } */ public class Solution { public TreeNodeP lowestCommonAncestor (TreeNodeP one, TreeNodeP two) { if (one == null || two == null ){ return null ; } TreeNodeP oneCurr = one; TreeNodeP twoCurr = two; boolean changeOne = false , changeTwo = false ; while (oneCurr != null && twoCurr != null && oneCurr != twoCurr){ oneCurr = oneCurr. parent ; // keep going up twoCurr = twoCurr. parent ; if (oneCurr == twoCurr){ // terminate if meet up return oneCurr; } if (oneCurr == null && changeOne == false ){ // only alternate once oneCurr = two; // finish oneCurr, now start with two's head changeOne = true ; } if (twoCurr == null && changeTwo == false ){ // only alternate once twoCurr = one; changeTwo = true ; } } if (oneCurr == twoCurr){ // possible that after the for loop they meet return oneCurr; } return null ; } } Code 2: check height and decide which node to proceed up \u00b6 #include <bits/stdc++.h> using namespace std; class TreeNodeP { public : int value; TreeNodeP * left; TreeNodeP * right; TreeNodeP * parent; TreeNodeP( int v, TreeNodeP * p) : value(v), left( NULL ), right( NULL ), parent(p) {} }; class Solution { public : int height(TreeNodeP * node) { int cnt = 0 ; while (node) { cnt ++ ; node = node -> parent; } return cnt; } TreeNodeP * solve(TreeNodeP * one, TreeNodeP * two) { if (one == two) return one; if ( ! one || ! two) return NULL ; TreeNodeP * res; int h1 = height(one), h2 = height(two); if (h1 > h2) { if ((res = solve(one -> parent, two))) return res; } else if (h1 < h2) { if ((res = solve(one, two -> parent))) return res; } return solve(one -> parent, two -> parent); } }; int main () { TreeNodeP * p1 = new TreeNodeP( 5 , NULL ); TreeNodeP * p2 = new TreeNodeP( 9 , p1); TreeNodeP * p3 = new TreeNodeP( 12 , p1); TreeNodeP * p4 = new TreeNodeP( 2 , p2); TreeNodeP * p5 = new TreeNodeP( 3 , p2); TreeNodeP * p6 = new TreeNodeP( 14 , p3); p1 -> left = p2; p1 -> right = p3; p2 -> left = p4; p2 -> right = p5; p3 -> right = p6; Solution s; // TreeNodeP *tmp = new TreeNodeP(-1, NULL); cout << s.solve(p5, p2) -> value; return 0 ; } Variant 4: find LCA for multiple nodes in the Binary Tree \u00b6 Use the same logic: find then check if use root as lca. Physical Meaning of lca(TreeNode* curr, unordered_set<TreeNode*> st) : 1. if all the nodes are under curr, return LCA of these nodes. 2. if a subset of the given node are under the root, return LCA of the nodes under root. 3. if none of the nodes are under root, return null. Code \u00b6 class Solution { public : TreeNode * lca(TreeNode * curr, unordered_set < TreeNode *> st) { if ( ! curr || st.count(curr)) return curr; TreeNode * left = lca(curr -> left, st); // if left is under root TreeNode * right = lca(curr -> right, st); // if right is under root if (left && right) return curr; return left ? left : right; } TreeNode * solve(TreeNode * root, vector < TreeNode *> nodes) { unordered_set < TreeNode *> st(nodes.begin(), nodes.end()); return lca (root, st); } }; Variant 5: find LCA for two nodes for m-ary tree \u00b6 Use the same logic to find the two corresponding nodes from the binary tree, and then check if any two are sharing with the same root. If so, return the root, or return the one that isn't null. Code \u00b6 public class Solution { public KnaryTreeNode lowestCommonAncestor (KnaryTreeNode root, KnaryTreeNode a, KnaryTreeNode b) { if (root == null || root == a || root == b) return root; KnaryTreeNode found = null ; // at least two children are found, or just return the one that is found or just null for (KnaryTreeNode node : root. children ) { KnaryTreeNode curr = lowestCommonAncestor(node, a, b); if (curr == null ) continue ; if (found != null ) return root; // already two nodes are sharing with the current root if (found == null ) found = curr; } return found; } } Variant 6: find LCA for n nodes for m-ary tree \u00b6 Use the same logic to find the two corresponding nodes from the m-ary tree, and then check if any two are sharing with the same root. If so, return the root, or return the one that isn't null. In the base case, we only need to check if current searched node is one of the node in the set. We don't need to care about duplication, since, all the children of the current node are distinct, meaning if there are two nodes being found from the recursion call, we can guarantee that these two nodes are distint. Code \u00b6 /** * public class KnaryTreeNode { * int key; * List<KnaryTreeNode> children; * public KnaryTreeNode(int key) { * this.key = key; * this.children = new ArrayList<>(); * } * } */ public class Solution { KnaryTreeNode helper (KnaryTreeNode root, Set < KnaryTreeNode > set) { if (root == null || set. contains (root)) return root; KnaryTreeNode found = null ; for (KnaryTreeNode nei : root. children ) { KnaryTreeNode node = helper(nei, set); if (node == null ) continue ; if (found == null ) found = node; else return root; } return found; } public KnaryTreeNode lowestCommonAncestor (KnaryTreeNode root, List < KnaryTreeNode > nodes) { // Write your solution here Set < KnaryTreeNode > set = new HashSet < KnaryTreeNode > (nodes); return helper(root, set); } }","title":"Lowest Common Ancester Problems"},{"location":"Interview/lowest-common-ancester/#lowest-common-ancester-problems","text":"","title":"Lowest Common Ancester Problems"},{"location":"Interview/lowest-common-ancester/#variant-1-input-is-a-bst","text":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ To utilize the property of BST, we should keep elimate either the right or the left subtree of the input tree: If p and q are all on the right subtree, that means root -> left is less than the min value of p and q -> so we don't need to search the root -> left subtree If p and q are all on the left subtree, that means root -> right is greater than the max value of p and q -> so we don't need to search the root -> right subtree If p is in root -> left subtree and p is in root -> right subtree (order doesn't matter), then we juet need to find the first root that satisfy this situation -> return current root Time: O(log_2{n}) O(log_2{n})","title":"Variant 1: input is a BST"},{"location":"Interview/lowest-common-ancester/#code","text":"TreeNode * lowestCommonAncestor (TreeNode * root, TreeNode * p, TreeNode * q) { while ( 1 ) { if (root -> val < min(p -> val, q -> val)) root = root -> right; else if (root -> val > max(p -> val, q -> val)) root = root -> left; else break ; } return root; }","title":"Code"},{"location":"Interview/lowest-common-ancester/#variant-2-input-is-a-binary-tree","text":"If the two nodes are all existed in the binary tree, then if we start from the root of the tree 1. if find one -> two is somewhere deeper than one , so one is the LCA 2. if find two -> one is somewhere deeper than two , so two is the LCA Now the problem reduced to how to find the two nodes from the binay tree. Time: O(n) O(n) Stack Space: O(height) O(height)","title":"Variant 2: input is a binary tree"},{"location":"Interview/lowest-common-ancester/#code_1","text":"class Solution { public : TreeNode * solve(TreeNode * root, TreeNode * one, TreeNode * two) { if ( ! root || root == one || two == root) return root; TreeNode * left = solve(root -> left, one, two); TreeNode * right = solve(root -> right, one, two); if (left && right) return root; // both exist, so current root is the LCA return left ? left : right; // return the one that is found } };","title":"Code"},{"location":"Interview/lowest-common-ancester/#variant-3-treenode-has-a-parent-pointer","text":"\u8fd9\u4e2a\u9898\u76ee\u5206\u6790\u4e00\u4e0b\u53ef\u4ee5\u770b\u51fa\u548c\u6811\u5e76\u6ca1\u6709\u4ec0\u4e48\u5173\u7cfb\uff0c\u6211\u4eec\u628aparent\u6307\u9488\u770b\u6210next\uff0c\u8fd9\u4e2a\u9898\u76ee\u5c31\u53d8\u6210\u4e86\u7ed9\u4f60\u4e24\u6761\u94fe\u8868\uff0c\u8fd4\u56de\u4ed6\u4eec\u7684\u4ea4\u70b9\uff0c\u82e5\u6ca1\u6709\u8fd4\u56denull \u6240\u4ee5\uff0c\u6211\u4eec\u5176\u5b9e\u4e0d\u9700\u8981\u53bb\u8ba1\u7b97\u4ed6\u4eec\u5230\u4ea4\u70b9\u7684\u9ad8\u5ea6\u5dee\uff0c\u6211\u4eec\u628a\u8fd9\u4e24\u4e2a\u8282\u70b9\u6210\u4e3aa\u548cb\uff0c\u4ea4\u70b9\u79f0\u4e3ai\uff0c\u94fe\u8868\u7ed3\u5c3e\u79f0\u4e3ae\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e24\u6761\u94fe\u8868\u7684\u957f\u5ea6\u5dee\u5c31\u662fi\u5230a\u548cb\u7684\u957f\u5ea6\u5dee\uff0c\u6240\u4ee5\u5f53\u8d70\u5230\u672b\u5c3e\u65f6\uff0c\u6211\u4eec\u8ba9\u4ed6\u4ece\u53e6\u4e00\u4e2a\u94fe\u8868\u7684\u5934\u90e8\u5f00\u59cb\u7ee7\u7eed\u904d\u5386\uff0c\u53ea\u8981\u6709\u4ea4\u70b9\uff0c\u4ed6\u4eec\u4e00\u5b9a\u4f1a\u78b0\u5728\u4e00\u8d77 changeOne \u548c changeTwo \u5728\u8fd9\u91cc\u4f7f\u5f97\u53ea\u4f1a\u8d70\u4e00\u6b21\uff0c\u907f\u514d\u6ca1\u6709\u76f8\u4ea4\u65f6\u8fdb\u53bb\u6b7b\u5faa\u73af","title":"Variant 3: TreeNode has a parent pointer"},{"location":"Interview/lowest-common-ancester/#code-1","text":"/** * public class TreeNodeP { * public int key; * public TreeNodeP left; * public TreeNodeP right; * public TreeNodeP parent; * public TreeNodeP(int key, TreeNodeP parent) { * this.key = key; * this.parent = parent; * } * } */ public class Solution { public TreeNodeP lowestCommonAncestor (TreeNodeP one, TreeNodeP two) { if (one == null || two == null ){ return null ; } TreeNodeP oneCurr = one; TreeNodeP twoCurr = two; boolean changeOne = false , changeTwo = false ; while (oneCurr != null && twoCurr != null && oneCurr != twoCurr){ oneCurr = oneCurr. parent ; // keep going up twoCurr = twoCurr. parent ; if (oneCurr == twoCurr){ // terminate if meet up return oneCurr; } if (oneCurr == null && changeOne == false ){ // only alternate once oneCurr = two; // finish oneCurr, now start with two's head changeOne = true ; } if (twoCurr == null && changeTwo == false ){ // only alternate once twoCurr = one; changeTwo = true ; } } if (oneCurr == twoCurr){ // possible that after the for loop they meet return oneCurr; } return null ; } }","title":"Code 1"},{"location":"Interview/lowest-common-ancester/#code-2-check-height-and-decide-which-node-to-proceed-up","text":"#include <bits/stdc++.h> using namespace std; class TreeNodeP { public : int value; TreeNodeP * left; TreeNodeP * right; TreeNodeP * parent; TreeNodeP( int v, TreeNodeP * p) : value(v), left( NULL ), right( NULL ), parent(p) {} }; class Solution { public : int height(TreeNodeP * node) { int cnt = 0 ; while (node) { cnt ++ ; node = node -> parent; } return cnt; } TreeNodeP * solve(TreeNodeP * one, TreeNodeP * two) { if (one == two) return one; if ( ! one || ! two) return NULL ; TreeNodeP * res; int h1 = height(one), h2 = height(two); if (h1 > h2) { if ((res = solve(one -> parent, two))) return res; } else if (h1 < h2) { if ((res = solve(one, two -> parent))) return res; } return solve(one -> parent, two -> parent); } }; int main () { TreeNodeP * p1 = new TreeNodeP( 5 , NULL ); TreeNodeP * p2 = new TreeNodeP( 9 , p1); TreeNodeP * p3 = new TreeNodeP( 12 , p1); TreeNodeP * p4 = new TreeNodeP( 2 , p2); TreeNodeP * p5 = new TreeNodeP( 3 , p2); TreeNodeP * p6 = new TreeNodeP( 14 , p3); p1 -> left = p2; p1 -> right = p3; p2 -> left = p4; p2 -> right = p5; p3 -> right = p6; Solution s; // TreeNodeP *tmp = new TreeNodeP(-1, NULL); cout << s.solve(p5, p2) -> value; return 0 ; }","title":"Code 2: check height and decide which node to proceed up"},{"location":"Interview/lowest-common-ancester/#variant-4-find-lca-for-multiple-nodes-in-the-binary-tree","text":"Use the same logic: find then check if use root as lca. Physical Meaning of lca(TreeNode* curr, unordered_set<TreeNode*> st) : 1. if all the nodes are under curr, return LCA of these nodes. 2. if a subset of the given node are under the root, return LCA of the nodes under root. 3. if none of the nodes are under root, return null.","title":"Variant 4: find LCA for multiple nodes in the Binary Tree"},{"location":"Interview/lowest-common-ancester/#code_2","text":"class Solution { public : TreeNode * lca(TreeNode * curr, unordered_set < TreeNode *> st) { if ( ! curr || st.count(curr)) return curr; TreeNode * left = lca(curr -> left, st); // if left is under root TreeNode * right = lca(curr -> right, st); // if right is under root if (left && right) return curr; return left ? left : right; } TreeNode * solve(TreeNode * root, vector < TreeNode *> nodes) { unordered_set < TreeNode *> st(nodes.begin(), nodes.end()); return lca (root, st); } };","title":"Code"},{"location":"Interview/lowest-common-ancester/#variant-5-find-lca-for-two-nodes-for-m-ary-tree","text":"Use the same logic to find the two corresponding nodes from the binary tree, and then check if any two are sharing with the same root. If so, return the root, or return the one that isn't null.","title":"Variant 5: find LCA for two nodes for m-ary tree"},{"location":"Interview/lowest-common-ancester/#code_3","text":"public class Solution { public KnaryTreeNode lowestCommonAncestor (KnaryTreeNode root, KnaryTreeNode a, KnaryTreeNode b) { if (root == null || root == a || root == b) return root; KnaryTreeNode found = null ; // at least two children are found, or just return the one that is found or just null for (KnaryTreeNode node : root. children ) { KnaryTreeNode curr = lowestCommonAncestor(node, a, b); if (curr == null ) continue ; if (found != null ) return root; // already two nodes are sharing with the current root if (found == null ) found = curr; } return found; } }","title":"Code"},{"location":"Interview/lowest-common-ancester/#variant-6-find-lca-for-n-nodes-for-m-ary-tree","text":"Use the same logic to find the two corresponding nodes from the m-ary tree, and then check if any two are sharing with the same root. If so, return the root, or return the one that isn't null. In the base case, we only need to check if current searched node is one of the node in the set. We don't need to care about duplication, since, all the children of the current node are distinct, meaning if there are two nodes being found from the recursion call, we can guarantee that these two nodes are distint.","title":"Variant 6: find LCA for n nodes for m-ary tree"},{"location":"Interview/lowest-common-ancester/#code_4","text":"/** * public class KnaryTreeNode { * int key; * List<KnaryTreeNode> children; * public KnaryTreeNode(int key) { * this.key = key; * this.children = new ArrayList<>(); * } * } */ public class Solution { KnaryTreeNode helper (KnaryTreeNode root, Set < KnaryTreeNode > set) { if (root == null || set. contains (root)) return root; KnaryTreeNode found = null ; for (KnaryTreeNode nei : root. children ) { KnaryTreeNode node = helper(nei, set); if (node == null ) continue ; if (found == null ) found = node; else return root; } return found; } public KnaryTreeNode lowestCommonAncestor (KnaryTreeNode root, List < KnaryTreeNode > nodes) { // Write your solution here Set < KnaryTreeNode > set = new HashSet < KnaryTreeNode > (nodes); return helper(root, set); } }","title":"Code"},{"location":"Interview/majority-element-with-k-times/","text":"Majority Element with k times \u00b6 Given an integer array of length L, find all numbers that occur more than 1/K * L times if any exist. Assumptions The given array is not null or empty K >= 2 Examples A = {1, 2, 1, 2, 1}, K = 3, return [1, 2] A = {1, 2, 1, 2, 3, 3, 1}, K = 4, return [1, 2, 3] A = {2, 1}, K = 2, return [] Analysis \u00b6 We can apply the same method usng in 2 and 3 times. General steps: 1. To have occurred more than 1/k * n times, we can only have k - 1 elements (so that k * (1/k * n) <= n). 2. Then we can limit the mapping has a size of at most k - 1 3. Do the checking for each element in the array: 1. if exist in the map, just incremenet the counter by 1 2. else 1. if the map is full, we decreament all the other couting, and if any of the counter reaches zero, we erase that mapping 2. if map isn't full, we just add one mapping of the new element to the map. 4. Do the final check to see if all the keys in the map has the appeared more than 1/k * n times. Code \u00b6 class Solution { public : vector < int > majority(vector < int > array, int k) { // write your solution here unordered_map < int , int > cnt; for ( int a : array) { if (cnt.count(a)) cnt[a] ++ ; else { if (cnt.size() == k - 1 ) { for ( auto & p : cnt) { if ( -- p.second == 0 ) cnt.erase(p.first); } } else if (cnt.size() < k - 1 ) { cnt[a] = 1 ; } } } unordered_map < int , int > check; vector < int > res; int target = array.size() / k; for ( int a : array) { if (cnt.count(a)) ++ check[a]; } for ( auto p : check) if (p.second > target) res.push_back(p.first); return res; } };","title":"Majority Element with k times"},{"location":"Interview/majority-element-with-k-times/#majority-element-with-k-times","text":"Given an integer array of length L, find all numbers that occur more than 1/K * L times if any exist. Assumptions The given array is not null or empty K >= 2 Examples A = {1, 2, 1, 2, 1}, K = 3, return [1, 2] A = {1, 2, 1, 2, 3, 3, 1}, K = 4, return [1, 2, 3] A = {2, 1}, K = 2, return []","title":"Majority Element with k times"},{"location":"Interview/majority-element-with-k-times/#analysis","text":"We can apply the same method usng in 2 and 3 times. General steps: 1. To have occurred more than 1/k * n times, we can only have k - 1 elements (so that k * (1/k * n) <= n). 2. Then we can limit the mapping has a size of at most k - 1 3. Do the checking for each element in the array: 1. if exist in the map, just incremenet the counter by 1 2. else 1. if the map is full, we decreament all the other couting, and if any of the counter reaches zero, we erase that mapping 2. if map isn't full, we just add one mapping of the new element to the map. 4. Do the final check to see if all the keys in the map has the appeared more than 1/k * n times.","title":"Analysis"},{"location":"Interview/majority-element-with-k-times/#code","text":"class Solution { public : vector < int > majority(vector < int > array, int k) { // write your solution here unordered_map < int , int > cnt; for ( int a : array) { if (cnt.count(a)) cnt[a] ++ ; else { if (cnt.size() == k - 1 ) { for ( auto & p : cnt) { if ( -- p.second == 0 ) cnt.erase(p.first); } } else if (cnt.size() < k - 1 ) { cnt[a] = 1 ; } } } unordered_map < int , int > check; vector < int > res; int target = array.size() / k; for ( int a : array) { if (cnt.count(a)) ++ check[a]; } for ( auto p : check) if (p.second > target) res.push_back(p.first); return res; } };","title":"Code"},{"location":"Interview/math/","text":"Math \u00b6 Fast way to find nCr (n choose r) \u00b6 Def of C(n,r): (N * N - 1 * N - 2 * ... * N - R + 1) / (1 * 2 * ... * R), so to calculate C(n,r), we do N/1 * N-\u00bd ... * N-R+1/R Special Property C(n,r)=C(n,n-r) Code \u00b6 // https://stackoverflow.com/a/42285958 int NCR ( int n, int r) { if (r == 0 ) return 1 ; /* Extra computation saving for large R, using property: N choose R = N choose (N-R) */ if (r > n / 2 ) return NCR(n, n - r); long res = 1 ; for ( int k = 1 ; k <= r; ++ k) { res *= n - k + 1 ; res /= k; } return res; }","title":"Math"},{"location":"Interview/math/#math","text":"","title":"Math"},{"location":"Interview/math/#fast-way-to-find-ncr-n-choose-r","text":"Def of C(n,r): (N * N - 1 * N - 2 * ... * N - R + 1) / (1 * 2 * ... * R), so to calculate C(n,r), we do N/1 * N-\u00bd ... * N-R+1/R Special Property C(n,r)=C(n,n-r)","title":"Fast way to find nCr (n choose r)"},{"location":"Interview/math/#code","text":"// https://stackoverflow.com/a/42285958 int NCR ( int n, int r) { if (r == 0 ) return 1 ; /* Extra computation saving for large R, using property: N choose R = N choose (N-R) */ if (r > n / 2 ) return NCR(n, n - r); long res = 1 ; for ( int k = 1 ; k <= r; ++ k) { res *= n - k + 1 ; res /= k; } return res; }","title":"Code"},{"location":"Interview/maximum-product-subarray/","text":"Maximum Product Subarray \u00b6 https://leetcode.com/problems/maximum-product-subarray/ Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. How many subarrays in total? \u00b6 There are N^2 N^2 subarrays. You can choose 1 out of N for the start of the subarray, and also 1 out of N for the end of the subarray, so in total it will be N^2 / 2 N^2 / 2 (divide by two because of duplicates). DFS with memo O(n^2) O(n^2) \u00b6 map<int,int> where key is the end and value is the product, create the map every time when start changes. DP O(n) O(n) with space O(n) O(n) \u00b6 max_dp[i]: from 0-i, the maximum product min_dp[i]: from 0-i, the minimum product base case: 1. max_dp[0] = max(0, array[0]) // you can choose itself or nothing 2. min_dp[0] = min(0, array[0]) induction: max_dp[i] = max(min_dp[i] * array[i], max_dp[i-1] * array[i], array[i]) where min_dp[i] * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp[i] * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public : int maxProduct(vector < int >& nums) { int n = nums.size(); int max_dp[n], min_dp[n]; memset(max_dp, 0 , sizeof max_dp); memset(min_dp, 0 , sizeof min_dp); int res = INT_MIN; for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) { min_dp[i] = nums[i]; max_dp[i] = nums[i]; } else { max_dp[i] = max(max(min_dp[i -1 ] * nums[i], max_dp[i -1 ] * nums[i]), nums[i]); min_dp[i] = min(min(min_dp[i -1 ] * nums[i], max_dp[i -1 ] * nums[i]), nums[i]); } res = max(res, max_dp[i]); } return res; } }; Optimize DP with O(1) O(1) space \u00b6 max_dp: from 0-i, the maximum product min_dp: from 0-i, the minimum product base case: 1. pre_max_dp = array[0] // you can choose itself or nothing 2. pre_min_dp = array[0] induction: max_dp = max(min_dp * array[i], pre_max_dp * array[i], array[i]) where min_dp * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public : int maxProduct(vector < int >& nums) { int size = nums.size(); if (size == 0 ) { return 0 ; } int oldMin = nums[ 0 ]; int oldMax = nums[ 0 ]; int ret = nums[ 0 ]; for ( int i = 1 ; i < size; ++ i) { int newMax = max(nums[i], nums[i] > 0 ? oldMax * nums[i] : oldMin * nums[i]); int newMin = min(nums[i], nums[i] > 0 ? oldMin * nums[i] : oldMax * nums[i]); ret = max(ret, newMax); oldMin = newMin; oldMax = newMax; } return ret; } };","title":"Maximum Product Subarray"},{"location":"Interview/maximum-product-subarray/#maximum-product-subarray","text":"https://leetcode.com/problems/maximum-product-subarray/ Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.","title":"Maximum Product Subarray"},{"location":"Interview/maximum-product-subarray/#how-many-subarrays-in-total","text":"There are N^2 N^2 subarrays. You can choose 1 out of N for the start of the subarray, and also 1 out of N for the end of the subarray, so in total it will be N^2 / 2 N^2 / 2 (divide by two because of duplicates).","title":"How many subarrays in total?"},{"location":"Interview/maximum-product-subarray/#dfs-with-memo-on2on2","text":"map<int,int> where key is the end and value is the product, create the map every time when start changes.","title":"DFS with memo O(n^2)O(n^2)"},{"location":"Interview/maximum-product-subarray/#dp-onon-with-space-onon","text":"max_dp[i]: from 0-i, the maximum product min_dp[i]: from 0-i, the minimum product base case: 1. max_dp[0] = max(0, array[0]) // you can choose itself or nothing 2. min_dp[0] = min(0, array[0]) induction: max_dp[i] = max(min_dp[i] * array[i], max_dp[i-1] * array[i], array[i]) where min_dp[i] * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp[i] * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public : int maxProduct(vector < int >& nums) { int n = nums.size(); int max_dp[n], min_dp[n]; memset(max_dp, 0 , sizeof max_dp); memset(min_dp, 0 , sizeof min_dp); int res = INT_MIN; for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) { min_dp[i] = nums[i]; max_dp[i] = nums[i]; } else { max_dp[i] = max(max(min_dp[i -1 ] * nums[i], max_dp[i -1 ] * nums[i]), nums[i]); min_dp[i] = min(min(min_dp[i -1 ] * nums[i], max_dp[i -1 ] * nums[i]), nums[i]); } res = max(res, max_dp[i]); } return res; } };","title":"DP O(n)O(n) with space O(n)O(n)"},{"location":"Interview/maximum-product-subarray/#optimize-dp-with-o1o1-space","text":"max_dp: from 0-i, the maximum product min_dp: from 0-i, the minimum product base case: 1. pre_max_dp = array[0] // you can choose itself or nothing 2. pre_min_dp = array[0] induction: max_dp = max(min_dp * array[i], pre_max_dp * array[i], array[i]) where min_dp * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public : int maxProduct(vector < int >& nums) { int size = nums.size(); if (size == 0 ) { return 0 ; } int oldMin = nums[ 0 ]; int oldMax = nums[ 0 ]; int ret = nums[ 0 ]; for ( int i = 1 ; i < size; ++ i) { int newMax = max(nums[i], nums[i] > 0 ? oldMax * nums[i] : oldMin * nums[i]); int newMin = min(nums[i], nums[i] > 0 ? oldMin * nums[i] : oldMax * nums[i]); ret = max(ret, newMax); oldMin = newMin; oldMax = newMax; } return ret; } };","title":"Optimize DP with O(1)O(1) space"},{"location":"Interview/midterm-java/","text":"Midterm \u00b6 P1: N queens \u00b6 Find all valid ways of putting N Queens on an N * N chessboard so that no two Queens can attack each other (two queens can attack each other if they are on the same row/column or same diagonal line). You can define your own way of how to print the solution, e.g. using a size N array/List to record which column the queen occupies on each row Analysis \u00b6 Assumption: Use array curr to represent the solution: one index row, place a queen on curr[index] column to represent the complete configuration. If there are no solutions (e.g. when N <= 3), return an empty array. Approach: 1. High Level: use DFS 2. Details: - Starting from the first row, try placing the queen from the column 0 to column N-1. After the first placement, begin another placement for second row. - In order to check if the current row and column can be placed a queen, we need to have a hashset for storing all the visited queens: column , diagonal and anti-diagonal . - if (x, y) is in the same column of (i, j), then y == j - if (x, y) is in the same diagonal of (i, j), then x + y == i + j - if (x, y) is in the same anti-diagonal of (i, j), then y - x + n - 1 == j - i (+ n - 1 because we want to make sure the sum will fit in our boolean array) - Base case: if we can successfully reach the last row with all the N placement of the queens, then the current configuration is one of the solution. 3. Recursion Tree: Complexity: - Time: O(N^N) O(N^N) - Space: O(N) O(N) Code \u00b6 package test ; import java.util.ArrayList ; import java.util.List ; public class test { /** * convert int[] to List<Integer>: List can track the size of the container * @param array * @return resulting List<Integer> */ private List < Integer > toList ( int [] array) { List < Integer > list = new ArrayList <> (); for ( int num : array) list. add (num); return list; } /** * check if the current placement is valid or not * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals * @return true: is valid, false: invalid */ private boolean valid ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { return ! usedColumns [ column ] && ! usedDiagonals [ column + row ] && ! usedAntiDiagonals [ column - row + n - 1] ; } /** * mark the current placement (if is valid) * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void mark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = true ; usedDiagonals [ column + row ] = true ; usedAntiDiagonals [ column - row + n - 1] = true ; } /** * unmark the current placement * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void unMark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = false ; usedDiagonals [ column + row ] = false ; usedAntiDiagonals [ column - row + n - 1] = false ; } /** * main DFS logic to iterate through all the rows and valid columns * @param n * @param row * @param curr * @param result * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void dfs ( int n, int row, int [] curr, List < List < Integer >> result, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { // base case: reach the last row, so we add the current configuration to the result if (row == n) { result. add (toList(curr)); return ; } for ( int i = 0 ; i < n; ++ i) { // first check if current placement is valid or not if (valid(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals)) { // if is valid, mark it down mark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); curr [ row ] = i; // place to current column dfs(n, row + 1 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); // don't forget to unmark it so that it will go back to the previous stage unMark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); } } } /** * driver method: user input a n, and we should return all the configurations that it should have * @param n * @return List<List<Integer>> result array (configurations) */ public List < List < Integer >> nqueens ( int n) { int [] curr = new int [ n ] ; List < List < Integer >> result = new ArrayList < List < Integer >> (); boolean [] usedColumns = new boolean [ n ] ; boolean [] usedDiagonals = new boolean [2 * n - 1] ; boolean [] usedAntiDiagonals = new boolean [2 * n - 1] ; dfs(n, 0 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); return result; } public static void main (String [] args) { test s = new test(); List < List < Integer >> list = s. nqueens ( 4 ); for (List < Integer > l : list) { for (Integer i : l) System. out . println (i); System. out . println (); } } } P2: Maximum leaf sum \u00b6 Given a binary tree in which each node contains an int number. Find the maximum possible sum from any leaf node to another leaf node. The maximum sum path may or may not go through root. Expected time complexity is O(n). Analysis \u00b6 Assumption: If input is null (no node), or without left OR right child, return Integer.MIN_VALUE. Approach: 1. High Level: use Post-order traversal to traverse the binary tree, and calculate the path sum for each path from left leaf - current root - right leaf. 2. Details: - The method signature is int maxPathSum(TreeNode root) where root is the input tree's root node, return is the maximum path sum. - If input is one of the case mentioned in the assumption, return Integer.MIN_VALUE - Define another helper method int postOrder(TreeNode root, int[] result) where result is an array because it will be able to be modified within the recursive method. The return value represents the maximum sum from any leaf to current root. - In the traverse: base case is when current root == null , it should return 0 as it has reach leaf node. Then there are three cases to be considered: 1. left and right children are both null: this path is invalid 2. left or right children have one is null: choose the path that has a leaf 3. left and right children both exist: choose the maximum path between the two paths 3. Recursion Tree: Complexity: - Time: O(N) O(N) - Space: O(height) O(height) or O(N) O(N) Code \u00b6 /** * public class TreeNode { * public int key; * public TreeNode left; * public TreeNode right; * public TreeNode(int key) { * this.key = key; * } * } */ public class Solution { private int postOrder (TreeNode root, int [] result) { if (root == null ) return 0 ; int leftSum = postOrder(root. left , result); int rightSum = postOrder(root. right , result); // case 1: if current root has both left and right child, // then update the result and choose the bigger sum between the left and right children if (root. left != null && root. right != null ) { result [0] = Math. max (root. key + leftSum + rightSum, result [0] ); return Math. max (root. key + leftSum, root. key + rightSum); } // case 2: if only one child exist, return the one with leaf if (root. left == null ) return root. key + rightSum; return root. key + leftSum; } public int maxPathSum (TreeNode root) { if (root == null || root. left == null || root. right == null ) return Integer. MIN_VALUE ; int [] result = {Integer. MIN_VALUE }; postOrder(root, result); return result [0] ; } } P3: minimal cuts to form palindrome \u00b6 Given a string, a partitioning of the string is a palindrome partitioning if every partition is a palindrome. For example, \u201caba |b | bbabb |a| b| aba\u201d is a palindrome partitioning of \u201cababbbabbababa\u201d. Determine the fewest cuts needed for palindrome partitioning of a given string. For example, minimum 3 cuts are needed for \u201cababbbabbababa\u201d. The three cuts are \u201ca | babbbab | b | ababa\u201d. If a string is palindrome, then minimum 0 cuts are needed. Return the minimum cuts. Analysis \u00b6 Assumption: Input string is a valid string: not null Approach: 1. High Level: because this question is asking the minimal cuts but not each configuration/how to cut, we can naturally think to use Dynamic Programming. 2. Details: - cuts[i]: minimal cuts from 0-i in char array - pal[i][j]: s[i-j] is a palindrome or not - base case / how to initialize the cuts array: consider each character in the array is a palindrome itself, so for each string with length n, the maximum cuts requires is n - 1 - induction rule: cuts[i] = min(cuts[i], cuts[j - 1] + 1) if s[j to i] is a palindrome AND s[i] == s[j] - result: cuts[n] 3. Fill \"table\": Complexity: Time: O(N^2) O(N^2) Space: O(N^2) O(N^2) Code Java \u00b6 package test ; public class MinimalCutsPalindrome { public int minCuts (String s) { char [] ch = s. toCharArray (); // convert to char array so that there is no overhead of substring int n = ch. length ; int [] cut = new int [ n ] ; // cut[i]: minimal cuts from 0-i in ch array boolean [][] pal = new boolean [ n ][ n ] ; // pal[i][j]: s[i-j] is a palindrome or not for ( int i = 0 ; i < n; i ++ ) { // grow 1 letter by 1 letter int min = i; for ( int j = 0 ; j <= i; j ++ ) { // j is the start index of the right section if (ch [ j ] == ch [ i ] && (j + 1 > i - 1 || pal [ j + 1][ i - 1] )) { pal [ j ][ i ] = true ; min = j == 0 ? 0 : Math. min (min, cut [ j - 1] + 1 ); } } cut [ i ] = min; System. out . println (); } return cut [ n - 1] ; } public static void main (String [] args) { MinimalCutsPalindrome solution = new MinimalCutsPalindrome(); System. out . println (solution. minCuts ( \"abaacda\" )); } } Code Cpp \u00b6 class Solution { public : int minCuts(string input) { // write your solution here int n = input.size(), inf = 0x3f3f3f3f ; int dp[n]; bool pal[n][n]; memset(pal, false , sizeof pal); memset(dp, inf, sizeof dp); dp[ 0 ] = 0 ; for ( int i = 0 ; i < n; ++ i) { pal[i][i] = true ; } for ( int i = 0 ; i < n; ++ i) for ( int j = 0 ; j <= i; ++ j) { if (input[i] == input[j] && (j + 1 > i - 1 || pal[i - 1 ][j + 1 ])) { if (j == 0 ) dp[i] = 0 ; // else dp[i] = min(dp[i], dp[j - 1 ] + 1 ); pal[i][j] = true ; } } return dp[n - 1 ]; } }; P4: Print all the if { and } \u00b6 Given an integer n, print/output all possible ways of writing n pairs of if blocks with correct indentation. Say n=2 output should be if { } if { } if { if {// here should exist two spaces before each inner block } } Analysis \u00b6 Assumption: input is a valid integer and output is a string that has been formatted in the correct indentation if input is less or equal then 0, print nothing Approach: 1. High Level: use DFS to traverse all the possible combination of if { and } , and then format the raw string into the correct indented string. 2. Details: - To get the correct combination, we need to track the number of if { and } , which have to match with each other. We can use the approach introduced in generated parenthesis to do so. - Format: we need to count the number of space for each level, and I will use int space to track. 3. Recursion Tree: Complexity: Time: O(2^n) O(2^n) Space: O(2 \\times N) O(2 \\times N) Code \u00b6 package test ; public class PrintAllBlock { /** * dfs method that keep generate the valid string of { and } * @param leftRemain * @param rightRemain * @param index * @param curr */ private void helper ( int leftRemain, int rightRemain, int index, char [] curr) { // base case if (leftRemain == 0 && rightRemain == 0 ) { printBlock(curr); return ; } if (leftRemain > 0 ) { curr [ index ] = '{' ; helper(leftRemain - 1 , rightRemain, index + 1 , curr); } if (rightRemain > leftRemain) { curr [ index ] = '}' ; helper(leftRemain, rightRemain - 1 , index + 1 , curr); } } /** * print the space for indentation * @param n */ private void printSpace ( int n) { while (n > 0 ) { System. out . print ( \" \" ); n -- ; } } /** * print the corrected format from valid { and } string * @param curr */ private void printBlock ( char [] curr) { int space = 0 ; for ( int i = 0 ; i < curr. length ; ++ i) { if (curr [ i ] == '{' ) { printSpace(space); System. out . println ( \"if {\" ); space += 2 ; } else { space -= 2 ; printSpace(space); System. out . println ( \"}\" ); } } System. out . println (); } /** * driver method: takes in a number represents the number of if { and } that it will have * @param n */ public void printBlocks ( int n) { if (n <= 0 ) return ; char [] curr = new char [2 * n ] ; helper(n, n, 0 , curr); } public static void main (String [] argc) { PrintAllBlock s = new PrintAllBlock(); s. printBlocks ( 3 ); } }","title":"Midterm"},{"location":"Interview/midterm-java/#midterm","text":"","title":"Midterm"},{"location":"Interview/midterm-java/#p1-n-queens","text":"Find all valid ways of putting N Queens on an N * N chessboard so that no two Queens can attack each other (two queens can attack each other if they are on the same row/column or same diagonal line). You can define your own way of how to print the solution, e.g. using a size N array/List to record which column the queen occupies on each row","title":"P1: N queens"},{"location":"Interview/midterm-java/#analysis","text":"Assumption: Use array curr to represent the solution: one index row, place a queen on curr[index] column to represent the complete configuration. If there are no solutions (e.g. when N <= 3), return an empty array. Approach: 1. High Level: use DFS 2. Details: - Starting from the first row, try placing the queen from the column 0 to column N-1. After the first placement, begin another placement for second row. - In order to check if the current row and column can be placed a queen, we need to have a hashset for storing all the visited queens: column , diagonal and anti-diagonal . - if (x, y) is in the same column of (i, j), then y == j - if (x, y) is in the same diagonal of (i, j), then x + y == i + j - if (x, y) is in the same anti-diagonal of (i, j), then y - x + n - 1 == j - i (+ n - 1 because we want to make sure the sum will fit in our boolean array) - Base case: if we can successfully reach the last row with all the N placement of the queens, then the current configuration is one of the solution. 3. Recursion Tree: Complexity: - Time: O(N^N) O(N^N) - Space: O(N) O(N)","title":"Analysis"},{"location":"Interview/midterm-java/#code","text":"package test ; import java.util.ArrayList ; import java.util.List ; public class test { /** * convert int[] to List<Integer>: List can track the size of the container * @param array * @return resulting List<Integer> */ private List < Integer > toList ( int [] array) { List < Integer > list = new ArrayList <> (); for ( int num : array) list. add (num); return list; } /** * check if the current placement is valid or not * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals * @return true: is valid, false: invalid */ private boolean valid ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { return ! usedColumns [ column ] && ! usedDiagonals [ column + row ] && ! usedAntiDiagonals [ column - row + n - 1] ; } /** * mark the current placement (if is valid) * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void mark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = true ; usedDiagonals [ column + row ] = true ; usedAntiDiagonals [ column - row + n - 1] = true ; } /** * unmark the current placement * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void unMark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = false ; usedDiagonals [ column + row ] = false ; usedAntiDiagonals [ column - row + n - 1] = false ; } /** * main DFS logic to iterate through all the rows and valid columns * @param n * @param row * @param curr * @param result * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void dfs ( int n, int row, int [] curr, List < List < Integer >> result, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { // base case: reach the last row, so we add the current configuration to the result if (row == n) { result. add (toList(curr)); return ; } for ( int i = 0 ; i < n; ++ i) { // first check if current placement is valid or not if (valid(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals)) { // if is valid, mark it down mark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); curr [ row ] = i; // place to current column dfs(n, row + 1 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); // don't forget to unmark it so that it will go back to the previous stage unMark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); } } } /** * driver method: user input a n, and we should return all the configurations that it should have * @param n * @return List<List<Integer>> result array (configurations) */ public List < List < Integer >> nqueens ( int n) { int [] curr = new int [ n ] ; List < List < Integer >> result = new ArrayList < List < Integer >> (); boolean [] usedColumns = new boolean [ n ] ; boolean [] usedDiagonals = new boolean [2 * n - 1] ; boolean [] usedAntiDiagonals = new boolean [2 * n - 1] ; dfs(n, 0 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); return result; } public static void main (String [] args) { test s = new test(); List < List < Integer >> list = s. nqueens ( 4 ); for (List < Integer > l : list) { for (Integer i : l) System. out . println (i); System. out . println (); } } }","title":"Code"},{"location":"Interview/midterm-java/#p2-maximum-leaf-sum","text":"Given a binary tree in which each node contains an int number. Find the maximum possible sum from any leaf node to another leaf node. The maximum sum path may or may not go through root. Expected time complexity is O(n).","title":"P2: Maximum leaf sum"},{"location":"Interview/midterm-java/#analysis_1","text":"Assumption: If input is null (no node), or without left OR right child, return Integer.MIN_VALUE. Approach: 1. High Level: use Post-order traversal to traverse the binary tree, and calculate the path sum for each path from left leaf - current root - right leaf. 2. Details: - The method signature is int maxPathSum(TreeNode root) where root is the input tree's root node, return is the maximum path sum. - If input is one of the case mentioned in the assumption, return Integer.MIN_VALUE - Define another helper method int postOrder(TreeNode root, int[] result) where result is an array because it will be able to be modified within the recursive method. The return value represents the maximum sum from any leaf to current root. - In the traverse: base case is when current root == null , it should return 0 as it has reach leaf node. Then there are three cases to be considered: 1. left and right children are both null: this path is invalid 2. left or right children have one is null: choose the path that has a leaf 3. left and right children both exist: choose the maximum path between the two paths 3. Recursion Tree: Complexity: - Time: O(N) O(N) - Space: O(height) O(height) or O(N) O(N)","title":"Analysis"},{"location":"Interview/midterm-java/#code_1","text":"/** * public class TreeNode { * public int key; * public TreeNode left; * public TreeNode right; * public TreeNode(int key) { * this.key = key; * } * } */ public class Solution { private int postOrder (TreeNode root, int [] result) { if (root == null ) return 0 ; int leftSum = postOrder(root. left , result); int rightSum = postOrder(root. right , result); // case 1: if current root has both left and right child, // then update the result and choose the bigger sum between the left and right children if (root. left != null && root. right != null ) { result [0] = Math. max (root. key + leftSum + rightSum, result [0] ); return Math. max (root. key + leftSum, root. key + rightSum); } // case 2: if only one child exist, return the one with leaf if (root. left == null ) return root. key + rightSum; return root. key + leftSum; } public int maxPathSum (TreeNode root) { if (root == null || root. left == null || root. right == null ) return Integer. MIN_VALUE ; int [] result = {Integer. MIN_VALUE }; postOrder(root, result); return result [0] ; } }","title":"Code"},{"location":"Interview/midterm-java/#p3-minimal-cuts-to-form-palindrome","text":"Given a string, a partitioning of the string is a palindrome partitioning if every partition is a palindrome. For example, \u201caba |b | bbabb |a| b| aba\u201d is a palindrome partitioning of \u201cababbbabbababa\u201d. Determine the fewest cuts needed for palindrome partitioning of a given string. For example, minimum 3 cuts are needed for \u201cababbbabbababa\u201d. The three cuts are \u201ca | babbbab | b | ababa\u201d. If a string is palindrome, then minimum 0 cuts are needed. Return the minimum cuts.","title":"P3: minimal cuts to form palindrome"},{"location":"Interview/midterm-java/#analysis_2","text":"Assumption: Input string is a valid string: not null Approach: 1. High Level: because this question is asking the minimal cuts but not each configuration/how to cut, we can naturally think to use Dynamic Programming. 2. Details: - cuts[i]: minimal cuts from 0-i in char array - pal[i][j]: s[i-j] is a palindrome or not - base case / how to initialize the cuts array: consider each character in the array is a palindrome itself, so for each string with length n, the maximum cuts requires is n - 1 - induction rule: cuts[i] = min(cuts[i], cuts[j - 1] + 1) if s[j to i] is a palindrome AND s[i] == s[j] - result: cuts[n] 3. Fill \"table\": Complexity: Time: O(N^2) O(N^2) Space: O(N^2) O(N^2)","title":"Analysis"},{"location":"Interview/midterm-java/#code-java","text":"package test ; public class MinimalCutsPalindrome { public int minCuts (String s) { char [] ch = s. toCharArray (); // convert to char array so that there is no overhead of substring int n = ch. length ; int [] cut = new int [ n ] ; // cut[i]: minimal cuts from 0-i in ch array boolean [][] pal = new boolean [ n ][ n ] ; // pal[i][j]: s[i-j] is a palindrome or not for ( int i = 0 ; i < n; i ++ ) { // grow 1 letter by 1 letter int min = i; for ( int j = 0 ; j <= i; j ++ ) { // j is the start index of the right section if (ch [ j ] == ch [ i ] && (j + 1 > i - 1 || pal [ j + 1][ i - 1] )) { pal [ j ][ i ] = true ; min = j == 0 ? 0 : Math. min (min, cut [ j - 1] + 1 ); } } cut [ i ] = min; System. out . println (); } return cut [ n - 1] ; } public static void main (String [] args) { MinimalCutsPalindrome solution = new MinimalCutsPalindrome(); System. out . println (solution. minCuts ( \"abaacda\" )); } }","title":"Code Java"},{"location":"Interview/midterm-java/#code-cpp","text":"class Solution { public : int minCuts(string input) { // write your solution here int n = input.size(), inf = 0x3f3f3f3f ; int dp[n]; bool pal[n][n]; memset(pal, false , sizeof pal); memset(dp, inf, sizeof dp); dp[ 0 ] = 0 ; for ( int i = 0 ; i < n; ++ i) { pal[i][i] = true ; } for ( int i = 0 ; i < n; ++ i) for ( int j = 0 ; j <= i; ++ j) { if (input[i] == input[j] && (j + 1 > i - 1 || pal[i - 1 ][j + 1 ])) { if (j == 0 ) dp[i] = 0 ; // else dp[i] = min(dp[i], dp[j - 1 ] + 1 ); pal[i][j] = true ; } } return dp[n - 1 ]; } };","title":"Code Cpp"},{"location":"Interview/midterm-java/#p4-print-all-the-if-and","text":"Given an integer n, print/output all possible ways of writing n pairs of if blocks with correct indentation. Say n=2 output should be if { } if { } if { if {// here should exist two spaces before each inner block } }","title":"P4: Print all the if { and }"},{"location":"Interview/midterm-java/#analysis_3","text":"Assumption: input is a valid integer and output is a string that has been formatted in the correct indentation if input is less or equal then 0, print nothing Approach: 1. High Level: use DFS to traverse all the possible combination of if { and } , and then format the raw string into the correct indented string. 2. Details: - To get the correct combination, we need to track the number of if { and } , which have to match with each other. We can use the approach introduced in generated parenthesis to do so. - Format: we need to count the number of space for each level, and I will use int space to track. 3. Recursion Tree: Complexity: Time: O(2^n) O(2^n) Space: O(2 \\times N) O(2 \\times N)","title":"Analysis"},{"location":"Interview/midterm-java/#code_2","text":"package test ; public class PrintAllBlock { /** * dfs method that keep generate the valid string of { and } * @param leftRemain * @param rightRemain * @param index * @param curr */ private void helper ( int leftRemain, int rightRemain, int index, char [] curr) { // base case if (leftRemain == 0 && rightRemain == 0 ) { printBlock(curr); return ; } if (leftRemain > 0 ) { curr [ index ] = '{' ; helper(leftRemain - 1 , rightRemain, index + 1 , curr); } if (rightRemain > leftRemain) { curr [ index ] = '}' ; helper(leftRemain, rightRemain - 1 , index + 1 , curr); } } /** * print the space for indentation * @param n */ private void printSpace ( int n) { while (n > 0 ) { System. out . print ( \" \" ); n -- ; } } /** * print the corrected format from valid { and } string * @param curr */ private void printBlock ( char [] curr) { int space = 0 ; for ( int i = 0 ; i < curr. length ; ++ i) { if (curr [ i ] == '{' ) { printSpace(space); System. out . println ( \"if {\" ); space += 2 ; } else { space -= 2 ; printSpace(space); System. out . println ( \"}\" ); } } System. out . println (); } /** * driver method: takes in a number represents the number of if { and } that it will have * @param n */ public void printBlocks ( int n) { if (n <= 0 ) return ; char [] curr = new char [2 * n ] ; helper(n, n, 0 , curr); } public static void main (String [] argc) { PrintAllBlock s = new PrintAllBlock(); s. printBlocks ( 3 ); } }","title":"Code"},{"location":"Interview/ood/","text":"Object Oriented Design \u00b6 Design Pattern \u00b6 https://github.com/JakubVojvoda/design-patterns-cpp Builder \u00b6 if there are a lot of fields in a class, cannot put them all in as parameters in the constructor. solution 0: define final and optional data fields in the class (no need to initialize in the constructor => bad because it could generate a lot of dfferent types of constructors. solution 1: use setter and getter => bad because if want to create an object, user has to call all the setters and getters (constructor isn't doing what it is supposed to do: dangerous in multi-threading) => encapsulation is destroyed => e.g. setters' member field might not want to be changed OR setters are not changed in the desire way solution 2: encapsulate the related fields into a single function, use an abstract class to manage the top level abstraction and some concrete subclasses to manage the specific constructions. Core: create a builder class for top level abstraction and subclasses for specific constructions. When implementing, don't forget to #include \"builder.hpp\" . /* * C++ Design Patterns: Builder * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * the final object that will be created using Builder */ class Product { public : void makeA( const std :: string & part ) { partA = part; } void makeB( const std :: string & part ) { partB = part; } void makeC( const std :: string & part ) { partC = part; } std :: string get() { return (partA + \" \" + partB + \" \" + partC); } // ... private : std :: string partA; std :: string partB; std :: string partC; // ... }; /* * Builder * abstract interface for creating products */ class Builder { public : virtual ~ Builder() {} Product get() { return product; } virtual void buildPartA() = 0 ; virtual void buildPartB() = 0 ; virtual void buildPartC() = 0 ; // ... protected : Product product; }; /* * Concrete Builder X and Y * create real products and stores them in the composite structure */ class ConcreteBuilderX : public Builder { public : void buildPartA() { product.makeA( \"A-X\" ); } void buildPartB() { product.makeB( \"B-X\" ); } void buildPartC() { product.makeC( \"C-X\" ); } // ... }; class ConcreteBuilderY : public Builder { public : void buildPartA() { product.makeA( \"A-Y\" ); } void buildPartB() { product.makeB( \"B-Y\" ); } void buildPartC() { product.makeC( \"C-Y\" ); } // ... }; /* * Director * responsible for managing the correct sequence of object creation */ class Director { public : Director() : builder() {} ~ Director() { if ( builder ) { delete builder; } } void set( Builder * b ) { if ( builder ) { delete builder; } builder = b; } Product get() { return builder -> get(); } void construct() { builder -> buildPartA(); builder -> buildPartB(); builder -> buildPartC(); // ... } // ... private : Builder * builder; }; int main () { Director director; director.set( new ConcreteBuilderX ); director.construct(); Product product1 = director.get(); std :: cout << \"1st product parts: \" << product1.get() << std :: endl; director.set( new ConcreteBuilderY ); director.construct(); Product product2 = director.get(); std :: cout << \"2nd product parts: \" << product2.get() << std :: endl; return 0 ; } Abstract Factory \u00b6 polymorphism: use an abstract class to include the shared method getName() multiple different classes create the same type of object with the shared method for creations, update and other CRUD operations. it's a easy to extend: if you want to add a new type and add its creation and other CURD , just create a new method in the abstract factory class (implement the details in the subclass). example usage: when designing an application on different platforms, methods themselves don't need to change the logic when running on different platform => create a factory class for initialize different object on different platform /* * C++ Design Patterns: Abstract Factory * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Product A * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class ProductA { public : virtual ~ ProductA() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductAX and ConcreteProductAY * define objects to be created by concrete factory */ class ConcreteProductAX : public ProductA { public : ~ ConcreteProductAX() {} const char * getName() { return \"A-X\" ; } // ... }; class ConcreteProductAY : public ProductA { public : ~ ConcreteProductAY() {} const char * getName() { return \"A-Y\" ; } // ... }; /* * Product B * same as Product A, Product B declares interface for concrete products * where each can produce an entire set of products */ class ProductB { public : virtual ~ ProductB() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductBX and ConcreteProductBY * same as previous concrete product classes */ class ConcreteProductBX : public ProductB { public : ~ ConcreteProductBX() {} const char * getName() { return \"B-X\" ; } // ... }; class ConcreteProductBY : public ProductB { public : ~ ConcreteProductBY() {} const char * getName() { return \"B-Y\" ; } // ... }; /* * Abstract Factory * provides an abstract interface for creating a family of products */ class AbstractFactory { public : virtual ~ AbstractFactory() {} virtual ProductA * createProductA() = 0 ; virtual ProductB * createProductB() = 0 ; }; /* * Concrete Factory X and Y * each concrete factory create a family of products and client uses * one of these factories so it never has to instantiate a product object */ class ConcreteFactoryX : public AbstractFactory { public : ~ ConcreteFactoryX() {} ProductA * createProductA() { return new ConcreteProductAX(); } ProductB * createProductB() { return new ConcreteProductBX(); } // ... }; class ConcreteFactoryY : public AbstractFactory { public : ~ ConcreteFactoryY() {} ProductA * createProductA() { return new ConcreteProductAY(); } ProductB * createProductB() { return new ConcreteProductBY(); } // ... }; int main () { ConcreteFactoryX * factoryX = new ConcreteFactoryX(); ConcreteFactoryY * factoryY = new ConcreteFactoryY(); ProductA * p1 = factoryX -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; ProductA * p2 = factoryY -> createProductA(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; delete p1; delete p2; delete factoryX; delete factoryY; return 0 ; } Factory Method \u00b6 When to use * a class cant anticipate the class of objects it must create * a class wants its subclasses to specify the objects it creates * classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate /* * C++ Design Patterns: Factory Method * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class Product { public : virtual ~ Product() {} virtual std :: string getName() = 0 ; // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductA : public Product { public : ~ ConcreteProductA() {} std :: string getName() { return \"type A\" ; } // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductB : public Product { public : ~ ConcreteProductB() {} std :: string getName() { return \"type B\" ; } // ... }; /* * Creator * contains the implementation for all of the methods * to manipulate products except for the factory method */ class Creator { public : virtual ~ Creator() {} virtual Product * createProductA() = 0 ; virtual Product * createProductB() = 0 ; virtual void removeProduct( Product * product ) = 0 ; // ... }; /* * Concrete Creator * implements factory method that is responsible for creating * one or more concrete products ie. it is class that has * the knowledge of how to create the products */ class ConcreteCreator : public Creator { public : ~ ConcreteCreator() {} Product * createProductA() { return new ConcreteProductA(); } Product * createProductB() { return new ConcreteProductB(); } void removeProduct( Product * product ) { delete product; } // ... }; int main () { Creator * creator = new ConcreteCreator(); Product * p1 = creator -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; creator -> removeProduct( p1 ); Product * p2 = creator -> createProductB(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; creator -> removeProduct( p2 ); delete creator; return 0 ; } Game Play Style OOD: BlackJack or 21 points \u00b6 OOD: what is the process of playing the game? What if System Design: how to make it be able to be played by multiple users? Data and Action \u00b6 Based on data and action to design class. What is the state of the game: total points -> state machine <= action will determine what state it is currently on. Simulator Class for controlling all the data flow Class \u00b6 Card, Deck, Player/Hand, Dealer, Game ( has Player[], Deck, Dealer) start with Card, since it's the easiest class to be designed. Card Assumption: standard 52-card set Card: 1) Value, 2) Suit (Club, Diamond, Heart, Spade) Deck: 1) List public enum Suit { Club, Diamond, Heart, Spade } public class Card { private int faceValue; // 1 for A, 11 for J, 12 for Q, 13 for K. Or we can use Enum here. private Suit suit; public Card ( int c, Suit s) { faceValue = c; suit = s; } public int value () { return faceValue; } public Suit suit () { return suit; } } public class Deck { private static final Random random = new Random(); // action private final List < Card > cards = new ArrayList <> (); // or Card[] private int dealtIndex = 0 ; public Deck () { for ( int i = 1 ; i <= 13 ; ++ i) { for (Suit suit : Suit. values ()) { cards. add ( new Card(i, suit)); } } } public void shuffle () { for ( int i = 0 ; i < cards. size () - 1 ; ++ i) { int j = random. nextInt (cards. size () - i) + i; Card card1 = cards. get (i); Card card2 = cards. get (j); cards. set (i, card2); cards. set (j, card1); } } private int remainingCards () { return cards. size () - dealtIndex; } public Card [] dealHand ( int number) { if (remainingCards() < number) return null ; Card [] cards = new Card [ number ] ; for ( int i = 0 ; i < number; ++ i) card [ i ] = dealCard(); return cards; } public Card dealCard () { return remainingCards() == 0 ? null : cards. get (dealIndex ++ ); } } public class Hand { protected final List < Card > cards = new ArrayList <> (); public int score () { // or design as an abstract class => more extenable: can be used by other game int score = 0 ; for (Card card : cards) { score += card. value (); } return score; } public void addCards (Card [] c) { Collections. addAll (cards, c); } public int size () { return cards. size (); } } Functionality \u00b6 How to extend the Card design to support Black Jack? Black Jack score rules: - 2 ~ 10 scores its face value - J, Q, and K score 10 - A score either 1 or 11 (store both, make decision later) public class BlackJackHand extends Hand { @Override public final int score () { List < Integer > scores = possibleScores(); int maxUnder = Integer. MIN_VALUE ; // max score <= 21 int minUnder = Integer. MAX_VALUE ; // max score <= 21 for ( int score : scores) { if (score > 21 && score < minOver) { minOver = score; } else if (score <= 21 && score > maxUnder) { maxUnder = score; } } return maxUnder == Integer. MIN_VALUE ? minOver : maxUnder; } private List < Integer > possibleScores () { List < Integer > scores = new ArrayList <> (); for (Card card : cards) { updateScores(card, scores); } return scores; } private void udpateScores (Card card, List < Integer > scores) { final int [] toAdd = getScore(card); if (scores. isEmpty ()) { for ( int score : toAdd) { scores. add (score); } } else { final int length = scores. size (); for ( int i = 0 ; i < length; ++ i) { int oldScore = scores. get (i); scores. set (i, oldScore + toAdd [0] ); for ( int j = 1 ; j < toAdd. length ; ++ j) { scores. add (oldScore + to) } } } } } Vending Machine \u00b6 no need to talk about how many user using (distribute system design) Data \u00b6 item vending machine Action \u00b6 buy/purchase: input (item id, money) and output (item, remain money) input and return type: int, Item exceptions (could talk later in details): if there is no more items remaining, or there is not enough money could talk about use case: assumption (money for change is efficient), use the most familiar one for your use case. Class \u00b6 Item (first design the most fundmental class) price: int name/id: int/string type Vending Machine money remaining: int colllection of Item: unordered_map -> unordered_map Item: should represent type of item instead of specific item -> add a field in item for type buy/purchase API more: if there are multiple tracks Elevator Simulator \u00b6 start from use case (discuss with the interviewer): show level button or just up and down then select inside the elevator swipe card to validate or not support for multiple elevator -> design elevator system how to schedule (it could be discussed later): support different types of requests What is elevator's state in each \"iteration\" (per floor) State to determine attribute \u00b6 which floor first floor: up or down (outstanding request to go up or down), open or close door (people load or unload from the elevator) -> next iteration is on second floor (if go up) -> do the same thing for 1 st floor move up or move down weight/headcount and capacity -> if overload what to do when reach a floor what to determine to open or not: depends on the request (from outside or inside people) after open door: get in and get out -> next requests determine whether to change the direction Data \u00b6 maxCapacity maxFloor load location Action \u00b6 open/close door floor going up or down Class \u00b6 System Management (Building) how many elevator going up or down map > Elevator vector : good for encapsulation User (no need -> too detailed) Floor (no need -> too detailed and not relate to action) Request up and down from which floor make the request Scheduling (Final Step) \u00b6 Each elevator makes its own decision check Up/Down requests the 1 st elevator arriving at the floor takes the request with the same direction the elevator loads ppl at the floor and handles their requests Parking Lot \u00b6 Steps: understand/analyze the functionality and its use case use case -> functionality -> APIs one level or multiple levels? parking-spot / vehicle sizes? track the location of each vehicle? Drive in: input is a car, and output could be number of spot, boolean for if possible to be parked, ticket, etc. Why it has some many solutions? Because of use case. Drive out: input is a ticket (money), car object, and output could be a boolean for if car actually exited, or a number for spots left APIs input output specific / important components Design Classes input / output DATA -> physical entities Parking Lot: CORE class -> store the main functionalities Car: physical entity Ticket: physical entity (depends on use case) Parking Spot (optional): track different sized car, visited only, clean energy, etc. level? no need, just a member field in parking lot; need, each level has many different attributes to be considered Class relationships association: a general binary relationship that describes an activity between two classes vehicle -- parking spot: a vehicle can park at a specific parking spot aggregation/composition: has-a inheritance vehicle -- car, truck Member fields and Methods of Class \u00b6 No need to have specific implementation at first Functionality Basic Functionality: for a given vehicle, tell whether there is avaliable spot in the parking lot possible extensions: provide avaliable spot locations, assign spot to the vehicle, ... assume there are multiple levels ENUM hard to be wrong used e.g. : weekday using int -> 8? doesn't exist class ParkingLot { private : vector < Level > levels; // what if no level class? -> 2d array to represent the spot in different level public : bool hasSpot(Vehicle v) { // check each level, for each level, call Level#hasSpot(Vehicle) } } class Level { /* public: bool hasSpot(Vehicle v) { // check current level, if has spot } */ } enum SIZE{suv, truck, eco} class ParkingSpot { private : enum SIZE size; // bool fit(Vehice): check size and avaliability } class Vehicle { public : // data field virtual int getSize() = 0 ; } Implementation \u00b6 no need to complete the entire implementation during the interview, just finish the core functions Exception Handler, Comparator (for enum?)","title":"Object Oriented Design"},{"location":"Interview/ood/#object-oriented-design","text":"","title":"Object Oriented Design"},{"location":"Interview/ood/#design-pattern","text":"https://github.com/JakubVojvoda/design-patterns-cpp","title":"Design Pattern"},{"location":"Interview/ood/#builder","text":"if there are a lot of fields in a class, cannot put them all in as parameters in the constructor. solution 0: define final and optional data fields in the class (no need to initialize in the constructor => bad because it could generate a lot of dfferent types of constructors. solution 1: use setter and getter => bad because if want to create an object, user has to call all the setters and getters (constructor isn't doing what it is supposed to do: dangerous in multi-threading) => encapsulation is destroyed => e.g. setters' member field might not want to be changed OR setters are not changed in the desire way solution 2: encapsulate the related fields into a single function, use an abstract class to manage the top level abstraction and some concrete subclasses to manage the specific constructions. Core: create a builder class for top level abstraction and subclasses for specific constructions. When implementing, don't forget to #include \"builder.hpp\" . /* * C++ Design Patterns: Builder * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * the final object that will be created using Builder */ class Product { public : void makeA( const std :: string & part ) { partA = part; } void makeB( const std :: string & part ) { partB = part; } void makeC( const std :: string & part ) { partC = part; } std :: string get() { return (partA + \" \" + partB + \" \" + partC); } // ... private : std :: string partA; std :: string partB; std :: string partC; // ... }; /* * Builder * abstract interface for creating products */ class Builder { public : virtual ~ Builder() {} Product get() { return product; } virtual void buildPartA() = 0 ; virtual void buildPartB() = 0 ; virtual void buildPartC() = 0 ; // ... protected : Product product; }; /* * Concrete Builder X and Y * create real products and stores them in the composite structure */ class ConcreteBuilderX : public Builder { public : void buildPartA() { product.makeA( \"A-X\" ); } void buildPartB() { product.makeB( \"B-X\" ); } void buildPartC() { product.makeC( \"C-X\" ); } // ... }; class ConcreteBuilderY : public Builder { public : void buildPartA() { product.makeA( \"A-Y\" ); } void buildPartB() { product.makeB( \"B-Y\" ); } void buildPartC() { product.makeC( \"C-Y\" ); } // ... }; /* * Director * responsible for managing the correct sequence of object creation */ class Director { public : Director() : builder() {} ~ Director() { if ( builder ) { delete builder; } } void set( Builder * b ) { if ( builder ) { delete builder; } builder = b; } Product get() { return builder -> get(); } void construct() { builder -> buildPartA(); builder -> buildPartB(); builder -> buildPartC(); // ... } // ... private : Builder * builder; }; int main () { Director director; director.set( new ConcreteBuilderX ); director.construct(); Product product1 = director.get(); std :: cout << \"1st product parts: \" << product1.get() << std :: endl; director.set( new ConcreteBuilderY ); director.construct(); Product product2 = director.get(); std :: cout << \"2nd product parts: \" << product2.get() << std :: endl; return 0 ; }","title":"Builder"},{"location":"Interview/ood/#abstract-factory","text":"polymorphism: use an abstract class to include the shared method getName() multiple different classes create the same type of object with the shared method for creations, update and other CRUD operations. it's a easy to extend: if you want to add a new type and add its creation and other CURD , just create a new method in the abstract factory class (implement the details in the subclass). example usage: when designing an application on different platforms, methods themselves don't need to change the logic when running on different platform => create a factory class for initialize different object on different platform /* * C++ Design Patterns: Abstract Factory * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Product A * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class ProductA { public : virtual ~ ProductA() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductAX and ConcreteProductAY * define objects to be created by concrete factory */ class ConcreteProductAX : public ProductA { public : ~ ConcreteProductAX() {} const char * getName() { return \"A-X\" ; } // ... }; class ConcreteProductAY : public ProductA { public : ~ ConcreteProductAY() {} const char * getName() { return \"A-Y\" ; } // ... }; /* * Product B * same as Product A, Product B declares interface for concrete products * where each can produce an entire set of products */ class ProductB { public : virtual ~ ProductB() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductBX and ConcreteProductBY * same as previous concrete product classes */ class ConcreteProductBX : public ProductB { public : ~ ConcreteProductBX() {} const char * getName() { return \"B-X\" ; } // ... }; class ConcreteProductBY : public ProductB { public : ~ ConcreteProductBY() {} const char * getName() { return \"B-Y\" ; } // ... }; /* * Abstract Factory * provides an abstract interface for creating a family of products */ class AbstractFactory { public : virtual ~ AbstractFactory() {} virtual ProductA * createProductA() = 0 ; virtual ProductB * createProductB() = 0 ; }; /* * Concrete Factory X and Y * each concrete factory create a family of products and client uses * one of these factories so it never has to instantiate a product object */ class ConcreteFactoryX : public AbstractFactory { public : ~ ConcreteFactoryX() {} ProductA * createProductA() { return new ConcreteProductAX(); } ProductB * createProductB() { return new ConcreteProductBX(); } // ... }; class ConcreteFactoryY : public AbstractFactory { public : ~ ConcreteFactoryY() {} ProductA * createProductA() { return new ConcreteProductAY(); } ProductB * createProductB() { return new ConcreteProductBY(); } // ... }; int main () { ConcreteFactoryX * factoryX = new ConcreteFactoryX(); ConcreteFactoryY * factoryY = new ConcreteFactoryY(); ProductA * p1 = factoryX -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; ProductA * p2 = factoryY -> createProductA(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; delete p1; delete p2; delete factoryX; delete factoryY; return 0 ; }","title":"Abstract Factory"},{"location":"Interview/ood/#factory-method","text":"When to use * a class cant anticipate the class of objects it must create * a class wants its subclasses to specify the objects it creates * classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate /* * C++ Design Patterns: Factory Method * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class Product { public : virtual ~ Product() {} virtual std :: string getName() = 0 ; // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductA : public Product { public : ~ ConcreteProductA() {} std :: string getName() { return \"type A\" ; } // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductB : public Product { public : ~ ConcreteProductB() {} std :: string getName() { return \"type B\" ; } // ... }; /* * Creator * contains the implementation for all of the methods * to manipulate products except for the factory method */ class Creator { public : virtual ~ Creator() {} virtual Product * createProductA() = 0 ; virtual Product * createProductB() = 0 ; virtual void removeProduct( Product * product ) = 0 ; // ... }; /* * Concrete Creator * implements factory method that is responsible for creating * one or more concrete products ie. it is class that has * the knowledge of how to create the products */ class ConcreteCreator : public Creator { public : ~ ConcreteCreator() {} Product * createProductA() { return new ConcreteProductA(); } Product * createProductB() { return new ConcreteProductB(); } void removeProduct( Product * product ) { delete product; } // ... }; int main () { Creator * creator = new ConcreteCreator(); Product * p1 = creator -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; creator -> removeProduct( p1 ); Product * p2 = creator -> createProductB(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; creator -> removeProduct( p2 ); delete creator; return 0 ; }","title":"Factory Method"},{"location":"Interview/ood/#game-play-style-ood-blackjack-or-21-points","text":"OOD: what is the process of playing the game? What if System Design: how to make it be able to be played by multiple users?","title":"Game Play Style OOD: BlackJack or 21 points"},{"location":"Interview/ood/#data-and-action","text":"Based on data and action to design class. What is the state of the game: total points -> state machine <= action will determine what state it is currently on. Simulator Class for controlling all the data flow","title":"Data and Action"},{"location":"Interview/ood/#class","text":"Card, Deck, Player/Hand, Dealer, Game ( has Player[], Deck, Dealer) start with Card, since it's the easiest class to be designed. Card Assumption: standard 52-card set Card: 1) Value, 2) Suit (Club, Diamond, Heart, Spade) Deck: 1) List public enum Suit { Club, Diamond, Heart, Spade } public class Card { private int faceValue; // 1 for A, 11 for J, 12 for Q, 13 for K. Or we can use Enum here. private Suit suit; public Card ( int c, Suit s) { faceValue = c; suit = s; } public int value () { return faceValue; } public Suit suit () { return suit; } } public class Deck { private static final Random random = new Random(); // action private final List < Card > cards = new ArrayList <> (); // or Card[] private int dealtIndex = 0 ; public Deck () { for ( int i = 1 ; i <= 13 ; ++ i) { for (Suit suit : Suit. values ()) { cards. add ( new Card(i, suit)); } } } public void shuffle () { for ( int i = 0 ; i < cards. size () - 1 ; ++ i) { int j = random. nextInt (cards. size () - i) + i; Card card1 = cards. get (i); Card card2 = cards. get (j); cards. set (i, card2); cards. set (j, card1); } } private int remainingCards () { return cards. size () - dealtIndex; } public Card [] dealHand ( int number) { if (remainingCards() < number) return null ; Card [] cards = new Card [ number ] ; for ( int i = 0 ; i < number; ++ i) card [ i ] = dealCard(); return cards; } public Card dealCard () { return remainingCards() == 0 ? null : cards. get (dealIndex ++ ); } } public class Hand { protected final List < Card > cards = new ArrayList <> (); public int score () { // or design as an abstract class => more extenable: can be used by other game int score = 0 ; for (Card card : cards) { score += card. value (); } return score; } public void addCards (Card [] c) { Collections. addAll (cards, c); } public int size () { return cards. size (); } }","title":"Class"},{"location":"Interview/ood/#functionality","text":"How to extend the Card design to support Black Jack? Black Jack score rules: - 2 ~ 10 scores its face value - J, Q, and K score 10 - A score either 1 or 11 (store both, make decision later) public class BlackJackHand extends Hand { @Override public final int score () { List < Integer > scores = possibleScores(); int maxUnder = Integer. MIN_VALUE ; // max score <= 21 int minUnder = Integer. MAX_VALUE ; // max score <= 21 for ( int score : scores) { if (score > 21 && score < minOver) { minOver = score; } else if (score <= 21 && score > maxUnder) { maxUnder = score; } } return maxUnder == Integer. MIN_VALUE ? minOver : maxUnder; } private List < Integer > possibleScores () { List < Integer > scores = new ArrayList <> (); for (Card card : cards) { updateScores(card, scores); } return scores; } private void udpateScores (Card card, List < Integer > scores) { final int [] toAdd = getScore(card); if (scores. isEmpty ()) { for ( int score : toAdd) { scores. add (score); } } else { final int length = scores. size (); for ( int i = 0 ; i < length; ++ i) { int oldScore = scores. get (i); scores. set (i, oldScore + toAdd [0] ); for ( int j = 1 ; j < toAdd. length ; ++ j) { scores. add (oldScore + to) } } } } }","title":"Functionality"},{"location":"Interview/ood/#vending-machine","text":"no need to talk about how many user using (distribute system design)","title":"Vending Machine"},{"location":"Interview/ood/#data","text":"item vending machine","title":"Data"},{"location":"Interview/ood/#action","text":"buy/purchase: input (item id, money) and output (item, remain money) input and return type: int, Item exceptions (could talk later in details): if there is no more items remaining, or there is not enough money could talk about use case: assumption (money for change is efficient), use the most familiar one for your use case.","title":"Action"},{"location":"Interview/ood/#class_1","text":"Item (first design the most fundmental class) price: int name/id: int/string type Vending Machine money remaining: int colllection of Item: unordered_map -> unordered_map Item: should represent type of item instead of specific item -> add a field in item for type buy/purchase API more: if there are multiple tracks","title":"Class"},{"location":"Interview/ood/#elevator-simulator","text":"start from use case (discuss with the interviewer): show level button or just up and down then select inside the elevator swipe card to validate or not support for multiple elevator -> design elevator system how to schedule (it could be discussed later): support different types of requests What is elevator's state in each \"iteration\" (per floor)","title":"Elevator Simulator"},{"location":"Interview/ood/#state-to-determine-attribute","text":"which floor first floor: up or down (outstanding request to go up or down), open or close door (people load or unload from the elevator) -> next iteration is on second floor (if go up) -> do the same thing for 1 st floor move up or move down weight/headcount and capacity -> if overload what to do when reach a floor what to determine to open or not: depends on the request (from outside or inside people) after open door: get in and get out -> next requests determine whether to change the direction","title":"State to determine attribute"},{"location":"Interview/ood/#data_1","text":"maxCapacity maxFloor load location","title":"Data"},{"location":"Interview/ood/#action_1","text":"open/close door floor going up or down","title":"Action"},{"location":"Interview/ood/#class_2","text":"System Management (Building) how many elevator going up or down map > Elevator vector : good for encapsulation User (no need -> too detailed) Floor (no need -> too detailed and not relate to action) Request up and down from which floor make the request","title":"Class"},{"location":"Interview/ood/#scheduling-final-step","text":"Each elevator makes its own decision check Up/Down requests the 1 st elevator arriving at the floor takes the request with the same direction the elevator loads ppl at the floor and handles their requests","title":"Scheduling (Final Step)"},{"location":"Interview/ood/#parking-lot","text":"Steps: understand/analyze the functionality and its use case use case -> functionality -> APIs one level or multiple levels? parking-spot / vehicle sizes? track the location of each vehicle? Drive in: input is a car, and output could be number of spot, boolean for if possible to be parked, ticket, etc. Why it has some many solutions? Because of use case. Drive out: input is a ticket (money), car object, and output could be a boolean for if car actually exited, or a number for spots left APIs input output specific / important components Design Classes input / output DATA -> physical entities Parking Lot: CORE class -> store the main functionalities Car: physical entity Ticket: physical entity (depends on use case) Parking Spot (optional): track different sized car, visited only, clean energy, etc. level? no need, just a member field in parking lot; need, each level has many different attributes to be considered Class relationships association: a general binary relationship that describes an activity between two classes vehicle -- parking spot: a vehicle can park at a specific parking spot aggregation/composition: has-a inheritance vehicle -- car, truck","title":"Parking Lot"},{"location":"Interview/ood/#member-fields-and-methods-of-class","text":"No need to have specific implementation at first Functionality Basic Functionality: for a given vehicle, tell whether there is avaliable spot in the parking lot possible extensions: provide avaliable spot locations, assign spot to the vehicle, ... assume there are multiple levels ENUM hard to be wrong used e.g. : weekday using int -> 8? doesn't exist class ParkingLot { private : vector < Level > levels; // what if no level class? -> 2d array to represent the spot in different level public : bool hasSpot(Vehicle v) { // check each level, for each level, call Level#hasSpot(Vehicle) } } class Level { /* public: bool hasSpot(Vehicle v) { // check current level, if has spot } */ } enum SIZE{suv, truck, eco} class ParkingSpot { private : enum SIZE size; // bool fit(Vehice): check size and avaliability } class Vehicle { public : // data field virtual int getSize() = 0 ; }","title":"Member fields and Methods of Class"},{"location":"Interview/ood/#implementation","text":"no need to complete the entire implementation during the interview, just finish the core functions Exception Handler, Comparator (for enum?)","title":"Implementation"},{"location":"Interview/rectangle-2d-dp/","text":"2 Dimension Dynamic Programming \u00b6 Longest Cross Of 1s \u00b6 Given a matrix that contains only 1s and 0s, find the largest cross which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest cross. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest cross of 1s has arm length 2. Analysis \u00b6 Use the same prefix sum technique to solve this problem: 1. prefix sum from left to i, j 2. prefix sum from right to i, j 3. prefix sum from top to i, j 4. prefix sum from bottom to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public : struct Node { int left, right, down, up; int minVal () { return min({left, right, down, up}); } void setRD ( int val) { right = val; down = val; } void setLU ( int val) { left = val; up = val; } }; int largest (vector < vector < int >> matrix) { // write your solution here int m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); int res = 0 ; for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int one = matrix[i][j]; dp[i][j].setRD(one); if (i != 0 && one) dp[i][j].right = dp[i - 1 ][j].right + 1 ; if (j != 0 && one) dp[i][j].down = dp[i][j - 1 ].down + 1 ; } } // Note: direction is reversed, or there is no precalculation for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int one = matrix[i][j]; dp[i][j].setLU(one); if (i != m - 1 && one) dp[i][j].left = dp[i + 1 ][j].left + 1 ; if (j != n - 1 && one) dp[i][j].up = dp[i][j + 1 ].up + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } }; Largest X Of 1s \u00b6 Given a matrix that contains only 1s and 0s, find the largest X shape which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest X shape. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest X of 1s has arm length 2. Analysis \u00b6 Same as the largest Cross of 1s, it calcualte the the presum for diagonal axis: 1. prefix sum from top left to i, j 2. prefix sum from top right to i, j 3. prefix sum from bottom left to i, j 4. prefix sum from bottom left to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public : struct Node { int nw, ne, sw, se; void setN ( int val) { nw = ne = val; } void setS ( int val) { sw = se = val; } int minVal () { return min({nw, ne, sw, se}); } }; int largest (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].setN(val); if (val == 0 ) continue ; if (i != 0 && j != 0 ) dp[i][j].nw = dp[i - 1 ][j - 1 ].nw + 1 ; if (i != 0 && j != n - 1 ) dp[i][j].ne = dp[i - 1 ][j + 1 ].ne + 1 ; } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].setS(val); if (val == 0 ) continue ; if (i != m - 1 && j != 0 ) dp[i][j].sw = dp[i + 1 ][j - 1 ].sw + 1 ; if (i != m - 1 && j != n - 1 ) dp[i][j].se = dp[i + 1 ][j + 1 ].se + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } }; Largest Square Surrounded By One \u00b6 Determine the largest square surrounded by 1s in a binary matrix (a binary matrix only contains 0 and 1), return the length of the largest square. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{1, 0, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 0, 1, 0}, {1, 1, 1, 1, 1}, {1, 1, 1, 0, 0}} The largest square surrounded by 1s has length of 3. Analysis \u00b6 Cannot just count the largest square that is all zero, because below case is also valid: 1111 \\ 1011 \\ 1111 \\ 1111 and the answer is 4. In order to find the largest submatrix, we need to determine the smallest \"stretching length\" for its width and height. To find the \"stretching\" width and height, we can use prefix sum to do so. After we maintained the two \"stretching length\", we should find the minimal and find the longest size of the submatrix. Time: O(m \\times n \\times max(m, n)) O(m \\times n \\times max(m, n)) Space: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public : struct Node { int hor, ver; int minVal () { return min(hor, ver); } void set ( int val) { hor = ver = val; } }; int largestSquareSurroundedByOne (vector < vector < int >> matrix) { if (matrix.empty() || matrix[ 0 ].empty()) return 0 ; int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].set(val); if (val == 1 ) { if (i != 0 ) dp[i][j].ver = dp[i - 1 ][j].ver + 1 ; if (j != 0 ) dp[i][j].hor = dp[i][j - 1 ].hor + 1 ; } } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int small = dp[i][j].minVal(); while (small > res) { // horizonal grow requires vertial has the same stretching size, vice versa for vertial grow if (dp[i][j - small + 1 ].ver >= small && dp[i - small + 1 ][j].hor >= small) res = small; small -- ; } } } return res; } }; Largest Square Of Matches \u00b6 Determine the largest square surrounded by a bunch of matches (each match is either horizontal or vertical), return the length of the largest square. The input is a matrix of points. Each point has one of the following values: 0 - there is no match to its right or bottom. 1 - there is a match to its right. 2 - there is a match to its bottom. 3 - there is a match to its right, and a match to its bottom. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{3, 1, 1, 3, 0, 1, 1, 0}, {2, 0, 0, 2, 0, 0, 0, 0}, {3, 1, 3, 0, 0, 0, 0, 0}, {2, 0, 2, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0}} This matrix represents the following bunch of matches: The largest square has length of 2. Analysis \u00b6 Use the same presum technique by defining two direction: left and top 1. if matrix[i][j] == 1 || matrix[i][j] == 3: dp[i][j].left = dp[i][j + 1].left + 1; 2. if matrix[i][j] == 2 || matrix[i][j] == 3: dp[i][j].top = dp[i + 1][j].top + 1; Note that it's [i][j + 1] and [i + 1][j] , which means we need to make sure the two locations have already populated, so we should going from bottom to top and right to left. Also note that the way to find largest submatrix is different from largest square surround by ones, because the direction of the presum is flipped. And the element stored is offset by 1, because the number represent the number of matches on its right or top, so we need to check one more. Time: O(m \\times n \\times max(n, m)) O(m \\times n \\times max(n, m)) Space: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public : struct Node { int left, top; int minVal () { return min(left, top); } void set ( int val) { left = top = val; } }; int largestSquareOfMatches (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].set( 0 ); if ((val == 1 || val == 3 ) && j != n - 1 ) dp[i][j].left = dp[i][j + 1 ].left + 1 ; if ((val == 2 || val == 3 ) && i != m - 1 ) dp[i][j].top = dp[i + 1 ][j].top + 1 ; } } for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int small = dp[i][j].minVal(); while (small > res) { // j + small but not j + small - 1 if (dp[i][j + small].top >= small && dp[i + small][j].left >= small) res = small; small -- ; } } } return res; } }; Largest SubMatrix Sum \u00b6 Given a matrix that contains integers, find the submatrix with the largest sum. Return the sum of the submatrix. Assumptions The given matrix is not null and has size of M * N, where M >= 1 and N >= 1 Examples { {1, -2, -1, 4}, {1, -1, 1, 1}, {0, -1, -1, 1}, {0, 0, 1, 1} } the largest submatrix sum is (-1) + 4 + 1 + 1 + (-1) + 1 + 1 + 1 = 7. Analysis \u00b6 Imagine there are two horizon lines split the matrix into three parts: xxxx yyyy yyyy xxxx Your job is to find the maximum area sum generated by the two line (max y's sum). If we can compress the area between the two horizon lines, we can use the technique for finding the largest subarray sum to solve this problem. Time: O(n \\times n \\times m) O(n \\times n \\times m) or O(min(m, n)^2 \\times max(m, n)) O(min(m, n)^2 \\times max(m, n)) Space: because we just need one 1-d presum array: O(min(m, n)) O(min(m, n)) Code \u00b6 class Solution { public : int largest(vector < vector < int >> matrix) { int res = matrix[ 0 ][ 0 ], m = matrix.size(), n = matrix[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { vector < int > preSum(n); // keep adding from i - j rows' sum for ( int j = i; j < m; ++ j) { for ( int k = 0 ; k < n; ++ k) preSum[k] += matrix[j][k]; int currMax = preSum[ 0 ]; for ( int k = 1 ; k < n; ++ k) { // find largest subarray currMax = max(currMax + preSum[k], preSum[k]); res = max(res, currMax); } } } return res; } };","title":"2 Dimension Dynamic Programming"},{"location":"Interview/rectangle-2d-dp/#2-dimension-dynamic-programming","text":"","title":"2 Dimension Dynamic Programming"},{"location":"Interview/rectangle-2d-dp/#longest-cross-of-1s","text":"Given a matrix that contains only 1s and 0s, find the largest cross which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest cross. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest cross of 1s has arm length 2.","title":"Longest Cross Of 1s"},{"location":"Interview/rectangle-2d-dp/#analysis","text":"Use the same prefix sum technique to solve this problem: 1. prefix sum from left to i, j 2. prefix sum from right to i, j 3. prefix sum from top to i, j 4. prefix sum from bottom to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle-2d-dp/#code","text":"class Solution { public : struct Node { int left, right, down, up; int minVal () { return min({left, right, down, up}); } void setRD ( int val) { right = val; down = val; } void setLU ( int val) { left = val; up = val; } }; int largest (vector < vector < int >> matrix) { // write your solution here int m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); int res = 0 ; for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int one = matrix[i][j]; dp[i][j].setRD(one); if (i != 0 && one) dp[i][j].right = dp[i - 1 ][j].right + 1 ; if (j != 0 && one) dp[i][j].down = dp[i][j - 1 ].down + 1 ; } } // Note: direction is reversed, or there is no precalculation for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int one = matrix[i][j]; dp[i][j].setLU(one); if (i != m - 1 && one) dp[i][j].left = dp[i + 1 ][j].left + 1 ; if (j != n - 1 && one) dp[i][j].up = dp[i][j + 1 ].up + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } };","title":"Code"},{"location":"Interview/rectangle-2d-dp/#largest-x-of-1s","text":"Given a matrix that contains only 1s and 0s, find the largest X shape which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest X shape. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest X of 1s has arm length 2.","title":"Largest X Of 1s"},{"location":"Interview/rectangle-2d-dp/#analysis_1","text":"Same as the largest Cross of 1s, it calcualte the the presum for diagonal axis: 1. prefix sum from top left to i, j 2. prefix sum from top right to i, j 3. prefix sum from bottom left to i, j 4. prefix sum from bottom left to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle-2d-dp/#code_1","text":"class Solution { public : struct Node { int nw, ne, sw, se; void setN ( int val) { nw = ne = val; } void setS ( int val) { sw = se = val; } int minVal () { return min({nw, ne, sw, se}); } }; int largest (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].setN(val); if (val == 0 ) continue ; if (i != 0 && j != 0 ) dp[i][j].nw = dp[i - 1 ][j - 1 ].nw + 1 ; if (i != 0 && j != n - 1 ) dp[i][j].ne = dp[i - 1 ][j + 1 ].ne + 1 ; } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].setS(val); if (val == 0 ) continue ; if (i != m - 1 && j != 0 ) dp[i][j].sw = dp[i + 1 ][j - 1 ].sw + 1 ; if (i != m - 1 && j != n - 1 ) dp[i][j].se = dp[i + 1 ][j + 1 ].se + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } };","title":"Code"},{"location":"Interview/rectangle-2d-dp/#largest-square-surrounded-by-one","text":"Determine the largest square surrounded by 1s in a binary matrix (a binary matrix only contains 0 and 1), return the length of the largest square. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{1, 0, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 0, 1, 0}, {1, 1, 1, 1, 1}, {1, 1, 1, 0, 0}} The largest square surrounded by 1s has length of 3.","title":"Largest Square Surrounded By One"},{"location":"Interview/rectangle-2d-dp/#analysis_2","text":"Cannot just count the largest square that is all zero, because below case is also valid: 1111 \\ 1011 \\ 1111 \\ 1111 and the answer is 4. In order to find the largest submatrix, we need to determine the smallest \"stretching length\" for its width and height. To find the \"stretching\" width and height, we can use prefix sum to do so. After we maintained the two \"stretching length\", we should find the minimal and find the longest size of the submatrix. Time: O(m \\times n \\times max(m, n)) O(m \\times n \\times max(m, n)) Space: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle-2d-dp/#code_2","text":"class Solution { public : struct Node { int hor, ver; int minVal () { return min(hor, ver); } void set ( int val) { hor = ver = val; } }; int largestSquareSurroundedByOne (vector < vector < int >> matrix) { if (matrix.empty() || matrix[ 0 ].empty()) return 0 ; int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].set(val); if (val == 1 ) { if (i != 0 ) dp[i][j].ver = dp[i - 1 ][j].ver + 1 ; if (j != 0 ) dp[i][j].hor = dp[i][j - 1 ].hor + 1 ; } } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int small = dp[i][j].minVal(); while (small > res) { // horizonal grow requires vertial has the same stretching size, vice versa for vertial grow if (dp[i][j - small + 1 ].ver >= small && dp[i - small + 1 ][j].hor >= small) res = small; small -- ; } } } return res; } };","title":"Code"},{"location":"Interview/rectangle-2d-dp/#largest-square-of-matches","text":"Determine the largest square surrounded by a bunch of matches (each match is either horizontal or vertical), return the length of the largest square. The input is a matrix of points. Each point has one of the following values: 0 - there is no match to its right or bottom. 1 - there is a match to its right. 2 - there is a match to its bottom. 3 - there is a match to its right, and a match to its bottom. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{3, 1, 1, 3, 0, 1, 1, 0}, {2, 0, 0, 2, 0, 0, 0, 0}, {3, 1, 3, 0, 0, 0, 0, 0}, {2, 0, 2, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0}} This matrix represents the following bunch of matches: The largest square has length of 2.","title":"Largest Square Of Matches"},{"location":"Interview/rectangle-2d-dp/#analysis_3","text":"Use the same presum technique by defining two direction: left and top 1. if matrix[i][j] == 1 || matrix[i][j] == 3: dp[i][j].left = dp[i][j + 1].left + 1; 2. if matrix[i][j] == 2 || matrix[i][j] == 3: dp[i][j].top = dp[i + 1][j].top + 1; Note that it's [i][j + 1] and [i + 1][j] , which means we need to make sure the two locations have already populated, so we should going from bottom to top and right to left. Also note that the way to find largest submatrix is different from largest square surround by ones, because the direction of the presum is flipped. And the element stored is offset by 1, because the number represent the number of matches on its right or top, so we need to check one more. Time: O(m \\times n \\times max(n, m)) O(m \\times n \\times max(n, m)) Space: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle-2d-dp/#code_3","text":"class Solution { public : struct Node { int left, top; int minVal () { return min(left, top); } void set ( int val) { left = top = val; } }; int largestSquareOfMatches (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].set( 0 ); if ((val == 1 || val == 3 ) && j != n - 1 ) dp[i][j].left = dp[i][j + 1 ].left + 1 ; if ((val == 2 || val == 3 ) && i != m - 1 ) dp[i][j].top = dp[i + 1 ][j].top + 1 ; } } for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int small = dp[i][j].minVal(); while (small > res) { // j + small but not j + small - 1 if (dp[i][j + small].top >= small && dp[i + small][j].left >= small) res = small; small -- ; } } } return res; } };","title":"Code"},{"location":"Interview/rectangle-2d-dp/#largest-submatrix-sum","text":"Given a matrix that contains integers, find the submatrix with the largest sum. Return the sum of the submatrix. Assumptions The given matrix is not null and has size of M * N, where M >= 1 and N >= 1 Examples { {1, -2, -1, 4}, {1, -1, 1, 1}, {0, -1, -1, 1}, {0, 0, 1, 1} } the largest submatrix sum is (-1) + 4 + 1 + 1 + (-1) + 1 + 1 + 1 = 7.","title":"Largest SubMatrix Sum"},{"location":"Interview/rectangle-2d-dp/#analysis_4","text":"Imagine there are two horizon lines split the matrix into three parts: xxxx yyyy yyyy xxxx Your job is to find the maximum area sum generated by the two line (max y's sum). If we can compress the area between the two horizon lines, we can use the technique for finding the largest subarray sum to solve this problem. Time: O(n \\times n \\times m) O(n \\times n \\times m) or O(min(m, n)^2 \\times max(m, n)) O(min(m, n)^2 \\times max(m, n)) Space: because we just need one 1-d presum array: O(min(m, n)) O(min(m, n))","title":"Analysis"},{"location":"Interview/rectangle-2d-dp/#code_4","text":"class Solution { public : int largest(vector < vector < int >> matrix) { int res = matrix[ 0 ][ 0 ], m = matrix.size(), n = matrix[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { vector < int > preSum(n); // keep adding from i - j rows' sum for ( int j = i; j < m; ++ j) { for ( int k = 0 ; k < n; ++ k) preSum[k] += matrix[j][k]; int currMax = preSum[ 0 ]; for ( int k = 1 ; k < n; ++ k) { // find largest subarray currMax = max(currMax + preSum[k], preSum[k]); res = max(res, currMax); } } } return res; } };","title":"Code"},{"location":"Interview/recursion-tree/","text":"Recursion and Tree \u00b6 Is tree symmetric \u00b6 Recurison Tree \u00b6 Solution \u00b6 bool isSymmetric(left, right) if left == null and right == null return true else if left == null || right == null return false else if left.val != right.val return false else return isSymmetric(left.left, right.right) and isSymmetric(left.right, right.left) Time = O(n/2)=O(n) Calculate Time Complexity \u00b6 Branch Factor: b Height: h Total Complexity: b^h b^h","title":"Recursion and Tree"},{"location":"Interview/recursion-tree/#recursion-and-tree","text":"","title":"Recursion and Tree"},{"location":"Interview/recursion-tree/#is-tree-symmetric","text":"","title":"Is tree symmetric"},{"location":"Interview/recursion-tree/#recurison-tree","text":"","title":"Recurison Tree"},{"location":"Interview/recursion-tree/#solution","text":"bool isSymmetric(left, right) if left == null and right == null return true else if left == null || right == null return false else if left.val != right.val return false else return isSymmetric(left.left, right.right) and isSymmetric(left.right, right.left) Time = O(n/2)=O(n)","title":"Solution"},{"location":"Interview/recursion-tree/#calculate-time-complexity","text":"Branch Factor: b Height: h Total Complexity: b^h b^h","title":"Calculate Time Complexity"},{"location":"Interview/recursion/","text":"Recursion \u00b6 Fibonacci Sequence \u00b6 Clarification Assumption Result Test Time Complexity: total nodes of the recursion tree Space Complexity: call stack (typically equals to the height of the recursion tree) Naive Approach \u00b6 int fib ( int n) { if (n == 0 || n == 1 ) return n; return fib(n - 1 ) + fib(n - 2 ); } Time: 2^0+2^1+2^2...+2^n \\approx 2^n 2^0+2^1+2^2...+2^n \\approx 2^n Space: n pow(a, b) \u00b6 don't care the case for a == 0 or b < 0 for now Naive Approach \u00b6 int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b - 1 ) * a; } analysis \u00b6 recursion tree: 2^999 | 2^998 | 2^997 | 2^996 ... there are b nodes and the longest path is b Time: O(b) Space: O(b) Optimize Space \u00b6 int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b / 2 ) * pow(a, b - b / 2 ); // why not using b/2? because 3/2 = 1.5 = 1 } 2^999 | | 2^500 2^499 | | | | 250 250 250 249 ... there are 1 + 2 + 4 + ... 2^log(b) = b => time: O(b) Space: O(log(b))","title":"Recursion"},{"location":"Interview/recursion/#recursion","text":"","title":"Recursion"},{"location":"Interview/recursion/#fibonacci-sequence","text":"Clarification Assumption Result Test Time Complexity: total nodes of the recursion tree Space Complexity: call stack (typically equals to the height of the recursion tree)","title":"Fibonacci Sequence"},{"location":"Interview/recursion/#naive-approach","text":"int fib ( int n) { if (n == 0 || n == 1 ) return n; return fib(n - 1 ) + fib(n - 2 ); } Time: 2^0+2^1+2^2...+2^n \\approx 2^n 2^0+2^1+2^2...+2^n \\approx 2^n Space: n","title":"Naive Approach"},{"location":"Interview/recursion/#powa-b","text":"don't care the case for a == 0 or b < 0 for now","title":"pow(a, b)"},{"location":"Interview/recursion/#naive-approach_1","text":"int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b - 1 ) * a; }","title":"Naive Approach"},{"location":"Interview/recursion/#analysis","text":"recursion tree: 2^999 | 2^998 | 2^997 | 2^996 ... there are b nodes and the longest path is b Time: O(b) Space: O(b)","title":"analysis"},{"location":"Interview/recursion/#optimize-space","text":"int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b / 2 ) * pow(a, b - b / 2 ); // why not using b/2? because 3/2 = 1.5 = 1 } 2^999 | | 2^500 2^499 | | | | 250 250 250 249 ... there are 1 + 2 + 4 + ... 2^log(b) = b => time: O(b) Space: O(log(b))","title":"Optimize Space"},{"location":"Interview/russian-doll/","text":"Russian Doll \u00b6 Input: Method 1: DFS \u00b6 Try each envelope as starting point and stack all the other avaliable envelopes. Level 1: n Level 2: n * (n - 1) Level 3: n * (n - 1) * (n - 2) ... Level n: O(n!) O(n!) Space: O(n) O(n) Method 2: Sort + DFS \u00b6 Sort by width and run DFS once: skip all the nodes if already included in previous iteration Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result) Method 3: Sort + DP (longest increasing subsequence) \u00b6 sort by width height after sorted (1,1,3,2,2,4) -- assume using stable sort check LIS from the hight array find the first height to the left of the current height that is less than the current height this will take O(n) O(n) to find such element Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result) Solution \u00b6 Optimize DP (Space and Time) \u00b6 delete the previous one (M[i]) if array[i] > array[i+1] and M[i] <= M[i+1] But if already sorted from low to high -> space stays the same create an array for storing the lowest ending at current index Then use binary search with O(log_2{n}) O(log_2{n}) Time: O(n \\times log_2{n}) O(n \\times log_2{n}) Space: O(n) O(n) will be less than n since LIS might not be continuous Pitfall \u00b6 When sort: if width is the same, higher height sort first (same width cannot stack together) So we need to rewrite the comparator such that when two width are the same, choose the one with higher height Solution Code \u00b6 #include <bits/stdc++.h> using namespace std; int main () { int n; cin >> n; pair < int , int > env[n]; for ( int i = 0 ; i < n; ++ i) { cin >> env[i].first; cin >> env[i].second; } sort(env, env + n, []( const pair < int , int >& l, const pair < int , int >& r) { return l.first < r.first || (l.first == r.first && l.second > r.second); }); vector < int > dp; for ( auto p : env) { int longest = lower_bound(dp.begin(), dp.end(), p.second) - dp.begin(); if (longest >= dp.size()) dp.push_back(p.second); else dp[longest] = p.second; } cout << dp.size(); return 0 ; }","title":"Russian Doll"},{"location":"Interview/russian-doll/#russian-doll","text":"Input:","title":"Russian Doll"},{"location":"Interview/russian-doll/#method-1-dfs","text":"Try each envelope as starting point and stack all the other avaliable envelopes. Level 1: n Level 2: n * (n - 1) Level 3: n * (n - 1) * (n - 2) ... Level n: O(n!) O(n!) Space: O(n) O(n)","title":"Method 1: DFS"},{"location":"Interview/russian-doll/#method-2-sort-dfs","text":"Sort by width and run DFS once: skip all the nodes if already included in previous iteration Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result)","title":"Method 2: Sort + DFS"},{"location":"Interview/russian-doll/#method-3-sort-dp-longest-increasing-subsequence","text":"sort by width height after sorted (1,1,3,2,2,4) -- assume using stable sort check LIS from the hight array find the first height to the left of the current height that is less than the current height this will take O(n) O(n) to find such element Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result)","title":"Method 3: Sort + DP (longest increasing subsequence)"},{"location":"Interview/russian-doll/#solution","text":"","title":"Solution"},{"location":"Interview/russian-doll/#optimize-dp-space-and-time","text":"delete the previous one (M[i]) if array[i] > array[i+1] and M[i] <= M[i+1] But if already sorted from low to high -> space stays the same create an array for storing the lowest ending at current index Then use binary search with O(log_2{n}) O(log_2{n}) Time: O(n \\times log_2{n}) O(n \\times log_2{n}) Space: O(n) O(n) will be less than n since LIS might not be continuous","title":"Optimize DP (Space and Time)"},{"location":"Interview/russian-doll/#pitfall","text":"When sort: if width is the same, higher height sort first (same width cannot stack together) So we need to rewrite the comparator such that when two width are the same, choose the one with higher height","title":"Pitfall"},{"location":"Interview/russian-doll/#solution-code","text":"#include <bits/stdc++.h> using namespace std; int main () { int n; cin >> n; pair < int , int > env[n]; for ( int i = 0 ; i < n; ++ i) { cin >> env[i].first; cin >> env[i].second; } sort(env, env + n, []( const pair < int , int >& l, const pair < int , int >& r) { return l.first < r.first || (l.first == r.first && l.second > r.second); }); vector < int > dp; for ( auto p : env) { int longest = lower_bound(dp.begin(), dp.end(), p.second) - dp.begin(); if (longest >= dp.size()) dp.push_back(p.second); else dp[longest] = p.second; } cout << dp.size(); return 0 ; }","title":"Solution Code"},{"location":"Interview/search-in-bitonic-array/","text":"Searcg in Bitonic Array \u00b6 Search for a target number in a bitonic array, return the index of the target number if found in the array, or return -1. A bitonic array is a combination of two sequence: the first sequence is a monotonically increasing one and the second sequence is a monotonically decreasing one. Assumptions: The array is not null. Examples: array = {1, 4, 7, 11, 6, 2, -3, -8}, target = 2, return 5. Analysis \u00b6 Use arr[m] and arr[m - 1] to find the order of the array for l ~ m or m ~ r if m > m - 1: l ~ m is in increasing order if target is greater than m, then search the (m, r] else: search in l ~ m in increasing order if m <= m - 1: m ~ r is in decreasing order if target is greater than m, then search the [l, m) else: search in m ~ r in decreasing order Depending on the order, change according for the binary search function Code \u00b6 class Solution { public : int bsearch(vector < int > a, int target, int l, int r) { bool dir = a[l] <= a[r]; while (l < r) { int m = (l + 0l l + r) >> 1 ; if (target == a[m]) return m; else if (target < a[m]) dir ? r = m : l = m + 1 ; else dir ? l = m + 1 : r = m; } return -1 ; } int search(vector < int > a, int target) { // write your solution here int n = a.size(); int l = 0 , r = n - 1 ; while (l < r) { int m = (l + 0l l + r) >> 1 ; if (target == a[m]) return m; if (a[m] > a[m - 1 ]) { // increasing from l to m if (target > a[m]) // m-1 < m < target l = m + 1 ; else { int res; if ((res = bsearch(a, target, l, m)) != -1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != -1 ) // m + 1 <= target <= r return res; else return -1 ; } } else { // decreasing from m - 1 to r if (target > a[m]) // target > m > m - 1 r = m; else { int res; if ((res = bsearch(a, target, l, m)) != -1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != -1 ) // m + 1 >= target >= r return res; else return -1 ; } } } return -1 ; } };","title":"Searcg in Bitonic Array"},{"location":"Interview/search-in-bitonic-array/#searcg-in-bitonic-array","text":"Search for a target number in a bitonic array, return the index of the target number if found in the array, or return -1. A bitonic array is a combination of two sequence: the first sequence is a monotonically increasing one and the second sequence is a monotonically decreasing one. Assumptions: The array is not null. Examples: array = {1, 4, 7, 11, 6, 2, -3, -8}, target = 2, return 5.","title":"Searcg in Bitonic Array"},{"location":"Interview/search-in-bitonic-array/#analysis","text":"Use arr[m] and arr[m - 1] to find the order of the array for l ~ m or m ~ r if m > m - 1: l ~ m is in increasing order if target is greater than m, then search the (m, r] else: search in l ~ m in increasing order if m <= m - 1: m ~ r is in decreasing order if target is greater than m, then search the [l, m) else: search in m ~ r in decreasing order Depending on the order, change according for the binary search function","title":"Analysis"},{"location":"Interview/search-in-bitonic-array/#code","text":"class Solution { public : int bsearch(vector < int > a, int target, int l, int r) { bool dir = a[l] <= a[r]; while (l < r) { int m = (l + 0l l + r) >> 1 ; if (target == a[m]) return m; else if (target < a[m]) dir ? r = m : l = m + 1 ; else dir ? l = m + 1 : r = m; } return -1 ; } int search(vector < int > a, int target) { // write your solution here int n = a.size(); int l = 0 , r = n - 1 ; while (l < r) { int m = (l + 0l l + r) >> 1 ; if (target == a[m]) return m; if (a[m] > a[m - 1 ]) { // increasing from l to m if (target > a[m]) // m-1 < m < target l = m + 1 ; else { int res; if ((res = bsearch(a, target, l, m)) != -1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != -1 ) // m + 1 <= target <= r return res; else return -1 ; } } else { // decreasing from m - 1 to r if (target > a[m]) // target > m > m - 1 r = m; else { int res; if ((res = bsearch(a, target, l, m)) != -1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != -1 ) // m + 1 >= target >= r return res; else return -1 ; } } } return -1 ; } };","title":"Code"},{"location":"Interview/serializing-and-deserializing/","text":"Serializing and Deserializing a tree \u00b6 Can do in-order + pre-order, in-order + post-porder, but cannot do pre-order + post-order Given a binary tree, flatten it to a linkedlist in-place \u00b6 Using DFS \u00b6 Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * prev; void flatten (TreeNode * root) { if ( ! root) return ; flatten (root -> right); flatten (root -> left); root -> right = prev; root -> left = NULL ; prev = root; } }; Using iterative \u00b6 https://www.acwing.com/video/1469/ if left subtree exists, then insert right children of left subtree to the current root's right. if left subtree doesn't exist, visit right subtree of current root, insert left subtree to current root's right. Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void flatten(TreeNode * root) { while (root) { TreeNode * p = root -> left; if (p) { while (p -> right) { p = p -> right; } p -> right = root -> right; root -> right = root -> left; root -> left = nullptr; } root = root -> right; } } }; Given a binary tree, flatten it to a doubly linkedlist \u00b6 Code \u00b6 TreeNode * helper (Treenode * root, TreeNode * prev, TreeNode * head) { if ( ! root) return ; helper(root -> left, prev, head); if ( ! pre) head = root; else { root -> left = prev; prev -> right = root; } prev = root; helper(root -> right, prev, head); } TreeNode * flatten (TreeNode * root) { helper(root, prev, head); return head; }","title":"Serializing and Deserializing a tree"},{"location":"Interview/serializing-and-deserializing/#serializing-and-deserializing-a-tree","text":"Can do in-order + pre-order, in-order + post-porder, but cannot do pre-order + post-order","title":"Serializing and Deserializing a tree"},{"location":"Interview/serializing-and-deserializing/#given-a-binary-tree-flatten-it-to-a-linkedlist-in-place","text":"","title":"Given a binary tree, flatten it to a linkedlist in-place"},{"location":"Interview/serializing-and-deserializing/#using-dfs","text":"","title":"Using DFS"},{"location":"Interview/serializing-and-deserializing/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * prev; void flatten (TreeNode * root) { if ( ! root) return ; flatten (root -> right); flatten (root -> left); root -> right = prev; root -> left = NULL ; prev = root; } };","title":"Code"},{"location":"Interview/serializing-and-deserializing/#using-iterative","text":"https://www.acwing.com/video/1469/ if left subtree exists, then insert right children of left subtree to the current root's right. if left subtree doesn't exist, visit right subtree of current root, insert left subtree to current root's right.","title":"Using iterative"},{"location":"Interview/serializing-and-deserializing/#code_1","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void flatten(TreeNode * root) { while (root) { TreeNode * p = root -> left; if (p) { while (p -> right) { p = p -> right; } p -> right = root -> right; root -> right = root -> left; root -> left = nullptr; } root = root -> right; } } };","title":"Code"},{"location":"Interview/serializing-and-deserializing/#given-a-binary-tree-flatten-it-to-a-doubly-linkedlist","text":"","title":"Given a binary tree, flatten it to a doubly linkedlist"},{"location":"Interview/serializing-and-deserializing/#code_2","text":"TreeNode * helper (Treenode * root, TreeNode * prev, TreeNode * head) { if ( ! root) return ; helper(root -> left, prev, head); if ( ! pre) head = root; else { root -> left = prev; prev -> right = root; } prev = root; helper(root -> right, prev, head); } TreeNode * flatten (TreeNode * root) { helper(root, prev, head); return head; }","title":"Code"},{"location":"Interview/singleton/","text":"Singleton \u00b6 Definition \u00b6 in the entire life cycles, there is only one object being created and used. so that a class should not provide an explict contructor for user AND the instance itself is private static there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code Lazy vs Eager initialization: create upon call or avaliable all the time. Below example is lazy initialization. Depending on use case. /* * C++ Design Patterns: Singleton * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Singleton * has private static variable to hold one instance of the class * and method which gives us a way to instantiate the class */ class Singleton { public : // The copy constructor and assignment operator // are defined as deleted, which means that you // can't make a copy of singleton. // // Note: you can achieve the same effect by declaring // the constructor and the operator as private Singleton( Singleton const & ) = delete; Singleton & operator = ( Singleton const & ) = delete; static Singleton * get() { if ( ! instance ) { instance = new Singleton(); } return instance; } static void restart() { if ( instance ) { delete instance; } } void tell() { std :: cout << \"This is Singleton.\" << std :: endl; // ... } // ... private : Singleton() {} static Singleton * instance; // ... }; Singleton * Singleton :: instance = nullptr; int main () { Singleton :: get() -> tell(); Singleton :: restart(); return 0 ; }","title":"Singleton"},{"location":"Interview/singleton/#singleton","text":"","title":"Singleton"},{"location":"Interview/singleton/#definition","text":"in the entire life cycles, there is only one object being created and used. so that a class should not provide an explict contructor for user AND the instance itself is private static there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code Lazy vs Eager initialization: create upon call or avaliable all the time. Below example is lazy initialization. Depending on use case. /* * C++ Design Patterns: Singleton * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Singleton * has private static variable to hold one instance of the class * and method which gives us a way to instantiate the class */ class Singleton { public : // The copy constructor and assignment operator // are defined as deleted, which means that you // can't make a copy of singleton. // // Note: you can achieve the same effect by declaring // the constructor and the operator as private Singleton( Singleton const & ) = delete; Singleton & operator = ( Singleton const & ) = delete; static Singleton * get() { if ( ! instance ) { instance = new Singleton(); } return instance; } static void restart() { if ( instance ) { delete instance; } } void tell() { std :: cout << \"This is Singleton.\" << std :: endl; // ... } // ... private : Singleton() {} static Singleton * instance; // ... }; Singleton * Singleton :: instance = nullptr; int main () { Singleton :: get() -> tell(); Singleton :: restart(); return 0 ; }","title":"Definition"},{"location":"Interview/sorting-algorithms/","text":"Sorting Algorithms \u00b6 Overview \u00b6 Selection Sort \u00b6 arr[] = 64 25 12 22 11 // Find the minimum element in arr[0...4] // and place it at beginning 11 25 12 22 64 // Find the minimum element in arr[1...4] // and place it at beginning of arr[1...4] 11 12 25 22 64 // Find the minimum element in arr[2...4] // and place it at beginning of arr[2...4] 11 12 22 25 64 // Find the minimum element in arr[3...4] // and place it at beginning of arr[3...4] 11 12 22 25 64 /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length /* advance the position through the entire array */ /* (could do i < aLength-1 because single element is also min element) */ for (i = 0 ; i < aLength -1 ; i ++ ) { /* find the min element in the unsorted a[i .. aLength-1] */ /* assume the min is the first element */ int jMin = i; /* test against elements after i to find the smallest */ for (j = i +1 ; j < aLength; j ++ ) { /* if this element is less, then it is the new minimum */ if (a[j] < a[jMin]) { /* found new minimum; remember its index */ jMin = j; } } if (jMin != i) { swap(a[i], a[jMin]); } } Complexity \u00b6 O(\\frac{(n-1)+1}{2} \\times (n-1)) O(\\frac{(n-1)+1}{2} \\times (n-1)) = O(n^2) O(n^2) -- no matter if is pre-sorted or not Q1: sort with stacks \u00b6 sort with two stacks: #include <bits/stdc++.h> using namespace std; int main () { int n; cin >> n; int num[n]; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; stack < int > s1, s2; // s1: buffer; s2: sorted array in ascending order for ( int i : num) s1.push(i); while ( ! s1.empty()) { int curr = s1.top(); s1.pop(); int cnt = 0 ; /* s1: C s2: LLL */ // remove everything that is less than curr in the buffer while ( ! s2.empty() && s2.top() < curr) { s1.push(s2.top()); s2.pop(); ++ cnt; } s2.push(curr); /* s1: LLL s2: C */ // move back for ( int i = 0 ; i < cnt; ++ i) { s2.push(s1.top()); s1.pop(); } /* s1: s2: CLLL */ } while ( ! s2.empty()) { cout << s2.top() << \" \" ; s2.pop(); } return 0 ; } counter: count number of element that is less than current top. 1. compare sorted.top() with item, pop all the elements back to the input stack that are greater than item 2. push the item to the sorted top 3. using the counter to determine when to stop when pushing the pop the input stack Here input stack's top (from top to top + counter) works as the buffer Insertion Sort \u00b6 for ( int i = 0 ; i < A.size(); ++ i) { for ( int j = i; j > 0 && A[j - 1 ] > A[j]; -- j) { // can terminate early if unsatisfy swap(A[j], A[j - 1 ]); } } 1, 4, 7, 11, 6, 2, -3, -8 1... 1, 4... 1, 4, 7... 1, 4, 7, 11... 1, 4, 6, 7, 11... 1, 2, 4, 6, 7, 11... -3, 1, 2, 4, 6, 11... -8, -3, 1, 2, 4, 6, 11 if the origional array is pre-sorted, then the complexity is O(n) O(n) , if not, it will be O(n^2) O(n^2) Counting Sort \u00b6 A[] original array to be sorted B[] sorted array from less to greater C[] is pre-sum for counting the frequency of each element (element is the index) on line 11, it keep \"filling\" the element from right to the left (greater to less) to B[]. initial \u00b6 after pre-sum \u00b6 Complexity \u00b6 Time: O(n) O(n) , Space: O(|max - min|) O(|max - min|) Merge Sort: stable \u00b6 int tmp[ 1010 ]; void merge_sort (vector < int >& q, int l, int r) { if (l >= r) return ; int mid = (l + r) >> 1 ; merge_sort(q, l, mid); merge_sort(q, mid + 1 , r); int k = 0 , i = l, j = mid + 1 ; while (i <= mid && j <= r) { // two pointers if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; } while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0 ; i <= r; i ++ , j ++ ) q[i] = tmp[j]; } vector < int > mergeSort(vector < int > array) { // write your solution here vector < int > res = array; merge_sort(res, 0 , array.size() - 1 ); return res; } Use merge sort to find Inversion Count \u00b6 Inversion Count: a_i > a_j a_i > a_j and i < j i < j , to do so, just uncomment line 12. Complexity \u00b6 space: - call stack: O(log(n)) O(log(n)) - heap: O(n) O(n) Q1: \u00b6 Quick Sort: not stable \u00b6 class Solution { public : void quick_sort(vector < int >& q, int l, int r) { if (l >= r) return ; // pivot at mid int i = l - 1 , j = r + 1 , x = q[(l + r) >> 1 ]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1 , r); } vector < int > quickSort(vector < int > array) { // write your solution here quick_sort(array, 0 , array.size() - 1 ); return array; } }; Quick select: select kth element \u00b6 Differ from Merge Sort, Quick sort first split array into two half where the values on the left of x are less than x and values on the right of x are equal or greater than x. Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N]; int quick_select ( int l, int r, int k) { if (l == r) return num[l]; int i = l - 1 , j = r + 1 , x = num[(l + r) >> 1 ]; while (i < j) { while (num[ ++ i] < x) ; while (num[ -- j] > x) ; if (i < j) swap(num[i], num[j]); } int offset = j - l + 1 ; if (k <= offset) return quick_select(l, j, k); return quick_select(j + 1 , r, k - offset); } int main () { int n, k; cin >> n >> k; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; cout << quick_select( 0 , n - 1 , k); return 0 ; } Auxiliary Space : Mergesort uses extra space , quicksort requires little space and exhibits good cache locality. Quick sort is an in-place sorting algorithm. In-place sorting means no additional storage space is needed to perform sorting. Merge sort requires a temporary array to merge the sorted arrays and hence it is not in-place giving Quick sort the advantage of space. Worst Cases : The worst case of quicksort O(n^2) O(n^2) can be avoided by using randomized quicksort . It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort. Locality of reference : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment. Merge sort is better for large data structures : Mergesort is a stable sort , unlike quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Best time complexity: O(n \\log n) O(n \\log n) , Worst: O(n^2) O(n^2) . It works great in small size array, and for large size array it's better to use merge sort. Q1: moving zeros \u00b6 Move 0s to the right end of the array. ref: https://leetcode.com/problems/move-zeroes/ // Method 1: use two pointer and cannot keep the relative order void moveZeros (vector < int >& arr) { if (arr.size() <= 1 ) return arr; int l = 0 , r = arr.size() - 1 ; while (l <= r) { if (arr[l] != 0 ) l ++ ; else if (arr[r] == 0 ) r -- ; else swap(arr[l ++ ], arr[r -- ]); } } // Method 2: use two pointers while maintaining the order void moveZeroes (vector < int >& nums) { for ( int i = 0 , j = 0 ; i < nums.size(); ++ i) { if (nums[i]) { swap(nums[j ++ ], nums[i]); } } } Q2: rainbow sort \u00b6 sort the array by three color (a,b,c represent three colors). e.g. given [a,b,a,a,a,c,b,a] -> [a,a,a,a,a,b,b,c] i): all elements to the left of arr[i] are a [i-j): all elements between arr[i] ~ arr[j] are b [j-k]: all elements between arr[j] ~ arr[k] are unexplored range [k: all elements to the right of arr[k] are c if arr[j] == a: swap(arr[i++], arr[j++]) // i++ because i~j are b, and after sway, arr[i] is a if arr[j] == b: j++ if arr[j] == c: swap(arr[j], arr[k--]) // don't need to j++ becasue arr[j] is unknown void rainbowSort (vector < char >& arr) { if (arr.size() <= 1 ) return ; int i = 0 , j = 0 , k = arr.size() - 1 ; while (j <= k) { if (arr[j] == 'a' ) swap(arr[i ++ ], arr[j ++ ]); else if (arr[j] == 'b' ) j ++ ; else swap(arr[j], arr[k -- ]); } } Q3: sort four color \u00b6 [aaa i0) [bbb i1) [ccc i2) [dddd i3) XXXX a=0,b=1,c=2,d=3 i0): all elements to the left of arr[i0] are a [i0-i1): all elements between arr[i0] ~ arr[i1] are b [i1-i2): all elements between arr[i1] ~ arr[i2] are c [i2-i3): all elements between arr[i2] ~ arr[i3] are d [i3: all elements to the right of arr[i3] are unexplored range if arr[i3] == d: i3++ if arr[i3] == c: swap(arr[i3++], arr[i2++]) if arr[i3] == b: swap(arr[i3++], arr[i2++]), swap(arr[i1++, i2]) if arr[i3] == a: swap(arr[i3++], arr[i2++]), swap(arr[i1++], arr[i2]) , swap(arr[i0++], arr[i1]) public int [] rainbowSortII ( int [] array) { // Write your solution here int i0 = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; while (i3 < array. length ) { if (array [ i3 ] == 3 ) { i3 ++ ; } else if (array [ i3 ] == 2 ) { swap(array, i2, i3); i2 ++ ; i3 ++ ; } else if (array [ i3 ] == 1 ) { swap(array, i2, i3); swap(array, i1, i2); i1 ++ ; i2 ++ ; i3 ++ ; } else { swap(array, i2, i3); swap(array, i1, i2); swap(array, i0, i1); i0 ++ ; i1 ++ ; i2 ++ ; i3 ++ ; } } return array; } Q4: What about k color? \u00b6 use counting sort, sort in linear time! class Solution { public : vector < int > rainbowSortIII (vector < int > a, int k) { vector < int > cnt (k + 1 ); // accumulate cnt of each element (from 0 - k) int n = a. size (); for ( int i = 0 ; i < n; ++ i) cnt [ a [ i ]]++ ; for ( int i = 1 ; i <= k; ++ i) cnt [ i ] = cnt [ i ] + cnt [ i - 1] ; vector < int > res (n); for ( int i = n - 1 ; i >= 0 ; -- i) { res [ cnt [ a [ i ]] - 1] = a [ i ] ; cnt [ a [ i ]]-- ; } return res; } }; \u590d\u6742\u5ea6\u5206\u6790 \u00b6 \u65f6\u95f4\uff1a O(n) O(n) \u7a7a\u95f4\uff1a O(n) O(n) <- this is not a in-place algorithm \u5206\u6790 \u00b6 \u5982\u679c\u6709k\u4e2acolor\uff0c\u90a3\u4e48\u5982\u679c\u60f3\u8981\u77e5\u9053\u6bcf\u4e2acolor\u5e94\u8be5\u653e\u5728\u54ea\u91cc\u9700\u8981\u77e5\u9053\u4ee5\u4e0b\u4fe1\u606f\uff1a 1. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e 2. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u4e2a\u6570 \u8fd9\u4e24\u4e2a\u4fe1\u606f\u867d\u7136\u770b\u4f3c\u6ca1\u6709\u5173\u8054\u5b9e\u9645\u4e0a\u662f\uff1a\u5f53\u77e5\u9053\u6240\u6709\u5728\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272 \u6bcf\u4e2a\u4e2a\u6570\u4e4b\u540e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\u3002\u90a3\u4e48\u5c31\u662f\u8981\u5904\u7406\u5982\u4f55\u77e5\u9053\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u6240\u6709\u989c\u8272 \u4e2a\u6570\u3002 \u8fd9\u91cc\u5c31\u53ef\u4ee5\u60f3\u5230accumulate list\u6216\u8005pre sum list\u6765\u5904\u7406\u3002 for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; \u8fd9\u4e24\u884c\u505a\u7684\u4e8b\u60c5\u5206\u522b\u662f\u627e\u5230\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u91cf\uff0c\u7136\u540e\u8ba1\u7b97presum\uff0c\u8fd9\u91cc\u7684presum\u4fbf\u662f\u4e0a\u9762\u8bf4\u7684 \u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272*\u6bcf\u4e2a\u4e2a\u6570 \u3002\u5f53\u77e5\u9053\u4e86\u8fd9\u4e24\u4e2a\u4fe1\u606f\u4e4b\u540e\u4fbf\u53ef\u4ee5\u628a\u4ed6\u4eec\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230sort\u597d\u7684res\u6570\u7ec4\u4e86\u3002 for ( int i = n - 1 ; i >= 0 ; -- i) { res[cnt[a[i]] - 1 ] = a[i]; cnt[a[i]] -- ; } \u6ce8\u610f\uff1a\u6bcf\u6b21\u904d\u5386\u7684\u65f6\u5019\u9700\u8981\u66f4\u65b0cnt(cnt --)\uff0c\u540c\u65f6\u56e0\u4e3a\u6570\u7ec4\u662f0 base\uff0c\u4f46\u662f\u989c\u8272\u662f\u4ece[1\uff5ek]\uff0c\u6240\u4ee5\u6bcf\u6b21res\u7684index\u8981-1. \u5982\u4f55\u89e3\u51b3\u975e\u6570\u5b57\u95ee\u9898 \u00b6 \u5047\u5982\u989c\u8272\u4e0d\u662f1\uff5ek\u7684\u6570\u5b57\uff0c\u90a3\u4e48\u4e3a\u4e86\u8ba1\u7b97presum\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u67d0\u79cd\u65b9\u6cd5\u6765\u77e5\u9053\u6bcf\u4e24\u4e2a\u5143\u7d20\u7684\u76f8\u5bf9\u4f4d\u7f6e\uff1a \u5047\u8bbeobjA < objB\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a unordered_map<Obj, int> mapping \u6765\u4e3a\u6bcf\u4e2a\u5143\u7d20\u8d4b\u503c\u3002\u5373\uff1a for ( int i = 0 ; i < n; ++ i) cnt[mapping[a[i]]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; In-place sort: space O(k), time O(n) \u00b6 vector < int > rainbowSortIII(vector < int > a, int k) { vector < int > cnt(k + 1 ); // cnt of each element (from 0 - k) int n = a.size(); for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 , idx = 0 ; i <= k; ++ i) { while (cnt[i] != 0 ) { a[idx ++ ] = i; cnt[i] -- ; } } return a; } Q5: reorder the array \u00b6 An array contains both pos and neg numbers in random order. Order the array elements so that pos and neg are placed alternatively. If there are more pos they appear at the end of the array. If there are more neg, they also appear at the end of the array. e.g. input: [1,2,3,4,5,-1,-1,-1], output: [1,-1,2,-1,3,-1,4,5] (the ordering of pos/neg number doesn't matter) Analysis \u00b6 Use quick sort's partition to split the array into two half, then put them back to the new array alternatively Code \u00b6 #include <bits/stdc++.h> using namespace std; #define N 1010 int nums[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; int x = 0 , l = 0 , r = n - 1 ; while (l < r) { while (nums[ ++ l] > x); while (nums[ -- r] < x); if (l < r) swap(nums[l], nums[r]); } cout << nums[l] << \" \" << nums[r] << endl; int res[n]; memset(res, -1 , sizeof res); int idx = 0 ; for ( int i = 0 ; idx <= r; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i = 1 ; idx < n; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Sorting Algorithms"},{"location":"Interview/sorting-algorithms/#sorting-algorithms","text":"","title":"Sorting Algorithms"},{"location":"Interview/sorting-algorithms/#overview","text":"","title":"Overview"},{"location":"Interview/sorting-algorithms/#selection-sort","text":"arr[] = 64 25 12 22 11 // Find the minimum element in arr[0...4] // and place it at beginning 11 25 12 22 64 // Find the minimum element in arr[1...4] // and place it at beginning of arr[1...4] 11 12 25 22 64 // Find the minimum element in arr[2...4] // and place it at beginning of arr[2...4] 11 12 22 25 64 // Find the minimum element in arr[3...4] // and place it at beginning of arr[3...4] 11 12 22 25 64 /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length /* advance the position through the entire array */ /* (could do i < aLength-1 because single element is also min element) */ for (i = 0 ; i < aLength -1 ; i ++ ) { /* find the min element in the unsorted a[i .. aLength-1] */ /* assume the min is the first element */ int jMin = i; /* test against elements after i to find the smallest */ for (j = i +1 ; j < aLength; j ++ ) { /* if this element is less, then it is the new minimum */ if (a[j] < a[jMin]) { /* found new minimum; remember its index */ jMin = j; } } if (jMin != i) { swap(a[i], a[jMin]); } }","title":"Selection Sort"},{"location":"Interview/sorting-algorithms/#complexity","text":"O(\\frac{(n-1)+1}{2} \\times (n-1)) O(\\frac{(n-1)+1}{2} \\times (n-1)) = O(n^2) O(n^2) -- no matter if is pre-sorted or not","title":"Complexity"},{"location":"Interview/sorting-algorithms/#q1-sort-with-stacks","text":"sort with two stacks: #include <bits/stdc++.h> using namespace std; int main () { int n; cin >> n; int num[n]; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; stack < int > s1, s2; // s1: buffer; s2: sorted array in ascending order for ( int i : num) s1.push(i); while ( ! s1.empty()) { int curr = s1.top(); s1.pop(); int cnt = 0 ; /* s1: C s2: LLL */ // remove everything that is less than curr in the buffer while ( ! s2.empty() && s2.top() < curr) { s1.push(s2.top()); s2.pop(); ++ cnt; } s2.push(curr); /* s1: LLL s2: C */ // move back for ( int i = 0 ; i < cnt; ++ i) { s2.push(s1.top()); s1.pop(); } /* s1: s2: CLLL */ } while ( ! s2.empty()) { cout << s2.top() << \" \" ; s2.pop(); } return 0 ; } counter: count number of element that is less than current top. 1. compare sorted.top() with item, pop all the elements back to the input stack that are greater than item 2. push the item to the sorted top 3. using the counter to determine when to stop when pushing the pop the input stack Here input stack's top (from top to top + counter) works as the buffer","title":"Q1: sort with stacks"},{"location":"Interview/sorting-algorithms/#insertion-sort","text":"for ( int i = 0 ; i < A.size(); ++ i) { for ( int j = i; j > 0 && A[j - 1 ] > A[j]; -- j) { // can terminate early if unsatisfy swap(A[j], A[j - 1 ]); } } 1, 4, 7, 11, 6, 2, -3, -8 1... 1, 4... 1, 4, 7... 1, 4, 7, 11... 1, 4, 6, 7, 11... 1, 2, 4, 6, 7, 11... -3, 1, 2, 4, 6, 11... -8, -3, 1, 2, 4, 6, 11 if the origional array is pre-sorted, then the complexity is O(n) O(n) , if not, it will be O(n^2) O(n^2)","title":"Insertion Sort"},{"location":"Interview/sorting-algorithms/#counting-sort","text":"A[] original array to be sorted B[] sorted array from less to greater C[] is pre-sum for counting the frequency of each element (element is the index) on line 11, it keep \"filling\" the element from right to the left (greater to less) to B[].","title":"Counting Sort"},{"location":"Interview/sorting-algorithms/#initial","text":"","title":"initial"},{"location":"Interview/sorting-algorithms/#after-pre-sum","text":"","title":"after pre-sum"},{"location":"Interview/sorting-algorithms/#complexity_1","text":"Time: O(n) O(n) , Space: O(|max - min|) O(|max - min|)","title":"Complexity"},{"location":"Interview/sorting-algorithms/#merge-sort-stable","text":"int tmp[ 1010 ]; void merge_sort (vector < int >& q, int l, int r) { if (l >= r) return ; int mid = (l + r) >> 1 ; merge_sort(q, l, mid); merge_sort(q, mid + 1 , r); int k = 0 , i = l, j = mid + 1 ; while (i <= mid && j <= r) { // two pointers if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; } while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0 ; i <= r; i ++ , j ++ ) q[i] = tmp[j]; } vector < int > mergeSort(vector < int > array) { // write your solution here vector < int > res = array; merge_sort(res, 0 , array.size() - 1 ); return res; }","title":"Merge Sort: stable"},{"location":"Interview/sorting-algorithms/#use-merge-sort-to-find-inversion-count","text":"Inversion Count: a_i > a_j a_i > a_j and i < j i < j , to do so, just uncomment line 12.","title":"Use merge sort to find Inversion Count"},{"location":"Interview/sorting-algorithms/#complexity_2","text":"space: - call stack: O(log(n)) O(log(n)) - heap: O(n) O(n)","title":"Complexity"},{"location":"Interview/sorting-algorithms/#q1","text":"","title":"Q1:"},{"location":"Interview/sorting-algorithms/#quick-sort-not-stable","text":"class Solution { public : void quick_sort(vector < int >& q, int l, int r) { if (l >= r) return ; // pivot at mid int i = l - 1 , j = r + 1 , x = q[(l + r) >> 1 ]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1 , r); } vector < int > quickSort(vector < int > array) { // write your solution here quick_sort(array, 0 , array.size() - 1 ); return array; } };","title":"Quick Sort: not stable"},{"location":"Interview/sorting-algorithms/#quick-select-select-kth-element","text":"Differ from Merge Sort, Quick sort first split array into two half where the values on the left of x are less than x and values on the right of x are equal or greater than x.","title":"Quick select: select kth element"},{"location":"Interview/sorting-algorithms/#code","text":"#include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N]; int quick_select ( int l, int r, int k) { if (l == r) return num[l]; int i = l - 1 , j = r + 1 , x = num[(l + r) >> 1 ]; while (i < j) { while (num[ ++ i] < x) ; while (num[ -- j] > x) ; if (i < j) swap(num[i], num[j]); } int offset = j - l + 1 ; if (k <= offset) return quick_select(l, j, k); return quick_select(j + 1 , r, k - offset); } int main () { int n, k; cin >> n >> k; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; cout << quick_select( 0 , n - 1 , k); return 0 ; } Auxiliary Space : Mergesort uses extra space , quicksort requires little space and exhibits good cache locality. Quick sort is an in-place sorting algorithm. In-place sorting means no additional storage space is needed to perform sorting. Merge sort requires a temporary array to merge the sorted arrays and hence it is not in-place giving Quick sort the advantage of space. Worst Cases : The worst case of quicksort O(n^2) O(n^2) can be avoided by using randomized quicksort . It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort. Locality of reference : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment. Merge sort is better for large data structures : Mergesort is a stable sort , unlike quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Best time complexity: O(n \\log n) O(n \\log n) , Worst: O(n^2) O(n^2) . It works great in small size array, and for large size array it's better to use merge sort.","title":"Code"},{"location":"Interview/sorting-algorithms/#q1-moving-zeros","text":"Move 0s to the right end of the array. ref: https://leetcode.com/problems/move-zeroes/ // Method 1: use two pointer and cannot keep the relative order void moveZeros (vector < int >& arr) { if (arr.size() <= 1 ) return arr; int l = 0 , r = arr.size() - 1 ; while (l <= r) { if (arr[l] != 0 ) l ++ ; else if (arr[r] == 0 ) r -- ; else swap(arr[l ++ ], arr[r -- ]); } } // Method 2: use two pointers while maintaining the order void moveZeroes (vector < int >& nums) { for ( int i = 0 , j = 0 ; i < nums.size(); ++ i) { if (nums[i]) { swap(nums[j ++ ], nums[i]); } } }","title":"Q1: moving zeros"},{"location":"Interview/sorting-algorithms/#q2-rainbow-sort","text":"sort the array by three color (a,b,c represent three colors). e.g. given [a,b,a,a,a,c,b,a] -> [a,a,a,a,a,b,b,c] i): all elements to the left of arr[i] are a [i-j): all elements between arr[i] ~ arr[j] are b [j-k]: all elements between arr[j] ~ arr[k] are unexplored range [k: all elements to the right of arr[k] are c if arr[j] == a: swap(arr[i++], arr[j++]) // i++ because i~j are b, and after sway, arr[i] is a if arr[j] == b: j++ if arr[j] == c: swap(arr[j], arr[k--]) // don't need to j++ becasue arr[j] is unknown void rainbowSort (vector < char >& arr) { if (arr.size() <= 1 ) return ; int i = 0 , j = 0 , k = arr.size() - 1 ; while (j <= k) { if (arr[j] == 'a' ) swap(arr[i ++ ], arr[j ++ ]); else if (arr[j] == 'b' ) j ++ ; else swap(arr[j], arr[k -- ]); } }","title":"Q2: rainbow sort"},{"location":"Interview/sorting-algorithms/#q3-sort-four-color","text":"[aaa i0) [bbb i1) [ccc i2) [dddd i3) XXXX a=0,b=1,c=2,d=3 i0): all elements to the left of arr[i0] are a [i0-i1): all elements between arr[i0] ~ arr[i1] are b [i1-i2): all elements between arr[i1] ~ arr[i2] are c [i2-i3): all elements between arr[i2] ~ arr[i3] are d [i3: all elements to the right of arr[i3] are unexplored range if arr[i3] == d: i3++ if arr[i3] == c: swap(arr[i3++], arr[i2++]) if arr[i3] == b: swap(arr[i3++], arr[i2++]), swap(arr[i1++, i2]) if arr[i3] == a: swap(arr[i3++], arr[i2++]), swap(arr[i1++], arr[i2]) , swap(arr[i0++], arr[i1]) public int [] rainbowSortII ( int [] array) { // Write your solution here int i0 = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; while (i3 < array. length ) { if (array [ i3 ] == 3 ) { i3 ++ ; } else if (array [ i3 ] == 2 ) { swap(array, i2, i3); i2 ++ ; i3 ++ ; } else if (array [ i3 ] == 1 ) { swap(array, i2, i3); swap(array, i1, i2); i1 ++ ; i2 ++ ; i3 ++ ; } else { swap(array, i2, i3); swap(array, i1, i2); swap(array, i0, i1); i0 ++ ; i1 ++ ; i2 ++ ; i3 ++ ; } } return array; }","title":"Q3: sort four color"},{"location":"Interview/sorting-algorithms/#q4-what-about-k-color","text":"use counting sort, sort in linear time! class Solution { public : vector < int > rainbowSortIII (vector < int > a, int k) { vector < int > cnt (k + 1 ); // accumulate cnt of each element (from 0 - k) int n = a. size (); for ( int i = 0 ; i < n; ++ i) cnt [ a [ i ]]++ ; for ( int i = 1 ; i <= k; ++ i) cnt [ i ] = cnt [ i ] + cnt [ i - 1] ; vector < int > res (n); for ( int i = n - 1 ; i >= 0 ; -- i) { res [ cnt [ a [ i ]] - 1] = a [ i ] ; cnt [ a [ i ]]-- ; } return res; } };","title":"Q4: What about k color?"},{"location":"Interview/sorting-algorithms/#_1","text":"\u65f6\u95f4\uff1a O(n) O(n) \u7a7a\u95f4\uff1a O(n) O(n) <- this is not a in-place algorithm","title":"\u590d\u6742\u5ea6\u5206\u6790"},{"location":"Interview/sorting-algorithms/#_2","text":"\u5982\u679c\u6709k\u4e2acolor\uff0c\u90a3\u4e48\u5982\u679c\u60f3\u8981\u77e5\u9053\u6bcf\u4e2acolor\u5e94\u8be5\u653e\u5728\u54ea\u91cc\u9700\u8981\u77e5\u9053\u4ee5\u4e0b\u4fe1\u606f\uff1a 1. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e 2. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u4e2a\u6570 \u8fd9\u4e24\u4e2a\u4fe1\u606f\u867d\u7136\u770b\u4f3c\u6ca1\u6709\u5173\u8054\u5b9e\u9645\u4e0a\u662f\uff1a\u5f53\u77e5\u9053\u6240\u6709\u5728\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272 \u6bcf\u4e2a\u4e2a\u6570\u4e4b\u540e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\u3002\u90a3\u4e48\u5c31\u662f\u8981\u5904\u7406\u5982\u4f55\u77e5\u9053\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u6240\u6709\u989c\u8272 \u4e2a\u6570\u3002 \u8fd9\u91cc\u5c31\u53ef\u4ee5\u60f3\u5230accumulate list\u6216\u8005pre sum list\u6765\u5904\u7406\u3002 for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; \u8fd9\u4e24\u884c\u505a\u7684\u4e8b\u60c5\u5206\u522b\u662f\u627e\u5230\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u91cf\uff0c\u7136\u540e\u8ba1\u7b97presum\uff0c\u8fd9\u91cc\u7684presum\u4fbf\u662f\u4e0a\u9762\u8bf4\u7684 \u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272*\u6bcf\u4e2a\u4e2a\u6570 \u3002\u5f53\u77e5\u9053\u4e86\u8fd9\u4e24\u4e2a\u4fe1\u606f\u4e4b\u540e\u4fbf\u53ef\u4ee5\u628a\u4ed6\u4eec\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230sort\u597d\u7684res\u6570\u7ec4\u4e86\u3002 for ( int i = n - 1 ; i >= 0 ; -- i) { res[cnt[a[i]] - 1 ] = a[i]; cnt[a[i]] -- ; } \u6ce8\u610f\uff1a\u6bcf\u6b21\u904d\u5386\u7684\u65f6\u5019\u9700\u8981\u66f4\u65b0cnt(cnt --)\uff0c\u540c\u65f6\u56e0\u4e3a\u6570\u7ec4\u662f0 base\uff0c\u4f46\u662f\u989c\u8272\u662f\u4ece[1\uff5ek]\uff0c\u6240\u4ee5\u6bcf\u6b21res\u7684index\u8981-1.","title":"\u5206\u6790"},{"location":"Interview/sorting-algorithms/#_3","text":"\u5047\u5982\u989c\u8272\u4e0d\u662f1\uff5ek\u7684\u6570\u5b57\uff0c\u90a3\u4e48\u4e3a\u4e86\u8ba1\u7b97presum\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u67d0\u79cd\u65b9\u6cd5\u6765\u77e5\u9053\u6bcf\u4e24\u4e2a\u5143\u7d20\u7684\u76f8\u5bf9\u4f4d\u7f6e\uff1a \u5047\u8bbeobjA < objB\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a unordered_map<Obj, int> mapping \u6765\u4e3a\u6bcf\u4e2a\u5143\u7d20\u8d4b\u503c\u3002\u5373\uff1a for ( int i = 0 ; i < n; ++ i) cnt[mapping[a[i]]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ];","title":"\u5982\u4f55\u89e3\u51b3\u975e\u6570\u5b57\u95ee\u9898"},{"location":"Interview/sorting-algorithms/#in-place-sort-space-ok-time-on","text":"vector < int > rainbowSortIII(vector < int > a, int k) { vector < int > cnt(k + 1 ); // cnt of each element (from 0 - k) int n = a.size(); for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 , idx = 0 ; i <= k; ++ i) { while (cnt[i] != 0 ) { a[idx ++ ] = i; cnt[i] -- ; } } return a; }","title":"In-place sort: space O(k), time O(n)"},{"location":"Interview/sorting-algorithms/#q5-reorder-the-array","text":"An array contains both pos and neg numbers in random order. Order the array elements so that pos and neg are placed alternatively. If there are more pos they appear at the end of the array. If there are more neg, they also appear at the end of the array. e.g. input: [1,2,3,4,5,-1,-1,-1], output: [1,-1,2,-1,3,-1,4,5] (the ordering of pos/neg number doesn't matter)","title":"Q5: reorder the array"},{"location":"Interview/sorting-algorithms/#analysis","text":"Use quick sort's partition to split the array into two half, then put them back to the new array alternatively","title":"Analysis"},{"location":"Interview/sorting-algorithms/#code_1","text":"#include <bits/stdc++.h> using namespace std; #define N 1010 int nums[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; int x = 0 , l = 0 , r = n - 1 ; while (l < r) { while (nums[ ++ l] > x); while (nums[ -- r] < x); if (l < r) swap(nums[l], nums[r]); } cout << nums[l] << \" \" << nums[r] << endl; int res[n]; memset(res, -1 , sizeof res); int idx = 0 ; for ( int i = 0 ; idx <= r; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i = 1 ; idx < n; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Code"},{"location":"Interview/stack-and-queue/","text":"Stack and Queue \u00b6 Use array to mimic stack \u00b6 // tt\u8868\u793a\u6808\u9876 int stk[N], tt = 0 ; // \u5411\u6808\u9876\u63d2\u5165\u4e00\u4e2a\u6570 stk[ ++ tt] = x; // \u4ece\u6808\u9876\u5f39\u51fa\u4e00\u4e2a\u6570 tt -- ; // \u6808\u9876\u7684\u503c stk[tt]; // \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a if (tt > 0 ) { } Monotonic Stack \u00b6 // \u5e38\u89c1\u6a21\u578b\uff1a\u627e\u51fa\u6bcf\u4e2a\u6570\u5de6\u8fb9\u79bb\u5b83\u6700\u8fd1\u7684\u6bd4\u5b83\u5927/\u5c0f\u7684\u6570 int tt = 0 ; for ( int i = 1 ; i <= n; i ++ ) { while (tt && check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } Use array to mimic queue \u00b6 Ordinary Queue \u00b6 // hh \u8868\u793a\u961f\u5934\uff0ctt\u8868\u793a\u961f\u5c3e int q[N], hh = 0 , tt = -1 ; // \u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u6570 q[ ++ tt] = x; // \u4ece\u961f\u5934\u5f39\u51fa\u4e00\u4e2a\u6570 hh ++ ; // \u961f\u5934\u7684\u503c q[hh]; // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a if (hh <= tt) { } Circular Queue (with only N - 1 elements) \u00b6 // hh \u8868\u793a\u961f\u5934\uff0ctt\u8868\u793a\u961f\u5c3e\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e int q[N], hh = 0 , tt = 0 ; // \u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u6570 q[tt ++ ] = x; if (tt == N) tt = 0 ; // reset to 0 // \u4ece\u961f\u5934\u5f39\u51fa\u4e00\u4e2a\u6570 hh ++ ; if (hh == N) hh = 0 ; // \u961f\u5934\u7684\u503c q[hh]; // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a if (hh != tt) { } Monotonic Queue \u00b6 // \u5e38\u89c1\u6a21\u578b\uff1a\u627e\u51fa\u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c/\u6700\u5c0f\u503c int hh = 0 , tt = -1 ; for ( int i = 0 ; i < n; i ++ ) { while (hh <= tt && check_out(q[hh])) hh ++ ; // \u5224\u65ad\u961f\u5934\u662f\u5426\u6ed1\u51fa\u7a97\u53e3 while (hh <= tt && check(q[tt], i)) tt -- ; q[ ++ tt] = i; }","title":"Stack and Queue"},{"location":"Interview/stack-and-queue/#stack-and-queue","text":"","title":"Stack and Queue"},{"location":"Interview/stack-and-queue/#use-array-to-mimic-stack","text":"// tt\u8868\u793a\u6808\u9876 int stk[N], tt = 0 ; // \u5411\u6808\u9876\u63d2\u5165\u4e00\u4e2a\u6570 stk[ ++ tt] = x; // \u4ece\u6808\u9876\u5f39\u51fa\u4e00\u4e2a\u6570 tt -- ; // \u6808\u9876\u7684\u503c stk[tt]; // \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a if (tt > 0 ) { }","title":"Use array to mimic stack"},{"location":"Interview/stack-and-queue/#monotonic-stack","text":"// \u5e38\u89c1\u6a21\u578b\uff1a\u627e\u51fa\u6bcf\u4e2a\u6570\u5de6\u8fb9\u79bb\u5b83\u6700\u8fd1\u7684\u6bd4\u5b83\u5927/\u5c0f\u7684\u6570 int tt = 0 ; for ( int i = 1 ; i <= n; i ++ ) { while (tt && check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; }","title":"Monotonic Stack"},{"location":"Interview/stack-and-queue/#use-array-to-mimic-queue","text":"","title":"Use array to mimic queue"},{"location":"Interview/stack-and-queue/#ordinary-queue","text":"// hh \u8868\u793a\u961f\u5934\uff0ctt\u8868\u793a\u961f\u5c3e int q[N], hh = 0 , tt = -1 ; // \u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u6570 q[ ++ tt] = x; // \u4ece\u961f\u5934\u5f39\u51fa\u4e00\u4e2a\u6570 hh ++ ; // \u961f\u5934\u7684\u503c q[hh]; // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a if (hh <= tt) { }","title":"Ordinary Queue"},{"location":"Interview/stack-and-queue/#circular-queue-with-only-n-1-elements","text":"// hh \u8868\u793a\u961f\u5934\uff0ctt\u8868\u793a\u961f\u5c3e\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e int q[N], hh = 0 , tt = 0 ; // \u5411\u961f\u5c3e\u63d2\u5165\u4e00\u4e2a\u6570 q[tt ++ ] = x; if (tt == N) tt = 0 ; // reset to 0 // \u4ece\u961f\u5934\u5f39\u51fa\u4e00\u4e2a\u6570 hh ++ ; if (hh == N) hh = 0 ; // \u961f\u5934\u7684\u503c q[hh]; // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a if (hh != tt) { }","title":"Circular Queue (with only N - 1 elements)"},{"location":"Interview/stack-and-queue/#monotonic-queue","text":"// \u5e38\u89c1\u6a21\u578b\uff1a\u627e\u51fa\u6ed1\u52a8\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c/\u6700\u5c0f\u503c int hh = 0 , tt = -1 ; for ( int i = 0 ; i < n; i ++ ) { while (hh <= tt && check_out(q[hh])) hh ++ ; // \u5224\u65ad\u961f\u5934\u662f\u5426\u6ed1\u51fa\u7a97\u53e3 while (hh <= tt && check(q[tt], i)) tt -- ; q[ ++ tt] = i; }","title":"Monotonic Queue"},{"location":"Interview/string-match/","text":"String Match \u00b6 Problem \u00b6 Determine if a small string is a substring of another large string. Return the index of the first occurrence of the small string in the large string. Return -1 if the small string is not a substring of the large string. Consider the case: mississippi issip -> return 4 KMP \u00b6 next array physcial meaning \u00b6 next[i] = j means p[1, j] = p[i - j + 1, i] (blue part is same with grean part) What it does is keep checking the longest suffix (ending at j) with prefix (starting at 0) Or: longest ending index j that makes 0 ~ j == i - j + 1 ~ i e.g. P = \"ababababab\" psuedocode \u00b6 Part 1: form the next array \u00b6 check if small[i] == small[j + 1] if not, meaning 0 ~ i - 1 matches 0 ~ j but i doesn't match j + 1 to find last match (0 ~ i matches i - j + 1 ~ j + 1) if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j set next[i] = j // last match Part 2: find in the original string \u00b6 check if large[i] == small[j + 1] if not, meaning large[0 ~ i] matches small[0 ~ j] but i doesn't match j + 1 (same as part 1) try last match if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j check if reach the end Code \u00b6 class Solution { public : int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); vector < int > next(n, -1 ); for ( int i = 1 , j = -1 ; i < n; ++ i) { // either not start matching yet // or find previous one that stops at current i while (j >= 0 && small[j + 1 ] != small[i]) j = next[j]; // check if current one is matched if (small[j + 1 ] == small[i]) j ++ ; // now next[i] = j; } for ( int i = 0 , j = -1 ; i < m; ++ i) { while (j != -1 && large[i] != small[j + 1 ]) j = next[j]; if (large[i] == small[j + 1 ]) j ++ ; if (j == n - 1 ) return i - j; } return -1 ; } }; String Hashing or RabinKarp Algorithm \u00b6 First calculate the hash value for subtring from 0 ~ i in large Second calculate the hash value for substring from i ~ j given hash values of 0 ~ i and 0 ~ j To Prevent collision, use a large prime for P. Why use unsigned long long ? Because unsigned long long 's max is 2^{64} 2^{64} , if add one more, it will become 0 0 , which makes sure all the values are in the range of 0 ~ 2^{64} 2^{64} -- works like a module operation. Why h[i - 1] * p[n] ? Because to find out the hash value for substring of i + n - 1 (right) to i - 1 (left), we need to find p[i + n - 1 (right) - i + 1 (left)], which yields p[n]. Code \u00b6 before Optimization class Solution { public : int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > p(m + 1 , 1 ), h(m + 1 , 1 ); for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; p[i] = p[i - 1 ] * P; } ULL check = 1 ; for ( int i = 1 ; i <= n; ++ i) { check = check * P + small[i - 1 ]; } check = check - p[n]; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { ULL hash = h[i + n - 1 ] - h[i - 1 ] * p[n]; if (h[i + n - 1 ] - h[i - 1 ] * p[n] == check) return i - 1 ; } return -1 ; } }; after optimization class Solution { public : int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > h(m + 1 , 1 ); ULL p = 1 , check = 1 ; for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; if (i <= n) { p *= P; check = check * P + small[i - 1 ]; } } check = check - p; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { if (h[i + n - 1 ] - h[i - 1 ] * p == check) return i - 1 ; } return -1 ; } };","title":"String Match"},{"location":"Interview/string-match/#string-match","text":"","title":"String Match"},{"location":"Interview/string-match/#problem","text":"Determine if a small string is a substring of another large string. Return the index of the first occurrence of the small string in the large string. Return -1 if the small string is not a substring of the large string. Consider the case: mississippi issip -> return 4","title":"Problem"},{"location":"Interview/string-match/#kmp","text":"","title":"KMP"},{"location":"Interview/string-match/#next-array-physcial-meaning","text":"next[i] = j means p[1, j] = p[i - j + 1, i] (blue part is same with grean part) What it does is keep checking the longest suffix (ending at j) with prefix (starting at 0) Or: longest ending index j that makes 0 ~ j == i - j + 1 ~ i e.g. P = \"ababababab\"","title":"next array physcial meaning"},{"location":"Interview/string-match/#psuedocode","text":"","title":"psuedocode"},{"location":"Interview/string-match/#part-1-form-the-next-array","text":"check if small[i] == small[j + 1] if not, meaning 0 ~ i - 1 matches 0 ~ j but i doesn't match j + 1 to find last match (0 ~ i matches i - j + 1 ~ j + 1) if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j set next[i] = j // last match","title":"Part 1: form the next array"},{"location":"Interview/string-match/#part-2-find-in-the-original-string","text":"check if large[i] == small[j + 1] if not, meaning large[0 ~ i] matches small[0 ~ j] but i doesn't match j + 1 (same as part 1) try last match if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j check if reach the end","title":"Part 2: find in the original string"},{"location":"Interview/string-match/#code","text":"class Solution { public : int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); vector < int > next(n, -1 ); for ( int i = 1 , j = -1 ; i < n; ++ i) { // either not start matching yet // or find previous one that stops at current i while (j >= 0 && small[j + 1 ] != small[i]) j = next[j]; // check if current one is matched if (small[j + 1 ] == small[i]) j ++ ; // now next[i] = j; } for ( int i = 0 , j = -1 ; i < m; ++ i) { while (j != -1 && large[i] != small[j + 1 ]) j = next[j]; if (large[i] == small[j + 1 ]) j ++ ; if (j == n - 1 ) return i - j; } return -1 ; } };","title":"Code"},{"location":"Interview/string-match/#string-hashing-or-rabinkarp-algorithm","text":"First calculate the hash value for subtring from 0 ~ i in large Second calculate the hash value for substring from i ~ j given hash values of 0 ~ i and 0 ~ j To Prevent collision, use a large prime for P. Why use unsigned long long ? Because unsigned long long 's max is 2^{64} 2^{64} , if add one more, it will become 0 0 , which makes sure all the values are in the range of 0 ~ 2^{64} 2^{64} -- works like a module operation. Why h[i - 1] * p[n] ? Because to find out the hash value for substring of i + n - 1 (right) to i - 1 (left), we need to find p[i + n - 1 (right) - i + 1 (left)], which yields p[n].","title":"String Hashing or RabinKarp Algorithm"},{"location":"Interview/string-match/#code_1","text":"before Optimization class Solution { public : int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > p(m + 1 , 1 ), h(m + 1 , 1 ); for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; p[i] = p[i - 1 ] * P; } ULL check = 1 ; for ( int i = 1 ; i <= n; ++ i) { check = check * P + small[i - 1 ]; } check = check - p[n]; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { ULL hash = h[i + n - 1 ] - h[i - 1 ] * p[n]; if (h[i + n - 1 ] - h[i - 1 ] * p[n] == check) return i - 1 ; } return -1 ; } }; after optimization class Solution { public : int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > h(m + 1 , 1 ); ULL p = 1 , check = 1 ; for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; if (i <= n) { p *= P; check = check * P + small[i - 1 ]; } } check = check - p; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { if (h[i + n - 1 ] - h[i - 1 ] * p == check) return i - 1 ; } return -1 ; } };","title":"Code"},{"location":"Interview/string/","text":"String \u00b6 Reverse \u00b6 Reverse \"I love yahoo\" to \"yahoo love I\" reverse entire string: \"oohay evol I\" reverse each word: \"yahoo love I\" Trick \u00b6 Right shift a given string by n characters. Assumptions The given string is not null. n >= 0. Examples \"abc\", 4 -> \"cab\" class Solution { public : string rightShift(string s, int n) { // write your solution here if ( ! n || s == \"\" ) return s; reverse(s.begin(), s.end()); int shift = n % s.size(); reverse(s.begin() + shift, s.end()); reverse(s.begin(), s.begin() + shift); return s; } }; Replacement \u00b6 Replace \"student\" to \"stuXXt\" -> replace all \"den\" to \"XX\" Note that replacement may have different size Use two pointers method + If p.size() > replaced part: 1. add space to the end of the original string (buffer zone) 2. start from right to left to replace (replace in reversed order) + If p.size() < replaced part 1. start from left to right. replace if met and continue on https://app.laicode.io/app/problem/649 // TODO for ( int i = 0 , j = 0 ; i < n; ++ i) { if (s[i] == p[j]) { j ++ ; s[i] = p[j]; } }","title":"String"},{"location":"Interview/string/#string","text":"","title":"String"},{"location":"Interview/string/#reverse","text":"Reverse \"I love yahoo\" to \"yahoo love I\" reverse entire string: \"oohay evol I\" reverse each word: \"yahoo love I\"","title":"Reverse"},{"location":"Interview/string/#trick","text":"Right shift a given string by n characters. Assumptions The given string is not null. n >= 0. Examples \"abc\", 4 -> \"cab\" class Solution { public : string rightShift(string s, int n) { // write your solution here if ( ! n || s == \"\" ) return s; reverse(s.begin(), s.end()); int shift = n % s.size(); reverse(s.begin() + shift, s.end()); reverse(s.begin(), s.begin() + shift); return s; } };","title":"Trick"},{"location":"Interview/string/#replacement","text":"Replace \"student\" to \"stuXXt\" -> replace all \"den\" to \"XX\" Note that replacement may have different size Use two pointers method + If p.size() > replaced part: 1. add space to the end of the original string (buffer zone) 2. start from right to left to replace (replace in reversed order) + If p.size() < replaced part 1. start from left to right. replace if met and continue on https://app.laicode.io/app/problem/649 // TODO for ( int i = 0 , j = 0 ; i < n; ++ i) { if (s[i] == p[j]) { j ++ ; s[i] = p[j]; } }","title":"Replacement"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/","text":"Subset, combination, Permutation Problems \u00b6 Generate all subset duplicate character can exist in the single set of a sequence \u00b6 All elements are distinct \u00b6 Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Analysis \u00b6 Since each element can either be included or not included, we have 2^N 2^N subsets. branch factor = 1 to n, height = 1 to n branch factor = 2 (choose or not choose), height = n Code 1: using bitwise manipulation \u00b6 class Solution { public : // use binary increment for listing all the combination of bits // converting the binary representation to subset representation vector < vector < int >> subsets(vector < int >& nums) { vector < vector < int >> res; for ( int i = 0 ; i < 1 << nums.size(); ++ i) { vector < int > temp; for ( int j = 0 ; j < nums.size(); ++ j) { // check if current bit is 1, if so, add the value to list if ((i >> j) & 1 ) temp.push_back(nums[j]); } res.push_back(temp); } return res; } }; Code 2: using backtracking/dfs with varied branch factor \u00b6 class Solution { public : vector < vector < int >> ret; vector < vector < int >> subsets(vector < int >& nums) { vector < int > v; helper(v, nums, 0 ); return ret; } void helper(vector < int > curr, vector < int >& nums, int i) { ret.push_back(curr); for (; i < nums.size(); ++ i) { curr.push_back(nums[i]); helper(curr, nums, i + 1 ); curr.pop_back(); } } }; Code 3: using backtracking/dfs with choose or not \u00b6 class Solution { public : vector < vector < int >> res; void dfs (vector < int >& nums, int i, vector < int >& curr) { if (i == nums.size()) { res.push_back(curr); return ; } // choose current element from nums[i] curr.push_back(nums[i]); dfs(nums, i + 1 , curr); curr.pop_back(); // not choose dfs(nums, i + 1 , curr); } vector < vector < int >> subsets(vector < int >& nums) { vector < int > curr; dfs(nums, 0 , curr); return res; } }; There are duplicates in the given nums \u00b6 Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Anaylsis \u00b6 Different from the distinct element subset problem, now we need to decide how to deal with duplicate: 1,2 and 1,2,2 are two different subsets, so we need to decide when to stop the recursion. In the previous problem, using \"choose or not choose\" we stop as we have reach to the end of the elements to be chosen. See the recursion tree for this particular problem: Code 1: using backtracking/dfs with varied branch factor \u00b6 class Solution { public : vector < vector < int >> subsetsWithDup(vector < int > & S) { if (S.empty()) return {}; vector < vector < int >> res; vector < int > out; sort(S.begin(), S.end()); getSubsets(S, 0 , out, res); return res; } void getSubsets(vector < int > & S, int pos, vector < int > & out, vector < vector < int >> & res) { res.push_back(out); for ( int i = pos; i < S.size(); ++ i) { out.push_back(S[i]); getSubsets(S, i + 1 , out, res); out.pop_back(); while (i + 1 < S.size() && S[i] == S[i + 1 ]) ++ i; } } }; Code 2: using backtracking/dfs with choose or not \u00b6 class Solution { public : vector < vector < int >> res; void dfs ( int i, vector < int >& s, vector < int >& curr) { if (i == s.size()) { res.push_back(curr); return ; } // choose current s[i] curr.push_back(s[i]); dfs(i + 1 , s, curr); curr.pop_back(); // not choose current s[i] and skip all the rest that are duplicated with s[i] int idx = i; while (i < s.size() && s[idx] == s[i]) i ++ ; dfs(i, s, curr); } vector < vector < int >> subsetsWithDup(vector < int >& nums) { sort(nums.begin(), nums.end()); vector < int > curr; dfs( 0 , nums, curr); return res; } }; Combination \u00b6","title":"Subset, combination, Permutation Problems"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#subset-combination-permutation-problems","text":"","title":"Subset, combination, Permutation Problems"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#generate-all-subset-duplicate-character-can-exist-in-the-single-set-of-a-sequence","text":"","title":"Generate all subset duplicate character can exist in the single set of a sequence"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#all-elements-are-distinct","text":"Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]","title":"All elements are distinct"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#analysis","text":"Since each element can either be included or not included, we have 2^N 2^N subsets. branch factor = 1 to n, height = 1 to n branch factor = 2 (choose or not choose), height = n","title":"Analysis"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-1-using-bitwise-manipulation","text":"class Solution { public : // use binary increment for listing all the combination of bits // converting the binary representation to subset representation vector < vector < int >> subsets(vector < int >& nums) { vector < vector < int >> res; for ( int i = 0 ; i < 1 << nums.size(); ++ i) { vector < int > temp; for ( int j = 0 ; j < nums.size(); ++ j) { // check if current bit is 1, if so, add the value to list if ((i >> j) & 1 ) temp.push_back(nums[j]); } res.push_back(temp); } return res; } };","title":"Code 1: using bitwise manipulation"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-2-using-backtrackingdfs-with-varied-branch-factor","text":"class Solution { public : vector < vector < int >> ret; vector < vector < int >> subsets(vector < int >& nums) { vector < int > v; helper(v, nums, 0 ); return ret; } void helper(vector < int > curr, vector < int >& nums, int i) { ret.push_back(curr); for (; i < nums.size(); ++ i) { curr.push_back(nums[i]); helper(curr, nums, i + 1 ); curr.pop_back(); } } };","title":"Code 2: using backtracking/dfs with varied branch factor"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-3-using-backtrackingdfs-with-choose-or-not","text":"class Solution { public : vector < vector < int >> res; void dfs (vector < int >& nums, int i, vector < int >& curr) { if (i == nums.size()) { res.push_back(curr); return ; } // choose current element from nums[i] curr.push_back(nums[i]); dfs(nums, i + 1 , curr); curr.pop_back(); // not choose dfs(nums, i + 1 , curr); } vector < vector < int >> subsets(vector < int >& nums) { vector < int > curr; dfs(nums, 0 , curr); return res; } };","title":"Code 3: using backtracking/dfs with choose or not"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#there-are-duplicates-in-the-given-nums","text":"Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]","title":"There are duplicates in the given nums"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#anaylsis","text":"Different from the distinct element subset problem, now we need to decide how to deal with duplicate: 1,2 and 1,2,2 are two different subsets, so we need to decide when to stop the recursion. In the previous problem, using \"choose or not choose\" we stop as we have reach to the end of the elements to be chosen. See the recursion tree for this particular problem:","title":"Anaylsis"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-1-using-backtrackingdfs-with-varied-branch-factor","text":"class Solution { public : vector < vector < int >> subsetsWithDup(vector < int > & S) { if (S.empty()) return {}; vector < vector < int >> res; vector < int > out; sort(S.begin(), S.end()); getSubsets(S, 0 , out, res); return res; } void getSubsets(vector < int > & S, int pos, vector < int > & out, vector < vector < int >> & res) { res.push_back(out); for ( int i = pos; i < S.size(); ++ i) { out.push_back(S[i]); getSubsets(S, i + 1 , out, res); out.pop_back(); while (i + 1 < S.size() && S[i] == S[i + 1 ]) ++ i; } } };","title":"Code 1: using backtracking/dfs with varied branch factor"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-2-using-backtrackingdfs-with-choose-or-not","text":"class Solution { public : vector < vector < int >> res; void dfs ( int i, vector < int >& s, vector < int >& curr) { if (i == s.size()) { res.push_back(curr); return ; } // choose current s[i] curr.push_back(s[i]); dfs(i + 1 , s, curr); curr.pop_back(); // not choose current s[i] and skip all the rest that are duplicated with s[i] int idx = i; while (i < s.size() && s[idx] == s[i]) i ++ ; dfs(i, s, curr); } vector < vector < int >> subsetsWithDup(vector < int >& nums) { sort(nums.begin(), nums.end()); vector < int > curr; dfs( 0 , nums, curr); return res; } };","title":"Code 2: using backtracking/dfs with choose or not"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#combination","text":"","title":"Combination"},{"location":"Interview/system-design-related-questions/","text":"System Design Questions \u00b6 Algorithm Problem: External Storage \u00b6 Q1.1: Merge k sorted arrays \u00b6 Duplication: input two arrays can have duplications, but output array cannot. Analysis \u00b6 Use a priority_queue to keep track of the smallest value for each array. Use a pair<int,int> to represent which array and which element from the array. This solution will read and write each element once from the disk (because we are using a pointer to point each array). Assume the average size of each array is n , then the time complexity is O(k \\times log_2{k} \\times N) O(k \\times log_2{k} \\times N) Other Common Solution Iterative Reduction: sort first two O(n) -> first three O(2n) -> ... -> all K O(kn): Time O(k^2 \\times n) O(k^2 \\times n) + Space O(k \\times n) O(k \\times n) because of the aux array Binary Reduction: merge 1 & 2, merge 3 & 4 ... merge k - 1 & k. -> merge 12 & 34 ... -> merge k-3k-2 & k-1k: Time O(k \\times n \\times log_2{k}) O(k \\times n \\times log_2{k}) : log_2{k} log_2{k} : merge ops, for each merge it takes n to merge and there are k arrays + Space O(k \\times n) O(k \\times n) . This solution has the same compleixty as the priority_queue solution, however if the array size is too big, then we need to read and write multiple times. Code \u00b6 vector < int > merge(vector < vector < int >> nums) { // write your solution here typedef pair < int , int > PII; int m = nums.size(); auto cmp = [ & ]( const PII & l, const PII & r) { return nums[l.first][l.second] > nums[r.first][r.second]; }; priority_queue < PII, vector < PII > , decltype(cmp) > pq(cmp); for ( int i = 0 ; i < m; ++ i) { if ( ! nums[i].empty()) pq.push(make_pair(i, 0 )); } vector < int > res; while ( ! pq.empty()) { int r, c; tie(r, c) = pq.top(); pq.pop(); res.push_back(nums[r][c]); if (c + 1 < nums[r].size()) pq.push(make_pair(r, c + 1 )); } return res; } Q1.2: External Sort 1 \u00b6 Given a simple computer with one core CPU, which has 2GB memory and 1GB avaliable to used, it also has two 100GB Hard Disk, how to sort 80GB integer of 64 bits? make 320 paritions for the 80GB data, so that each parition has 0.25 GB size (which is less than 1 GB, and we can use the additional free space to do other things, such as running our algorithm). maintain a min-heap (320 partition files) with fix size to sort externally. Below are quoted from wikipedia One example of external sorting is the external merge sort algorithm, which is a K-way merge algorithm. It sorts chunks that each fit in RAM, then merges the sorted chunks together. The algorithm first sorts M items at a time and puts the sorted lists back into external memory. It then recursively does a M/B-way merge on those sorted lists. To do this merge, B elements from each sorted list are loaded into internal memory, and the minimum is repeatedly outputted. For example, for sorting 900 megabytes of data using only 100 megabytes of RAM: Read 100 MB of the data in main memory and sort by some conventional method, like quicksort. Write the sorted data to disk. Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file. Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.) Perform a 9-way merge and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally -- because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed. Historically, instead of a sort, sometimes a replacement-selection algorithm was used to perform the initial distribution, to produce on average half as many output chunks of double the length. Q1.3: External Sort 2 \u00b6 LC Followup for Contains Duplicate II \u00b6 link Q1.4: 2Sum on 1TB data \u00b6 1 GB memory vs 1TB data Solution \u00b6 use external sort to sort and apply two pointers. assume duplicate exist. If we cannot read the entire dataset to memory, then we need to know how to partition the list s.t. we can decrease the search range. How to partition the list? ans: by doing the sampling of data to find the pattern do sampling on HD to get the distribution of the values => let's say the distribution is even distributed scan the HD (1TB data) and put data into correspondng range into a file. (-100-0, 1-100, 101-200...) assume now we have k files. load each file into the memory, e.g. for a file of range [1, 100], the only possible other file should be in the range of [101, 200], so we only need to load these two files into the memory.__ Q2.1 Find common elements in two arrays \u00b6 Solutions \u00b6 Solution 1 (assume sorted): use two pointer (i points to the start of array1, j points to the start of array2). Time: O(m + n) O(m + n) , Space: O(1) O(1) Solution 2 (assume unsoted): Use a hashset to contain the array whose size is less, then check the other array to see if exist in the set. Time: O(m + n) O(m + n) , Space: O(min(m,n)) O(min(m,n)) Solution 3 (assume sorted): use binary search on the large array. Time: O(m \\times log_2{n}) O(m \\times log_2{n}) , Space: O(1) O(1) Q2.2 Find common elements in k sorted arrays \u00b6 Assume the size of each array is approx equal to n Solutions \u00b6 Solution 1: iterative reduction -> do the search between 1, 2, use the commom elements to search the 3, do the same thing for 4... Time: O(k \\times n) O(k \\times n) , Space: O(n) O(n) Solution 2: binary reduction -> 1,2 common + 3,4 common + .... + (k - 1) + (k) common then merge, For implementation: stackoverflow link","title":"System Design Questions"},{"location":"Interview/system-design-related-questions/#system-design-questions","text":"","title":"System Design Questions"},{"location":"Interview/system-design-related-questions/#algorithm-problem-external-storage","text":"","title":"Algorithm Problem: External Storage"},{"location":"Interview/system-design-related-questions/#q11-merge-k-sorted-arrays","text":"Duplication: input two arrays can have duplications, but output array cannot.","title":"Q1.1: Merge k sorted arrays"},{"location":"Interview/system-design-related-questions/#analysis","text":"Use a priority_queue to keep track of the smallest value for each array. Use a pair<int,int> to represent which array and which element from the array. This solution will read and write each element once from the disk (because we are using a pointer to point each array). Assume the average size of each array is n , then the time complexity is O(k \\times log_2{k} \\times N) O(k \\times log_2{k} \\times N) Other Common Solution Iterative Reduction: sort first two O(n) -> first three O(2n) -> ... -> all K O(kn): Time O(k^2 \\times n) O(k^2 \\times n) + Space O(k \\times n) O(k \\times n) because of the aux array Binary Reduction: merge 1 & 2, merge 3 & 4 ... merge k - 1 & k. -> merge 12 & 34 ... -> merge k-3k-2 & k-1k: Time O(k \\times n \\times log_2{k}) O(k \\times n \\times log_2{k}) : log_2{k} log_2{k} : merge ops, for each merge it takes n to merge and there are k arrays + Space O(k \\times n) O(k \\times n) . This solution has the same compleixty as the priority_queue solution, however if the array size is too big, then we need to read and write multiple times.","title":"Analysis"},{"location":"Interview/system-design-related-questions/#code","text":"vector < int > merge(vector < vector < int >> nums) { // write your solution here typedef pair < int , int > PII; int m = nums.size(); auto cmp = [ & ]( const PII & l, const PII & r) { return nums[l.first][l.second] > nums[r.first][r.second]; }; priority_queue < PII, vector < PII > , decltype(cmp) > pq(cmp); for ( int i = 0 ; i < m; ++ i) { if ( ! nums[i].empty()) pq.push(make_pair(i, 0 )); } vector < int > res; while ( ! pq.empty()) { int r, c; tie(r, c) = pq.top(); pq.pop(); res.push_back(nums[r][c]); if (c + 1 < nums[r].size()) pq.push(make_pair(r, c + 1 )); } return res; }","title":"Code"},{"location":"Interview/system-design-related-questions/#q12-external-sort-1","text":"Given a simple computer with one core CPU, which has 2GB memory and 1GB avaliable to used, it also has two 100GB Hard Disk, how to sort 80GB integer of 64 bits? make 320 paritions for the 80GB data, so that each parition has 0.25 GB size (which is less than 1 GB, and we can use the additional free space to do other things, such as running our algorithm). maintain a min-heap (320 partition files) with fix size to sort externally. Below are quoted from wikipedia One example of external sorting is the external merge sort algorithm, which is a K-way merge algorithm. It sorts chunks that each fit in RAM, then merges the sorted chunks together. The algorithm first sorts M items at a time and puts the sorted lists back into external memory. It then recursively does a M/B-way merge on those sorted lists. To do this merge, B elements from each sorted list are loaded into internal memory, and the minimum is repeatedly outputted. For example, for sorting 900 megabytes of data using only 100 megabytes of RAM: Read 100 MB of the data in main memory and sort by some conventional method, like quicksort. Write the sorted data to disk. Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file. Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.) Perform a 9-way merge and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally -- because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed. Historically, instead of a sort, sometimes a replacement-selection algorithm was used to perform the initial distribution, to produce on average half as many output chunks of double the length.","title":"Q1.2: External Sort 1"},{"location":"Interview/system-design-related-questions/#q13-external-sort-2","text":"","title":"Q1.3: External Sort 2"},{"location":"Interview/system-design-related-questions/#lc-followup-for-contains-duplicate-ii","text":"link","title":"LC Followup for Contains Duplicate II"},{"location":"Interview/system-design-related-questions/#q14-2sum-on-1tb-data","text":"1 GB memory vs 1TB data","title":"Q1.4: 2Sum on 1TB data"},{"location":"Interview/system-design-related-questions/#solution","text":"use external sort to sort and apply two pointers. assume duplicate exist. If we cannot read the entire dataset to memory, then we need to know how to partition the list s.t. we can decrease the search range. How to partition the list? ans: by doing the sampling of data to find the pattern do sampling on HD to get the distribution of the values => let's say the distribution is even distributed scan the HD (1TB data) and put data into correspondng range into a file. (-100-0, 1-100, 101-200...) assume now we have k files. load each file into the memory, e.g. for a file of range [1, 100], the only possible other file should be in the range of [101, 200], so we only need to load these two files into the memory.__","title":"Solution"},{"location":"Interview/system-design-related-questions/#q21-find-common-elements-in-two-arrays","text":"","title":"Q2.1 Find common elements in two arrays"},{"location":"Interview/system-design-related-questions/#solutions","text":"Solution 1 (assume sorted): use two pointer (i points to the start of array1, j points to the start of array2). Time: O(m + n) O(m + n) , Space: O(1) O(1) Solution 2 (assume unsoted): Use a hashset to contain the array whose size is less, then check the other array to see if exist in the set. Time: O(m + n) O(m + n) , Space: O(min(m,n)) O(min(m,n)) Solution 3 (assume sorted): use binary search on the large array. Time: O(m \\times log_2{n}) O(m \\times log_2{n}) , Space: O(1) O(1)","title":"Solutions"},{"location":"Interview/system-design-related-questions/#q22-find-common-elements-in-k-sorted-arrays","text":"Assume the size of each array is approx equal to n","title":"Q2.2 Find common elements in k sorted arrays"},{"location":"Interview/system-design-related-questions/#solutions_1","text":"Solution 1: iterative reduction -> do the search between 1, 2, use the commom elements to search the 3, do the same thing for 4... Time: O(k \\times n) O(k \\times n) , Space: O(n) O(n) Solution 2: binary reduction -> 1,2 common + 3,4 common + .... + (k - 1) + (k) common then merge, For implementation: stackoverflow link","title":"Solutions"},{"location":"Interview/tree/","text":"Tree \u00b6 Balanced Tree \u00b6 Def: height of the left and right subtrees of every node differ by 1 or less. Method 1: check is balanced \u00b6 int height (TreeNode * root) { if ( ! root) return 0 ; return max(height(root -> left), height(root -> right)) + 1 ; } bool isBalanced (TreeNode * root) { if ( ! root) return true ; if (abs(height(root -> left) - height(root -> right)) > 1 ) return false ; return isBalanced(root -> left) && isBalanced(root -> right); } Analysis \u00b6 Time: worst case happens when tree is balanced, so there are log(n) levels. first level requires n ops to get height, second = n/2, ....1. So total complexity is n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} Space: \\log{n} \\log{n} Method 2: check is balanced \u00b6 int checkDepth (TreeNode * root) { if ( ! root) return 0 ; int left = checkDepth(root -> left); if (left == -1 ) return -1 ; int right = checkDepth(root -> right); if (right == -1 ) return -1 ; if (abs(right - left) > 1 ) return -1 ; else return 1 + max(left, right); } bool isBalanced (TreeNode * root) { if (checkDepth(root) == -1 ) return false ; else return true ; } Analysis \u00b6 For each node, early terminate if left or right subtree is invalid. Each node only requries to visit once, so the time compleixty is O(n) O(n) Space Compleixty: the worst case would be like a linkedlist and the height is n, so O(n) O(n) Symmetric Tree \u00b6 Assume if we tweak the lchild with rchild of an arbitrary node in a binary tree, then the \"structure\" of the tree are not changed. Then how can we determinte whether two binary trees' structures are identical. bool isTweakedIdentical (TreeNode * l, TreeNode * r) { // write your solution here if ( ! l && ! r) return true ; if ( ! l || ! r) return false ; if (l -> value != r -> value) return false ; return (isTweakedIdentical(l -> left, r -> right) && isTweakedIdentical(l -> right, r -> left)) || (isTweakedIdentical(l -> right, r -> right) && isTweakedIdentical(l -> left, r -> left)) || (isTweakedIdentical(l -> left, r -> left) && isTweakedIdentical(l -> right, r -> right)) || (isTweakedIdentical(l -> right, r -> left) && isTweakedIdentical(l -> left, r -> right)); } Analysis \u00b6 Each level has four nodes, and total cost is N. There are \\log_2{N} \\log_2{N} because the wrost case is when the tree is balanced (there are not a lot early terminations). Total number of nodes in the quadral tree is 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) Space: wrost case is linkedlist so O(n) O(n) Traverse Tree \u00b6 pre-order: root -> left -> right in-order: left -> root -> right post-order: left -> right -> root Pre-order \u00b6 recursion: vector < int > res; vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; res.push_back(root -> val); preorderTraversal(root -> left); preorderTraversal(root -> right); /* traverse a graph for (int i = 0; i < n; ++i) preorder(root -> neighbour[i]); */ return res; } iterative: vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st{{root}}; while ( ! st.empty()) { TreeNode * t = st.top(); st.pop(); res.push_back(t -> val); /* traverse a graph for (int i = n - 1; i >= 0; --i) preorder(root -> neighbour[i]); */ if (t -> right) st.push(t -> right); // push right first, so it will be popped last if (t -> left) st.push(t -> left); } return res; } In-order \u00b6 recursion: vector < int > res; vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; /* traverse a graph: all from 0 to current root for (int i = 0; i < m; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> left); res.push_back(root -> val); /* traverse a graph: all from current root to the end for (int i = m; i < n; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> right); return res; } iterative: vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st; while (root || ! st.empty()) { while (root) { // first push all the left children to the stack st.push(root); root = root -> left; } root = st.top(); st.pop(); res.push_back(root -> val); root = root -> right; } return res; } Post-order \u00b6 recursion: vector < int > res; vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; postorderTraversal(root -> left); postorderTraversal(root -> right); res.push_back(root -> val); return res; } iterative: vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> s; while (root || ! s.empty()) { if (root) { s.push(root); res.insert(res.begin(), root -> val); root = root -> right; } else { TreeNode * pleft = s.top(); s.pop(); root = pleft -> left; } } return res; } Binary Searh Tree \u00b6 Query \u00b6 find min/max: while x.left / x.right != null : x = x.left / x.right return x // if using x.left -> min, x.right -> max Insertion \u00b6 class Solution { public : TreeNode * insertIntoBST(TreeNode * root, int val) { if ( ! root) return new TreeNode(val); TreeNode * cur = root; while ( true ) { if (cur -> val > val) { if ( ! cur -> left) { cur -> left = new TreeNode(val); break ; } cur = cur -> left; } else { if ( ! cur -> right) { cur -> right = new TreeNode(val); break ; } cur = cur -> right; } } return root; } }; Form the Minimal Tree \u00b6 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a bnary search tree with minimal height. Analysis \u00b6 In order to have the shortest height, we need to make left subtree and right subtree as close size as possible. To do so, we can recursively find the middle value of the sorted array and then appoints that as the root node (left subtree and right subtree). Code \u00b6 TreeNode * h (vector < int >& arr, int l, int r) { if (l == r) return NULL ; int mid = (l + r) >> 1 ; TreeNode * n = new TreeNode(arr[mid]); n -> left = h(arr, l, mid - 1 ); // [l, mid) are less than arr[mid] n -> right = h(arr, mid + 1 , r); // (mid, r] are greater than arr[mid] return n; } TreeNode * createMinimalBST (vector < int >& arr) { return h(arr, 0 , arr.size() - 1 ); } Tree Serialization \u00b6 Reconstruct Binary Tree With Levelorder And Inorder: Given the levelorder and inorder traversal sequence of a binary tree, reconstruct the original tree. Assumptions The given sequences are not null and they have the same length There are no duplicate keys in the binary tree Examples levelorder traversal = {5, 3, 8, 1, 4, 11} inorder traversal = {1, 3, 4, 5, 8, 11} the corresponding binary tree is 5 / \\ 3 8 / \\ \\ 1 4 11 How is the binary tree represented? We use level order traversal sequence with a special symbol \"#\" denoting the null node. For Example: The sequence [1, 2, 3, #, #, 4] represents the following binary tree: 1 / \\ 2 3 / 4 Analysis \u00b6 Assumption: all nodes have different values In order traversal: left - root - right Level order traversal: root -> next level -> next level * 2 ... Details: First node of the level order traversal is the root node, and if we can locate the root node in the in-order travseral, we can know which nodes are on the left AND right side of the current root. To fast locate the position of root, we can preprocess aa map that maps node value to the index in the in-order array. Time: O(n^2) O(n^2) Space: O(n) O(n) Code \u00b6 //class TreeNode { // public: // int value; // TreeNode* left; // TreeNode* right; // TreeNode(int v) : value(v), left(NULL), right(NULL) {} //}; class Solution { public : TreeNode * helper(vector < int >& levelOrder, unordered_map < int , int >& idx) { if (levelOrder.empty()) return NULL ; TreeNode * root = new TreeNode(levelOrder[ 0 ]); levelOrder.erase(levelOrder.begin()); // we can do better if we don't erase and instead using a start pointer to point to the new root vector < int > left, right; for ( int n : levelOrder) { if (idx[n] < idx[root -> value]) left.push_back(n); else right.push_back(n); } root -> left = helper(left, idx); root -> right = helper(right, idx); return root; } TreeNode * reconstruct(vector < int > inOrder, vector < int > levelOrder) { // write your solution here unordered_map < int , int > idx; for ( int i = 0 ; i < inOrder.size(); ++ i) idx[inOrder[i]] = i; return helper (levelOrder, idx); } };","title":"Tree"},{"location":"Interview/tree/#tree","text":"","title":"Tree"},{"location":"Interview/tree/#balanced-tree","text":"Def: height of the left and right subtrees of every node differ by 1 or less.","title":"Balanced Tree"},{"location":"Interview/tree/#method-1-check-is-balanced","text":"int height (TreeNode * root) { if ( ! root) return 0 ; return max(height(root -> left), height(root -> right)) + 1 ; } bool isBalanced (TreeNode * root) { if ( ! root) return true ; if (abs(height(root -> left) - height(root -> right)) > 1 ) return false ; return isBalanced(root -> left) && isBalanced(root -> right); }","title":"Method 1: check is balanced"},{"location":"Interview/tree/#analysis","text":"Time: worst case happens when tree is balanced, so there are log(n) levels. first level requires n ops to get height, second = n/2, ....1. So total complexity is n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} Space: \\log{n} \\log{n}","title":"Analysis"},{"location":"Interview/tree/#method-2-check-is-balanced","text":"int checkDepth (TreeNode * root) { if ( ! root) return 0 ; int left = checkDepth(root -> left); if (left == -1 ) return -1 ; int right = checkDepth(root -> right); if (right == -1 ) return -1 ; if (abs(right - left) > 1 ) return -1 ; else return 1 + max(left, right); } bool isBalanced (TreeNode * root) { if (checkDepth(root) == -1 ) return false ; else return true ; }","title":"Method 2: check is balanced"},{"location":"Interview/tree/#analysis_1","text":"For each node, early terminate if left or right subtree is invalid. Each node only requries to visit once, so the time compleixty is O(n) O(n) Space Compleixty: the worst case would be like a linkedlist and the height is n, so O(n) O(n)","title":"Analysis"},{"location":"Interview/tree/#symmetric-tree","text":"Assume if we tweak the lchild with rchild of an arbitrary node in a binary tree, then the \"structure\" of the tree are not changed. Then how can we determinte whether two binary trees' structures are identical. bool isTweakedIdentical (TreeNode * l, TreeNode * r) { // write your solution here if ( ! l && ! r) return true ; if ( ! l || ! r) return false ; if (l -> value != r -> value) return false ; return (isTweakedIdentical(l -> left, r -> right) && isTweakedIdentical(l -> right, r -> left)) || (isTweakedIdentical(l -> right, r -> right) && isTweakedIdentical(l -> left, r -> left)) || (isTweakedIdentical(l -> left, r -> left) && isTweakedIdentical(l -> right, r -> right)) || (isTweakedIdentical(l -> right, r -> left) && isTweakedIdentical(l -> left, r -> right)); }","title":"Symmetric Tree"},{"location":"Interview/tree/#analysis_2","text":"Each level has four nodes, and total cost is N. There are \\log_2{N} \\log_2{N} because the wrost case is when the tree is balanced (there are not a lot early terminations). Total number of nodes in the quadral tree is 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) Space: wrost case is linkedlist so O(n) O(n)","title":"Analysis"},{"location":"Interview/tree/#traverse-tree","text":"pre-order: root -> left -> right in-order: left -> root -> right post-order: left -> right -> root","title":"Traverse Tree"},{"location":"Interview/tree/#pre-order","text":"recursion: vector < int > res; vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; res.push_back(root -> val); preorderTraversal(root -> left); preorderTraversal(root -> right); /* traverse a graph for (int i = 0; i < n; ++i) preorder(root -> neighbour[i]); */ return res; } iterative: vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st{{root}}; while ( ! st.empty()) { TreeNode * t = st.top(); st.pop(); res.push_back(t -> val); /* traverse a graph for (int i = n - 1; i >= 0; --i) preorder(root -> neighbour[i]); */ if (t -> right) st.push(t -> right); // push right first, so it will be popped last if (t -> left) st.push(t -> left); } return res; }","title":"Pre-order"},{"location":"Interview/tree/#in-order","text":"recursion: vector < int > res; vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; /* traverse a graph: all from 0 to current root for (int i = 0; i < m; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> left); res.push_back(root -> val); /* traverse a graph: all from current root to the end for (int i = m; i < n; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> right); return res; } iterative: vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st; while (root || ! st.empty()) { while (root) { // first push all the left children to the stack st.push(root); root = root -> left; } root = st.top(); st.pop(); res.push_back(root -> val); root = root -> right; } return res; }","title":"In-order"},{"location":"Interview/tree/#post-order","text":"recursion: vector < int > res; vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; postorderTraversal(root -> left); postorderTraversal(root -> right); res.push_back(root -> val); return res; } iterative: vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> s; while (root || ! s.empty()) { if (root) { s.push(root); res.insert(res.begin(), root -> val); root = root -> right; } else { TreeNode * pleft = s.top(); s.pop(); root = pleft -> left; } } return res; }","title":"Post-order"},{"location":"Interview/tree/#binary-searh-tree","text":"","title":"Binary Searh Tree"},{"location":"Interview/tree/#query","text":"find min/max: while x.left / x.right != null : x = x.left / x.right return x // if using x.left -> min, x.right -> max","title":"Query"},{"location":"Interview/tree/#insertion","text":"class Solution { public : TreeNode * insertIntoBST(TreeNode * root, int val) { if ( ! root) return new TreeNode(val); TreeNode * cur = root; while ( true ) { if (cur -> val > val) { if ( ! cur -> left) { cur -> left = new TreeNode(val); break ; } cur = cur -> left; } else { if ( ! cur -> right) { cur -> right = new TreeNode(val); break ; } cur = cur -> right; } } return root; } };","title":"Insertion"},{"location":"Interview/tree/#form-the-minimal-tree","text":"Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a bnary search tree with minimal height.","title":"Form the Minimal Tree"},{"location":"Interview/tree/#analysis_3","text":"In order to have the shortest height, we need to make left subtree and right subtree as close size as possible. To do so, we can recursively find the middle value of the sorted array and then appoints that as the root node (left subtree and right subtree).","title":"Analysis"},{"location":"Interview/tree/#code","text":"TreeNode * h (vector < int >& arr, int l, int r) { if (l == r) return NULL ; int mid = (l + r) >> 1 ; TreeNode * n = new TreeNode(arr[mid]); n -> left = h(arr, l, mid - 1 ); // [l, mid) are less than arr[mid] n -> right = h(arr, mid + 1 , r); // (mid, r] are greater than arr[mid] return n; } TreeNode * createMinimalBST (vector < int >& arr) { return h(arr, 0 , arr.size() - 1 ); }","title":"Code"},{"location":"Interview/tree/#tree-serialization","text":"Reconstruct Binary Tree With Levelorder And Inorder: Given the levelorder and inorder traversal sequence of a binary tree, reconstruct the original tree. Assumptions The given sequences are not null and they have the same length There are no duplicate keys in the binary tree Examples levelorder traversal = {5, 3, 8, 1, 4, 11} inorder traversal = {1, 3, 4, 5, 8, 11} the corresponding binary tree is 5 / \\ 3 8 / \\ \\ 1 4 11 How is the binary tree represented? We use level order traversal sequence with a special symbol \"#\" denoting the null node. For Example: The sequence [1, 2, 3, #, #, 4] represents the following binary tree: 1 / \\ 2 3 / 4","title":"Tree Serialization"},{"location":"Interview/tree/#analysis_4","text":"Assumption: all nodes have different values In order traversal: left - root - right Level order traversal: root -> next level -> next level * 2 ... Details: First node of the level order traversal is the root node, and if we can locate the root node in the in-order travseral, we can know which nodes are on the left AND right side of the current root. To fast locate the position of root, we can preprocess aa map that maps node value to the index in the in-order array. Time: O(n^2) O(n^2) Space: O(n) O(n)","title":"Analysis"},{"location":"Interview/tree/#code_1","text":"//class TreeNode { // public: // int value; // TreeNode* left; // TreeNode* right; // TreeNode(int v) : value(v), left(NULL), right(NULL) {} //}; class Solution { public : TreeNode * helper(vector < int >& levelOrder, unordered_map < int , int >& idx) { if (levelOrder.empty()) return NULL ; TreeNode * root = new TreeNode(levelOrder[ 0 ]); levelOrder.erase(levelOrder.begin()); // we can do better if we don't erase and instead using a start pointer to point to the new root vector < int > left, right; for ( int n : levelOrder) { if (idx[n] < idx[root -> value]) left.push_back(n); else right.push_back(n); } root -> left = helper(left, idx); root -> right = helper(right, idx); return root; } TreeNode * reconstruct(vector < int > inOrder, vector < int > levelOrder) { // write your solution here unordered_map < int , int > idx; for ( int i = 0 ; i < inOrder.size(); ++ i) idx[inOrder[i]] = i; return helper (levelOrder, idx); } };","title":"Code"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/","text":"\u5348\u95f4\u8bfe\u5802 \u00b6 Graph \u00b6 Subset Problem \u00b6 Not asking for total number, but ask for each configuration. When each element can have only two possibability: count or not count, then it's a subset problem. void findSubset ( int idx, vector < int >& nums, vector < int >& curr) { if (idx == nums.size()) { cout << curr << endl; return ; } curr.push_back(nums[idx]); findSubset(idx + 1 , nums, curr); curr.pop_back(); // revoke back findSubset(idx + 1 , nums, curr); } void solve (vector < int >& nums) { vector < int > curr; findSubset( 0 , nums, curr); } Why cannot swap? curr.push_back(nums[idx]); findSubset(idx + 1 , nums, curr); curr.pop_back(); // revoke back findSubset(idx + 1 , nums, curr); cannot be: findSubset(idx + 1 , nums, curr); curr.push_back(nums[idx]); findSubset(idx + 1 , nums, curr); Answer: it will only push and not pop, so when finishing the recursion, the node will contain the previous character/number. Rule of thumb: push times == pop times With duplicate elements \u00b6 each subset can have multiple same element e.g. given nums = {a, b1, b2, c} a: 0 or 1 b: 0, 1 or 2 c: 0 or 1 so there are 2 \\times 3 \\times 2 2 \\times 3 \\times 2 possible configurations the recusion tree will look like: a --- {a} | {} b ---{a} {a,b} {a,b,b} | {} {b} {b,b} c ---... vector < vector < int >> res; void dfs ( int idx, vector < int >& nums, vector < int >& curr) { if (idx == nums.size()) { res.push_back(curr); return ; } curr.push_back(nums[idx]); dfs(idx + 1 , nums, curr); curr.pop_back(); int next = idx; while (next < nums.size() && nums[next] == nums[idx]) next ++ ; dfs(next, nums, curr); } vector < vector < int >> subsetsWithDup(vector < int >& nums) { sort(nums.begin(), nums.end()); vector < int > curr; dfs( 0 , nums, curr); return res; } Split array into two parts s.t. each part sum is equal to the other \u00b6 calculate the total sum then our target sum is sum / 2, our task is to find the combination #include <bits/stdc++.h> using namespace std; void helper (vector < int >& num, int idx, int sum, vector < int >& curr) { if (sum == 0 ) { for ( int c : curr) printf( \"%d \" , c); cout << endl; return ; } if (idx == num.size()) return ; curr.push_back(num[idx]); helper(num, idx + 1 , sum - num[idx], curr); curr.pop_back(); helper(num, idx + 1 , sum, curr); } void solve (vector < int >& nums) { int sum = 0 ; for ( int c : nums) sum += c; sum /= 2 ; vector < int > curr; helper(nums, 0 , sum, curr); } int main () { int n; cin >> n; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num); return 0 ; } Note: this code will check all the possible sum: e.g. given array 1, 1, 1, 1 -> 1, 1 | 1, 1 | 1, 1 | 1, 1 since these are all the valid configurations (different 1s though) To determine if possible (without enumerating all the configurations, which means you can terminate early): #include <bits/stdc++.h> using namespace std; bool helper (vector < int >& num, int idx, int sum, vector < int >& curr) { if (sum == 0 ) { for ( int c : curr) printf( \"%d \" , c); cout << endl; return true ; } if (idx == num.size()) return false ; curr.push_back(num[idx]); if (helper(num, idx + 1 , sum - num[idx], curr)) return true ; curr.pop_back(); if (helper(num, idx + 1 , sum, curr)) return true ; } void solve (vector < int >& nums) { int sum = 0 ; for ( int c : nums) sum += c; sum /= 2 ; vector < int > curr; helper(nums, 0 , sum, curr); } int main () { int n; cin >> n; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num); return 0 ; } Variant: find minimal diff for the two subset sum \u00b6 #include <bits/stdc++.h> using namespace std; int gDiff = INT_MAX; void helper (vector < int >& num, int idx, int curr, int sum) { if (idx == num.size()) return ; curr += num[idx]; gDiff = min(gDiff, abs((sum - curr) - curr)); helper(num, idx + 1 , curr, sum); curr -= num[idx]; helper(num, idx + 1 , curr, sum); } void solve (vector < int >& nums) { int sum = 0 ; for ( int c : nums) sum += c; vector < int > curr; helper(nums, 0 , 0 , sum); } int main () { int n; cin >> n; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num); cout << gDiff; return 0 ; } Note: we don't need to maintain a list to save current configuration, just use an int curr to keep track of the current sum is fine. Find all combination of size k \u00b6 assume no duplication base case: curr.size() == k #include <bits/stdc++.h> using namespace std; void findSubset ( int idx, int k, vector < int >& nums, vector < int >& curr) { if (curr.size() == k) { for ( int c : curr) printf( \"%d \" , c); cout << endl; return ; } if (idx == nums.size()) return ; curr.push_back(nums[idx]); findSubset(idx + 1 , k, nums, curr); curr.pop_back(); // revoke back findSubset(idx + 1 , k, nums, curr); } void solve (vector < int >& nums, int k) { vector < int > curr; findSubset( 0 , k, nums, curr); } int main () { int n, k; cin >> n >> k; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num, k); return 0 ; } Insert whitespaces into string \u00b6 Should print all the configurations Same logic as subset problem, now you have word.size() branches and each branch can either choose add or not add character to the current configuration. maintain a sliding window which contains previous 6 elements. for each iterations, check position from current position to i - 5 elements, if they are all space, don't add , or add space . Graph 2 \u00b6 Parenthesis Problem \u00b6 P1: ()()() given the provided parenthesis, find all valid permutations. \u00b6 vector < string > res; void helper ( int open, int close, int total, string & curr) { if (curr.size() == total * 2 ) { res.push_back(curr); return ; } if (close < open) helper(open, close + 1 , total, curr + ')' ); if (open < total) helper(open + 1 , close, total, curr + '(' ); } vector < string > solve( int c) { string curr; helper( 0 , 0 , c, curr); return res; } what if? vector < string > res; bool checkIfValid (string & curr) { // do the check for if open // and close parentheses are the same amount stack < char > st; for ( char c : s) { if (st.empty() || c == '(' ) st.push(c); else st.pop(); } return st.empty(); } void helper ( int open, int close, int total, string & curr) { if (checkIfValid(curr) == false ) return ; if (curr.size() == total * 2 ) { res.push_back(curr); return ; } helper(open, close + 1 , total, curr + ')' ); helper(open + 1 , close, total, curr + '(' ); } vector < string > solve( int c) { string curr; helper( 0 , 0 , c, curr); return res; } ans: it will work but DON'T do check in BASE case! (unnecessary overhead) P2: given ((()) find how many more (minimal) parenthese to be added to make it valid \u00b6 int solve (string & s) { stack < char > st; for ( char c : s) { if (st.empty() || c == '(' ) st.push(c); // only pop if can make into a pair else if (st.top() == '(' ) st.pop(); } return st.size(); } public int solve (String s){ Deque < Character > stack = new ArrayDeque <> (); int count = 0 ; for ( char c : s. toCharArray ()){ if (c == '(' ){ stack. offerFirst (c); } else { if (stack. isEmpty ()){ count ++ ; } else { stack. pollFirst (); } } } return count + stack. size (); } P3: given a string contains {}, try to find the minimal number of curly braces that are needed to be reversed to make it valid \u00b6 check this link 1. {} -> 0 2. {}}{ -> 2 3. {}} -> -1 (not possible) int solve (string s) { stack < char > st; for ( char c : s) { if (st.empty() || c == '(' ) st.push(c); // only pop if can make into a pair else if (st.top() == '(' ) st.pop(); } // not possible if (st.size() % 2 == 1 ) return -1 ; if (st.empty()) return 0 ; int cnt = 0 ; while ( ! st.empty() && st.top() == '(' ) { st.pop(); cnt ++ ; } // open and close not match in size if (st.size() != cnt) return -1 ; return st.size(); } P4: followup for P3, what if we can use []{}() ? \u00b6 ans: use a map to set the mappings, where the key is opening bracket, and value is closing bracket. P5: split array into k subarray s.t. each subarray shares the same sum. \u00b6 here and here vector < vector < vector < int >>> res; void helper (vector < vector < int >>& sol, vector < int >& curr, int sum, int target, int idx, int level, vector < int >& nums) { if (level == 0 ) { res.push_back(sol); return ; } if (idx >= nums.size()) return ; while (sum < target) { curr.push_back(nums[idx]); helper(sol, curr, sum + nums[idx], target, idx + 1 , level - 1 , nums); curr.pop_back(); helper(sol, curr, sum, target, idx + 1 , level - 1 , nums); } // now move on to next subarray if (sum == target) { vector < int > newCurr; sol.push_back(curr); helper(sol, newCurr, 0 , target, idx + 1 , level - 1 , nums); sol.pop_back(); } } vector < vector < vector < int >>> solve(vector < int >& nums, int k) { int m = nums.size(), n = nums[ 0 ].size(); int sum = accumlate(nums.begin(), nums.end(), 0 ); sum /= k; vector < vector < int >> sol; vector < int > curr; helper(sol, curr, 0 , sum, 0 , 0 , nums); return res; } public List < List < Integer >> solve ( int [] array, int k){ int sum = 0 ; for ( int a : array){ sum += a; } List < Integer > sol = new ArrayList <> (); List < List < Integer >> result = new ArrayList <> (); int target = sum / k; dfs(array, 0 , k,target, sol, result); return result; } private void dfs ( int [] array, int start, int k, int target, List < Integer > sol, List < List < Integer >> result){ if (start == array. length ){ if (sol. size () == k -1 ){ result. add (sol); } return ; } int sum = 0 ; for ( int i = start; i < array. length ; i ++ ){ sum += array [ i ] ; if (target == sum){ sol. add (i); dfs(array, i +1 , k, target, sol, result); sol. remove (sol. size () -1 ); } } }","title":"\u5348\u95f4\u8bfe\u5802"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#_1","text":"","title":"\u5348\u95f4\u8bfe\u5802"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#graph","text":"","title":"Graph"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#subset-problem","text":"Not asking for total number, but ask for each configuration. When each element can have only two possibability: count or not count, then it's a subset problem. void findSubset ( int idx, vector < int >& nums, vector < int >& curr) { if (idx == nums.size()) { cout << curr << endl; return ; } curr.push_back(nums[idx]); findSubset(idx + 1 , nums, curr); curr.pop_back(); // revoke back findSubset(idx + 1 , nums, curr); } void solve (vector < int >& nums) { vector < int > curr; findSubset( 0 , nums, curr); } Why cannot swap? curr.push_back(nums[idx]); findSubset(idx + 1 , nums, curr); curr.pop_back(); // revoke back findSubset(idx + 1 , nums, curr); cannot be: findSubset(idx + 1 , nums, curr); curr.push_back(nums[idx]); findSubset(idx + 1 , nums, curr); Answer: it will only push and not pop, so when finishing the recursion, the node will contain the previous character/number. Rule of thumb: push times == pop times","title":"Subset Problem"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#with-duplicate-elements","text":"each subset can have multiple same element e.g. given nums = {a, b1, b2, c} a: 0 or 1 b: 0, 1 or 2 c: 0 or 1 so there are 2 \\times 3 \\times 2 2 \\times 3 \\times 2 possible configurations the recusion tree will look like: a --- {a} | {} b ---{a} {a,b} {a,b,b} | {} {b} {b,b} c ---... vector < vector < int >> res; void dfs ( int idx, vector < int >& nums, vector < int >& curr) { if (idx == nums.size()) { res.push_back(curr); return ; } curr.push_back(nums[idx]); dfs(idx + 1 , nums, curr); curr.pop_back(); int next = idx; while (next < nums.size() && nums[next] == nums[idx]) next ++ ; dfs(next, nums, curr); } vector < vector < int >> subsetsWithDup(vector < int >& nums) { sort(nums.begin(), nums.end()); vector < int > curr; dfs( 0 , nums, curr); return res; }","title":"With duplicate elements"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#split-array-into-two-parts-st-each-part-sum-is-equal-to-the-other","text":"calculate the total sum then our target sum is sum / 2, our task is to find the combination #include <bits/stdc++.h> using namespace std; void helper (vector < int >& num, int idx, int sum, vector < int >& curr) { if (sum == 0 ) { for ( int c : curr) printf( \"%d \" , c); cout << endl; return ; } if (idx == num.size()) return ; curr.push_back(num[idx]); helper(num, idx + 1 , sum - num[idx], curr); curr.pop_back(); helper(num, idx + 1 , sum, curr); } void solve (vector < int >& nums) { int sum = 0 ; for ( int c : nums) sum += c; sum /= 2 ; vector < int > curr; helper(nums, 0 , sum, curr); } int main () { int n; cin >> n; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num); return 0 ; } Note: this code will check all the possible sum: e.g. given array 1, 1, 1, 1 -> 1, 1 | 1, 1 | 1, 1 | 1, 1 since these are all the valid configurations (different 1s though) To determine if possible (without enumerating all the configurations, which means you can terminate early): #include <bits/stdc++.h> using namespace std; bool helper (vector < int >& num, int idx, int sum, vector < int >& curr) { if (sum == 0 ) { for ( int c : curr) printf( \"%d \" , c); cout << endl; return true ; } if (idx == num.size()) return false ; curr.push_back(num[idx]); if (helper(num, idx + 1 , sum - num[idx], curr)) return true ; curr.pop_back(); if (helper(num, idx + 1 , sum, curr)) return true ; } void solve (vector < int >& nums) { int sum = 0 ; for ( int c : nums) sum += c; sum /= 2 ; vector < int > curr; helper(nums, 0 , sum, curr); } int main () { int n; cin >> n; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num); return 0 ; }","title":"Split array into two parts s.t. each part sum is equal to the other"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#variant-find-minimal-diff-for-the-two-subset-sum","text":"#include <bits/stdc++.h> using namespace std; int gDiff = INT_MAX; void helper (vector < int >& num, int idx, int curr, int sum) { if (idx == num.size()) return ; curr += num[idx]; gDiff = min(gDiff, abs((sum - curr) - curr)); helper(num, idx + 1 , curr, sum); curr -= num[idx]; helper(num, idx + 1 , curr, sum); } void solve (vector < int >& nums) { int sum = 0 ; for ( int c : nums) sum += c; vector < int > curr; helper(nums, 0 , 0 , sum); } int main () { int n; cin >> n; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num); cout << gDiff; return 0 ; } Note: we don't need to maintain a list to save current configuration, just use an int curr to keep track of the current sum is fine.","title":"Variant: find minimal diff for the two subset sum"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#find-all-combination-of-size-k","text":"assume no duplication base case: curr.size() == k #include <bits/stdc++.h> using namespace std; void findSubset ( int idx, int k, vector < int >& nums, vector < int >& curr) { if (curr.size() == k) { for ( int c : curr) printf( \"%d \" , c); cout << endl; return ; } if (idx == nums.size()) return ; curr.push_back(nums[idx]); findSubset(idx + 1 , k, nums, curr); curr.pop_back(); // revoke back findSubset(idx + 1 , k, nums, curr); } void solve (vector < int >& nums, int k) { vector < int > curr; findSubset( 0 , k, nums, curr); } int main () { int n, k; cin >> n >> k; vector < int > num(n); for ( int i = 0 ; i < n; ++ i) cin >> num[i]; solve(num, k); return 0 ; }","title":"Find all combination of size k"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#insert-whitespaces-into-string","text":"Should print all the configurations Same logic as subset problem, now you have word.size() branches and each branch can either choose add or not add character to the current configuration. maintain a sliding window which contains previous 6 elements. for each iterations, check position from current position to i - 5 elements, if they are all space, don't add , or add space .","title":"Insert whitespaces into string"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#graph-2","text":"","title":"Graph 2"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#parenthesis-problem","text":"","title":"Parenthesis Problem"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#p1-given-the-provided-parenthesis-find-all-valid-permutations","text":"vector < string > res; void helper ( int open, int close, int total, string & curr) { if (curr.size() == total * 2 ) { res.push_back(curr); return ; } if (close < open) helper(open, close + 1 , total, curr + ')' ); if (open < total) helper(open + 1 , close, total, curr + '(' ); } vector < string > solve( int c) { string curr; helper( 0 , 0 , c, curr); return res; } what if? vector < string > res; bool checkIfValid (string & curr) { // do the check for if open // and close parentheses are the same amount stack < char > st; for ( char c : s) { if (st.empty() || c == '(' ) st.push(c); else st.pop(); } return st.empty(); } void helper ( int open, int close, int total, string & curr) { if (checkIfValid(curr) == false ) return ; if (curr.size() == total * 2 ) { res.push_back(curr); return ; } helper(open, close + 1 , total, curr + ')' ); helper(open + 1 , close, total, curr + '(' ); } vector < string > solve( int c) { string curr; helper( 0 , 0 , c, curr); return res; } ans: it will work but DON'T do check in BASE case! (unnecessary overhead)","title":"P1: ()()() given the provided parenthesis, find all valid permutations."},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#p2-given-find-how-many-more-minimal-parenthese-to-be-added-to-make-it-valid","text":"int solve (string & s) { stack < char > st; for ( char c : s) { if (st.empty() || c == '(' ) st.push(c); // only pop if can make into a pair else if (st.top() == '(' ) st.pop(); } return st.size(); } public int solve (String s){ Deque < Character > stack = new ArrayDeque <> (); int count = 0 ; for ( char c : s. toCharArray ()){ if (c == '(' ){ stack. offerFirst (c); } else { if (stack. isEmpty ()){ count ++ ; } else { stack. pollFirst (); } } } return count + stack. size (); }","title":"P2: given ((()) find how many more (minimal) parenthese to be added to make it valid"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#p3-given-a-string-contains-try-to-find-the-minimal-number-of-curly-braces-that-are-needed-to-be-reversed-to-make-it-valid","text":"check this link 1. {} -> 0 2. {}}{ -> 2 3. {}} -> -1 (not possible) int solve (string s) { stack < char > st; for ( char c : s) { if (st.empty() || c == '(' ) st.push(c); // only pop if can make into a pair else if (st.top() == '(' ) st.pop(); } // not possible if (st.size() % 2 == 1 ) return -1 ; if (st.empty()) return 0 ; int cnt = 0 ; while ( ! st.empty() && st.top() == '(' ) { st.pop(); cnt ++ ; } // open and close not match in size if (st.size() != cnt) return -1 ; return st.size(); }","title":"P3: given a string contains {}, try to find the minimal number of curly braces that are needed to be reversed to make it valid"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#p4-followup-for-p3-what-if-we-can-use","text":"ans: use a map to set the mappings, where the key is opening bracket, and value is closing bracket.","title":"P4: followup for P3, what if we can use []{}()?"},{"location":"Interview/%E5%8D%88%E9%97%B4%E8%AF%BE%E5%A0%82/#p5-split-array-into-k-subarray-st-each-subarray-shares-the-same-sum","text":"here and here vector < vector < vector < int >>> res; void helper (vector < vector < int >>& sol, vector < int >& curr, int sum, int target, int idx, int level, vector < int >& nums) { if (level == 0 ) { res.push_back(sol); return ; } if (idx >= nums.size()) return ; while (sum < target) { curr.push_back(nums[idx]); helper(sol, curr, sum + nums[idx], target, idx + 1 , level - 1 , nums); curr.pop_back(); helper(sol, curr, sum, target, idx + 1 , level - 1 , nums); } // now move on to next subarray if (sum == target) { vector < int > newCurr; sol.push_back(curr); helper(sol, newCurr, 0 , target, idx + 1 , level - 1 , nums); sol.pop_back(); } } vector < vector < vector < int >>> solve(vector < int >& nums, int k) { int m = nums.size(), n = nums[ 0 ].size(); int sum = accumlate(nums.begin(), nums.end(), 0 ); sum /= k; vector < vector < int >> sol; vector < int > curr; helper(sol, curr, 0 , sum, 0 , 0 , nums); return res; } public List < List < Integer >> solve ( int [] array, int k){ int sum = 0 ; for ( int a : array){ sum += a; } List < Integer > sol = new ArrayList <> (); List < List < Integer >> result = new ArrayList <> (); int target = sum / k; dfs(array, 0 , k,target, sol, result); return result; } private void dfs ( int [] array, int start, int k, int target, List < Integer > sol, List < List < Integer >> result){ if (start == array. length ){ if (sol. size () == k -1 ){ result. add (sol); } return ; } int sum = 0 ; for ( int i = start; i < array. length ; i ++ ){ sum += array [ i ] ; if (target == sum){ sol. add (i); dfs(array, i +1 , k, target, sol, result); sol. remove (sol. size () -1 ); } } }","title":"P5: split array into k subarray s.t. each subarray shares the same sum."},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/","text":"\u6bcf\u65e5\u6253\u5361 \u00b6 5.26 Consider a hash table of size seven, with starting index zero, and a hash function (7x+3) mod 4. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing ? Here \u201c__\u201d denotes an empty location in the table. _ 1 _ _ 3 _ 1 _ _ 3 _ 1 8 _ _ 3 10 1 8 _ _ _ 5.25 To implement Dijkstra\u2019s shortest path algorithm on unweighted graphs so that it runs in linear time, the data structure to be used is\uff1f Priority Queue 5.24 When do we consider using dynamic programming? For problem that can be solved by dividing problems to sub problems, where results of sub problems can be reused. It can be solved by recursion method but recursion here is sometimes not ideal in time complexity (too many overlapping a). Since the results can be reused. DP provides a way to record and reuse the results from previous solved sub problems, which greatly reduce the time complexity. 5.23 Analysis Complexity 5.22 Check output 5.21 Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix. 5.20 What does final mean in Java? What does finally mean in Java? final is a keyword that once a field/method/class has been designed, it\u2019s unchangeable and un override-able. Finally is a block that always executed when the try block exits. 5.19 What is dependency injection\uff1f https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/ 5.18 What are the differences between overload and override? 1). The real object type in the run-time, not the reference variable's type, determines which overridden method is used at runtime. In contrast, reference type determines which overloaded method will be used at compile time. 2). Polymorphism applies to overriding, not to overloading. 3). Overriding is a run-time concept while overloading is a compile-time concept. 5.17 Which class does all the Enums directly extend? All enums extend java.lang.Enum. Enum cannot extend any other class. 5.16 Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than that of array. Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity? \u6536\u5230\u5927\u5bb6\u7684\u6253\u5361\u5566~\u6628\u5929\u57fa\u7840\u9898\u7684\u7b54\u6848\u662f Heap Sort\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nLogk) create a Min heap \uff0c\u6700\u5c0f\u5143\u7d20\u5728\u7b2ck+1\u4f4d\u7f6e\uff0c\u6392\u5e8f\u6574\u4e2aarray\uff0co(k)\u5efa\u7acb\u4e00\u4e2amin heap,O(n-k)logk\u5bf9\u4e8e\u5269\u4f59\u5143\u7d20\uff0cO1\u4ecemin heap\u4e2d\u53d6\u51fa\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6nlogk 5.15 What is OOPS? Could you name some important OOPS features in Java? Object Oriented Programing ,like java, is different from Process Oriented programing, like C. More focus on the object itself rather running process. we can bind the data and the function methods together in the object. Program become more flexible. Important features like inheritance, abstraction, polymorphism, Encapsulation and so on. 5.14 In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child? \u55ef\u55ef\uff0c\u6bcf\u4e2anode\u7684child\u90fd\u662f2\u4e2a\uff0c\u90a3node\u7684descendent\u5c31\u4f1a\u662f0\uff0c2\uff0c4\uff0c6 and so on \u5982\u679c\u8981\u8bc1\u660e\u7684\u8bdd\uff0c\u53ef\u4ee5\u7528\u53cd\u6b63\u6cd5\uff1a\u82e5\u5b58\u5728\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9X\uff0c\u5047\u8bbeX->right=NULL\uff0c\u90a3\u4e48\u7531\u4e8eX\u548cX->left\u7684descendent\u6570\u76ee\u5747\u8981\u4e3a\u5947\u6570\uff0c\u4f46\u8fd9\u4e24\u4e2a\u503c\u53ea\u5dee1\uff0c\u56e0\u6b64\u77db\u76fe 5.13 What are the differences between traversing a graph and traversing a tree? tree \u7684\u904d\u5386\u53ef\u4ee5\u7528 pre-order, in-order, post-order, level-order, \u524d\u4e09\u79cd\u90fd\u53ef\u4ee5\u7528 dfs \u6765\u5b9e\u73b0\uff0c\u6700\u540e\u4e00\u79cd\u7528 bfs\u3002graph \u7684\u904d\u5386\u4e5f\u53ef\u4ee5\u7528 dfs \u6216\u8005 bfs\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f graph \u4e2d\u53ef\u80fd\u6709\u975e\u8fde\u901a\u533a\u57df\uff0c\u9700\u8981\u4ee5\u6bcf\u4e2a\u8282\u70b9\u4e3a\u8d77\u59cb\u6765\u505a\u4e00\u904d bfs/dfs\uff0c\u5f53\u7136\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b deduplicate \u673a\u5236\u6765\u907f\u514d\u91cd\u590d 5.12 An unordered list contains n distinct elements. What is number of comparisons to find an element in this list that is neither maximum nor minimum? worst case\u662f3\u6b21 \u590d\u6742\u5ea6\u662f\u0398(1) \u9700\u8981\u8ba8\u8bban!=length\u7684case 5.26 Alien Dictionary https://app.laicode.io/app/problem/501 5.25 Merge Stones https://app.laicode.io/app/problem/96 5.24 Edit Distance https://app.laicode.io/app/problem/100 5.23 Largest Rectangle Of 1s https://app.laicode.io/app/problem/102 5.22 Depth Of Forest https://app.laicode.io/app/problem/323 5.21 Walls and gates https://app.laicode.io/app/problem/503 5.20 All Permutations II https://app.laicode.io/app/problem/65 5.19 Restore IP Addresses https://app.laicode.io/app/problem/147 5.18 Longest Substring With K Typed Characters https://app.laicode.io/app/problem/285 5.17 Compress String https://app.laicode.io/app/problem/173 StringBuilder in Java 5.16 Distance Of Two Nodes In Binary Tree https://app.laicode.io/app/problem/299 LCA 5.15 Longest Ascending Path Binary Tree https://app.laicode.io/app/problem/388 tree height 5.14 Merge Sort Linked List https://app.laicode.io/app/problem/29 5.13 Search In Bitonic Array https://app.laicode.io/app/problem/401 bst 5.12 Largest Container https://app.laicode.io/app/problem/201 Longest Substring With K Typed Characters \u00b6 Given a string, return the longest contiguous substring that contains exactly k type of characters. Return null if there does not exist such substring. Assumptions: The given string is not null and guaranteed to have at least k different characters. k > 0. Examples: input = \"aabcc\", k = 3, output = \"aabcc\". input = \"aabcccc\", k = 2, output = \"bcccc\". Analysis \u00b6 Using sliding window to search and update the current longest string: dabaaebac: l = 0, r = 0, cnt = 0, len = 9 l = 0, r = 7: dabaaeba Code \u00b6 class Solution { public : string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt <= k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt <= k && len < r - l) { // cnt is valid len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // cnt is invalid len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } };","title":"\u6bcf\u65e5\u6253\u5361"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#_1","text":"5.26 Consider a hash table of size seven, with starting index zero, and a hash function (7x+3) mod 4. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing ? Here \u201c__\u201d denotes an empty location in the table. _ 1 _ _ 3 _ 1 _ _ 3 _ 1 8 _ _ 3 10 1 8 _ _ _ 5.25 To implement Dijkstra\u2019s shortest path algorithm on unweighted graphs so that it runs in linear time, the data structure to be used is\uff1f Priority Queue 5.24 When do we consider using dynamic programming? For problem that can be solved by dividing problems to sub problems, where results of sub problems can be reused. It can be solved by recursion method but recursion here is sometimes not ideal in time complexity (too many overlapping a). Since the results can be reused. DP provides a way to record and reuse the results from previous solved sub problems, which greatly reduce the time complexity. 5.23 Analysis Complexity 5.22 Check output 5.21 Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix. 5.20 What does final mean in Java? What does finally mean in Java? final is a keyword that once a field/method/class has been designed, it\u2019s unchangeable and un override-able. Finally is a block that always executed when the try block exits. 5.19 What is dependency injection\uff1f https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/ 5.18 What are the differences between overload and override? 1). The real object type in the run-time, not the reference variable's type, determines which overridden method is used at runtime. In contrast, reference type determines which overloaded method will be used at compile time. 2). Polymorphism applies to overriding, not to overloading. 3). Overriding is a run-time concept while overloading is a compile-time concept. 5.17 Which class does all the Enums directly extend? All enums extend java.lang.Enum. Enum cannot extend any other class. 5.16 Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than that of array. Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity? \u6536\u5230\u5927\u5bb6\u7684\u6253\u5361\u5566~\u6628\u5929\u57fa\u7840\u9898\u7684\u7b54\u6848\u662f Heap Sort\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nLogk) create a Min heap \uff0c\u6700\u5c0f\u5143\u7d20\u5728\u7b2ck+1\u4f4d\u7f6e\uff0c\u6392\u5e8f\u6574\u4e2aarray\uff0co(k)\u5efa\u7acb\u4e00\u4e2amin heap,O(n-k)logk\u5bf9\u4e8e\u5269\u4f59\u5143\u7d20\uff0cO1\u4ecemin heap\u4e2d\u53d6\u51fa\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6nlogk 5.15 What is OOPS? Could you name some important OOPS features in Java? Object Oriented Programing ,like java, is different from Process Oriented programing, like C. More focus on the object itself rather running process. we can bind the data and the function methods together in the object. Program become more flexible. Important features like inheritance, abstraction, polymorphism, Encapsulation and so on. 5.14 In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child? \u55ef\u55ef\uff0c\u6bcf\u4e2anode\u7684child\u90fd\u662f2\u4e2a\uff0c\u90a3node\u7684descendent\u5c31\u4f1a\u662f0\uff0c2\uff0c4\uff0c6 and so on \u5982\u679c\u8981\u8bc1\u660e\u7684\u8bdd\uff0c\u53ef\u4ee5\u7528\u53cd\u6b63\u6cd5\uff1a\u82e5\u5b58\u5728\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9X\uff0c\u5047\u8bbeX->right=NULL\uff0c\u90a3\u4e48\u7531\u4e8eX\u548cX->left\u7684descendent\u6570\u76ee\u5747\u8981\u4e3a\u5947\u6570\uff0c\u4f46\u8fd9\u4e24\u4e2a\u503c\u53ea\u5dee1\uff0c\u56e0\u6b64\u77db\u76fe 5.13 What are the differences between traversing a graph and traversing a tree? tree \u7684\u904d\u5386\u53ef\u4ee5\u7528 pre-order, in-order, post-order, level-order, \u524d\u4e09\u79cd\u90fd\u53ef\u4ee5\u7528 dfs \u6765\u5b9e\u73b0\uff0c\u6700\u540e\u4e00\u79cd\u7528 bfs\u3002graph \u7684\u904d\u5386\u4e5f\u53ef\u4ee5\u7528 dfs \u6216\u8005 bfs\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f graph \u4e2d\u53ef\u80fd\u6709\u975e\u8fde\u901a\u533a\u57df\uff0c\u9700\u8981\u4ee5\u6bcf\u4e2a\u8282\u70b9\u4e3a\u8d77\u59cb\u6765\u505a\u4e00\u904d bfs/dfs\uff0c\u5f53\u7136\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b deduplicate \u673a\u5236\u6765\u907f\u514d\u91cd\u590d 5.12 An unordered list contains n distinct elements. What is number of comparisons to find an element in this list that is neither maximum nor minimum? worst case\u662f3\u6b21 \u590d\u6742\u5ea6\u662f\u0398(1) \u9700\u8981\u8ba8\u8bban!=length\u7684case 5.26 Alien Dictionary https://app.laicode.io/app/problem/501 5.25 Merge Stones https://app.laicode.io/app/problem/96 5.24 Edit Distance https://app.laicode.io/app/problem/100 5.23 Largest Rectangle Of 1s https://app.laicode.io/app/problem/102 5.22 Depth Of Forest https://app.laicode.io/app/problem/323 5.21 Walls and gates https://app.laicode.io/app/problem/503 5.20 All Permutations II https://app.laicode.io/app/problem/65 5.19 Restore IP Addresses https://app.laicode.io/app/problem/147 5.18 Longest Substring With K Typed Characters https://app.laicode.io/app/problem/285 5.17 Compress String https://app.laicode.io/app/problem/173 StringBuilder in Java 5.16 Distance Of Two Nodes In Binary Tree https://app.laicode.io/app/problem/299 LCA 5.15 Longest Ascending Path Binary Tree https://app.laicode.io/app/problem/388 tree height 5.14 Merge Sort Linked List https://app.laicode.io/app/problem/29 5.13 Search In Bitonic Array https://app.laicode.io/app/problem/401 bst 5.12 Largest Container https://app.laicode.io/app/problem/201","title":"\u6bcf\u65e5\u6253\u5361"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#longest-substring-with-k-typed-characters","text":"Given a string, return the longest contiguous substring that contains exactly k type of characters. Return null if there does not exist such substring. Assumptions: The given string is not null and guaranteed to have at least k different characters. k > 0. Examples: input = \"aabcc\", k = 3, output = \"aabcc\". input = \"aabcccc\", k = 2, output = \"bcccc\".","title":"Longest Substring With K Typed Characters"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#analysis","text":"Using sliding window to search and update the current longest string: dabaaebac: l = 0, r = 0, cnt = 0, len = 9 l = 0, r = 7: dabaaeba","title":"Analysis"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#code","text":"class Solution { public : string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt <= k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt <= k && len < r - l) { // cnt is valid len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // cnt is invalid len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } };","title":"Code"},{"location":"Java/Serialization/","text":"Compare two Files containing two integer Complete the method below to read two integers from the input file, compare them, and write true or false into the output file based on whether the values are the same or not. // inputFile: path to input file; outputFile: path to output file public void compareValues (String inputFile, String outputFile) { Scanner scan = null ; PrintWriter pw = null ; try { scan = new Scanner( new FileReader(inputFile)); int num1 = scan. nextInt (); int num2 = scan. nextInt (); pw = new PrintWriter( new FileWriter(outputFile)); if (num1 == num2) { pw. println ( \"true\" ); } else { pw. println ( \"false\" ); } } catch (FileNotFoundException fnfe) { System. out . println ( \"fnfe: \" + fnfe. getMessage ()); } catch (IOException ioe) { System. out . println ( \"ioe: \" + ioe. getMessage ()); } finally { if (pw != null ) { pw. close (); } if (scan != null ) { scan. close (); } } } Scanner takes in a FileReader instannce FileReader takes in a path string ChatRoom Practice -- Serialization in network \u00b6 main thread for connection, and each thread with each client PrintWriter for printing string","title":"Serialization"},{"location":"Java/Serialization/#chatroom-practice-serialization-in-network","text":"main thread for connection, and each thread with each client PrintWriter for printing string","title":"ChatRoom Practice -- Serialization in network"},{"location":"Java/array%2C-class-and-objects/","text":"Useful notes and codes for Java \u00b6 1D/2D Array constructor initialization read/write length/dimension traversal Main Function public static void main(String[] args) signacture OOD or OOP class, object, reference, dereference Student tom = new Student(\"Tom\", 5, 4.0); Declaration Instantiation Initialization Assignment Array \u00b6 1-D array \u00b6 create: int[] array = new int[10]; once create, size cannot be modified int [] numbers = new int [] { 1 , 2 , 3 , 4 }; int num = numbers [2] ; number [4] = 15 ; int size = numbers. length ; for ( int index = 0 ; index < number. length ; ++ index) {} for ( int num : numbers) {} Max value \u00b6 Integer. MAX_VALUE Integer. MIN_VALUE Insert \u00b6 public int [] reverse ( int [] arr) { int [] new_arr = new int [ arr. length - 1] ; for ( int i = 0 ; i < position; ++ i) { new_arr [ i ] = arr [ i ] ; } new_arr [ position ] = element; for ( int i = position; i < arr. length ; ++ i) { new_arr [ i + 1] = arr [ i ] ; } return new_arr; } Reverse Array \u00b6 swap public int [] reverse ( int [] arr) { int i = 0 , j = arr. length - 1 ; while (i < j) { int tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp; i ++ , j -- ; } return arr; } 2-D Array \u00b6 create \u00b6 int [][] matrix = new int [][] {{ 2 , 1 },{ 4 , 7 },{ 5 , 9 }}; int [] firstRow = matrix [0] ; int firstElementOfSecondRow = matrix [1][0] ; int rows = matrix. length ; // (row = 3 because the array has 3 elements) int cols = matrix [0] . length ; calculate \"g\": the diagonal -- has to be square matrix \u00b6 public int [] reverse ( int [][] matrix) { int g = 0 ; for ( int i = 0 ; i < matrix. length ; ++ i) { g += matrix [ i ][ i ] ; } return g; } calculate sum of two matrix -- has to be same dimension \u00b6 public int [][] reverse ( int [][] matrix1, int [][] matrix2) { int row = matrix1. length ; int col = matrix1 [0] . length ; int [][] result = new int [][] ; for ( int i = 0 ; i < row; ++ i) { for ( int j = 0 ; j < col; ++ j) { result [ i ][ j ] = matrix1 [ i ][ j ] + matrix2 [ i ][ j ] ; } } return result; } Main Function \u00b6 public static void main (String [] args) { System. out . println ( \"hello world.\" ); } OOD or OOP \u00b6 Memory Layout \u00b6 Stack: local variable (in function or scope) Heap: all the object","title":"Useful notes and codes for Java"},{"location":"Java/array%2C-class-and-objects/#useful-notes-and-codes-for-java","text":"1D/2D Array constructor initialization read/write length/dimension traversal Main Function public static void main(String[] args) signacture OOD or OOP class, object, reference, dereference Student tom = new Student(\"Tom\", 5, 4.0); Declaration Instantiation Initialization Assignment","title":"Useful notes and codes for Java"},{"location":"Java/array%2C-class-and-objects/#array","text":"","title":"Array"},{"location":"Java/array%2C-class-and-objects/#1-d-array","text":"create: int[] array = new int[10]; once create, size cannot be modified int [] numbers = new int [] { 1 , 2 , 3 , 4 }; int num = numbers [2] ; number [4] = 15 ; int size = numbers. length ; for ( int index = 0 ; index < number. length ; ++ index) {} for ( int num : numbers) {}","title":"1-D array"},{"location":"Java/array%2C-class-and-objects/#max-value","text":"Integer. MAX_VALUE Integer. MIN_VALUE","title":"Max value"},{"location":"Java/array%2C-class-and-objects/#insert","text":"public int [] reverse ( int [] arr) { int [] new_arr = new int [ arr. length - 1] ; for ( int i = 0 ; i < position; ++ i) { new_arr [ i ] = arr [ i ] ; } new_arr [ position ] = element; for ( int i = position; i < arr. length ; ++ i) { new_arr [ i + 1] = arr [ i ] ; } return new_arr; }","title":"Insert"},{"location":"Java/array%2C-class-and-objects/#reverse-array","text":"swap public int [] reverse ( int [] arr) { int i = 0 , j = arr. length - 1 ; while (i < j) { int tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp; i ++ , j -- ; } return arr; }","title":"Reverse Array"},{"location":"Java/array%2C-class-and-objects/#2-d-array","text":"","title":"2-D Array"},{"location":"Java/array%2C-class-and-objects/#create","text":"int [][] matrix = new int [][] {{ 2 , 1 },{ 4 , 7 },{ 5 , 9 }}; int [] firstRow = matrix [0] ; int firstElementOfSecondRow = matrix [1][0] ; int rows = matrix. length ; // (row = 3 because the array has 3 elements) int cols = matrix [0] . length ;","title":"create"},{"location":"Java/array%2C-class-and-objects/#calculate-g-the-diagonal-has-to-be-square-matrix","text":"public int [] reverse ( int [][] matrix) { int g = 0 ; for ( int i = 0 ; i < matrix. length ; ++ i) { g += matrix [ i ][ i ] ; } return g; }","title":"calculate \"g\": the diagonal -- has to be square matrix"},{"location":"Java/array%2C-class-and-objects/#calculate-sum-of-two-matrix-has-to-be-same-dimension","text":"public int [][] reverse ( int [][] matrix1, int [][] matrix2) { int row = matrix1. length ; int col = matrix1 [0] . length ; int [][] result = new int [][] ; for ( int i = 0 ; i < row; ++ i) { for ( int j = 0 ; j < col; ++ j) { result [ i ][ j ] = matrix1 [ i ][ j ] + matrix2 [ i ][ j ] ; } } return result; }","title":"calculate sum of two matrix -- has to be same dimension"},{"location":"Java/array%2C-class-and-objects/#main-function","text":"public static void main (String [] args) { System. out . println ( \"hello world.\" ); }","title":"Main Function"},{"location":"Java/array%2C-class-and-objects/#ood-or-oop","text":"","title":"OOD or OOP"},{"location":"Java/array%2C-class-and-objects/#memory-layout","text":"Stack: local variable (in function or scope) Heap: all the object","title":"Memory Layout"},{"location":"Java/common-problem/","text":"Java pass-by-value \u00b6 reassignment int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b = new int [] { 2 }; // if print a, it will output 1 int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b [0] = 2 ; // if print a, it will output 2 pass in as parameter // anything \"new\" in function will stay local and will not modify the outter scope variable public void reassign ( int [] array) { array = new int [] { 2 }; } public void modify ( int [] array) { array [0] = 2 ; } public int [] returnArray ( int [] array) { array = new int [] { 2 }; return array; } public void foo ( int [] array) { array [0] = 2 ; // output this value 2 array = new int [] { 3 }; array [0] = 4 ; } public void foo2 ( int [] array) { array [0] = 2 ; array [0] = 4 ; // output 4 array = new int [] { 3 }; } public static void main (String [] args) { int [] array = new int [] { 1 }; reassign(array); //what\u2019s the result? 1 modify(array); //what\u2019s the result? 2 (ignore previous statement) array = returnArray(array); //what\u2019s the result? 2 (ignore previous statement) } debug \u00b6 public class Solution { public void reverse ( int [] array) { int [] array1 = new int [ array. length ] ; for ( int i =0 ; i < array. length ; i = i +1 ) { array1 [ i ]= array [ array. length -1- i ] ; } array = array1; // Write your solution here } Problem: Give an array list of integer, calculate the sum of squares of all its elements. Note: return 0 if the list is null or empty. Example: list = {1,2,3} \u2192 returns 14 (14=1 1+2 2+3*3) public class Solution { public int sumOfSquare (List < Integer > list) { if (list == null || list. isEmpty ()) { return 0 ; } int sum = 0 ; for ( int i = 0 ; i < list. size (); i ++ ) { sum += list. get (i) * list. get (i); } return sum; } Misc \u00b6 String s = 4 + \"aa\"; // will print 4aa, because 4.toString() + \"aa\", however it won't work in c++ low -> high precision: will cast implicitly (no need to add (long) for example). high -> low precision: need explict cast","title":"Common problem"},{"location":"Java/common-problem/#java-pass-by-value","text":"reassignment int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b = new int [] { 2 }; // if print a, it will output 1 int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b [0] = 2 ; // if print a, it will output 2 pass in as parameter // anything \"new\" in function will stay local and will not modify the outter scope variable public void reassign ( int [] array) { array = new int [] { 2 }; } public void modify ( int [] array) { array [0] = 2 ; } public int [] returnArray ( int [] array) { array = new int [] { 2 }; return array; } public void foo ( int [] array) { array [0] = 2 ; // output this value 2 array = new int [] { 3 }; array [0] = 4 ; } public void foo2 ( int [] array) { array [0] = 2 ; array [0] = 4 ; // output 4 array = new int [] { 3 }; } public static void main (String [] args) { int [] array = new int [] { 1 }; reassign(array); //what\u2019s the result? 1 modify(array); //what\u2019s the result? 2 (ignore previous statement) array = returnArray(array); //what\u2019s the result? 2 (ignore previous statement) }","title":"Java pass-by-value"},{"location":"Java/common-problem/#debug","text":"public class Solution { public void reverse ( int [] array) { int [] array1 = new int [ array. length ] ; for ( int i =0 ; i < array. length ; i = i +1 ) { array1 [ i ]= array [ array. length -1- i ] ; } array = array1; // Write your solution here } Problem: Give an array list of integer, calculate the sum of squares of all its elements. Note: return 0 if the list is null or empty. Example: list = {1,2,3} \u2192 returns 14 (14=1 1+2 2+3*3) public class Solution { public int sumOfSquare (List < Integer > list) { if (list == null || list. isEmpty ()) { return 0 ; } int sum = 0 ; for ( int i = 0 ; i < list. size (); i ++ ) { sum += list. get (i) * list. get (i); } return sum; }","title":"debug"},{"location":"Java/common-problem/#misc","text":"String s = 4 + \"aa\"; // will print 4aa, because 4.toString() + \"aa\", however it won't work in c++ low -> high precision: will cast implicitly (no need to add (long) for example). high -> low precision: need explict cast","title":"Misc"},{"location":"Java/comparison-with-other-languages/","text":"Difference between C++ \u00b6 Platform compatible, write once, compile once, run everywhere on JVM C++: write once, compile everywhere vs Java: write once, compile once What is JVM? Java Virtual Machine JRE vs JDK JRE (Java Runtime Environment) is the JVM program, Java application need to run on JRE JDK contains the tools for developing Java programs running on JRE, for example, it provides the compiler \"javac\"","title":"Comparison with other languages"},{"location":"Java/comparison-with-other-languages/#difference-between-c","text":"Platform compatible, write once, compile once, run everywhere on JVM C++: write once, compile everywhere vs Java: write once, compile once What is JVM? Java Virtual Machine JRE vs JDK JRE (Java Runtime Environment) is the JVM program, Java application need to run on JRE JDK contains the tools for developing Java programs running on JRE, for example, it provides the compiler \"javac\"","title":"Difference between C++"},{"location":"Java/control-flow-and-methods/","text":"Method overloading \u00b6 method name is the same, but parameter type list is different 1. different types 2. different num of parameters 3. different order Notes \u00b6 return type cannot be used to identify which function to use \u00b6 public class test { public static int add ( double a, double b) { return ( int ) (a + b); } public static double add ( double a, double b) { return (a + b); } public static void main (String [] args) { double a = 1.3 , b = 2.4 ; // int c = add(a, b); System. out . println (add(a, b)); } }","title":"Control flow and methods"},{"location":"Java/control-flow-and-methods/#method-overloading","text":"method name is the same, but parameter type list is different 1. different types 2. different num of parameters 3. different order","title":"Method overloading"},{"location":"Java/control-flow-and-methods/#notes","text":"","title":"Notes"},{"location":"Java/control-flow-and-methods/#return-type-cannot-be-used-to-identify-which-function-to-use","text":"public class test { public static int add ( double a, double b) { return ( int ) (a + b); } public static double add ( double a, double b) { return (a + b); } public static void main (String [] args) { double a = 1.3 , b = 2.4 ; // int c = add(a, b); System. out . println (add(a, b)); } }","title":"return type cannot be used to identify which function to use"},{"location":"Java/primitive-types-and-basic-operations/","text":"Primitive Types \u00b6 char 2 bytes 2's complement \u00b6 flip all digit and +1 Default Value \u00b6 Instance field: 0 false null Local variable: not allow -> will throw compile exception","title":"Primitive types and basic operations"},{"location":"Java/primitive-types-and-basic-operations/#primitive-types","text":"char 2 bytes","title":"Primitive Types"},{"location":"Java/primitive-types-and-basic-operations/#2s-complement","text":"flip all digit and +1","title":"2's complement"},{"location":"Java/primitive-types-and-basic-operations/#default-value","text":"Instance field: 0 false null Local variable: not allow -> will throw compile exception","title":"Default Value"},{"location":"Java/tips/","text":"Min and Max value \u00b6 int: Integer.MAX_VALUE ( 2^{31} - 1 2^{31} - 1 ), Integer.MIN_VALUE ( -2^{31} -2^{31} ) Data structure \u00b6 Stack \u00b6 Deque < Integer > stack = new LinkedList < Integer > (); stack. isEmpty () stack. peekFirst () stack. pollFirst (); stack. offerFirst ( 1 ); String \u00b6 StringBuilder cur = new StringBuilder(); cur. append ( '(' ); cur. deleteCharAt (cur. length () - 1 ); // remove last char from the string String result = cur. toString ();","title":"Tips"},{"location":"Java/tips/#min-and-max-value","text":"int: Integer.MAX_VALUE ( 2^{31} - 1 2^{31} - 1 ), Integer.MIN_VALUE ( -2^{31} -2^{31} )","title":"Min and Max value"},{"location":"Java/tips/#data-structure","text":"","title":"Data structure"},{"location":"Java/tips/#stack","text":"Deque < Integer > stack = new LinkedList < Integer > (); stack. isEmpty () stack. peekFirst () stack. pollFirst (); stack. offerFirst ( 1 );","title":"Stack"},{"location":"Java/tips/#string","text":"StringBuilder cur = new StringBuilder(); cur. append ( '(' ); cur. deleteCharAt (cur. length () - 1 ); // remove last char from the string String result = cur. toString ();","title":"String"},{"location":"Leetcode/10.-regular-expression-matching/","text":"Regular Expression Matching \u00b6 Given an input string ( s ) and a pattern ( p ), implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\", p = \".*\" Output: true Explanation: \".*\" means \"zero or more (*) of any character (.)\". Example 4: Input: s = \"aab\", p = \"c*a*b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\", p = \"mis*is*p*.\" Output: false Constraints: 0 <= s.length <= 20 0 <= p.length <= 30 s contains only lowercase English letters. p contains only lowercase English letters, '.' , and '*' . It is guaranteed for each appearance of the character '*' , there will be a previous valid character to match. Analysis \u00b6 dp[i][j]: s[0:i] matches p[0:j] if p[i] == . then matches everything from s, so dp[i][j] = true if p[i] == * then if dp[i][j-2] (skip the last one and check if previous one matches) or s[i] == p[j-1] or p[j-1] (match anything) set dp[i][j] = true Code \u00b6 class Solution { public : bool isMatch(string s, string p) { int n = s.length(), m = p.length(); vector < vector < bool >> f(n + 1 , vector < bool > (m + 1 , false )); s = \" \" + s; p = \" \" + p; f[ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= n; i ++ ) for ( int j = 1 ; j <= m; j ++ ) { if (i > 0 && (s[i] == p[j] || p[j] == '.' )) f[i][j] = f[i - 1 ][j - 1 ]; if (p[j] == '*' ) { if (j >= 2 ) f[i][j] = f[i][j - 2 ]; if (i > 0 && (s[i] == p[j - 1 ] || p[j - 1 ] == '.' )) f[i][j] = f[i][j] | f[i - 1 ][j]; // if anything happened to set f[i][j] = true, here will ignore if f[i-1][j] ?= true } } return f[n][m]; } };","title":"Regular Expression Matching"},{"location":"Leetcode/10.-regular-expression-matching/#regular-expression-matching","text":"Given an input string ( s ) and a pattern ( p ), implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\", p = \".*\" Output: true Explanation: \".*\" means \"zero or more (*) of any character (.)\". Example 4: Input: s = \"aab\", p = \"c*a*b\" Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\". Example 5: Input: s = \"mississippi\", p = \"mis*is*p*.\" Output: false Constraints: 0 <= s.length <= 20 0 <= p.length <= 30 s contains only lowercase English letters. p contains only lowercase English letters, '.' , and '*' . It is guaranteed for each appearance of the character '*' , there will be a previous valid character to match.","title":"Regular Expression Matching"},{"location":"Leetcode/10.-regular-expression-matching/#analysis","text":"dp[i][j]: s[0:i] matches p[0:j] if p[i] == . then matches everything from s, so dp[i][j] = true if p[i] == * then if dp[i][j-2] (skip the last one and check if previous one matches) or s[i] == p[j-1] or p[j-1] (match anything) set dp[i][j] = true","title":"Analysis"},{"location":"Leetcode/10.-regular-expression-matching/#code","text":"class Solution { public : bool isMatch(string s, string p) { int n = s.length(), m = p.length(); vector < vector < bool >> f(n + 1 , vector < bool > (m + 1 , false )); s = \" \" + s; p = \" \" + p; f[ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= n; i ++ ) for ( int j = 1 ; j <= m; j ++ ) { if (i > 0 && (s[i] == p[j] || p[j] == '.' )) f[i][j] = f[i - 1 ][j - 1 ]; if (p[j] == '*' ) { if (j >= 2 ) f[i][j] = f[i][j - 2 ]; if (i > 0 && (s[i] == p[j - 1 ] || p[j - 1 ] == '.' )) f[i][j] = f[i][j] | f[i - 1 ][j]; // if anything happened to set f[i][j] = true, here will ignore if f[i-1][j] ?= true } } return f[n][m]; } };","title":"Code"},{"location":"Leetcode/1011.-Capacity-To-Ship-Packages-Within-D-Days/","text":"Capacity To Ship Packages Within D Days \u00b6 A conveyor belt has packages that must be shipped from one port to another within D days. The ith package on the conveyor belt has a weight of weights[i] . Each day, we load the ship with packages on the conveyor belt (in the order given by weights ). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days. Example 1: Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. Example 2: Input: weights = [3,2,2,4,1,4], D = 3 Output: 6 Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4 Example 3: Input: weights = [1,2,3,1,1], D = 4 Output: 3 Explanation: 1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1 Constraints: 1 <= D <= weights.length <= 5 * 104 1 <= weights[i] <= 500 Analysis \u00b6 Using brute-force we can solve it with C(n, D) \\approx O(n!) C(n, D) \\approx O(n!) , we essentially try all the slots between each two days, and see if we can put all the previous items (up to the last slot that we have picked) in a single conveyor. However, it will cause TLE. A better approach is not checking all the slots, but check all the possible capacity from max(weights) up to total(weights) . Then we can find the minimal capacity that will fullfill our requirement. By using binary search on the capacity, we can speed up the search. Note that this solution is optimal only when total weight is comparable in size of weight array. If max weight and the total weight are not very close and the total weight is much larger than max weight, the search space might be much larger than the burte-force solution. Also keep in mind instead of using 0 as the lower bound, we use max weight. It's just purely for the convenience of the possible() helper function. Time: O(\\log(\\sum(weight)) \\times n) O(\\log(\\sum(weight)) \\times n) , where n is the length of the weights array. Space: O(1) O(1) Code \u00b6 class Solution { public : bool inline possible( int cap, vector < int >& w, int D) { int curr = 0 , cnt = 1 ; for ( int i : w) { curr += i; // we never check the condition that if i > cap, which will return false if (curr > cap) { cnt ++ ; curr = i; } } return cnt <= D; } int shipWithinDays(vector < int >& w, int D) { int l = * max_element(w.begin(), w.end()), r = accumulate(w.begin(), w.end(), 0 ); while (l < r) { int cap = l + 0l l + r >> 1 ; if (possible(cap, w, D)) { r = cap; } else { l = cap + 1 ; } } return l; } };","title":"Capacity To Ship Packages Within D Days"},{"location":"Leetcode/1011.-Capacity-To-Ship-Packages-Within-D-Days/#capacity-to-ship-packages-within-d-days","text":"A conveyor belt has packages that must be shipped from one port to another within D days. The ith package on the conveyor belt has a weight of weights[i] . Each day, we load the ship with packages on the conveyor belt (in the order given by weights ). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days. Example 1: Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. Example 2: Input: weights = [3,2,2,4,1,4], D = 3 Output: 6 Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4 Example 3: Input: weights = [1,2,3,1,1], D = 4 Output: 3 Explanation: 1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1 Constraints: 1 <= D <= weights.length <= 5 * 104 1 <= weights[i] <= 500","title":"Capacity To Ship Packages Within D Days"},{"location":"Leetcode/1011.-Capacity-To-Ship-Packages-Within-D-Days/#analysis","text":"Using brute-force we can solve it with C(n, D) \\approx O(n!) C(n, D) \\approx O(n!) , we essentially try all the slots between each two days, and see if we can put all the previous items (up to the last slot that we have picked) in a single conveyor. However, it will cause TLE. A better approach is not checking all the slots, but check all the possible capacity from max(weights) up to total(weights) . Then we can find the minimal capacity that will fullfill our requirement. By using binary search on the capacity, we can speed up the search. Note that this solution is optimal only when total weight is comparable in size of weight array. If max weight and the total weight are not very close and the total weight is much larger than max weight, the search space might be much larger than the burte-force solution. Also keep in mind instead of using 0 as the lower bound, we use max weight. It's just purely for the convenience of the possible() helper function. Time: O(\\log(\\sum(weight)) \\times n) O(\\log(\\sum(weight)) \\times n) , where n is the length of the weights array. Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/1011.-Capacity-To-Ship-Packages-Within-D-Days/#code","text":"class Solution { public : bool inline possible( int cap, vector < int >& w, int D) { int curr = 0 , cnt = 1 ; for ( int i : w) { curr += i; // we never check the condition that if i > cap, which will return false if (curr > cap) { cnt ++ ; curr = i; } } return cnt <= D; } int shipWithinDays(vector < int >& w, int D) { int l = * max_element(w.begin(), w.end()), r = accumulate(w.begin(), w.end(), 0 ); while (l < r) { int cap = l + 0l l + r >> 1 ; if (possible(cap, w, D)) { r = cap; } else { l = cap + 1 ; } } return l; } };","title":"Code"},{"location":"Leetcode/1014.-Best-Sightseeing-Pair/","text":"Best Sightseeing Pair \u00b6 Given an array A of positive integers, A[i] represents the value of the i -th sightseeing spot, and two sightseeing spots i and j have distance j - i between them. The score of a pair ( i < j ) of sightseeing spots is ( A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots. Example 1: Input: [8,1,5,2,6] Output: 11 Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 Note: 2 <= A.length <= 50000 1 <= A[i] <= 1000 Analysis \u00b6 By using brute-force, it will cause TLE. We can rarrange the equation into A[i] + i + A[j] - j , where i < j. So that we just need to make sure A[i] + i is the maximum and since it's always on the left side of j and A[j], we can \"lazy\" update its value when we process to the right. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : int maxScoreSightseeingPair(vector < int >& A) { int res = 0 , n = A.size(), mx = 0 ; // mx = A[i] + i for ( int i = 0 ; i < n; ++ i) { res = max(res, mx + A[i] - i); mx = max(mx, A[i] + i); } return res; } };","title":"Best Sightseeing Pair"},{"location":"Leetcode/1014.-Best-Sightseeing-Pair/#best-sightseeing-pair","text":"Given an array A of positive integers, A[i] represents the value of the i -th sightseeing spot, and two sightseeing spots i and j have distance j - i between them. The score of a pair ( i < j ) of sightseeing spots is ( A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots. Example 1: Input: [8,1,5,2,6] Output: 11 Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 Note: 2 <= A.length <= 50000 1 <= A[i] <= 1000","title":"Best Sightseeing Pair"},{"location":"Leetcode/1014.-Best-Sightseeing-Pair/#analysis","text":"By using brute-force, it will cause TLE. We can rarrange the equation into A[i] + i + A[j] - j , where i < j. So that we just need to make sure A[i] + i is the maximum and since it's always on the left side of j and A[j], we can \"lazy\" update its value when we process to the right. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/1014.-Best-Sightseeing-Pair/#code","text":"class Solution { public : int maxScoreSightseeingPair(vector < int >& A) { int res = 0 , n = A.size(), mx = 0 ; // mx = A[i] + i for ( int i = 0 ; i < n; ++ i) { res = max(res, mx + A[i] - i); mx = max(mx, A[i] + i); } return res; } };","title":"Code"},{"location":"Leetcode/1015.-Smallest-Integer-Divisible-by-K/","text":"Smallest Integer Divisible by K \u00b6 Given a positive integer K , you need to find the length of the smallest positive integer N such that N is divisible by K , and N only contains the digit 1 . Return the length of N . If there is no such N , return -1. Note: N may not fit in a 64-bit signed integer. Example 1: Input: K = 1 Output: 1 Explanation: The smallest answer is N = 1, which has length 1. Example 2: Input: K = 2 Output: -1 Explanation: There is no such positive integer N divisible by 2. Example 3: Input: K = 3 Output: 3 Explanation: The smallest answer is N = 111, which has length 3. Constraints: 1 <= K <= 105 Analysis \u00b6 By observation, we can find that the only case that will return -1 is when there is a repetend for the reminder as we grow our candidate number, so we can just create a set that will store all the prevous reminders and see if current reminder already exist or not. However, if we just arbitarily increase our candidate number, it will result in overflow, so we need to apply the modulus trick: r = n % k n = m * k + r 10 * n + 1 = 10 * (m * k + r) + 1 10 * n + 1 = 10 * m * k + 10 * r + 1 (10 * n + 1) % k = (10 * m * k + 10 * r + 1) % k (10 * n + 1) % k = (10 * r + 1) % k // (10 * m * k) % k = 0 so whatever n is, (10 * n + 1) % k equals to (10 * r + 1) % k, where r is n % k. So that's why we only need to keep the remainder. Or inituitively, we can see that reminder is always in the range from 0 to K. No mater how do we increase our number, we just need to keep the reminder (% K result), since we are only interested in the reminder of the long number. So we conclude that r = (r * 10 + 1) % K , where left-side r is our new r. However, there is a even smarter way to reduce the space: Assume that N = 1 to N = K, if there isn't 111...11 % K == 0 There are at most K - 1 different remainders: 1, 2, .... K - 1. So this is a pigeon holes problem: There must be at least 2 same remainders. Assume that, f(N) \u2261 f(M), N > M f(N - M) * 10 ^ M \u2261 0 10 ^ M \u2261 0, mod K so that K has factor 2 or factor 5. Proof by contradiction\uff0c If (K % 2 == 0 || K % 5 == 0) return -1; otherwise, there must be a solution N <= K. This will allow us to just check these two simple cases to determine if we should return -1. Time: O(K) O(K) Code: with extra space \u00b6 class Solution { public : int smallestRepunitDivByK( int K) { set < int > vis; int curr = 0 , cnt = 0 ; while ( 1 ) { curr = (curr * 10 + 1 ) % K; cnt ++ ; int mod = curr % K; if (vis.count(mod)) return -1 ; else if (mod == 0 ) return cnt; else vis.insert(mod); } return cnt; } }; Space: O(K) O(K) Code: use math \u00b6 https://leetcode.com/problems/smallest-integer-divisible-by-k/discuss/260852/JavaC%2B%2BPython-O(1)-Space-with-Proves-of-Pigeon-Holes int smallestRepunitDivByK ( int K) { for ( int r = 0 , N = 1 ; N <= K; ++ N) if ((r = (r * 10 + 1 ) % K) == 0 ) return N; return -1 ; } Space: O(1) O(1)","title":"Smallest Integer Divisible by K"},{"location":"Leetcode/1015.-Smallest-Integer-Divisible-by-K/#smallest-integer-divisible-by-k","text":"Given a positive integer K , you need to find the length of the smallest positive integer N such that N is divisible by K , and N only contains the digit 1 . Return the length of N . If there is no such N , return -1. Note: N may not fit in a 64-bit signed integer. Example 1: Input: K = 1 Output: 1 Explanation: The smallest answer is N = 1, which has length 1. Example 2: Input: K = 2 Output: -1 Explanation: There is no such positive integer N divisible by 2. Example 3: Input: K = 3 Output: 3 Explanation: The smallest answer is N = 111, which has length 3. Constraints: 1 <= K <= 105","title":"Smallest Integer Divisible by K"},{"location":"Leetcode/1015.-Smallest-Integer-Divisible-by-K/#analysis","text":"By observation, we can find that the only case that will return -1 is when there is a repetend for the reminder as we grow our candidate number, so we can just create a set that will store all the prevous reminders and see if current reminder already exist or not. However, if we just arbitarily increase our candidate number, it will result in overflow, so we need to apply the modulus trick: r = n % k n = m * k + r 10 * n + 1 = 10 * (m * k + r) + 1 10 * n + 1 = 10 * m * k + 10 * r + 1 (10 * n + 1) % k = (10 * m * k + 10 * r + 1) % k (10 * n + 1) % k = (10 * r + 1) % k // (10 * m * k) % k = 0 so whatever n is, (10 * n + 1) % k equals to (10 * r + 1) % k, where r is n % k. So that's why we only need to keep the remainder. Or inituitively, we can see that reminder is always in the range from 0 to K. No mater how do we increase our number, we just need to keep the reminder (% K result), since we are only interested in the reminder of the long number. So we conclude that r = (r * 10 + 1) % K , where left-side r is our new r. However, there is a even smarter way to reduce the space: Assume that N = 1 to N = K, if there isn't 111...11 % K == 0 There are at most K - 1 different remainders: 1, 2, .... K - 1. So this is a pigeon holes problem: There must be at least 2 same remainders. Assume that, f(N) \u2261 f(M), N > M f(N - M) * 10 ^ M \u2261 0 10 ^ M \u2261 0, mod K so that K has factor 2 or factor 5. Proof by contradiction\uff0c If (K % 2 == 0 || K % 5 == 0) return -1; otherwise, there must be a solution N <= K. This will allow us to just check these two simple cases to determine if we should return -1. Time: O(K) O(K)","title":"Analysis"},{"location":"Leetcode/1015.-Smallest-Integer-Divisible-by-K/#code-with-extra-space","text":"class Solution { public : int smallestRepunitDivByK( int K) { set < int > vis; int curr = 0 , cnt = 0 ; while ( 1 ) { curr = (curr * 10 + 1 ) % K; cnt ++ ; int mod = curr % K; if (vis.count(mod)) return -1 ; else if (mod == 0 ) return cnt; else vis.insert(mod); } return cnt; } }; Space: O(K) O(K)","title":"Code: with extra space"},{"location":"Leetcode/1015.-Smallest-Integer-Divisible-by-K/#code-use-math","text":"https://leetcode.com/problems/smallest-integer-divisible-by-k/discuss/260852/JavaC%2B%2BPython-O(1)-Space-with-Proves-of-Pigeon-Holes int smallestRepunitDivByK ( int K) { for ( int r = 0 , N = 1 ; N <= K; ++ N) if ((r = (r * 10 + 1 ) % K) == 0 ) return N; return -1 ; } Space: O(1) O(1)","title":"Code: use math"},{"location":"Leetcode/1020.-Number-of-Enclaves/","text":"Number of Enclaves \u00b6 Given a 2D array A , each cell is 0 (representing sea) or 1 (representing land) A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves. Example 1: Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary. Example 2: Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. Note: 1 <= A.length <= 500 1 <= A[i].length <= 500 0 <= A[i][j] <= 1 All rows have the same size. Analysis \u00b6 What this question is asking: give a grid, count all the land that is disconnected to the border. Step 1: find all the 1 from the borders. Step 2: \"flood fill\" from border to all the internal land. Step 3: recursively fill all the neighbours of current land. Step 4: count the number of 1s in the grid. Time: O(m \\times n) O(m \\times n) Space: O(m \\times n) O(m \\times n) possible stack space allocated for the dfs call Code \u00b6 class Solution { public : int dir[ 4 ][ 2 ] = {{ 1 , 0 },{ -1 , 0 },{ 0 , 1 },{ 0 , -1 }}; int m, n; void dfs (vector < vector < int >>& A, int x, int y) { if (x >= m || y >= n || x < 0 || y < 0 || A[x][y] == 0 ) return ; A[x][y] = 0 ; for ( auto d : dir) { dfs(A, x + d[ 0 ], y + d[ 1 ]); } } int numEnclaves (vector < vector < int >>& A) { m = A.size(), n = A[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { // here we do a trick: 1 * 0, 0 * 1 and 0 * 0 == 0 // equal to i == 0 || j == 0 if (i * j == 0 || i == m - 1 || j == n - 1 ) dfs(A, i, j); } } int res = 0 ; for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) if (A[i][j] == 1 ) res ++ ; return res; } };","title":"Number of Enclaves"},{"location":"Leetcode/1020.-Number-of-Enclaves/#number-of-enclaves","text":"Given a 2D array A , each cell is 0 (representing sea) or 1 (representing land) A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid. Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves. Example 1: Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary. Example 2: Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. Note: 1 <= A.length <= 500 1 <= A[i].length <= 500 0 <= A[i][j] <= 1 All rows have the same size.","title":"Number of Enclaves"},{"location":"Leetcode/1020.-Number-of-Enclaves/#analysis","text":"What this question is asking: give a grid, count all the land that is disconnected to the border. Step 1: find all the 1 from the borders. Step 2: \"flood fill\" from border to all the internal land. Step 3: recursively fill all the neighbours of current land. Step 4: count the number of 1s in the grid. Time: O(m \\times n) O(m \\times n) Space: O(m \\times n) O(m \\times n) possible stack space allocated for the dfs call","title":"Analysis"},{"location":"Leetcode/1020.-Number-of-Enclaves/#code","text":"class Solution { public : int dir[ 4 ][ 2 ] = {{ 1 , 0 },{ -1 , 0 },{ 0 , 1 },{ 0 , -1 }}; int m, n; void dfs (vector < vector < int >>& A, int x, int y) { if (x >= m || y >= n || x < 0 || y < 0 || A[x][y] == 0 ) return ; A[x][y] = 0 ; for ( auto d : dir) { dfs(A, x + d[ 0 ], y + d[ 1 ]); } } int numEnclaves (vector < vector < int >>& A) { m = A.size(), n = A[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { // here we do a trick: 1 * 0, 0 * 1 and 0 * 0 == 0 // equal to i == 0 || j == 0 if (i * j == 0 || i == m - 1 || j == n - 1 ) dfs(A, i, j); } } int res = 0 ; for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) if (A[i][j] == 1 ) res ++ ; return res; } };","title":"Code"},{"location":"Leetcode/1021.-Remove-Outermost-Parentheses/","text":"Remove Outermost Parentheses \u00b6 A valid parentheses string is either empty (\"\") , \"(\" + A + \")\" , or A + B , where A and B are valid parentheses strings, and + represents string concatenation. For example, \"\" , \"()\" , \"(())()\" , and \"(()(()))\" are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B , with A and B nonempty valid parentheses strings. Given a valid parentheses string S , consider its primitive decomposition: S = P_1 + P_2 + ... + P_k , where P_i are primitive valid parentheses strings. Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S . Example 1: Input: \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2: Input: \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3: Input: \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\". Note: S.length <= 10000 S[i] is \"(\" or \")\" S is a valid parentheses string Analysis \u00b6 In order to identify which parenthesis to be included inside our return string, we need to check two cases: If current open parenthesis is the first parenthesis in the block of the decomposition, we should not add it. This means the current unmatched pairs in block is 1. If current close parenthesis is the last parenthesis in the block of the decomposition, we should not add it. This means the current unmatched pairs in block is 0. Let's walk through an example: The left most column represents the current processing parthesis For \"(()(()))\": ( (|()(())): we have 1 unmatched pair -> \"\" don't do anything here ( ((|)(())): we have 2 unmatched pair -> \"(\" ) (()|(())): we have 1 unmatched pair -> \"()\" ( (()(|())): we have 2 unmatched pair -> \"()(\" ( (()((|))): we have 3 unmatched pair -> \"()((\" ) (()(()|)): we have 2 unmatched pair -> \"()(()\" ) (()(())|): we have 1 unmatched pair -> \"()(())\" ) (()(()))|: we have 0 unmatched pair -> \"()(())\" don't do anything here From this example, we can see that all we need is to count the number of unmatched pairs as well as the current processing parenthesis. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : string removeOuterParentheses(string S) { string res; int cnt = 0 ; for ( char & c : S) { if (c == '(' && ++ cnt != 1 ) res += c; if (c == ')' && -- cnt != 0 ) res += c; } return res; } }; Note that since the input is always valid (no mismatch), we can just use != instead of >= to check the unmatched pairs.","title":"Remove Outermost Parentheses"},{"location":"Leetcode/1021.-Remove-Outermost-Parentheses/#remove-outermost-parentheses","text":"A valid parentheses string is either empty (\"\") , \"(\" + A + \")\" , or A + B , where A and B are valid parentheses strings, and + represents string concatenation. For example, \"\" , \"()\" , \"(())()\" , and \"(()(()))\" are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B , with A and B nonempty valid parentheses strings. Given a valid parentheses string S , consider its primitive decomposition: S = P_1 + P_2 + ... + P_k , where P_i are primitive valid parentheses strings. Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S . Example 1: Input: \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2: Input: \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3: Input: \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\". Note: S.length <= 10000 S[i] is \"(\" or \")\" S is a valid parentheses string","title":"Remove Outermost Parentheses"},{"location":"Leetcode/1021.-Remove-Outermost-Parentheses/#analysis","text":"In order to identify which parenthesis to be included inside our return string, we need to check two cases: If current open parenthesis is the first parenthesis in the block of the decomposition, we should not add it. This means the current unmatched pairs in block is 1. If current close parenthesis is the last parenthesis in the block of the decomposition, we should not add it. This means the current unmatched pairs in block is 0. Let's walk through an example: The left most column represents the current processing parthesis For \"(()(()))\": ( (|()(())): we have 1 unmatched pair -> \"\" don't do anything here ( ((|)(())): we have 2 unmatched pair -> \"(\" ) (()|(())): we have 1 unmatched pair -> \"()\" ( (()(|())): we have 2 unmatched pair -> \"()(\" ( (()((|))): we have 3 unmatched pair -> \"()((\" ) (()(()|)): we have 2 unmatched pair -> \"()(()\" ) (()(())|): we have 1 unmatched pair -> \"()(())\" ) (()(()))|: we have 0 unmatched pair -> \"()(())\" don't do anything here From this example, we can see that all we need is to count the number of unmatched pairs as well as the current processing parenthesis. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/1021.-Remove-Outermost-Parentheses/#code","text":"class Solution { public : string removeOuterParentheses(string S) { string res; int cnt = 0 ; for ( char & c : S) { if (c == '(' && ++ cnt != 1 ) res += c; if (c == ')' && -- cnt != 0 ) res += c; } return res; } }; Note that since the input is always valid (no mismatch), we can just use != instead of >= to check the unmatched pairs.","title":"Code"},{"location":"Leetcode/103.-binary-tree-zigzag-level-order-traversal/","text":"Binary Tree Zigzag Level Order Traversal \u00b6 Given the root of a binary tree, return the zigzag level order traversal of its nodes' values . (i.e., from left to right, then right to left for the next level and alternate between). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000] . -100 <= Node.val <= 100 Analysis \u00b6 When seeing level order traversal, we should think about BFS. Different from level order traversal problem, it also requires us to reverse the level as we proceed, so we can introduce a bool right variable to represent if we need to reverse the order. Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> zigzagLevelOrder(TreeNode * root) { vector < vector < int >> res; if ( ! root) return res; queue < TreeNode *> q{{root}}; bool right = true ; while ( ! q.empty()) { int sz = q.size(); vector < int > level; for ( int i = 0 ; i < sz; ++ i) { TreeNode * t = q.front(); level.push_back(t -> val); q.pop(); if (t -> left) q.push(t -> left); if (t -> right) q.push(t -> right); } if (right) res.push_back(level); else { reverse(level.begin(), level.end()); res.push_back(level); } right = ! right; } return res; } };","title":"Binary Tree Zigzag Level Order Traversal"},{"location":"Leetcode/103.-binary-tree-zigzag-level-order-traversal/#binary-tree-zigzag-level-order-traversal","text":"Given the root of a binary tree, return the zigzag level order traversal of its nodes' values . (i.e., from left to right, then right to left for the next level and alternate between). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000] . -100 <= Node.val <= 100","title":"Binary Tree Zigzag Level Order Traversal"},{"location":"Leetcode/103.-binary-tree-zigzag-level-order-traversal/#analysis","text":"When seeing level order traversal, we should think about BFS. Different from level order traversal problem, it also requires us to reverse the level as we proceed, so we can introduce a bool right variable to represent if we need to reverse the order.","title":"Analysis"},{"location":"Leetcode/103.-binary-tree-zigzag-level-order-traversal/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> zigzagLevelOrder(TreeNode * root) { vector < vector < int >> res; if ( ! root) return res; queue < TreeNode *> q{{root}}; bool right = true ; while ( ! q.empty()) { int sz = q.size(); vector < int > level; for ( int i = 0 ; i < sz; ++ i) { TreeNode * t = q.front(); level.push_back(t -> val); q.pop(); if (t -> left) q.push(t -> left); if (t -> right) q.push(t -> right); } if (right) res.push_back(level); else { reverse(level.begin(), level.end()); res.push_back(level); } right = ! right; } return res; } };","title":"Code"},{"location":"Leetcode/1041.-robot-bounded-in-circle/","text":"Robot Bounded in Circle \u00b6 On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \"G\" : go straight 1 unit; \"L\" : turn 90 degrees to the left; \"R\" : turn 90 degrees to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle. Example 1: Input: instructions = \"GGLLGG\" Output: true Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0). When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin. Example 2: Input: instructions = \"GG\" Output: false Explanation: The robot moves north indefinitely. Example 3: Input: instructions = \"GL\" Output: true Explanation: The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ... Constraints: 1 <= instructions.length <= 100 instructions[i] is 'G' , 'L' or, 'R' . Analysis \u00b6 if after mimicing the instructions ends up with x = 0, y = 0, that means it's already a circle, so we return true. if after mimicing we ends up with a direction other than going up (if it's up, then that is the only direcion and we cannot go back), we can still make it a circle Code \u00b6 class Solution { public : bool isRobotBounded(string instructions) { int sx = 0 , sy = 0 ; int dir = 0 ; // 0: up, 1: left, 2: down, 3: right for ( char c : instructions) { if (c == 'G' ) { if (dir == 0 ) sx ++ ; else if (dir == 1 ) sy -- ; else if (dir == 3 ) sy ++ ; else sx -- ; } else if (c == 'L' ) dir = (dir + 1 ) % 4 ; else dir = (dir + 3 ) % 4 ; } return sx == 0 && sy == 0 || dir > 0 ; } };","title":"Robot Bounded in Circle"},{"location":"Leetcode/1041.-robot-bounded-in-circle/#robot-bounded-in-circle","text":"On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \"G\" : go straight 1 unit; \"L\" : turn 90 degrees to the left; \"R\" : turn 90 degrees to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle. Example 1: Input: instructions = \"GGLLGG\" Output: true Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0). When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin. Example 2: Input: instructions = \"GG\" Output: false Explanation: The robot moves north indefinitely. Example 3: Input: instructions = \"GL\" Output: true Explanation: The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ... Constraints: 1 <= instructions.length <= 100 instructions[i] is 'G' , 'L' or, 'R' .","title":"Robot Bounded in Circle"},{"location":"Leetcode/1041.-robot-bounded-in-circle/#analysis","text":"if after mimicing the instructions ends up with x = 0, y = 0, that means it's already a circle, so we return true. if after mimicing we ends up with a direction other than going up (if it's up, then that is the only direcion and we cannot go back), we can still make it a circle","title":"Analysis"},{"location":"Leetcode/1041.-robot-bounded-in-circle/#code","text":"class Solution { public : bool isRobotBounded(string instructions) { int sx = 0 , sy = 0 ; int dir = 0 ; // 0: up, 1: left, 2: down, 3: right for ( char c : instructions) { if (c == 'G' ) { if (dir == 0 ) sx ++ ; else if (dir == 1 ) sy -- ; else if (dir == 3 ) sy ++ ; else sx -- ; } else if (c == 'L' ) dir = (dir + 1 ) % 4 ; else dir = (dir + 3 ) % 4 ; } return sx == 0 && sy == 0 || dir > 0 ; } };","title":"Code"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/","text":"Remove all Adjacent Duplicates in String \u00b6 Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique. Example 1: Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". Note: 1 <= S.length <= 20000 S consists only of English lowercase letters. Analysis: using stack \u00b6 Because it requires to continuously merge and delete char that are the same, we should think about using stack to solve this problem. Code 1 \u00b6 Using a stack to maintain resulting string, if there is a duplicate with the ongoing char, we just keep popping the stack (the top) in O(1) O(1) and put ongoing char back to the stack. class Solution { public : string removeDuplicates(string s) { int n = s.length(); string res; for ( int i = 0 ; i < n; ++ i) { if ( ! res.empty() && res.back() == s[i]) res.pop_back(); else res += s[i]; } return res; } }; Analysis: two pointers \u00b6 The first solution requires to allocate a new string to be return (as a stack), which will create space overhead for the new string (if the string is all distinct, then the return string will have the same size of the input string). To solve this, we can use two pointer to mimic the stack operations, and then use substr from C++ to split the string (although substr also make copy, but if it's a linkedlist, we can just delete the remaining part in place). i: everything from 0:i are distinct (our returned string). j: probing pointer that will exam if our new string need to be \"shrink\" or not. assign s[i] = s[j] exam if s[i] == s[i - 1], if so, that means the jth char is invalid, we just need to step back by 2 (previous one is also going to be deleted). e.g. s = \"abbaca\" Code 2 \u00b6 class Solution { public : string removeDuplicates(string s) { int i = 0 , n = s.length(); for ( int j = 0 ; j < n; ++ j, ++ i) { s[i] = s[j]; if (i > 0 && s[i - 1 ] == s[i]) i -= 2 ; // not only remove itself but also the remaining one in previous iteration } return s.substr( 0 , i); } };","title":"Remove all Adjacent Duplicates in String"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#remove-all-adjacent-duplicates-in-string","text":"Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique. Example 1: Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". Note: 1 <= S.length <= 20000 S consists only of English lowercase letters.","title":"Remove all Adjacent Duplicates in String"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#analysis-using-stack","text":"Because it requires to continuously merge and delete char that are the same, we should think about using stack to solve this problem.","title":"Analysis: using stack"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#code-1","text":"Using a stack to maintain resulting string, if there is a duplicate with the ongoing char, we just keep popping the stack (the top) in O(1) O(1) and put ongoing char back to the stack. class Solution { public : string removeDuplicates(string s) { int n = s.length(); string res; for ( int i = 0 ; i < n; ++ i) { if ( ! res.empty() && res.back() == s[i]) res.pop_back(); else res += s[i]; } return res; } };","title":"Code 1"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#analysis-two-pointers","text":"The first solution requires to allocate a new string to be return (as a stack), which will create space overhead for the new string (if the string is all distinct, then the return string will have the same size of the input string). To solve this, we can use two pointer to mimic the stack operations, and then use substr from C++ to split the string (although substr also make copy, but if it's a linkedlist, we can just delete the remaining part in place). i: everything from 0:i are distinct (our returned string). j: probing pointer that will exam if our new string need to be \"shrink\" or not. assign s[i] = s[j] exam if s[i] == s[i - 1], if so, that means the jth char is invalid, we just need to step back by 2 (previous one is also going to be deleted). e.g. s = \"abbaca\"","title":"Analysis: two pointers"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#code-2","text":"class Solution { public : string removeDuplicates(string s) { int i = 0 , n = s.length(); for ( int j = 0 ; j < n; ++ j, ++ i) { s[i] = s[j]; if (i > 0 && s[i - 1 ] == s[i]) i -= 2 ; // not only remove itself but also the remaining one in previous iteration } return s.substr( 0 , i); } };","title":"Code 2"},{"location":"Leetcode/1057.-campus-bikes/","text":"Campus Bikes \u00b6 On a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid. Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers. The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|. Return a vector ansof length N, where ans[i]is the index (0-indexed) of the bike that the i-th worker is assigned to. Example 1: Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]] Output: [1,0] Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0]. Example 2: Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]] Output: [0,2,1] Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1]. Note: 0 <= workers[i][j], bikes[i][j] < 1000 All worker and bike locations are distinct. 1 <= workers.length <= bikes.length <= 1000 Analysis \u00b6 Sort based on 1. Manahattan distance between bike and worker 2. Worker index 3. Bike index Using Priority Queue if the input is unbounded. Code \u00b6 /* * tmp.cpp * Copyright (C) 2020 Haoyang <me@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; typedef tuple < int , int , int > TII; int inline manhattan(vector < int >& p1, vector < int >& p2) { return abs (p1[ 0 ] - p2[ 0 ]) + abs(p1[ 1 ] - p2[ 1 ]); } vector < int > assignBikes(vector < vector < int >>& workers, vector < vector < int >>& bikes) { /* *auto cmp = [](const TII& l, const TII& r) { * int ld = get<0>(l), rd = get<0>(r), wl = get<1>(l), wr = get<1>(r), * bl = get<2>(l), br = get<2>(r); * if (ld != rd) * return ld > rd; * else if (wl != wr) * return wl > wr; * else * return bl > br; *}; */ //priority_queue<TII, vector<TII>, decltype(cmp)> pq(cmp); priority_queue < TII, vector < TII > , greater < TII >> pq; for ( int i = 0 ; i < workers.size(); ++ i) { for ( int j = 0 ; j < bikes.size(); ++ j) { pq.push({manhattan(workers[i], bikes[j]), i, j}); } } vector < int > wo(workers.size(), -1 ), bi(bikes.size(), -1 ); int assigned = 0 ; while ( ! pq.empty() && assigned < workers.size()) { TII t = pq.top(); printf( \"after: %d, %d, %d \\n \" , get <0> (t), get <1> (t), get <2> (t)); pq.pop(); if (wo[get <1> (t)] == -1 && bi[get <2> (t)] == -1 ) { // both unassigned wo[get <1> (t)] = get <2> (t); bi[get <2> (t)] = get <1> (t); assigned ++ ; } } return wo; } int main() { int w, b; cin >> w; vector < vector < int >> workers, bikes; for ( int i = 0 ; i < w; ++ i) { int x, y; cin >> x >> y; workers.push_back({x, y}); } cin >> b; for ( int i = 0 ; i < b; ++ i) { int x, y; cin >> x >> y; bikes.push_back({x, y}); } vector < int > res = assignBikes(workers, bikes); for ( int i : res) cout << i << \" \" ; return 0 ; } Variant 1: match as much as possible \u00b6 Find the assignment such that the most workers can be matched (there are obstacle that some bikes ain't reachabe by certain cars ). Using Hungarian algorithm \u00b6 match the workers in the order of manhattan distance (it actually doesn't matter, the order can be random) to the bike, keep matching until there is a tie. find the one with tie's other matches (same distance but different bike). Find the max # of matches for this bipartite graph Start from node 1, matches with 6 (because 6 < 8), then node 2 matches with 5 (5 < 7): mark matches with red lines When it comes to node 3, it can only matches with 6, but node 6 is already matched with 1. However, since node 1 can also matches with 8, node 1 will concede 6 and gives 6 to node 3. Final match: 4 pairs Complete Bipartite graph \u00b6 Since all workers can freely assigned with all the bikes, and bikes can \"choose\" any of the workers. It's a complete bipartitie graph. We should assume # of bikes != # of workes, or the ans is simply # of bikes or # of workers. #include <iostream> #include <cstring> using namespace std; const int N = 510 , M = 100010 ; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add ( int a , int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void init () { memset(h, -1 , sizeof h); } int find ( int x) { //\u904d\u5386\u81ea\u5df1\u559c\u6b22\u7684\u5973\u5b69 for ( int i = h[x] ; i != -1 ;i = ne[i]) { int j = e[i]; if ( ! st[j]) //\u5982\u679c\u5728\u8fd9\u4e00\u8f6e\u6a21\u62df\u5339\u914d\u4e2d,\u8fd9\u4e2a\u5973\u5b69\u5c1a\u672a\u88ab\u9884\u5b9a { st[j] = true ; //\u90a3x\u5c31\u9884\u5b9a\u8fd9\u4e2a\u5973\u5b69\u4e86 //\u5982\u679c\u5973\u5b69j\u6ca1\u6709\u7537\u670b\u53cb\uff0c\u6216\u8005\u5979\u539f\u6765\u7684\u7537\u670b\u53cb\u80fd\u591f\u9884\u5b9a\u5176\u5b83\u559c\u6b22\u7684\u5973\u5b69\u3002\u914d\u5bf9\u6210\u529f if ( ! match[j] || find(match[j])) { match[j] = x; return true ; } } } //\u81ea\u5df1\u4e2d\u610f\u7684\u5168\u90e8\u90fd\u88ab\u9884\u5b9a\u4e86\u3002\u914d\u5bf9\u5931\u8d25\u3002 return false ; } int main () { init(); cin >> n1 >> n2 >> m; while (m -- ) { int a,b; cin >> a >> b; add(a,b); } int res = 0 ; for ( int i = 1 ; i <= n1 ;i ++ ) { //\u56e0\u4e3a\u6bcf\u6b21\u6a21\u62df\u5339\u914d\u7684\u9884\u5b9a\u60c5\u51b5\u90fd\u662f\u4e0d\u4e00\u6837\u7684\u6240\u4ee5\u6bcf\u8f6e\u6a21\u62df\u90fd\u8981\u521d\u59cb\u5316 memset(st, false , sizeof st); if (find(i)) res ++ ; } cout << res << endl; } \u4f5c\u8005\uff1a\u5728\u7ebf\u767d\u7ed9 \u94fe\u63a5\uff1a https : //www.acwing.com/solution/content/5334/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Variant 2: find the max manhattan to be the smallest \u00b6 https://www.acwing.com/problem/content/259/ Property of the max distance: - dis > max: can assign all the bikes and workers whose manhattan distance are greater than max distance into other pairs (already assigned, so even if they have higher manhattan distance, they can still get the bike) - dis < max: there is a at least one bike and worker cannot be assigned whose distance is greater than max distance Use binary search for finding the biggest distance where the graph is still bipartite Use dfs to check if all the other can have the coloring Now we have a different problem: find the if the graph is bipartitie if max = ?, and we find the smallest max #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 20010 , M = 200010 ; int n, m; int h[N], e[M], w[M], ne[M], idx; int color[N]; void add ( int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs ( int u, int c, int limit) { color[u] = c; // color current node to c for ( int i = h[u]; ~ i; i = ne[i]) { if (w[i] <= limit) continue ; // weight is less than current found max wight int j = e[i]; if (color[j]) { if (color[j] == c) return false ; // in the same group } else if ( ! dfs(j, 3 - c, limit)) return false ; // check alternative coloring => place j to another group } return true ; } bool check ( int limit) { memset(color, 0 , sizeof color); for ( int i = 1 ; i <= n; i ++ ) if (color[i] == 0 ) if ( ! dfs(i, 1 , limit)) // start with coloring current node with 1, any that couldn't make it work will return false return false ; return true ; } int main () { scanf( \"%d%d\" , & n, & m); memset(h, -1 , sizeof h); while (m -- ) { int a, b, c; scanf( \"%d%d%d\" , & a, & b, & c); // a: bike id, b: worker id, c: weight add(a, b, c); add(b, a, c); } int l = 0 , r = 1e9 ; while (l < r) { int mid = l + r >> 1 ; if (check(mid)) r = mid; else l = mid + 1 ; } printf( \"%d \\n \" , l); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/solution/content/3042/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Campus Bikes"},{"location":"Leetcode/1057.-campus-bikes/#campus-bikes","text":"On a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid. Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers. The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|. Return a vector ansof length N, where ans[i]is the index (0-indexed) of the bike that the i-th worker is assigned to. Example 1: Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]] Output: [1,0] Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0]. Example 2: Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]] Output: [0,2,1] Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1]. Note: 0 <= workers[i][j], bikes[i][j] < 1000 All worker and bike locations are distinct. 1 <= workers.length <= bikes.length <= 1000","title":"Campus Bikes"},{"location":"Leetcode/1057.-campus-bikes/#analysis","text":"Sort based on 1. Manahattan distance between bike and worker 2. Worker index 3. Bike index Using Priority Queue if the input is unbounded.","title":"Analysis"},{"location":"Leetcode/1057.-campus-bikes/#code","text":"/* * tmp.cpp * Copyright (C) 2020 Haoyang <me@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; typedef tuple < int , int , int > TII; int inline manhattan(vector < int >& p1, vector < int >& p2) { return abs (p1[ 0 ] - p2[ 0 ]) + abs(p1[ 1 ] - p2[ 1 ]); } vector < int > assignBikes(vector < vector < int >>& workers, vector < vector < int >>& bikes) { /* *auto cmp = [](const TII& l, const TII& r) { * int ld = get<0>(l), rd = get<0>(r), wl = get<1>(l), wr = get<1>(r), * bl = get<2>(l), br = get<2>(r); * if (ld != rd) * return ld > rd; * else if (wl != wr) * return wl > wr; * else * return bl > br; *}; */ //priority_queue<TII, vector<TII>, decltype(cmp)> pq(cmp); priority_queue < TII, vector < TII > , greater < TII >> pq; for ( int i = 0 ; i < workers.size(); ++ i) { for ( int j = 0 ; j < bikes.size(); ++ j) { pq.push({manhattan(workers[i], bikes[j]), i, j}); } } vector < int > wo(workers.size(), -1 ), bi(bikes.size(), -1 ); int assigned = 0 ; while ( ! pq.empty() && assigned < workers.size()) { TII t = pq.top(); printf( \"after: %d, %d, %d \\n \" , get <0> (t), get <1> (t), get <2> (t)); pq.pop(); if (wo[get <1> (t)] == -1 && bi[get <2> (t)] == -1 ) { // both unassigned wo[get <1> (t)] = get <2> (t); bi[get <2> (t)] = get <1> (t); assigned ++ ; } } return wo; } int main() { int w, b; cin >> w; vector < vector < int >> workers, bikes; for ( int i = 0 ; i < w; ++ i) { int x, y; cin >> x >> y; workers.push_back({x, y}); } cin >> b; for ( int i = 0 ; i < b; ++ i) { int x, y; cin >> x >> y; bikes.push_back({x, y}); } vector < int > res = assignBikes(workers, bikes); for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Code"},{"location":"Leetcode/1057.-campus-bikes/#variant-1-match-as-much-as-possible","text":"Find the assignment such that the most workers can be matched (there are obstacle that some bikes ain't reachabe by certain cars ).","title":"Variant 1: match as much as possible"},{"location":"Leetcode/1057.-campus-bikes/#using-hungarian-algorithm","text":"match the workers in the order of manhattan distance (it actually doesn't matter, the order can be random) to the bike, keep matching until there is a tie. find the one with tie's other matches (same distance but different bike). Find the max # of matches for this bipartite graph Start from node 1, matches with 6 (because 6 < 8), then node 2 matches with 5 (5 < 7): mark matches with red lines When it comes to node 3, it can only matches with 6, but node 6 is already matched with 1. However, since node 1 can also matches with 8, node 1 will concede 6 and gives 6 to node 3. Final match: 4 pairs","title":"Using Hungarian algorithm"},{"location":"Leetcode/1057.-campus-bikes/#complete-bipartite-graph","text":"Since all workers can freely assigned with all the bikes, and bikes can \"choose\" any of the workers. It's a complete bipartitie graph. We should assume # of bikes != # of workes, or the ans is simply # of bikes or # of workers. #include <iostream> #include <cstring> using namespace std; const int N = 510 , M = 100010 ; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add ( int a , int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void init () { memset(h, -1 , sizeof h); } int find ( int x) { //\u904d\u5386\u81ea\u5df1\u559c\u6b22\u7684\u5973\u5b69 for ( int i = h[x] ; i != -1 ;i = ne[i]) { int j = e[i]; if ( ! st[j]) //\u5982\u679c\u5728\u8fd9\u4e00\u8f6e\u6a21\u62df\u5339\u914d\u4e2d,\u8fd9\u4e2a\u5973\u5b69\u5c1a\u672a\u88ab\u9884\u5b9a { st[j] = true ; //\u90a3x\u5c31\u9884\u5b9a\u8fd9\u4e2a\u5973\u5b69\u4e86 //\u5982\u679c\u5973\u5b69j\u6ca1\u6709\u7537\u670b\u53cb\uff0c\u6216\u8005\u5979\u539f\u6765\u7684\u7537\u670b\u53cb\u80fd\u591f\u9884\u5b9a\u5176\u5b83\u559c\u6b22\u7684\u5973\u5b69\u3002\u914d\u5bf9\u6210\u529f if ( ! match[j] || find(match[j])) { match[j] = x; return true ; } } } //\u81ea\u5df1\u4e2d\u610f\u7684\u5168\u90e8\u90fd\u88ab\u9884\u5b9a\u4e86\u3002\u914d\u5bf9\u5931\u8d25\u3002 return false ; } int main () { init(); cin >> n1 >> n2 >> m; while (m -- ) { int a,b; cin >> a >> b; add(a,b); } int res = 0 ; for ( int i = 1 ; i <= n1 ;i ++ ) { //\u56e0\u4e3a\u6bcf\u6b21\u6a21\u62df\u5339\u914d\u7684\u9884\u5b9a\u60c5\u51b5\u90fd\u662f\u4e0d\u4e00\u6837\u7684\u6240\u4ee5\u6bcf\u8f6e\u6a21\u62df\u90fd\u8981\u521d\u59cb\u5316 memset(st, false , sizeof st); if (find(i)) res ++ ; } cout << res << endl; } \u4f5c\u8005\uff1a\u5728\u7ebf\u767d\u7ed9 \u94fe\u63a5\uff1a https : //www.acwing.com/solution/content/5334/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Complete Bipartite graph"},{"location":"Leetcode/1057.-campus-bikes/#variant-2-find-the-max-manhattan-to-be-the-smallest","text":"https://www.acwing.com/problem/content/259/ Property of the max distance: - dis > max: can assign all the bikes and workers whose manhattan distance are greater than max distance into other pairs (already assigned, so even if they have higher manhattan distance, they can still get the bike) - dis < max: there is a at least one bike and worker cannot be assigned whose distance is greater than max distance Use binary search for finding the biggest distance where the graph is still bipartite Use dfs to check if all the other can have the coloring Now we have a different problem: find the if the graph is bipartitie if max = ?, and we find the smallest max #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 20010 , M = 200010 ; int n, m; int h[N], e[M], w[M], ne[M], idx; int color[N]; void add ( int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs ( int u, int c, int limit) { color[u] = c; // color current node to c for ( int i = h[u]; ~ i; i = ne[i]) { if (w[i] <= limit) continue ; // weight is less than current found max wight int j = e[i]; if (color[j]) { if (color[j] == c) return false ; // in the same group } else if ( ! dfs(j, 3 - c, limit)) return false ; // check alternative coloring => place j to another group } return true ; } bool check ( int limit) { memset(color, 0 , sizeof color); for ( int i = 1 ; i <= n; i ++ ) if (color[i] == 0 ) if ( ! dfs(i, 1 , limit)) // start with coloring current node with 1, any that couldn't make it work will return false return false ; return true ; } int main () { scanf( \"%d%d\" , & n, & m); memset(h, -1 , sizeof h); while (m -- ) { int a, b, c; scanf( \"%d%d%d\" , & a, & b, & c); // a: bike id, b: worker id, c: weight add(a, b, c); add(b, a, c); } int l = 0 , r = 1e9 ; while (l < r) { int mid = l + r >> 1 ; if (check(mid)) r = mid; else l = mid + 1 ; } printf( \"%d \\n \" , l); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https : //www.acwing.com/solution/content/3042/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Variant 2: find the max manhattan to be the smallest"},{"location":"Leetcode/1074.-number-of-submatrices-that-sum-to-target/","text":"Number of Submatrices that sum to Target \u00b6 Given a matrix and a target , return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2 . Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1' . Example 1: Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0. Example 2: Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix. Example 3: Input: matrix = [[904]], target = 0 Output: 0 Constraints: 1 <= matrix.length <= 100 1 <= matrix[0].length <= 100 -1000 <= matrix[i] <= 1000 -10^8 <= target <= 10^8 Analysis: using two fixed points \u00b6 Use prefix sum we can get the area of any submatrix in O(1) O(1) . For example: Original matrix: 0 1 0 1 1 1 0 1 0 After prefix sum area from (0,0) to (x,y) = sum(x,y-1)+sum(x-1,y)-sum(x-1,y-1)+matrix(x-1,y-1) : 0 0 0 0 0 0 1 1 0 1 3 4 0 1 4 5 To calculate any submatrix sum from (x1, y1) to (x2, y2) where x1 < x2 and y1 < y2. For example, if (x1, y1) = (1, 1), (x2, y2) = (2, 2), area of (1+1, 1+1) to (2, 2) square is: 3-1-1+0=1 we are calculating this part of the submatrix (just a single element): 1 and the prefix sum is: 0 1 1 3 The formula for calculating the area for any submatrix is thus: sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1] and the area that it represents is from (x1+1,y1+1) to (x2,y2) Time: O(n^4) O(n^4) since we need to iterate through all the possible two coordinates (two fix points) Space: O(n^2) O(n^2) for the prefix sum matrix Code \u00b6 class Solution { public : int numSubmatrixSumTarget(vector < vector < int >>& d, int target) { int m = d.size(), n = d[ 0 ].size(), res = 0 ; vector < vector < int >> sum(m +1 ,vector < int > (n +1 , 0 )); for ( int i = 1 ; i <= m; ++ i) for ( int j = 1 ; j <= n; ++ j) { sum[i][j] = sum[i -1 ][j] + sum[i][j -1 ] - sum[i -1 ][j -1 ] + d[i -1 ][j -1 ]; } for ( int x1 = 0 ; x1 < m; ++ x1) { for ( int y1 = 0 ; y1 < n; ++ y1) { for ( int x2 = x1 +1 ; x2 <= m; ++ x2) { for ( int y2 = y1 +1 ; y2 <= n; ++ y2) { int area = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]; if (area == target) res ++ ; } } } } return res; } Analysis: using map \u00b6 Similar to finding the target subarray , this problem can use a map to record all the previous existing sum, and try to find the complement for the current sum. The smaller number represents the prefix sum by row: The red rectangular represents the condition when we want to calculate all the submatrix sum from left=0 and right=2 and row=1 . To find if current [i, j] is the right down point of the target submatrix (and how many), we just need to check if there are any submatrix whose area is equal to the complement of the current sum. For example, on row=0 , the map changes from: {{0,1}} -> {{0,2}} on right = 0 and update our res before we update the map -> {{0,2}, {1,1}} on right = 1 -> {{0,2}, {1,2}} on right = 2 Time: O(n^3) O(n^3) using map will reduce the time for finding duplicate submatrices that has the same complement sum Space: O(n^2) O(n^2) we could possibly have m \\times n m \\times n different sum Code \u00b6 class Solution { public : int numSubmatrixSumTarget(vector < vector < int >>& A, int target) { int res = 0 , m = A.size(), n = A[ 0 ].size(); for ( int i = 0 ; i < m; i ++ ) for ( int j = 1 ; j < n; j ++ ) A[i][j] += A[i][j - 1 ]; unordered_map < int , int > counter; // area: count for ( int i = 0 ; i < n; i ++ ) { // left for ( int j = i; j < n; j ++ ) { // right counter = {{ 0 , 1 }}; // init counter each time for a new right int cur = 0 ; for ( int row = 0 ; row < m; row ++ ) { cur += A[row][j] - (i > 0 ? A[row][i - 1 ] : 0 ); // update res first res += counter.count(cur - target) ? counter[cur - target] : 0 ; counter[cur] ++ ; } } } return res; } };","title":"Number of Submatrices that sum to Target"},{"location":"Leetcode/1074.-number-of-submatrices-that-sum-to-target/#number-of-submatrices-that-sum-to-target","text":"Given a matrix and a target , return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2 . Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1' . Example 1: Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0. Example 2: Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix. Example 3: Input: matrix = [[904]], target = 0 Output: 0 Constraints: 1 <= matrix.length <= 100 1 <= matrix[0].length <= 100 -1000 <= matrix[i] <= 1000 -10^8 <= target <= 10^8","title":"Number of Submatrices that sum to Target"},{"location":"Leetcode/1074.-number-of-submatrices-that-sum-to-target/#analysis-using-two-fixed-points","text":"Use prefix sum we can get the area of any submatrix in O(1) O(1) . For example: Original matrix: 0 1 0 1 1 1 0 1 0 After prefix sum area from (0,0) to (x,y) = sum(x,y-1)+sum(x-1,y)-sum(x-1,y-1)+matrix(x-1,y-1) : 0 0 0 0 0 0 1 1 0 1 3 4 0 1 4 5 To calculate any submatrix sum from (x1, y1) to (x2, y2) where x1 < x2 and y1 < y2. For example, if (x1, y1) = (1, 1), (x2, y2) = (2, 2), area of (1+1, 1+1) to (2, 2) square is: 3-1-1+0=1 we are calculating this part of the submatrix (just a single element): 1 and the prefix sum is: 0 1 1 3 The formula for calculating the area for any submatrix is thus: sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1] and the area that it represents is from (x1+1,y1+1) to (x2,y2) Time: O(n^4) O(n^4) since we need to iterate through all the possible two coordinates (two fix points) Space: O(n^2) O(n^2) for the prefix sum matrix","title":"Analysis: using two fixed points"},{"location":"Leetcode/1074.-number-of-submatrices-that-sum-to-target/#code","text":"class Solution { public : int numSubmatrixSumTarget(vector < vector < int >>& d, int target) { int m = d.size(), n = d[ 0 ].size(), res = 0 ; vector < vector < int >> sum(m +1 ,vector < int > (n +1 , 0 )); for ( int i = 1 ; i <= m; ++ i) for ( int j = 1 ; j <= n; ++ j) { sum[i][j] = sum[i -1 ][j] + sum[i][j -1 ] - sum[i -1 ][j -1 ] + d[i -1 ][j -1 ]; } for ( int x1 = 0 ; x1 < m; ++ x1) { for ( int y1 = 0 ; y1 < n; ++ y1) { for ( int x2 = x1 +1 ; x2 <= m; ++ x2) { for ( int y2 = y1 +1 ; y2 <= n; ++ y2) { int area = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]; if (area == target) res ++ ; } } } } return res; }","title":"Code"},{"location":"Leetcode/1074.-number-of-submatrices-that-sum-to-target/#analysis-using-map","text":"Similar to finding the target subarray , this problem can use a map to record all the previous existing sum, and try to find the complement for the current sum. The smaller number represents the prefix sum by row: The red rectangular represents the condition when we want to calculate all the submatrix sum from left=0 and right=2 and row=1 . To find if current [i, j] is the right down point of the target submatrix (and how many), we just need to check if there are any submatrix whose area is equal to the complement of the current sum. For example, on row=0 , the map changes from: {{0,1}} -> {{0,2}} on right = 0 and update our res before we update the map -> {{0,2}, {1,1}} on right = 1 -> {{0,2}, {1,2}} on right = 2 Time: O(n^3) O(n^3) using map will reduce the time for finding duplicate submatrices that has the same complement sum Space: O(n^2) O(n^2) we could possibly have m \\times n m \\times n different sum","title":"Analysis: using map"},{"location":"Leetcode/1074.-number-of-submatrices-that-sum-to-target/#code_1","text":"class Solution { public : int numSubmatrixSumTarget(vector < vector < int >>& A, int target) { int res = 0 , m = A.size(), n = A[ 0 ].size(); for ( int i = 0 ; i < m; i ++ ) for ( int j = 1 ; j < n; j ++ ) A[i][j] += A[i][j - 1 ]; unordered_map < int , int > counter; // area: count for ( int i = 0 ; i < n; i ++ ) { // left for ( int j = i; j < n; j ++ ) { // right counter = {{ 0 , 1 }}; // init counter each time for a new right int cur = 0 ; for ( int row = 0 ; row < m; row ++ ) { cur += A[row][j] - (i > 0 ? A[row][i - 1 ] : 0 ); // update res first res += counter.count(cur - target) ? counter[cur - target] : 0 ; counter[cur] ++ ; } } } return res; } };","title":"Code"},{"location":"Leetcode/109.-convert-sorted-list-to-binary-search-tree/","text":"Convert Sorted List to Binary Search Tree \u00b6 Given the head of a singly linked list where elements are sorted in ascending order , convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2: Input: head = [] Output: [] Example 3: Input: head = [0] Output: [0] Example 4: Input: head = [1,3] Output: [3,1] Constraints: The number of nodes in head is in the range [0, 2 * 104] . -10^5 <= Node.val <= 10^5 Analysis \u00b6 To build a bst from a sorted array , we can do so by recursively finding the middle of the array to generate the tree. However, we need extra time to find the middle of a linkedlist (use fast slow pointer requires O(n) O(n) We can definitely use fast slow pointer to find the mid in each iteration and the psuedo code would like sort(node): set mid = find_min_for_head set root->value = mid->value","title":"Convert Sorted List to Binary Search Tree"},{"location":"Leetcode/109.-convert-sorted-list-to-binary-search-tree/#convert-sorted-list-to-binary-search-tree","text":"Given the head of a singly linked list where elements are sorted in ascending order , convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2: Input: head = [] Output: [] Example 3: Input: head = [0] Output: [0] Example 4: Input: head = [1,3] Output: [3,1] Constraints: The number of nodes in head is in the range [0, 2 * 104] . -10^5 <= Node.val <= 10^5","title":"Convert Sorted List to Binary Search Tree"},{"location":"Leetcode/109.-convert-sorted-list-to-binary-search-tree/#analysis","text":"To build a bst from a sorted array , we can do so by recursively finding the middle of the array to generate the tree. However, we need extra time to find the middle of a linkedlist (use fast slow pointer requires O(n) O(n) We can definitely use fast slow pointer to find the mid in each iteration and the psuedo code would like sort(node): set mid = find_min_for_head set root->value = mid->value","title":"Analysis"},{"location":"Leetcode/11.-container-with-most-water/","text":"Container with Most Water \u00b6 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai) . n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0) . Find two lines, which, together with the x-axis forms a container, such that the container contains the most water. Notice that you may not slant the container. Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2: Input: height = [1,1] Output: 1 Example 3: Input: height = [4,3,2,1,4] Output: 16 Example 4: Input: height = [1,2,1] Output: 2 Constraints: n == height.length 2 <= n <= 105 0 <= height[i] <= 104 Using two pointers \u00b6 if a_i > a_j : then j -- else then i ++ until two pointers have met Proof : Assume the answer is i^{'} i^{'} and j^{'} j^{'} where (i^{'} < j^{'}) (i^{'} < j^{'}) , use S^{'} S^{'} to represent the total water. Also assume a_i > a_j a_i > a_j , so i to j - 1 should have the answer. We need to prove it is correct by showing optimal isn't in i + 1 to j Assume there is another S S that is greater than S^{'} S^{'} , then S = min(a_i, a_j) * (j - i) min(a_i, a_j) * (j - i) and j > j^{'} j > j^{'} = a_i \\times (j - i) = a_i \\times (j - i) > a_i \\times (j^{'} - i) > a_i \\times (j^{'} - i) \\geqslant min(a_i, a_{j^{'}}) \\times (j^{'} - i) = S^{'} \\geqslant min(a_i, a_{j^{'}}) \\times (j^{'} - i) = S^{'} Code \u00b6 class Solution { public : int maxArea(vector < int >& height) { int res = 0 ; for ( int i = 0 , j = height.size() - 1 ; i < j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] > height[j]) j -- ; else i ++ ; } return res; } };","title":"Container with Most Water"},{"location":"Leetcode/11.-container-with-most-water/#container-with-most-water","text":"Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai) . n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0) . Find two lines, which, together with the x-axis forms a container, such that the container contains the most water. Notice that you may not slant the container. Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2: Input: height = [1,1] Output: 1 Example 3: Input: height = [4,3,2,1,4] Output: 16 Example 4: Input: height = [1,2,1] Output: 2 Constraints: n == height.length 2 <= n <= 105 0 <= height[i] <= 104","title":"Container with Most Water"},{"location":"Leetcode/11.-container-with-most-water/#using-two-pointers","text":"if a_i > a_j : then j -- else then i ++ until two pointers have met Proof : Assume the answer is i^{'} i^{'} and j^{'} j^{'} where (i^{'} < j^{'}) (i^{'} < j^{'}) , use S^{'} S^{'} to represent the total water. Also assume a_i > a_j a_i > a_j , so i to j - 1 should have the answer. We need to prove it is correct by showing optimal isn't in i + 1 to j Assume there is another S S that is greater than S^{'} S^{'} , then S = min(a_i, a_j) * (j - i) min(a_i, a_j) * (j - i) and j > j^{'} j > j^{'} = a_i \\times (j - i) = a_i \\times (j - i) > a_i \\times (j^{'} - i) > a_i \\times (j^{'} - i) \\geqslant min(a_i, a_{j^{'}}) \\times (j^{'} - i) = S^{'} \\geqslant min(a_i, a_{j^{'}}) \\times (j^{'} - i) = S^{'}","title":"Using two pointers"},{"location":"Leetcode/11.-container-with-most-water/#code","text":"class Solution { public : int maxArea(vector < int >& height) { int res = 0 ; for ( int i = 0 , j = height.size() - 1 ; i < j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] > height[j]) j -- ; else i ++ ; } return res; } };","title":"Code"},{"location":"Leetcode/112.-path-sum/","text":"Path Sum \u00b6 Given the root of a binary tree and an integer targetSum , return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum . A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Example 2: Input: root = [1,2,3], targetSum = 5 Output: false Example 3: Input: root = [1,2], targetSum = 0 Output: false Constraints: The number of nodes in the tree is in the range [0, 5000] . -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000 Analysis \u00b6 The path has be from root to leaf, and we need to make sure our code satisfy both: if node->left==nullptr && node->right==nullptr , then the node is a leaf node if current sum==sum , then current path sum is satisfied. We can then use recursion to solve. TIme: O(n) O(n) where n is number of nodes in the tree Space: O(n) O(n) worst case when tree is a linkedlist Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool hasPathSum(TreeNode * root, int sum) { if ( ! root) return false ; // already visited to the children node of leaf sum -= root -> val; // is leaf node + curr sum == target sum if ( ! sum && ! root -> left && ! root -> right) return true ; return hasPathSum (root -> left, sum) || hasPathSum(root -> right, sum); } };","title":"Path Sum"},{"location":"Leetcode/112.-path-sum/#path-sum","text":"Given the root of a binary tree and an integer targetSum , return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum . A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Example 2: Input: root = [1,2,3], targetSum = 5 Output: false Example 3: Input: root = [1,2], targetSum = 0 Output: false Constraints: The number of nodes in the tree is in the range [0, 5000] . -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000","title":"Path Sum"},{"location":"Leetcode/112.-path-sum/#analysis","text":"The path has be from root to leaf, and we need to make sure our code satisfy both: if node->left==nullptr && node->right==nullptr , then the node is a leaf node if current sum==sum , then current path sum is satisfied. We can then use recursion to solve. TIme: O(n) O(n) where n is number of nodes in the tree Space: O(n) O(n) worst case when tree is a linkedlist","title":"Analysis"},{"location":"Leetcode/112.-path-sum/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool hasPathSum(TreeNode * root, int sum) { if ( ! root) return false ; // already visited to the children node of leaf sum -= root -> val; // is leaf node + curr sum == target sum if ( ! sum && ! root -> left && ! root -> right) return true ; return hasPathSum (root -> left, sum) || hasPathSum(root -> right, sum); } };","title":"Code"},{"location":"Leetcode/113.-path-sum-II/","text":"Path Sum II \u00b6 Given the root of a binary tree and an integer targetSum , return all root-to-leaf paths where each path's sum equals targetSum . A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Example 2: Input: root = [1,2,3], targetSum = 5 Output: [] Example 3: Input: root = [1,2], targetSum = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 5000] . -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000 Analysis \u00b6 Similar to path sum, this question requires us to return all the paths, so we need to maintain the path along the recrusion calls. Time: O(n^2) O(n^2) because for each push_back to the res , it will require path.size() operation. Space: O(n) O(n) if don't count the return space. Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> res; void dfs (TreeNode * root, int sum, vector < int > path) { if ( ! root) return ; sum -= root -> val; path.push_back(root -> val); if ( ! sum && ! root -> left && ! root -> right) { res.push_back(path); return ; } dfs(root -> left, sum, path); dfs(root -> right, sum, path); } vector < vector < int >> pathSum(TreeNode * root, int sum) { dfs(root, sum, {}); return res; } };","title":"Path Sum II"},{"location":"Leetcode/113.-path-sum-II/#path-sum-ii","text":"Given the root of a binary tree and an integer targetSum , return all root-to-leaf paths where each path's sum equals targetSum . A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Example 2: Input: root = [1,2,3], targetSum = 5 Output: [] Example 3: Input: root = [1,2], targetSum = 0 Output: [] Constraints: The number of nodes in the tree is in the range [0, 5000] . -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000","title":"Path Sum II"},{"location":"Leetcode/113.-path-sum-II/#analysis","text":"Similar to path sum, this question requires us to return all the paths, so we need to maintain the path along the recrusion calls. Time: O(n^2) O(n^2) because for each push_back to the res , it will require path.size() operation. Space: O(n) O(n) if don't count the return space.","title":"Analysis"},{"location":"Leetcode/113.-path-sum-II/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> res; void dfs (TreeNode * root, int sum, vector < int > path) { if ( ! root) return ; sum -= root -> val; path.push_back(root -> val); if ( ! sum && ! root -> left && ! root -> right) { res.push_back(path); return ; } dfs(root -> left, sum, path); dfs(root -> right, sum, path); } vector < vector < int >> pathSum(TreeNode * root, int sum) { dfs(root, sum, {}); return res; } };","title":"Code"},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/","text":"Flatten binary tree to linked list \u00b6 Given the root of a binary tree, flatten the tree into a \"linked list\": The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null . The \"linked list\" should be in the same order as a pre-order traversal of the binary tree. Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0] Constraints: The number of nodes in the tree is in the range [0, 2000] . -100 <= Node.val <= 100 Follow up: Can you flatten the tree in-place (with O(1) extra space)? Analysis \u00b6 Method 1: flatten left and right tree, then append the left to the end of right. \u00b6 Time Complexity: if the tree is fully balanced (left height - right height abs value <= 1), then the tree will have at max log(N) log(N) levels, each node in the recursion tree, it will require log(N) log(N) runs for the while loop, so the time complexity is O(log(N) \\times N) O(log(N) \\times N) Method 2: travese right then left, then directly append \u00b6 \u6211\u4eec\u77e5\u9053\u9898\u76ee\u7ed9\u5b9a\u7684\u904d\u5386\u987a\u5e8f\u5176\u5b9e\u5c31\u662f\u5148\u5e8f\u904d\u5386\u7684\u987a\u5e8f\uff0c\u6240\u4ee5\u6211\u4eec\u80fd\u4e0d\u80fd\u5229\u7528\u5148\u5e8f\u904d\u5386\u7684\u4ee3\u7801\uff0c\u6bcf\u904d\u5386\u4e00\u4e2a\u8282\u70b9\uff0c\u5c31\u5c06\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684\u53f3\u6307\u9488\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5148\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u662f 1 2 3 4 5 6\u3002 \u904d\u5386\u5230 2\uff0c\u628a 1 \u7684\u53f3\u6307\u9488\u6307\u5411 2\u30021 -> 2 3 4 5 6\u3002 \u904d\u5386\u5230 3\uff0c\u628a 2 \u7684\u53f3\u6307\u9488\u6307\u5411 3\u30021 -> 2 -> 3 4 5 6\u3002 ... ... \u4e00\u76f4\u8fdb\u884c\u4e0b\u53bb\u4f3c\u4e4e\u5c31\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002\u4f46\u73b0\u5b9e\u662f\u6b8b\u9177\u7684\uff0c\u539f\u56e0\u5c31\u662f\u6211\u4eec\u628a 1 \u7684\u53f3\u6307\u9488\u6307\u5411 2\uff0c\u90a3\u4e48 1 \u7684\u539f\u672c\u7684\u53f3\u5b69\u5b50\u5c31\u4e22\u5931\u4e86\uff0c\u4e5f\u5c31\u662f 5 \u5c31\u627e\u4e0d\u5230\u4e86\u3002 \u89e3\u51b3\u65b9\u6cd5\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u9006\u8fc7\u6765\u8fdb\u884c\u3002 \u6211\u4eec\u4f9d\u6b21\u904d\u5386 6 5 4 3 2 1\uff0c\u7136\u540e\u6bcf\u904d\u5386\u4e00\u4e2a\u8282\u70b9\u5c31\u5c06\u5f53\u524d\u8282\u70b9\u7684\u53f3\u6307\u9488\u66f4\u65b0\u4e3a\u4e0a\u4e00\u4e2a\u8282\u70b9\u3002 \u904d\u5386\u5230 5\uff0c\u628a 5 \u7684\u53f3\u6307\u9488\u6307\u5411 6\u30026 <- 5 4 3 2 1\u3002 \u904d\u5386\u5230 4\uff0c\u628a 4 \u7684\u53f3\u6307\u9488\u6307\u5411 5\u30026 <- 5 <- 4 3 2 1\u3002 ... ... \u4f5c\u8005\uff1awindliang \u94fe\u63a5\uff1a https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Code 1 \u00b6 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void flatten (TreeNode root) { if (root == null ) return ; flatten(root. left ); flatten(root. right ); TreeNode tmp = root. right ; root. right = root. left ; root. left = null ; while (root. right != null ) root = root. right ; root. right = tmp; } } Code 2 \u00b6 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private TreeNode pre = null ; public void flatten (TreeNode root) { if (root == null ) return ; flatten(root. right ); flatten(root. left ); root. right = pre; root. left = null ; pre = root; } }","title":"Flatten binary tree to linked list"},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/#flatten-binary-tree-to-linked-list","text":"Given the root of a binary tree, flatten the tree into a \"linked list\": The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null . The \"linked list\" should be in the same order as a pre-order traversal of the binary tree. Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0] Constraints: The number of nodes in the tree is in the range [0, 2000] . -100 <= Node.val <= 100 Follow up: Can you flatten the tree in-place (with O(1) extra space)?","title":"Flatten binary tree to linked list"},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/#analysis","text":"","title":"Analysis"},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/#method-1-flatten-left-and-right-tree-then-append-the-left-to-the-end-of-right","text":"Time Complexity: if the tree is fully balanced (left height - right height abs value <= 1), then the tree will have at max log(N) log(N) levels, each node in the recursion tree, it will require log(N) log(N) runs for the while loop, so the time complexity is O(log(N) \\times N) O(log(N) \\times N)","title":"Method 1: flatten left and right tree, then append the left to the end of right."},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/#method-2-travese-right-then-left-then-directly-append","text":"\u6211\u4eec\u77e5\u9053\u9898\u76ee\u7ed9\u5b9a\u7684\u904d\u5386\u987a\u5e8f\u5176\u5b9e\u5c31\u662f\u5148\u5e8f\u904d\u5386\u7684\u987a\u5e8f\uff0c\u6240\u4ee5\u6211\u4eec\u80fd\u4e0d\u80fd\u5229\u7528\u5148\u5e8f\u904d\u5386\u7684\u4ee3\u7801\uff0c\u6bcf\u904d\u5386\u4e00\u4e2a\u8282\u70b9\uff0c\u5c31\u5c06\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684\u53f3\u6307\u9488\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5148\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u662f 1 2 3 4 5 6\u3002 \u904d\u5386\u5230 2\uff0c\u628a 1 \u7684\u53f3\u6307\u9488\u6307\u5411 2\u30021 -> 2 3 4 5 6\u3002 \u904d\u5386\u5230 3\uff0c\u628a 2 \u7684\u53f3\u6307\u9488\u6307\u5411 3\u30021 -> 2 -> 3 4 5 6\u3002 ... ... \u4e00\u76f4\u8fdb\u884c\u4e0b\u53bb\u4f3c\u4e4e\u5c31\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002\u4f46\u73b0\u5b9e\u662f\u6b8b\u9177\u7684\uff0c\u539f\u56e0\u5c31\u662f\u6211\u4eec\u628a 1 \u7684\u53f3\u6307\u9488\u6307\u5411 2\uff0c\u90a3\u4e48 1 \u7684\u539f\u672c\u7684\u53f3\u5b69\u5b50\u5c31\u4e22\u5931\u4e86\uff0c\u4e5f\u5c31\u662f 5 \u5c31\u627e\u4e0d\u5230\u4e86\u3002 \u89e3\u51b3\u65b9\u6cd5\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u9006\u8fc7\u6765\u8fdb\u884c\u3002 \u6211\u4eec\u4f9d\u6b21\u904d\u5386 6 5 4 3 2 1\uff0c\u7136\u540e\u6bcf\u904d\u5386\u4e00\u4e2a\u8282\u70b9\u5c31\u5c06\u5f53\u524d\u8282\u70b9\u7684\u53f3\u6307\u9488\u66f4\u65b0\u4e3a\u4e0a\u4e00\u4e2a\u8282\u70b9\u3002 \u904d\u5386\u5230 5\uff0c\u628a 5 \u7684\u53f3\u6307\u9488\u6307\u5411 6\u30026 <- 5 4 3 2 1\u3002 \u904d\u5386\u5230 4\uff0c\u628a 4 \u7684\u53f3\u6307\u9488\u6307\u5411 5\u30026 <- 5 <- 4 3 2 1\u3002 ... ... \u4f5c\u8005\uff1awindliang \u94fe\u63a5\uff1a https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Method 2: travese right then left, then directly append"},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/#code-1","text":"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void flatten (TreeNode root) { if (root == null ) return ; flatten(root. left ); flatten(root. right ); TreeNode tmp = root. right ; root. right = root. left ; root. left = null ; while (root. right != null ) root = root. right ; root. right = tmp; } }","title":"Code 1"},{"location":"Leetcode/114.-flatten-binary-tree-to-linked-list/#code-2","text":"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private TreeNode pre = null ; public void flatten (TreeNode root) { if (root == null ) return ; flatten(root. right ); flatten(root. left ); root. right = pre; root. left = null ; pre = root; } }","title":"Code 2"},{"location":"Leetcode/115.-distinct-subsequences/","text":"Distinct Subsequences \u00b6 Given two strings s and t , return the number of distinct subsequences of s which equals t . A string's subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). It is guaranteed the answer fits on a 32-bit signed integer. Example 1: Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from S. rabbbit rabbbit rabbbit Example 2: Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag Constraints: 0 <= s.length, t.length <= 1000 s and t consist of English letters. Analysis \u00b6 S = \"rabbbit\", T = \"rabbit\" rabbbit ^ ^ ^^ rabbbit ^^ ^ ^ rabbbit ^ ^ note: can only delete dp[i][j]: ways to transform S[0:i] to T[0:j] if t is \"\", then only one way to form t from s (delete all) if t[i] == s[j]: dp[i][j] = dp[i-1][j-1]+dp[i][j-1] -> t can choose either delete the current one or not, both are valid if t[i] != s[j]: dp[i][j] = dp[i][j-1] -> the extra one cannot be counted and should only use the previous stage result (delete current one) Code \u00b6 class Solution { public : int numDistinct(string s, string t) { int m = t.length(), n = s.length(); int64_t dp[m +1 ][n +1 ]; memset(dp, 0 , sizeof dp); for ( int j = 0 ; j <= n; j ++ ) dp[ 0 ][j] = 1 ; for ( int i = 1 ; i <= m; i ++ ) for ( int j = i; j <= n; j ++ ) dp[i][j] = dp[i][j - 1 ] + (t[i - 1 ] == s[j - 1 ] ? dp[i - 1 ][j - 1 ] : 0 ); return dp[m][n]; } };","title":"Distinct Subsequences"},{"location":"Leetcode/115.-distinct-subsequences/#distinct-subsequences","text":"Given two strings s and t , return the number of distinct subsequences of s which equals t . A string's subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). It is guaranteed the answer fits on a 32-bit signed integer. Example 1: Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from S. rabbbit rabbbit rabbbit Example 2: Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag Constraints: 0 <= s.length, t.length <= 1000 s and t consist of English letters.","title":"Distinct Subsequences"},{"location":"Leetcode/115.-distinct-subsequences/#analysis","text":"S = \"rabbbit\", T = \"rabbit\" rabbbit ^ ^ ^^ rabbbit ^^ ^ ^ rabbbit ^ ^ note: can only delete dp[i][j]: ways to transform S[0:i] to T[0:j] if t is \"\", then only one way to form t from s (delete all) if t[i] == s[j]: dp[i][j] = dp[i-1][j-1]+dp[i][j-1] -> t can choose either delete the current one or not, both are valid if t[i] != s[j]: dp[i][j] = dp[i][j-1] -> the extra one cannot be counted and should only use the previous stage result (delete current one)","title":"Analysis"},{"location":"Leetcode/115.-distinct-subsequences/#code","text":"class Solution { public : int numDistinct(string s, string t) { int m = t.length(), n = s.length(); int64_t dp[m +1 ][n +1 ]; memset(dp, 0 , sizeof dp); for ( int j = 0 ; j <= n; j ++ ) dp[ 0 ][j] = 1 ; for ( int i = 1 ; i <= m; i ++ ) for ( int j = i; j <= n; j ++ ) dp[i][j] = dp[i][j - 1 ] + (t[i - 1 ] == s[j - 1 ] ? dp[i - 1 ][j - 1 ] : 0 ); return dp[m][n]; } };","title":"Code"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/","text":"Populating Next Right Pointers in Each Node \u00b6 You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Example 1: Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 212 - 1] . -1000 <= Node.val <= 1000 Follow-up: You may only use constant extra space. The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem. Analysis \u00b6 Using recusion/DFS traverse \u00b6 We could use DFS to solve this question by connecting the silbling nodes in a recursive fashion. Be mindful for the case when we need to connect right child with the left child from a different parent root. We need to use node -> right -> next to check if such case exist. Time: O(n) O(n) Space: O(n) O(n) linkedlist case Using level/BFS traverse \u00b6 More straighforward yet need extra cautions. For each iteration, we should start from the left-most node of the tree, which means our while loop should be going deep by moving the root -> left node. Using this method we can save some space because we don't need to hold the call stack space any more. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 Recursion \u00b6 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect(Node * root) { if ( ! root) return nullptr ; if (root -> left) { // we only need to traverse when left node exists root -> left -> next = root -> right; if (root -> next) { root -> right -> next = root -> next -> left; } connect(root -> left); connect(root -> right); } return root; } }; Level \u00b6 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() {} Node(int _val, Node* _left, Node* _right, Node* _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public : Node * connect(Node * root) { Node * ret = root; while (root && root -> left) { Node * curr = root; while (curr) { curr -> left -> next = curr -> right; curr -> right -> next = curr -> next ? curr -> next -> left : NULL ; curr = curr -> next; } root = root -> left; } return ret; } };","title":"Populating Next Right Pointers in Each Node"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#populating-next-right-pointers-in-each-node","text":"You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Example 1: Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 212 - 1] . -1000 <= Node.val <= 1000 Follow-up: You may only use constant extra space. The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.","title":"Populating Next Right Pointers in Each Node"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#analysis","text":"","title":"Analysis"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#using-recusiondfs-traverse","text":"We could use DFS to solve this question by connecting the silbling nodes in a recursive fashion. Be mindful for the case when we need to connect right child with the left child from a different parent root. We need to use node -> right -> next to check if such case exist. Time: O(n) O(n) Space: O(n) O(n) linkedlist case","title":"Using recusion/DFS traverse"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#using-levelbfs-traverse","text":"More straighforward yet need extra cautions. For each iteration, we should start from the left-most node of the tree, which means our while loop should be going deep by moving the root -> left node. Using this method we can save some space because we don't need to hold the call stack space any more. Time: O(n) O(n) Space: O(1) O(1)","title":"Using level/BFS traverse"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#code","text":"","title":"Code"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#recursion","text":"/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect(Node * root) { if ( ! root) return nullptr ; if (root -> left) { // we only need to traverse when left node exists root -> left -> next = root -> right; if (root -> next) { root -> right -> next = root -> next -> left; } connect(root -> left); connect(root -> right); } return root; } };","title":"Recursion"},{"location":"Leetcode/116.-Populating-Next-Right-Pointers-in-Each-Node/#level","text":"/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() {} Node(int _val, Node* _left, Node* _right, Node* _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public : Node * connect(Node * root) { Node * ret = root; while (root && root -> left) { Node * curr = root; while (curr) { curr -> left -> next = curr -> right; curr -> right -> next = curr -> next ? curr -> next -> left : NULL ; curr = curr -> next; } root = root -> left; } return ret; } };","title":"Level"},{"location":"Leetcode/12.-integer-to-roman/","text":"Integer to Roman \u00b6 Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII , which is simply X + II . The number 27 is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Example 1: Input: num = 3 Output: \"III\" Example 2: Input: num = 4 Output: \"IV\" Example 3: Input: num = 9 Output: \"IX\" Example 4: Input: num = 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: num = 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: 1 <= num <= 3999 Analysis \u00b6 This question is finding the relationship of Roma Integer to decimal integer. for 1 to 9 (one digit: 1: I, 2: II, 3: III, 4: IV, 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL, 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD, 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM It can generate any number from the map: e.g. 1234 1: M 2: CC 3: XXX 4: IV -> 1234 = MCCXXXIV Code \u00b6 class Solution { public : string intToRoman( int num) { int val[] = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }; string repr[] = { \"M\" , \"CM\" , \"D\" , \"CD\" , \"C\" , \"XC\" , \"L\" , \"XL\" , \"X\" , \"IX\" , \"V\" , \"IV\" , \"I\" }; string res; for ( int i = 0 ; i < 13 ; ++ i) { while (num >= val[i]) { num -= val[i]; res += repr[i]; } } return res; } };","title":"Integer to Roman"},{"location":"Leetcode/12.-integer-to-roman/#integer-to-roman","text":"Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII , which is simply X + II . The number 27 is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Example 1: Input: num = 3 Output: \"III\" Example 2: Input: num = 4 Output: \"IV\" Example 3: Input: num = 9 Output: \"IX\" Example 4: Input: num = 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: num = 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: 1 <= num <= 3999","title":"Integer to Roman"},{"location":"Leetcode/12.-integer-to-roman/#analysis","text":"This question is finding the relationship of Roma Integer to decimal integer. for 1 to 9 (one digit: 1: I, 2: II, 3: III, 4: IV, 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL, 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD, 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM It can generate any number from the map: e.g. 1234 1: M 2: CC 3: XXX 4: IV -> 1234 = MCCXXXIV","title":"Analysis"},{"location":"Leetcode/12.-integer-to-roman/#code","text":"class Solution { public : string intToRoman( int num) { int val[] = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }; string repr[] = { \"M\" , \"CM\" , \"D\" , \"CD\" , \"C\" , \"XC\" , \"L\" , \"XL\" , \"X\" , \"IX\" , \"V\" , \"IV\" , \"I\" }; string res; for ( int i = 0 ; i < 13 ; ++ i) { while (num >= val[i]) { num -= val[i]; res += repr[i]; } } return res; } };","title":"Code"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/","text":"Best Time to Buy and Sell Stock -- Summary \u00b6 solution all referenced from: \u4f5c\u8005\uff1alabuladong \u94fe\u63a5\uff1a https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. presumptions \u00b6 there is only one stock to be bought no consective buy or sell happens (buy on day one and buy one day two, instead, can only choose rest or sell) state machine \u00b6 representation dp[i][j][k] 1. i: current day from day zero 2. j: transections left 3. k: {1,0} own (rest) or sold (sell) dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 sell ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6ca1\u6709\u6301\u6709\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u662f\u6211\u6628\u5929\u5c31\u6ca1\u6709\u6301\u6709\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u662f\u6ca1\u6709\u6301\u6709\uff1b \u8981\u4e48\u662f\u6211\u6628\u5929\u6301\u6709\u80a1\u7968\uff0c\u4f46\u662f\u4eca\u5929\u6211 sell \u4e86\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u6ca1\u6709\u6301\u6709\u80a1\u7968\u4e86\u3002 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 buy ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6301\u6709\u7740\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u6211\u6628\u5929\u5c31\u6301\u6709\u7740\u80a1\u7968\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u6301\u6709\u7740\u80a1\u7968\uff1b \u8981\u4e48\u6211\u6628\u5929\u672c\u6ca1\u6709\u6301\u6709\uff0c\u4f46\u4eca\u5929\u6211\u9009\u62e9 buy\uff0c\u6240\u4ee5\u4eca\u5929\u6211\u5c31\u6301\u6709\u80a1\u7968\u4e86\u3002 inital : dp[-1][k][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a i \u662f\u4ece 0 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 i = -1 \u610f\u5473\u7740\u8fd8\u6ca1\u6709\u5f00\u59cb\uff0c\u8fd9\u65f6\u5019\u7684\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[-1][k][1] = -infinity \u89e3\u91ca\uff1a\u8fd8\u6ca1\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 dp[i][0][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a k \u662f\u4ece 1 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 k = 0 \u610f\u5473\u7740\u6839\u672c\u4e0d\u5141\u8bb8\u4ea4\u6613\uff0c\u8fd9\u65f6\u5019\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[i][0][1] = -infinity \u89e3\u91ca\uff1a\u4e0d\u5141\u8bb8\u4ea4\u6613\u7684\u60c5\u51b5\u4e0b\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 part 1: one transection \u00b6 dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) \u89e3\u91ca\uff1ak = 0 \u7684 base case\uff0c\u6240\u4ee5 dp[i-1][0][0] = 0\u3002 \u73b0\u5728\u53d1\u73b0 k \u90fd\u662f 1\uff0c\u4e0d\u4f1a\u6539\u53d8\uff0c\u5373 k \u5bf9\u72b6\u6001\u8f6c\u79fb\u5df2\u7ecf\u6ca1\u6709\u5f71\u54cd\u4e86\u3002 \u53ef\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u5316\u7b80\u53bb\u6389\u6240\u6709 k\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) for ( int i = 0 ; i < n; i ++ ) { if (i - 1 == -1 ) { // i==0 dp[i][ 0 ] = 0 ; // \u89e3\u91ca\uff1a // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][ 1 ] = - prices[i]; //\u89e3\u91ca\uff1a // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue ; } dp[i][ 0 ] = max(dp[i -1 ][ 0 ], dp[i -1 ][ 1 ] + prices[i]); dp[i][ 1 ] = max(dp[i -1 ][ 1 ], - prices[i]); // now is sell, if last is sold now has to hold // if last is buy, now is rest } return dp[n - 1 ][ 0 ]; part 2: k transections \u00b6 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) \u6211\u4eec\u53d1\u73b0\u6570\u7ec4\u4e2d\u7684 k \u5df2\u7ecf\u4e0d\u4f1a\u6539\u53d8\u4e86\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u9700\u8981\u8bb0\u5f55 k \u8fd9\u4e2a\u72b6\u6001\u4e86\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) int maxProfit_k_inf (vector < int > prices) { int n = prices.size(); int dp_i_0 = 0 , dp_i_1 = INT_MIN; for ( int i = 0 ; i < n; i ++ ) { int temp = dp_i_0; // last state is dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, temp - prices[i]); } return dp_i_0; }","title":"Best Time to Buy and Sell Stock -- Summary"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#best-time-to-buy-and-sell-stock-summary","text":"solution all referenced from: \u4f5c\u8005\uff1alabuladong \u94fe\u63a5\uff1a https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0.","title":"Best Time to Buy and Sell Stock -- Summary"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#presumptions","text":"there is only one stock to be bought no consective buy or sell happens (buy on day one and buy one day two, instead, can only choose rest or sell)","title":"presumptions"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#state-machine","text":"representation dp[i][j][k] 1. i: current day from day zero 2. j: transections left 3. k: {1,0} own (rest) or sold (sell) dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 sell ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6ca1\u6709\u6301\u6709\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u662f\u6211\u6628\u5929\u5c31\u6ca1\u6709\u6301\u6709\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u662f\u6ca1\u6709\u6301\u6709\uff1b \u8981\u4e48\u662f\u6211\u6628\u5929\u6301\u6709\u80a1\u7968\uff0c\u4f46\u662f\u4eca\u5929\u6211 sell \u4e86\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u6ca1\u6709\u6301\u6709\u80a1\u7968\u4e86\u3002 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 buy ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6301\u6709\u7740\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u6211\u6628\u5929\u5c31\u6301\u6709\u7740\u80a1\u7968\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u6301\u6709\u7740\u80a1\u7968\uff1b \u8981\u4e48\u6211\u6628\u5929\u672c\u6ca1\u6709\u6301\u6709\uff0c\u4f46\u4eca\u5929\u6211\u9009\u62e9 buy\uff0c\u6240\u4ee5\u4eca\u5929\u6211\u5c31\u6301\u6709\u80a1\u7968\u4e86\u3002 inital : dp[-1][k][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a i \u662f\u4ece 0 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 i = -1 \u610f\u5473\u7740\u8fd8\u6ca1\u6709\u5f00\u59cb\uff0c\u8fd9\u65f6\u5019\u7684\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[-1][k][1] = -infinity \u89e3\u91ca\uff1a\u8fd8\u6ca1\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 dp[i][0][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a k \u662f\u4ece 1 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 k = 0 \u610f\u5473\u7740\u6839\u672c\u4e0d\u5141\u8bb8\u4ea4\u6613\uff0c\u8fd9\u65f6\u5019\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[i][0][1] = -infinity \u89e3\u91ca\uff1a\u4e0d\u5141\u8bb8\u4ea4\u6613\u7684\u60c5\u51b5\u4e0b\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002","title":"state machine"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#part-1-one-transection","text":"dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) \u89e3\u91ca\uff1ak = 0 \u7684 base case\uff0c\u6240\u4ee5 dp[i-1][0][0] = 0\u3002 \u73b0\u5728\u53d1\u73b0 k \u90fd\u662f 1\uff0c\u4e0d\u4f1a\u6539\u53d8\uff0c\u5373 k \u5bf9\u72b6\u6001\u8f6c\u79fb\u5df2\u7ecf\u6ca1\u6709\u5f71\u54cd\u4e86\u3002 \u53ef\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u5316\u7b80\u53bb\u6389\u6240\u6709 k\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) for ( int i = 0 ; i < n; i ++ ) { if (i - 1 == -1 ) { // i==0 dp[i][ 0 ] = 0 ; // \u89e3\u91ca\uff1a // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][ 1 ] = - prices[i]; //\u89e3\u91ca\uff1a // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue ; } dp[i][ 0 ] = max(dp[i -1 ][ 0 ], dp[i -1 ][ 1 ] + prices[i]); dp[i][ 1 ] = max(dp[i -1 ][ 1 ], - prices[i]); // now is sell, if last is sold now has to hold // if last is buy, now is rest } return dp[n - 1 ][ 0 ];","title":"part 1: one transection"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#part-2-k-transections","text":"dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) \u6211\u4eec\u53d1\u73b0\u6570\u7ec4\u4e2d\u7684 k \u5df2\u7ecf\u4e0d\u4f1a\u6539\u53d8\u4e86\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u9700\u8981\u8bb0\u5f55 k \u8fd9\u4e2a\u72b6\u6001\u4e86\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) int maxProfit_k_inf (vector < int > prices) { int n = prices.size(); int dp_i_0 = 0 , dp_i_1 = INT_MIN; for ( int i = 0 ; i < n; i ++ ) { int temp = dp_i_0; // last state is dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, temp - prices[i]); } return dp_i_0; }","title":"part 2: k transections"},{"location":"Leetcode/1235.-maximum-profit-in-job-scheduling/","text":"Maximum Profit in job scheduling \u00b6 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i]. You're given the startTime , endTime and profit arrays, you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range. If you choose a job that ends at time X you will be able to start another job that starts at time X. Example 1: Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70. Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. Example 3: Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] Output: 6 Constraints: 1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4 1 <= startTime[i] < endTime[i] <= 10^9 1 <= profit[i] <= 10^4 Analysis \u00b6 For this problem, we cannot use greedy algorithm, since each interval's contribution isn't uniform (not all 1), so we need dp to solve. Different from classic dp problem, which we need to store all the timestamp, in this problem, we just care about the timestamp that is one of the ending time of any task. For example: // if t is between two interval (w/o any intersection), dp[t] is equal to [dp[job1.end], dp[job1.start]], we don't need to record all the timestamp job1: -----[ t ] job2: ------ Now we can define our dp[i] as maximum profits from (0, i] timestamp. We can derive that for any dp[i]: * if we choose to take job x, dp[x.end] = dp[last job end before x.start] + job x's profit * if we choose not to take job x, dp[x.end] = dp[last job's end] Our answer will be dp[last job ending time]. Time: O(n \\log(n)) O(n \\log(n)) for sorting, O(n \\log(n)) O(n \\log(n)) for search last job ending (choose case from dp) Space: O(n) O(n) we need to store all the interval in the map. Code Link \u00b6 class Solution { public : int jobScheduling(vector < int >& startTime, vector < int >& endTime, vector < int >& profit) { int n = startTime.size(); vector < vector < int >> jobs; for ( int i = 0 ; i < n; ++ i) { jobs.push_back({endTime[i], startTime[i], profit[i]}); } sort(jobs.begin(), jobs.end()); // sort by ending time map < int , int > dp = {{ 0 , 0 }}; for ( auto job : jobs) { // find the last ending which end before current start time, so that we can schedule current job int last_ending_profit = prev(dp.upper_bound(job[ 1 ])) -> second; // if by adding current job will cause a higher profit, we can update current ending time's profit if (last_ending_profit + job[ 2 ] > dp.rbegin() -> second) dp[job[ 0 ]] = last_ending_profit + job[ 2 ]; } return dp.rbegin() -> second; } }; Misc \u00b6 In c++, dp.rbegin() will return the last sorted pair from map, whereas dp.end() should return an empty nothing. source: http://www.cplusplus.com/reference/map/map/end/","title":"Maximum Profit in job scheduling"},{"location":"Leetcode/1235.-maximum-profit-in-job-scheduling/#maximum-profit-in-job-scheduling","text":"We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i]. You're given the startTime , endTime and profit arrays, you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range. If you choose a job that ends at time X you will be able to start another job that starts at time X. Example 1: Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70. Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. Example 3: Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] Output: 6 Constraints: 1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4 1 <= startTime[i] < endTime[i] <= 10^9 1 <= profit[i] <= 10^4","title":"Maximum Profit in job scheduling"},{"location":"Leetcode/1235.-maximum-profit-in-job-scheduling/#analysis","text":"For this problem, we cannot use greedy algorithm, since each interval's contribution isn't uniform (not all 1), so we need dp to solve. Different from classic dp problem, which we need to store all the timestamp, in this problem, we just care about the timestamp that is one of the ending time of any task. For example: // if t is between two interval (w/o any intersection), dp[t] is equal to [dp[job1.end], dp[job1.start]], we don't need to record all the timestamp job1: -----[ t ] job2: ------ Now we can define our dp[i] as maximum profits from (0, i] timestamp. We can derive that for any dp[i]: * if we choose to take job x, dp[x.end] = dp[last job end before x.start] + job x's profit * if we choose not to take job x, dp[x.end] = dp[last job's end] Our answer will be dp[last job ending time]. Time: O(n \\log(n)) O(n \\log(n)) for sorting, O(n \\log(n)) O(n \\log(n)) for search last job ending (choose case from dp) Space: O(n) O(n) we need to store all the interval in the map.","title":"Analysis"},{"location":"Leetcode/1235.-maximum-profit-in-job-scheduling/#code-link","text":"class Solution { public : int jobScheduling(vector < int >& startTime, vector < int >& endTime, vector < int >& profit) { int n = startTime.size(); vector < vector < int >> jobs; for ( int i = 0 ; i < n; ++ i) { jobs.push_back({endTime[i], startTime[i], profit[i]}); } sort(jobs.begin(), jobs.end()); // sort by ending time map < int , int > dp = {{ 0 , 0 }}; for ( auto job : jobs) { // find the last ending which end before current start time, so that we can schedule current job int last_ending_profit = prev(dp.upper_bound(job[ 1 ])) -> second; // if by adding current job will cause a higher profit, we can update current ending time's profit if (last_ending_profit + job[ 2 ] > dp.rbegin() -> second) dp[job[ 0 ]] = last_ending_profit + job[ 2 ]; } return dp.rbegin() -> second; } };","title":"Code Link"},{"location":"Leetcode/1235.-maximum-profit-in-job-scheduling/#misc","text":"In c++, dp.rbegin() will return the last sorted pair from map, whereas dp.end() should return an empty nothing. source: http://www.cplusplus.com/reference/map/map/end/","title":"Misc"},{"location":"Leetcode/1240.-Tiling-a-Rectangle-with-the-Fewest-Squares/","text":"Tiling a Rectangle with the Fewest Squares \u00b6 Given a rectangle of size n x m , find the minimum number of integer-sided squares that tile the rectangle. Example 1: Input: n = 2, m = 3 Output: 3 Explanation: 3 squares are necessary to coverthe rectangle. 2 (squares of 1x1) 1 (square of 2x2) Example 2: Input: n = 5, m = 8 Output: 5 Example 3: Input: n = 11, m = 13 Output: 6 Constraints: 1 <= n <= 13 1 <= m <= 13 Analysis \u00b6 If you think about using greedy to solve this problem, you will probably fail. If you try to fill the rectangular space from largest to smallest, it will not guarantee to be the most optimal solution. Check On the middle right, it has splayed the right down region with the upper right region, which breaks the greedy algorithm. So we go back to use the rudimentary DFS search solution. Imagine you can fill the rectangular as a skyline problem (from left to right, bottom to top). You task is to fill all parts of the rectangular. We use a height[i] array to represent the skyline. If our skyline has the same height as the given height m , then we have reach our base case. We update the answer with the current minimal. if (min_height == m) { res = min(cnt, res); return ; } To place next block, we try to eagerly find the next square from the current concave shape skyline. We need to first determine the largest block to be filled with, and then update the new height with the current skyline. int left = 0 , min_height = m; for ( int i = 0 ; i < n; ++ i) { if (heights[i] < min_height) min_height = heights[left = i]; } if (min_height == m) { res = min(cnt, res); return ; } int right = left; // giving space for square with width and height equal to min_height while (right < n && heights[left] == heights[right] && // check width to fit in m right - left + min_height < m) right ++ ; // update the new height for ( int i = left; i < right; ++ i) heights[i] += right - left; Now we have filled the next largest piece of square in the block, and we need to recursively find the next one from the current shape. However, at this point we cannot just keep doing it greedily , since we have prove it won't work for some cases. What we do is try all the square starting from the current largest square we have occupied, and decrease the height[i] one by one. for ( int size = right - left; size >= 1 ; -- size) { // try the largest square first dfs(n, m, heights, cnt + 1 , res); // try other squares by decreasing the size of it, or \"recover\" the original block for ( int i = left; i < left + size - 1 ; ++ i) heights[i] -- ; heights[left + size - 1 ] -= size; } Time: O(n^4) O(n^4) , in each iteration we have n^2 n^2 complexity, and we can run the program from any point of the 2d matrix, so in total is n^2 \\times n^2 n^2 \\times n^2 Space: O(n^2) O(n^2) both the stack space and the height[i] array. Code \u00b6 class Solution { public : void dfs( int n, int m, vector < int >& heights, int cnt, int & res) { if (cnt >= res) return ; // left: min_height's index, if there are multiple min_height, it uses the left most min_height's index int left = 0 , min_height = m; for ( int i = 0 ; i < n; ++ i) { if (heights[i] < min_height) min_height = heights[left = i]; } if (min_height == m) { res = min(cnt, res); return ; } int right = left; // giving space for square with width and height equal to min_height while (right < n && heights[left] == heights[right] && right - left + min_height < m) right ++ ; for ( int i = left; i < right; ++ i) heights[i] += right - left; for ( int size = right - left; size >= 1 ; -- size) { dfs(n, m, heights, cnt + 1 , res); for ( int i = left; i < left + size - 1 ; ++ i) heights[i] -- ; heights[left + size - 1 ] -= size; } } int tilingRectangle( int n, int m) { if (n > m) return tilingRectangle(m, n); vector < int > heights(n); int res = INT_MAX; dfs(n, m, heights, 0 , res); return res; } };","title":"Tiling a Rectangle with the Fewest Squares"},{"location":"Leetcode/1240.-Tiling-a-Rectangle-with-the-Fewest-Squares/#tiling-a-rectangle-with-the-fewest-squares","text":"Given a rectangle of size n x m , find the minimum number of integer-sided squares that tile the rectangle. Example 1: Input: n = 2, m = 3 Output: 3 Explanation: 3 squares are necessary to coverthe rectangle. 2 (squares of 1x1) 1 (square of 2x2) Example 2: Input: n = 5, m = 8 Output: 5 Example 3: Input: n = 11, m = 13 Output: 6 Constraints: 1 <= n <= 13 1 <= m <= 13","title":"Tiling a Rectangle with the Fewest Squares"},{"location":"Leetcode/1240.-Tiling-a-Rectangle-with-the-Fewest-Squares/#analysis","text":"If you think about using greedy to solve this problem, you will probably fail. If you try to fill the rectangular space from largest to smallest, it will not guarantee to be the most optimal solution. Check On the middle right, it has splayed the right down region with the upper right region, which breaks the greedy algorithm. So we go back to use the rudimentary DFS search solution. Imagine you can fill the rectangular as a skyline problem (from left to right, bottom to top). You task is to fill all parts of the rectangular. We use a height[i] array to represent the skyline. If our skyline has the same height as the given height m , then we have reach our base case. We update the answer with the current minimal. if (min_height == m) { res = min(cnt, res); return ; } To place next block, we try to eagerly find the next square from the current concave shape skyline. We need to first determine the largest block to be filled with, and then update the new height with the current skyline. int left = 0 , min_height = m; for ( int i = 0 ; i < n; ++ i) { if (heights[i] < min_height) min_height = heights[left = i]; } if (min_height == m) { res = min(cnt, res); return ; } int right = left; // giving space for square with width and height equal to min_height while (right < n && heights[left] == heights[right] && // check width to fit in m right - left + min_height < m) right ++ ; // update the new height for ( int i = left; i < right; ++ i) heights[i] += right - left; Now we have filled the next largest piece of square in the block, and we need to recursively find the next one from the current shape. However, at this point we cannot just keep doing it greedily , since we have prove it won't work for some cases. What we do is try all the square starting from the current largest square we have occupied, and decrease the height[i] one by one. for ( int size = right - left; size >= 1 ; -- size) { // try the largest square first dfs(n, m, heights, cnt + 1 , res); // try other squares by decreasing the size of it, or \"recover\" the original block for ( int i = left; i < left + size - 1 ; ++ i) heights[i] -- ; heights[left + size - 1 ] -= size; } Time: O(n^4) O(n^4) , in each iteration we have n^2 n^2 complexity, and we can run the program from any point of the 2d matrix, so in total is n^2 \\times n^2 n^2 \\times n^2 Space: O(n^2) O(n^2) both the stack space and the height[i] array.","title":"Analysis"},{"location":"Leetcode/1240.-Tiling-a-Rectangle-with-the-Fewest-Squares/#code","text":"class Solution { public : void dfs( int n, int m, vector < int >& heights, int cnt, int & res) { if (cnt >= res) return ; // left: min_height's index, if there are multiple min_height, it uses the left most min_height's index int left = 0 , min_height = m; for ( int i = 0 ; i < n; ++ i) { if (heights[i] < min_height) min_height = heights[left = i]; } if (min_height == m) { res = min(cnt, res); return ; } int right = left; // giving space for square with width and height equal to min_height while (right < n && heights[left] == heights[right] && right - left + min_height < m) right ++ ; for ( int i = left; i < right; ++ i) heights[i] += right - left; for ( int size = right - left; size >= 1 ; -- size) { dfs(n, m, heights, cnt + 1 , res); for ( int i = left; i < left + size - 1 ; ++ i) heights[i] -- ; heights[left + size - 1 ] -= size; } } int tilingRectangle( int n, int m) { if (n > m) return tilingRectangle(m, n); vector < int > heights(n); int res = INT_MAX; dfs(n, m, heights, 0 , res); return res; } };","title":"Code"},{"location":"Leetcode/1286.-iterator-for-combination/","text":"Iterator for Combination \u00b6 Design an Iterator class, which has: A constructor that takes a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments. A function next() that returns the next combination of length combinationLength in lexicographical order . A function hasNext() that returns True if and only if there exists a next combination. Example: CombinationIterator iterator = new CombinationIterator(\"abc\", 2); // creates the iterator. iterator.next(); // returns \"ab\" iterator.hasNext(); // returns true iterator.next(); // returns \"ac\" iterator.hasNext(); // returns true iterator.next(); // returns \"bc\" iterator.hasNext(); // returns false Constraints: 1 <= combinationLength <= characters.length <= 15 There will be at most 10^4 function calls per test. It's guaranteed that all calls of the function next are valid. Analysis \u00b6 When seeing combination problem, we can think of bit manipulation (0 represents not choose and 1 represents choose). Take an example Num bit_rep no_of_set_bit a b c hold_set 1 0 0 1 1 0 0 1 nothing <= because combinationLength != no_of_set_bit 2 0 1 0 1 0 1 0 same case like upper one 3 0 1 1 2 0 1 1 \"bc\" <= combinationLength ==no_of 4 1 0 0 1 1 0 0 nothing 5 1 0 1 2 1 0 1 \"ac\" 6 1 1 0 2 1 1 0 \"ab\" 7 1 1 1 3 1 1 1 nothing <= because combinationLength != no_of_set_bit return that set in lexi order [\"ab\",\"ac\",\"bc\"] Code \u00b6 class CombinationIterator { public : int len, mask; string s; CombinationIterator(string characters, int combinationLength) { s = characters; len = combinationLength; mask = ( 1 << characters.length()) - 1 ; } string next() { // step 1: make sure # of bits inside the mask == len while (mask && __builtin_popcount(mask) != len) mask -- ; string out; // step 2: check each character's location in mask for ( int i = 0 ; i < s.length(); i ++ ) { if (mask & ( 1 << (s.length() - i - 1 ))) // chosen out += s[i]; } // step 3: update mask to next one mask -- ; return out; } bool hasNext() { // step 1: try to find next valid mask while (mask && __builtin_popcount(mask) != len) mask -- ; // step 2: see if is found or not if ( ! mask) return false ; return true ; } }; /** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj->next(); * bool param_2 = obj->hasNext(); */","title":"Iterator for Combination"},{"location":"Leetcode/1286.-iterator-for-combination/#iterator-for-combination","text":"Design an Iterator class, which has: A constructor that takes a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments. A function next() that returns the next combination of length combinationLength in lexicographical order . A function hasNext() that returns True if and only if there exists a next combination. Example: CombinationIterator iterator = new CombinationIterator(\"abc\", 2); // creates the iterator. iterator.next(); // returns \"ab\" iterator.hasNext(); // returns true iterator.next(); // returns \"ac\" iterator.hasNext(); // returns true iterator.next(); // returns \"bc\" iterator.hasNext(); // returns false Constraints: 1 <= combinationLength <= characters.length <= 15 There will be at most 10^4 function calls per test. It's guaranteed that all calls of the function next are valid.","title":"Iterator for Combination"},{"location":"Leetcode/1286.-iterator-for-combination/#analysis","text":"When seeing combination problem, we can think of bit manipulation (0 represents not choose and 1 represents choose). Take an example Num bit_rep no_of_set_bit a b c hold_set 1 0 0 1 1 0 0 1 nothing <= because combinationLength != no_of_set_bit 2 0 1 0 1 0 1 0 same case like upper one 3 0 1 1 2 0 1 1 \"bc\" <= combinationLength ==no_of 4 1 0 0 1 1 0 0 nothing 5 1 0 1 2 1 0 1 \"ac\" 6 1 1 0 2 1 1 0 \"ab\" 7 1 1 1 3 1 1 1 nothing <= because combinationLength != no_of_set_bit return that set in lexi order [\"ab\",\"ac\",\"bc\"]","title":"Analysis"},{"location":"Leetcode/1286.-iterator-for-combination/#code","text":"class CombinationIterator { public : int len, mask; string s; CombinationIterator(string characters, int combinationLength) { s = characters; len = combinationLength; mask = ( 1 << characters.length()) - 1 ; } string next() { // step 1: make sure # of bits inside the mask == len while (mask && __builtin_popcount(mask) != len) mask -- ; string out; // step 2: check each character's location in mask for ( int i = 0 ; i < s.length(); i ++ ) { if (mask & ( 1 << (s.length() - i - 1 ))) // chosen out += s[i]; } // step 3: update mask to next one mask -- ; return out; } bool hasNext() { // step 1: try to find next valid mask while (mask && __builtin_popcount(mask) != len) mask -- ; // step 2: see if is found or not if ( ! mask) return false ; return true ; } }; /** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj->next(); * bool param_2 = obj->hasNext(); */","title":"Code"},{"location":"Leetcode/13.-roman-to-integer/","text":"Roman to Integer \u00b6 Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII , which is simply X + II . The number 27 is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Example 1: Input: s = \"III\" Output: 3 Example 2: Input: s = \"IV\" Output: 4 Example 3: Input: s = \"IX\" Output: 9 Example 4: Input: s = \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: s = \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: 1 <= s.length <= 15 s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M') . It is guaranteed that s is a valid roman numeral in the range [1, 3999] . Analysis \u00b6 for 1 to 9 (one digit): 1: I, 2: II, 3: III, 4: IV , 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL , 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD , 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM Notice that only 4, 40 and 400 are having the roman character reversed (smaller mapping is in the front the larger mapping), so we only need to handle the special case for that. Code \u00b6 class Solution { public : int romanToInt(string s) { unordered_map < char , int > hash; hash[ 'I' ] = 1 , hash[ 'V' ] = 5 ; hash[ 'X' ] = 10 , hash[ 'L' ] = 50 ; hash[ 'C' ] = 100 , hash[ 'D' ] = 500 ; hash[ 'M' ] = 1000 ; int res = 0 ; for ( int i = 0 ; i < s.size(); i ++ ) { if (i + 1 < s.size() && hash[s[i]] < hash[s[i + 1 ]]) // compare neighour character res -= hash[s[i]]; // if less then - else res += hash[s[i]]; // normal case then + } return res; } };","title":"Roman to Integer"},{"location":"Leetcode/13.-roman-to-integer/#roman-to-integer","text":"Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII , which is simply X + II . The number 27 is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Example 1: Input: s = \"III\" Output: 3 Example 2: Input: s = \"IV\" Output: 4 Example 3: Input: s = \"IX\" Output: 9 Example 4: Input: s = \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: s = \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: 1 <= s.length <= 15 s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M') . It is guaranteed that s is a valid roman numeral in the range [1, 3999] .","title":"Roman to Integer"},{"location":"Leetcode/13.-roman-to-integer/#analysis","text":"for 1 to 9 (one digit): 1: I, 2: II, 3: III, 4: IV , 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL , 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD , 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM Notice that only 4, 40 and 400 are having the roman character reversed (smaller mapping is in the front the larger mapping), so we only need to handle the special case for that.","title":"Analysis"},{"location":"Leetcode/13.-roman-to-integer/#code","text":"class Solution { public : int romanToInt(string s) { unordered_map < char , int > hash; hash[ 'I' ] = 1 , hash[ 'V' ] = 5 ; hash[ 'X' ] = 10 , hash[ 'L' ] = 50 ; hash[ 'C' ] = 100 , hash[ 'D' ] = 500 ; hash[ 'M' ] = 1000 ; int res = 0 ; for ( int i = 0 ; i < s.size(); i ++ ) { if (i + 1 < s.size() && hash[s[i]] < hash[s[i + 1 ]]) // compare neighour character res -= hash[s[i]]; // if less then - else res += hash[s[i]]; // normal case then + } return res; } };","title":"Code"},{"location":"Leetcode/130.-surrounded-regions/","text":"Surrounded Regions \u00b6 Given an m x n matrix board containing 'X' and 'O' , capture all regions surrounded by 'X' . A region is captured by flipping all 'O' s into 'X' s in that surrounded region. Example 1: Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Example 2: Input: board = [[\"X\"]] Output: [[\"X\"]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 200 board[i][j] is 'X' or 'O' . Analysis \u00b6 We cannot just find all 'O' that isn't at the boarder and expand through dfs, because consider the case: X X X X X O O X X O O X X O X X This case will cause all the 'O' not be able to be flipped, so our first step is to find all the 'O' that is on the boarder and mark all the connected 'O' as visited (either allocate a new set or special symbol other than 'O' or 'X'). This will takes O(n) O(n) time at worst. Step 2 would be find all the 'O' remaining in the board and flip them. Time: O(N) O(N) Space: O(N) O(N) if cannot modify the original board, or O(1) O(1) Code \u00b6 class Solution { public : void solve(vector < vector < char >>& board) { if (board.empty() || board[ 0 ].empty()) return ; int m = board.size(), n = board[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (i == 0 || i == m - 1 || j == 0 || j == n - 1 ) { if (board[i][j] == 'O' ) dfs(board, i , j); } } } for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (board[i][j] == 'O' ) board[i][j] = 'X' ; // recover if (board[i][j] == '$' ) board[i][j] = 'O' ; } } } // find all 'O' that are invalid -- from boarder void dfs(vector < vector < char >> & board, int x, int y) { int m = board.size(), n = board[ 0 ].size(); vector < vector < int >> dir{{ 0 , -1 },{ -1 , 0 },{ 0 , 1 },{ 1 , 0 }}; board[x][y] = '$' ; for ( int i = 0 ; i < dir.size(); ++ i) { int dx = x + dir[i][ 0 ], dy = y + dir[i][ 1 ]; if (dx >= 0 && dx < m && dy > 0 && dy < n && board[dx][dy] == 'O' ) { dfs(board, dx, dy); } } } };","title":"Surrounded Regions"},{"location":"Leetcode/130.-surrounded-regions/#surrounded-regions","text":"Given an m x n matrix board containing 'X' and 'O' , capture all regions surrounded by 'X' . A region is captured by flipping all 'O' s into 'X' s in that surrounded region. Example 1: Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Example 2: Input: board = [[\"X\"]] Output: [[\"X\"]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 200 board[i][j] is 'X' or 'O' .","title":"Surrounded Regions"},{"location":"Leetcode/130.-surrounded-regions/#analysis","text":"We cannot just find all 'O' that isn't at the boarder and expand through dfs, because consider the case: X X X X X O O X X O O X X O X X This case will cause all the 'O' not be able to be flipped, so our first step is to find all the 'O' that is on the boarder and mark all the connected 'O' as visited (either allocate a new set or special symbol other than 'O' or 'X'). This will takes O(n) O(n) time at worst. Step 2 would be find all the 'O' remaining in the board and flip them. Time: O(N) O(N) Space: O(N) O(N) if cannot modify the original board, or O(1) O(1)","title":"Analysis"},{"location":"Leetcode/130.-surrounded-regions/#code","text":"class Solution { public : void solve(vector < vector < char >>& board) { if (board.empty() || board[ 0 ].empty()) return ; int m = board.size(), n = board[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (i == 0 || i == m - 1 || j == 0 || j == n - 1 ) { if (board[i][j] == 'O' ) dfs(board, i , j); } } } for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (board[i][j] == 'O' ) board[i][j] = 'X' ; // recover if (board[i][j] == '$' ) board[i][j] = 'O' ; } } } // find all 'O' that are invalid -- from boarder void dfs(vector < vector < char >> & board, int x, int y) { int m = board.size(), n = board[ 0 ].size(); vector < vector < int >> dir{{ 0 , -1 },{ -1 , 0 },{ 0 , 1 },{ 1 , 0 }}; board[x][y] = '$' ; for ( int i = 0 ; i < dir.size(); ++ i) { int dx = x + dir[i][ 0 ], dy = y + dir[i][ 1 ]; if (dx >= 0 && dx < m && dy > 0 && dy < n && board[dx][dy] == 'O' ) { dfs(board, dx, dy); } } } };","title":"Code"},{"location":"Leetcode/138.-copy-list-with-random-pointer/","text":"Copy list with Random Pointer \u00b6 A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null . Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list . For example, if there are two nodes X and Y in the original list, where X.random --> Y , then for the corresponding two nodes x and y in the copied list, x.random --> y . Return the head of the copied linked list . The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1 ) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list. Example 1: Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] Example 2: Input: head = [[1,1],[2,1]] Output: [[1,1],[2,1]] Example 3: Input: head = [[3,null],[3,0],[3,null]] Output: [[3,null],[3,0],[3,null]] Example 4: Input: head = [] Output: [] Explanation: The given linked list is empty (null pointer), so return null. Constraints: 0 <= n <= 1000 -10000 <= Node.val <= 10000 Node.random is null or is pointing to some node in the linked list. \u7b97\u6cd51 \u00b6 \u8fed\u4ee3+\u54c8\u5e0c\u8868 O(n) O(n) \u00b6 \u56e0\u4e3a\u4f7f\u7528next\u8282\u70b9\u53ef\u4ee5\u4fdd\u8bc1\u904d\u5386\u5230\u6240\u6709\u7684\u8282\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528next\u8282\u70b9\u8fdb\u884c\u904d\u5386\u3002\u5728\u904d\u5386\u7684\u65f6\u5019\u6bcf\u6b21\u628anext\u8282\u70b9\u653e\u5165\u54c8\u5e0c\u8868\u4e2d\uff0c\u8fd9\u6837\u65b9\u4fbf\u68c0\u67e5\u5728\u68c0\u67e5\u662f\u5426\u751f\u6210random\u8282\u70b9\u4e2d\u9632\u6b62\u91cd\u590d\u751f\u6210\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 \u00b6 \u56e0\u4e3a\u6bcf\u6b21\u904d\u5386\u6574\u4e2a\u94fe\u8868\u9700\u8981 O(n) O(n) \uff0c\u7a7a\u95f4\u4e0a\u4e0d\u7b97\u751f\u6210\u7684\u8282\u70b9\u9700\u8981 O(2 \\times n) O(2 \\times n) \u6765\u5efa\u7acb\u54c8\u5e0c\u8868\u3002 C++ \u4ee3\u7801 \u00b6 /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public : unordered_map < Node * , Node *> m; Node * copyRandomList (Node * head) { if ( ! head) return NULL ; Node * newHead = new Node(head -> val); Node * cpy = newHead; m[head] = newHead; // don't forget to put newHead into the map!!! while (head) { if (head -> next) { if ( ! m.count(head -> next)) m[head -> next] = new Node(head -> next -> val); cpy -> next = m[head -> next]; } if (head -> random) { if ( ! m.count(head -> random)) m[head -> random] = new Node(head -> random -> val); cpy -> random = m[head -> random]; } head = head -> next; cpy = cpy -> next; } return newHead; } }; \u7b97\u6cd52 \u00b6 \u9012\u5f52+\u54c8\u5e0c\u8868 O(n) O(n) \u00b6 \u540c\u6837\u7684\u601d\u8def\u4e5f\u53ef\u4ee5\u5e94\u7528\u4e8e\u56fe\u7684\u904d\u5386\u3002\u5bf9\u4e8e Node* copyRandomList(Node* head) { \u8fd9\u4e2a\u51fd\u6570\u7684\u7269\u7406\u610f\u4e49\u662f\uff1acopy\u4e00\u4e2a\u5f53\u524dhead\u8282\u70b9\u548c\u4ed6\u5176\u4ed6\u6240\u6709next\u548crandom\u8282\u70b9\uff0c \u5e76\u4e14\u8fd4\u56de\u8fd9\u4e2a\u5df2\u7ecfcopy\u597d\u7684\u8282\u70b9 \u3002\u8fd9\u6837base case\u5c31\u5f88\u6e05\u6670\uff1a\u5982\u679chead\u662f\u7a7a\uff0c\u90a3\u4e48\u8fd4\u56deNULL\uff0c\u5982\u679chead\u5df2\u7ecf\u5b58\u5728\u4e8e\u54c8\u5e0c\u8868\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u76f4\u63a5\u8fd4\u56dedeep copy\u597d\u7684\u8fd9\u4e2a\u8282\u70b9\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 \u00b6 \u7531\u4e8e\u6bcf\u6b21recursion call\u6700\u7ec8\u4f1a\u88abcall n\u6b21\uff08\u4e0d\u662frandom\u7684\u6307\u9488\u7684\u6570\u91cf\uff0c\u56e0\u4e3a\u5982\u679c\u591a\u6b21\u8bbf\u95ee\u5df2\u7ecf\u5b58\u5728\u7684\u8282\u70b9\u5c31\u53ef\u4ee5\u76f4\u63a5\u526a\u679d\u4f7f\u7528\u4e4b\u524d\u5df2\u7ecf\u751f\u6210\u7684\u8282\u70b9\u6765\u8fd4\u56de\uff0c\u4e0d\u4f1a\u518d\u8fdb\u884c\u9012\u5f52\u8c03\u7528\uff09\uff0c\u6240\u4ee5\u65f6\u95f4\u662f O(n) O(n) \u3002\u7a7a\u95f4\u4e0a\u9664\u4e86\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u8fd8\u9700\u8981\u8ba1\u7b97call stack\u7684\u5927\u5c0f\uff0c\u5373 O(n + 2 n) O(n + 2 n) C++ \u4ee3\u7801 \u00b6 /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public : unordered_map < Node * , Node *> m; Node * copyRandomList (Node * head) { if ( ! head) return NULL ; if (m.count(head)) return m[head]; Node * newHead = new Node(head -> val); m[head] = newHead; newHead -> next = copyRandomList(head -> next); newHead -> random = copyRandomList(head -> random); return newHead; } }; \u7b97\u6cd53 \u00b6 \u8fed\u4ee3+\u65e0\u54c8\u5e0c\u8868 O(n) O(n) \u00b6 \u9996\u5148\u5728\u6bcf\u4e00\u4e2acurr, curr -> next\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u5373\uff1acurr, newNext, curr -> next\u3002 \u7b2c\u4e8c\u6b65\u662f\u6dfb\u52a0\u6240\u6709\u7684random\u6307\u9488\uff0c\u6ce8\u610f\u6b64\u65f6\u6240\u6709\u7684\u8282\u70b9\u5df2\u7ecf\u5b58\u5728\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u6dfb\u52a0\u6240\u6709\u7684random\u6307\u9488\u5373\u53ef\u3002 \u6700\u540e\u4e00\u6b65\u662f\u65ad\u5f00\u6240\u6709\u7684next\u8282\u70b9\uff0c\u56e0\u4e3a\u6b64\u65f6\u6211\u4eec\u5df2\u7ecf\u904d\u5386\u5e76\u4e14\u5b89\u88c5\u4e86\u6240\u6709\u7684random\u6307\u9488\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 \u00b6 \u56e0\u4e3a\u6bcf\u6b21\u904d\u5386\u6574\u4e2a\u94fe\u8868\u9700\u8981 O(n) O(n) \uff0c\u7a7a\u95f4\u4e0a\u4e0d\u518d\u9700\u8981\u4f7f\u7528\u54c8\u5e0c\u8868\u6240\u4ee5\u662f O(1) O(1) . C++ \u4ee3\u7801 \u00b6 /** * Definition for singly-linked list with a random pointer. * struct RandomListNode { * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) {} * }; */ class Solution { public : RandomListNode * copyRandomList(RandomListNode * head) { if ( ! head) return NULL ; RandomListNode * newHead, * l1, * l2; for (l1 = head; l1 != NULL ; l1 = l1 -> next -> next) { l2 = new RandomListNode(l1 -> label); l2 -> next = l1 -> next; l1 -> next = l2; } for (l1 = head; l1 != NULL ; l1 = l1 -> next -> next) { if (l1 -> random) l1 -> next -> random = l1 -> random -> next; } newHead = head -> next; for (l1 = head; l1 != NULL ; l1 = l1 -> next) { l2 = l1 -> next; l1 -> next = l2 -> next; if (l2 -> next) l2 -> next = l2 -> next -> next; } return newHead; } };","title":"Copy list with Random Pointer"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#copy-list-with-random-pointer","text":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null . Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list . For example, if there are two nodes X and Y in the original list, where X.random --> Y , then for the corresponding two nodes x and y in the copied list, x.random --> y . Return the head of the copied linked list . The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1 ) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list. Example 1: Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] Example 2: Input: head = [[1,1],[2,1]] Output: [[1,1],[2,1]] Example 3: Input: head = [[3,null],[3,0],[3,null]] Output: [[3,null],[3,0],[3,null]] Example 4: Input: head = [] Output: [] Explanation: The given linked list is empty (null pointer), so return null. Constraints: 0 <= n <= 1000 -10000 <= Node.val <= 10000 Node.random is null or is pointing to some node in the linked list.","title":"Copy list with Random Pointer"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#1","text":"","title":"\u7b97\u6cd51"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#onon","text":"\u56e0\u4e3a\u4f7f\u7528next\u8282\u70b9\u53ef\u4ee5\u4fdd\u8bc1\u904d\u5386\u5230\u6240\u6709\u7684\u8282\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528next\u8282\u70b9\u8fdb\u884c\u904d\u5386\u3002\u5728\u904d\u5386\u7684\u65f6\u5019\u6bcf\u6b21\u628anext\u8282\u70b9\u653e\u5165\u54c8\u5e0c\u8868\u4e2d\uff0c\u8fd9\u6837\u65b9\u4fbf\u68c0\u67e5\u5728\u68c0\u67e5\u662f\u5426\u751f\u6210random\u8282\u70b9\u4e2d\u9632\u6b62\u91cd\u590d\u751f\u6210\u3002","title":"\u8fed\u4ee3+\u54c8\u5e0c\u8868  O(n)O(n)"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#_1","text":"\u56e0\u4e3a\u6bcf\u6b21\u904d\u5386\u6574\u4e2a\u94fe\u8868\u9700\u8981 O(n) O(n) \uff0c\u7a7a\u95f4\u4e0a\u4e0d\u7b97\u751f\u6210\u7684\u8282\u70b9\u9700\u8981 O(2 \\times n) O(2 \\times n) \u6765\u5efa\u7acb\u54c8\u5e0c\u8868\u3002","title":"\u65f6\u95f4\u590d\u6742\u5ea6"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#c","text":"/* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public : unordered_map < Node * , Node *> m; Node * copyRandomList (Node * head) { if ( ! head) return NULL ; Node * newHead = new Node(head -> val); Node * cpy = newHead; m[head] = newHead; // don't forget to put newHead into the map!!! while (head) { if (head -> next) { if ( ! m.count(head -> next)) m[head -> next] = new Node(head -> next -> val); cpy -> next = m[head -> next]; } if (head -> random) { if ( ! m.count(head -> random)) m[head -> random] = new Node(head -> random -> val); cpy -> random = m[head -> random]; } head = head -> next; cpy = cpy -> next; } return newHead; } };","title":"C++ \u4ee3\u7801"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#2","text":"","title":"\u7b97\u6cd52"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#onon_1","text":"\u540c\u6837\u7684\u601d\u8def\u4e5f\u53ef\u4ee5\u5e94\u7528\u4e8e\u56fe\u7684\u904d\u5386\u3002\u5bf9\u4e8e Node* copyRandomList(Node* head) { \u8fd9\u4e2a\u51fd\u6570\u7684\u7269\u7406\u610f\u4e49\u662f\uff1acopy\u4e00\u4e2a\u5f53\u524dhead\u8282\u70b9\u548c\u4ed6\u5176\u4ed6\u6240\u6709next\u548crandom\u8282\u70b9\uff0c \u5e76\u4e14\u8fd4\u56de\u8fd9\u4e2a\u5df2\u7ecfcopy\u597d\u7684\u8282\u70b9 \u3002\u8fd9\u6837base case\u5c31\u5f88\u6e05\u6670\uff1a\u5982\u679chead\u662f\u7a7a\uff0c\u90a3\u4e48\u8fd4\u56deNULL\uff0c\u5982\u679chead\u5df2\u7ecf\u5b58\u5728\u4e8e\u54c8\u5e0c\u8868\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u76f4\u63a5\u8fd4\u56dedeep copy\u597d\u7684\u8fd9\u4e2a\u8282\u70b9\u3002","title":"\u9012\u5f52+\u54c8\u5e0c\u8868 O(n)O(n)"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#_2","text":"\u7531\u4e8e\u6bcf\u6b21recursion call\u6700\u7ec8\u4f1a\u88abcall n\u6b21\uff08\u4e0d\u662frandom\u7684\u6307\u9488\u7684\u6570\u91cf\uff0c\u56e0\u4e3a\u5982\u679c\u591a\u6b21\u8bbf\u95ee\u5df2\u7ecf\u5b58\u5728\u7684\u8282\u70b9\u5c31\u53ef\u4ee5\u76f4\u63a5\u526a\u679d\u4f7f\u7528\u4e4b\u524d\u5df2\u7ecf\u751f\u6210\u7684\u8282\u70b9\u6765\u8fd4\u56de\uff0c\u4e0d\u4f1a\u518d\u8fdb\u884c\u9012\u5f52\u8c03\u7528\uff09\uff0c\u6240\u4ee5\u65f6\u95f4\u662f O(n) O(n) \u3002\u7a7a\u95f4\u4e0a\u9664\u4e86\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u8fd8\u9700\u8981\u8ba1\u7b97call stack\u7684\u5927\u5c0f\uff0c\u5373 O(n + 2 n) O(n + 2 n)","title":"\u65f6\u95f4\u590d\u6742\u5ea6"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#c_1","text":"/* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public : unordered_map < Node * , Node *> m; Node * copyRandomList (Node * head) { if ( ! head) return NULL ; if (m.count(head)) return m[head]; Node * newHead = new Node(head -> val); m[head] = newHead; newHead -> next = copyRandomList(head -> next); newHead -> random = copyRandomList(head -> random); return newHead; } };","title":"C++ \u4ee3\u7801"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#3","text":"","title":"\u7b97\u6cd53"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#onon_2","text":"\u9996\u5148\u5728\u6bcf\u4e00\u4e2acurr, curr -> next\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u5373\uff1acurr, newNext, curr -> next\u3002 \u7b2c\u4e8c\u6b65\u662f\u6dfb\u52a0\u6240\u6709\u7684random\u6307\u9488\uff0c\u6ce8\u610f\u6b64\u65f6\u6240\u6709\u7684\u8282\u70b9\u5df2\u7ecf\u5b58\u5728\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u6dfb\u52a0\u6240\u6709\u7684random\u6307\u9488\u5373\u53ef\u3002 \u6700\u540e\u4e00\u6b65\u662f\u65ad\u5f00\u6240\u6709\u7684next\u8282\u70b9\uff0c\u56e0\u4e3a\u6b64\u65f6\u6211\u4eec\u5df2\u7ecf\u904d\u5386\u5e76\u4e14\u5b89\u88c5\u4e86\u6240\u6709\u7684random\u6307\u9488\u3002","title":"\u8fed\u4ee3+\u65e0\u54c8\u5e0c\u8868 O(n)O(n)"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#_3","text":"\u56e0\u4e3a\u6bcf\u6b21\u904d\u5386\u6574\u4e2a\u94fe\u8868\u9700\u8981 O(n) O(n) \uff0c\u7a7a\u95f4\u4e0a\u4e0d\u518d\u9700\u8981\u4f7f\u7528\u54c8\u5e0c\u8868\u6240\u4ee5\u662f O(1) O(1) .","title":"\u65f6\u95f4\u590d\u6742\u5ea6"},{"location":"Leetcode/138.-copy-list-with-random-pointer/#c_2","text":"/** * Definition for singly-linked list with a random pointer. * struct RandomListNode { * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) {} * }; */ class Solution { public : RandomListNode * copyRandomList(RandomListNode * head) { if ( ! head) return NULL ; RandomListNode * newHead, * l1, * l2; for (l1 = head; l1 != NULL ; l1 = l1 -> next -> next) { l2 = new RandomListNode(l1 -> label); l2 -> next = l1 -> next; l1 -> next = l2; } for (l1 = head; l1 != NULL ; l1 = l1 -> next -> next) { if (l1 -> random) l1 -> next -> random = l1 -> random -> next; } newHead = head -> next; for (l1 = head; l1 != NULL ; l1 = l1 -> next) { l2 = l1 -> next; l1 -> next = l2 -> next; if (l2 -> next) l2 -> next = l2 -> next -> next; } return newHead; } };","title":"C++ \u4ee3\u7801"},{"location":"Leetcode/139.-word-break/","text":"Word Break \u00b6 Given a string s and a dictionary of strings wordDict , return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: false Constraints: 1 <= s.length <= 300 1 <= wordDict.length <= 1000 1 <= wordDict[i].length <= 20 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique . cpp: dfs with memo \u00b6 class Solution { public : unordered_map < string, bool > memo; bool wordBreak (string s, vector < string >& wordDict) { unordered_set < string > dict(wordDict.begin(), wordDict.end()); return dfs(s, dict); } bool dfs (string s, unordered_set < string >& dict) { if (memo.count(s)) return memo[s]; if (dict.count(s)) return memo[s] = true ; for ( int i = 1 ; i < s.size(); ++ i) { if (dict.count(s.substr( 0 , i)) == 0 ) // cannot split from here continue ; if (dfs(s.substr(i), dict)) // 0-i do exist, now check the rest return memo[s] = true ; } return memo[s] = false ; // has tried all options } }; java: dp \u00b6 public class Solution { public boolean wordBreak (String s, Set < String > dict) { boolean [] f = new boolean [ s. length () + 1] ; f [0] = true ; /* First DP for(int i = 1; i <= s.length(); i++){ for(String str: dict){ // check each element in dp if(str.length() <= i){ if(f[i - str.length()]){ // complement exist if(s.substring(i-str.length(), i).equals(str)){ f[i] = true; break; } } } } }*/ //Second DP for ( int i =1 ; i <= s. length (); i ++ ){ for ( int j =0 ; j < i; j ++ ){ // split current s into s[0:j] and s[j:i] if (f [ j ] && dict. contains (s. substring (j, i))){ f [ i ] = true ; break ; } } } return f [ s. length () ] ; } } f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes. The default value for boolean array is false. Therefore we need to set f[0] to be true. cpp w/ optimization \u00b6 class Solution { public : bool wordBreak(string s, vector < string >& word) { int n = s.size(); vector < bool > dp(n +1 ); dp[ 0 ] = true ; for ( int i =0 ; i < n; i ++ ) if (dp[i]) { // only consider if s[0:i] already exists for ( auto & str : word) { int l = str.size(); if (s.substr(i, l) == str) dp[i + l] = true ; // s[0:i] and s[i+str.size()] all valid } } return dp.back(); } }; instead of comparing with the rest from s, compare with the word dict.","title":"Word Break"},{"location":"Leetcode/139.-word-break/#word-break","text":"Given a string s and a dictionary of strings wordDict , return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: false Constraints: 1 <= s.length <= 300 1 <= wordDict.length <= 1000 1 <= wordDict[i].length <= 20 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique .","title":"Word Break"},{"location":"Leetcode/139.-word-break/#cpp-dfs-with-memo","text":"class Solution { public : unordered_map < string, bool > memo; bool wordBreak (string s, vector < string >& wordDict) { unordered_set < string > dict(wordDict.begin(), wordDict.end()); return dfs(s, dict); } bool dfs (string s, unordered_set < string >& dict) { if (memo.count(s)) return memo[s]; if (dict.count(s)) return memo[s] = true ; for ( int i = 1 ; i < s.size(); ++ i) { if (dict.count(s.substr( 0 , i)) == 0 ) // cannot split from here continue ; if (dfs(s.substr(i), dict)) // 0-i do exist, now check the rest return memo[s] = true ; } return memo[s] = false ; // has tried all options } };","title":"cpp: dfs with memo"},{"location":"Leetcode/139.-word-break/#java-dp","text":"public class Solution { public boolean wordBreak (String s, Set < String > dict) { boolean [] f = new boolean [ s. length () + 1] ; f [0] = true ; /* First DP for(int i = 1; i <= s.length(); i++){ for(String str: dict){ // check each element in dp if(str.length() <= i){ if(f[i - str.length()]){ // complement exist if(s.substring(i-str.length(), i).equals(str)){ f[i] = true; break; } } } } }*/ //Second DP for ( int i =1 ; i <= s. length (); i ++ ){ for ( int j =0 ; j < i; j ++ ){ // split current s into s[0:j] and s[j:i] if (f [ j ] && dict. contains (s. substring (j, i))){ f [ i ] = true ; break ; } } } return f [ s. length () ] ; } } f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes. The default value for boolean array is false. Therefore we need to set f[0] to be true.","title":"java: dp"},{"location":"Leetcode/139.-word-break/#cpp-w-optimization","text":"class Solution { public : bool wordBreak(string s, vector < string >& word) { int n = s.size(); vector < bool > dp(n +1 ); dp[ 0 ] = true ; for ( int i =0 ; i < n; i ++ ) if (dp[i]) { // only consider if s[0:i] already exists for ( auto & str : word) { int l = str.size(); if (s.substr(i, l) == str) dp[i + l] = true ; // s[0:i] and s[i+str.size()] all valid } } return dp.back(); } }; instead of comparing with the rest from s, compare with the word dict.","title":"cpp w/ optimization"},{"location":"Leetcode/1396.-design-underground-system/","text":"Design Underground System \u00b6 Implement the class UndergroundSystem that supports three methods: 1. checkIn(int id, string stationName, int t) A customer with id card equal to id , gets in the station stationName at time t . A customer can only be checked into one place at a time. checkOut(int id, string stationName, int t) A customer with id card equal to id , gets out from the station stationName at time t . getAverageTime(string startStation, string endStation) Returns the average time to travel between the startStation and the endStation . The average time is computed from all the previous traveling from startStation to endStation that happened directly . Call to getAverageTime is always valid. You can assume all calls to checkIn and checkOut methods are consistent. That is, if a customer gets in at time t1 at some station, then it gets out at time t2 with t2 > t1 . All events happen in chronological order. Example 1: Input [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]] Output [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(45, \"Leyton\", 3); undergroundSystem.checkIn(32, \"Paradise\", 8); undergroundSystem.checkIn(27, \"Leyton\", 10); undergroundSystem.checkOut(45, \"Waterloo\", 15); undergroundSystem.checkOut(27, \"Waterloo\", 20); undergroundSystem.checkOut(32, \"Cambridge\", 22); undergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // return 14.00000. There was only one travel from \"Paradise\" (at time 8) to \"Cambridge\" (at time 22) undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000. There were two travels from \"Leyton\" to \"Waterloo\", a customer with id=45 from time=3 to time=15 and a customer with id=27 from time=10 to time=20. So the average time is ( (15-3) + (20-10) ) / 2 = 11.00000 undergroundSystem.checkIn(10, \"Leyton\", 24); undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000 undergroundSystem.checkOut(10, \"Waterloo\", 38); undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 12.00000 Example 2: Input [\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"] [[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]] Output [null,null,null,5.00000,null,null,5.50000,null,null,6.66667] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(10, \"Leyton\", 3); undergroundSystem.checkOut(10, \"Paradise\", 8); undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.00000 undergroundSystem.checkIn(5, \"Leyton\", 10); undergroundSystem.checkOut(5, \"Paradise\", 16); undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.50000 undergroundSystem.checkIn(2, \"Leyton\", 21); undergroundSystem.checkOut(2, \"Paradise\", 30); undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 6.66667 Constraints: There will be at most 20000 operations. 1 <= id, t <= 10^6 All strings consist of uppercase, lowercase English letters and digits. 1 <= stationName.length <= 10 Answers within 10^-5 of the actual value will be accepted as correct. Analysis \u00b6 The hard part for this problem is to get the average time quick. If we can have the route from startStation to endStation in O(1) O(1) and also the total time of traveling in these two stations + total passengers in O(1) O(1) , then we can implement this function is O(1) O(1) . We can create a map for storing the mentioned information: map<string, pair<int,int>> checkout which the key is the route, and the value is (total traveling time, total passengers). If we want to get the result, we just need to return checkout[route].first / checkout[route].second; . Now the problem becomes how to populate this map. Each id will be unique, so from this id we can know which station this user has begined from. Having this info we can populate the map when checkOut(int id, string stationName, int t) , so that we need another map to store the relationship between the begin station associated with id and the timestamp. Time: O(1) O(1) Space: O(number of routes + total passengers) O(number of routes + total passengers) Code \u00b6 class UndergroundSystem { public : UndergroundSystem() { } void checkIn( int id, string stationName, int t) { checkin[id] = {stationName, t}; } void checkOut( int id, string stationName, int t) { string route = checkin[id].first + \"-\" + stationName; checkout[route].first += t - checkin[id].second; checkout[route].second ++ ; } double getAverageTime(string startStation, string endStation) { string route = startStation + \"-\" + endStation; return ( double ) checkout[route].first / checkout[route].second; } private : unordered_map < int , pair < string, int >> checkin; // id -> (start station, checkin time) unordered_map < string, pair < int , int >> checkout; // route -> (total time, cnt) }; /** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem* obj = new UndergroundSystem(); * obj->checkIn(id,stationName,t); * obj->checkOut(id,stationName,t); * double param_3 = obj->getAverageTime(startStation,endStation); */","title":"Design Underground System"},{"location":"Leetcode/1396.-design-underground-system/#design-underground-system","text":"Implement the class UndergroundSystem that supports three methods: 1. checkIn(int id, string stationName, int t) A customer with id card equal to id , gets in the station stationName at time t . A customer can only be checked into one place at a time. checkOut(int id, string stationName, int t) A customer with id card equal to id , gets out from the station stationName at time t . getAverageTime(string startStation, string endStation) Returns the average time to travel between the startStation and the endStation . The average time is computed from all the previous traveling from startStation to endStation that happened directly . Call to getAverageTime is always valid. You can assume all calls to checkIn and checkOut methods are consistent. That is, if a customer gets in at time t1 at some station, then it gets out at time t2 with t2 > t1 . All events happen in chronological order. Example 1: Input [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]] Output [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(45, \"Leyton\", 3); undergroundSystem.checkIn(32, \"Paradise\", 8); undergroundSystem.checkIn(27, \"Leyton\", 10); undergroundSystem.checkOut(45, \"Waterloo\", 15); undergroundSystem.checkOut(27, \"Waterloo\", 20); undergroundSystem.checkOut(32, \"Cambridge\", 22); undergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // return 14.00000. There was only one travel from \"Paradise\" (at time 8) to \"Cambridge\" (at time 22) undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000. There were two travels from \"Leyton\" to \"Waterloo\", a customer with id=45 from time=3 to time=15 and a customer with id=27 from time=10 to time=20. So the average time is ( (15-3) + (20-10) ) / 2 = 11.00000 undergroundSystem.checkIn(10, \"Leyton\", 24); undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000 undergroundSystem.checkOut(10, \"Waterloo\", 38); undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 12.00000 Example 2: Input [\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"] [[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]] Output [null,null,null,5.00000,null,null,5.50000,null,null,6.66667] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(10, \"Leyton\", 3); undergroundSystem.checkOut(10, \"Paradise\", 8); undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.00000 undergroundSystem.checkIn(5, \"Leyton\", 10); undergroundSystem.checkOut(5, \"Paradise\", 16); undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.50000 undergroundSystem.checkIn(2, \"Leyton\", 21); undergroundSystem.checkOut(2, \"Paradise\", 30); undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 6.66667 Constraints: There will be at most 20000 operations. 1 <= id, t <= 10^6 All strings consist of uppercase, lowercase English letters and digits. 1 <= stationName.length <= 10 Answers within 10^-5 of the actual value will be accepted as correct.","title":"Design Underground System"},{"location":"Leetcode/1396.-design-underground-system/#analysis","text":"The hard part for this problem is to get the average time quick. If we can have the route from startStation to endStation in O(1) O(1) and also the total time of traveling in these two stations + total passengers in O(1) O(1) , then we can implement this function is O(1) O(1) . We can create a map for storing the mentioned information: map<string, pair<int,int>> checkout which the key is the route, and the value is (total traveling time, total passengers). If we want to get the result, we just need to return checkout[route].first / checkout[route].second; . Now the problem becomes how to populate this map. Each id will be unique, so from this id we can know which station this user has begined from. Having this info we can populate the map when checkOut(int id, string stationName, int t) , so that we need another map to store the relationship between the begin station associated with id and the timestamp. Time: O(1) O(1) Space: O(number of routes + total passengers) O(number of routes + total passengers)","title":"Analysis"},{"location":"Leetcode/1396.-design-underground-system/#code","text":"class UndergroundSystem { public : UndergroundSystem() { } void checkIn( int id, string stationName, int t) { checkin[id] = {stationName, t}; } void checkOut( int id, string stationName, int t) { string route = checkin[id].first + \"-\" + stationName; checkout[route].first += t - checkin[id].second; checkout[route].second ++ ; } double getAverageTime(string startStation, string endStation) { string route = startStation + \"-\" + endStation; return ( double ) checkout[route].first / checkout[route].second; } private : unordered_map < int , pair < string, int >> checkin; // id -> (start station, checkin time) unordered_map < string, pair < int , int >> checkout; // route -> (total time, cnt) }; /** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem* obj = new UndergroundSystem(); * obj->checkIn(id,stationName,t); * obj->checkOut(id,stationName,t); * double param_3 = obj->getAverageTime(startStation,endStation); */","title":"Code"},{"location":"Leetcode/140.-word-break-ii/","text":"Word Break II \u00b6 Given a string s and a dictionary of strings wordDict , add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order . Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"] Output: [\"cats and dog\",\"cat sand dog\"] Example 2: Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"] Output: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: [] Constraints: 1 <= s.length <= 20 1 <= wordDict.length <= 1000 1 <= wordDict[i].length <= 10 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique . dfs w/ memo \u00b6 class Solution { unordered_map < string, vector < string >> m; vector < string > combine (string word, vector < string > prev){ for ( int i =0 ;i < prev. size (); ++ i){ prev [ i ]+= \" \" + word; } return prev; } public: vector < string > wordBreak (string s, unordered_set < string >& dict) { if (m. count (s)) return m [ s ] ; //take from memory vector < string > result; if (dict. count (s)){ //a whole string is a word result. push_back (s); } for ( int i =1 ;i < s. size (); ++ i){ string word = s. substr (i); if (dict. count (word)){ //s[0:i] and s[i:], s[i:] is checked, now check s[0:i] string rem = s. substr ( 0 ,i); vector < string > prev = combine(word,wordBreak(rem,dict)); result. insert (result. end (),prev. begin (), prev. end ()); } } m [ s ]= result; //memorize return result; } }; dfs always takes in from s[0:i], and check s[i:] for current branch cache is the map of current s[0:i] to all the combination for this substring, so for s[0:i+1], to check s[0:i], just uses the cached one and combine with s[:i] Another way w/ memo \u00b6 After memo: class Solution { public : vector < string > wordBreak (string s, vector < string >& wordDict) { unordered_map < string, vector < string >> m; // word segment -> using what words to form return helper(s, wordDict, m); } // will return all ways to combine this word vector < string > helper (string s, vector < string >& wordDict, unordered_map < string, vector < string >>& m) { if (m. count (s)) return m [ s ] ; if (s. empty ()) return { \"\" }; vector < string > res; for (string word : wordDict) { // try all words if (s. substr ( 0 , word. size ()) != word) continue ; vector < string > rem = helper(s. substr (word. size ()), wordDict, m); for (string str : rem) { res. push_back (word + (str. empty () ? \"\" : \" \" ) + str); } } return m [ s ] = res; } };","title":"Word Break II"},{"location":"Leetcode/140.-word-break-ii/#word-break-ii","text":"Given a string s and a dictionary of strings wordDict , add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order . Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"] Output: [\"cats and dog\",\"cat sand dog\"] Example 2: Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"] Output: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: [] Constraints: 1 <= s.length <= 20 1 <= wordDict.length <= 1000 1 <= wordDict[i].length <= 10 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique .","title":"Word Break II"},{"location":"Leetcode/140.-word-break-ii/#dfs-w-memo","text":"class Solution { unordered_map < string, vector < string >> m; vector < string > combine (string word, vector < string > prev){ for ( int i =0 ;i < prev. size (); ++ i){ prev [ i ]+= \" \" + word; } return prev; } public: vector < string > wordBreak (string s, unordered_set < string >& dict) { if (m. count (s)) return m [ s ] ; //take from memory vector < string > result; if (dict. count (s)){ //a whole string is a word result. push_back (s); } for ( int i =1 ;i < s. size (); ++ i){ string word = s. substr (i); if (dict. count (word)){ //s[0:i] and s[i:], s[i:] is checked, now check s[0:i] string rem = s. substr ( 0 ,i); vector < string > prev = combine(word,wordBreak(rem,dict)); result. insert (result. end (),prev. begin (), prev. end ()); } } m [ s ]= result; //memorize return result; } }; dfs always takes in from s[0:i], and check s[i:] for current branch cache is the map of current s[0:i] to all the combination for this substring, so for s[0:i+1], to check s[0:i], just uses the cached one and combine with s[:i]","title":"dfs w/ memo"},{"location":"Leetcode/140.-word-break-ii/#another-way-w-memo","text":"After memo: class Solution { public : vector < string > wordBreak (string s, vector < string >& wordDict) { unordered_map < string, vector < string >> m; // word segment -> using what words to form return helper(s, wordDict, m); } // will return all ways to combine this word vector < string > helper (string s, vector < string >& wordDict, unordered_map < string, vector < string >>& m) { if (m. count (s)) return m [ s ] ; if (s. empty ()) return { \"\" }; vector < string > res; for (string word : wordDict) { // try all words if (s. substr ( 0 , word. size ()) != word) continue ; vector < string > rem = helper(s. substr (word. size ()), wordDict, m); for (string str : rem) { res. push_back (word + (str. empty () ? \"\" : \" \" ) + str); } } return m [ s ] = res; } };","title":"Another way w/ memo"},{"location":"Leetcode/146.-lru-cache/","text":"LRU Cache \u00b6 Design a data structure that follows the constraints of a Least Recently Used (LRU) cache . Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity . int get(int key) Return the value of the key if the key exists, otherwise return -1 . void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. Follow up: Could you do get and put in O(1) time complexity? Example 1: Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 Constraints: 1 <= capacity <= 3000 0 <= key <= 3000 0 <= value <= 104 At most 3 * 104 calls will be made to get and put . double linked list with map (java) \u00b6 import java.util.Hashtable ; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } /** * Always add the new node right after head; */ /* before: node.pre - node - node.post head - head.post (tail) after: head - node - head.post (tail) */ private void addNode (DLinkedNode node) { node. pre = head; node. post = head. post ; head. post . pre = node; head. post = node; } /** * Remove an existing node from the linked list. */ // pre - node - post -> pre - post private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } /** * Move certain node in between to the head. */ private void moveToHead (DLinkedNode node){ this . removeNode (node); this . addNode (node); // head->post now point to node } // pop the current tail. private DLinkedNode popTail (){ DLinkedNode res = tail. pre ; this . removeNode (res); // return res; } private Hashtable < Integer, DLinkedNode > cache = new Hashtable < Integer, DLinkedNode > (); private int count; private int capacity; private DLinkedNode head, tail; // head.pre (null) - head - head.post (tail) // tail.pre (head) - tail - tail.post (null) // -> head.pre (null) - head - tail - tail.post (null) public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } public int get ( int key) { DLinkedNode node = cache. get (key); if (node == null ){ return -1 ; // should raise exception here. } // move the accessed node to the head; this . moveToHead (node); return node. value ; } public void put ( int key, int value) { DLinkedNode node = cache. get (key); if (node == null ){ // need to insert new key-value pair into the list DLinkedNode newNode = new DLinkedNode(); newNode. key = key; newNode. value = value; this . cache . put (key, newNode); this . addNode (newNode); ++ count; // same as the size of cache.size() if (count > capacity){ // pop the tail DLinkedNode tail = this . popTail (); this . cache . remove (tail. key ); -- count; } } else { // just swap to the head and update value node. value = value; this . moveToHead (node); } } } why bother doubly linked list \u00b6 Fast removal. Doubly linked lists let us remove and insert in constant time if we have access to a node directly. The hashtable gives us access to a node directly. If we use a singly linked list we will need to spend O(n) time to remove a node even if we have direct reference to the node that needs to get removed. (This is because to remove in a singly linked list we need to point nodeToDelete's previous node to nodeToDelete's next node. Finding nodeToDelete's previous is expensive if nodeToDelete is the last node in the list.) why cannot converted to singly linked list in Java \u00b6 People who are wondering why we have double-linked list here instead of single-linked linked list : Yes, the purpose can be achieved with a single-linked LL with some hacks but NOT in java. Let's say I've to remove node n and it's previous node is p. If n is the last node in the list, I've to modify the next field of p to point to null. This can't be done if I don't have access to p.next since in java, method parameters are actually references of the objects and they are passed by value. So, let's say right now, n and p.next point to the same object (i.e. n of course). If I do n=null, that doesn't makes the object null. The object is still there and p.next points to that object. The only diff is that now n doesn't point to that object. In fact, it doesn't point to anything. n=null doesn't remove n, but just send what it points-to to null public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } if tail.pre is always pointing to head, and head.post always points to tail private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } cpp \u00b6 class LRUCache { struct Node { int key, val; Node * next, * pre; Node( int key, int val) : key(key) , val(val) { } }; private : unordered_map < int , Node *> map; int cap; Node * head, * tail; public : LRUCache( int capacity) { cap = capacity; head = NULL , tail = NULL ; } int get( int key) { if ( ! map.count(key)) return -1 ; Node * node = map[key]; if (node != tail) { if (node == head) { head = head -> next; // leave space for head to move node to the back } else { // pre <-> node <-> next => pre <-> next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; // now tail points to the latest node node -> pre = tail; node -> next = NULL ; tail = node; } return node -> val; } void put( int key, int value) { // exist if (map.count(key)) { Node * node = map[key]; node -> val = value; // update value if (node != tail) { // here are the same logic as in get() if (node == head) { // head now points to the second recent used node head = head -> next; } else { // split out node, now node.pre - node.next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL ; tail = node; } } else { // not exit Node * newNode = new Node(key, value); if (cap == 0 ) { // cap == capacity - map.size() Node * temp = head; head = head -> next; // always remove the least recent used node map.erase(temp -> key); cap ++ ; } // what could happen after removal? if (head == NULL && tail == NULL ) { head = newNode; } else { // let tail point to the newly inserted node tail -> next = newNode; newNode -> pre = tail; newNode -> next = NULL ; } tail = newNode; map[key] = newNode; cap -- ; } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ head: least recent used node tail: most recent used node","title":"LRU Cache"},{"location":"Leetcode/146.-lru-cache/#lru-cache","text":"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache . Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity . int get(int key) Return the value of the key if the key exists, otherwise return -1 . void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. Follow up: Could you do get and put in O(1) time complexity? Example 1: Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 Constraints: 1 <= capacity <= 3000 0 <= key <= 3000 0 <= value <= 104 At most 3 * 104 calls will be made to get and put .","title":"LRU Cache"},{"location":"Leetcode/146.-lru-cache/#double-linked-list-with-map-java","text":"import java.util.Hashtable ; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } /** * Always add the new node right after head; */ /* before: node.pre - node - node.post head - head.post (tail) after: head - node - head.post (tail) */ private void addNode (DLinkedNode node) { node. pre = head; node. post = head. post ; head. post . pre = node; head. post = node; } /** * Remove an existing node from the linked list. */ // pre - node - post -> pre - post private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } /** * Move certain node in between to the head. */ private void moveToHead (DLinkedNode node){ this . removeNode (node); this . addNode (node); // head->post now point to node } // pop the current tail. private DLinkedNode popTail (){ DLinkedNode res = tail. pre ; this . removeNode (res); // return res; } private Hashtable < Integer, DLinkedNode > cache = new Hashtable < Integer, DLinkedNode > (); private int count; private int capacity; private DLinkedNode head, tail; // head.pre (null) - head - head.post (tail) // tail.pre (head) - tail - tail.post (null) // -> head.pre (null) - head - tail - tail.post (null) public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } public int get ( int key) { DLinkedNode node = cache. get (key); if (node == null ){ return -1 ; // should raise exception here. } // move the accessed node to the head; this . moveToHead (node); return node. value ; } public void put ( int key, int value) { DLinkedNode node = cache. get (key); if (node == null ){ // need to insert new key-value pair into the list DLinkedNode newNode = new DLinkedNode(); newNode. key = key; newNode. value = value; this . cache . put (key, newNode); this . addNode (newNode); ++ count; // same as the size of cache.size() if (count > capacity){ // pop the tail DLinkedNode tail = this . popTail (); this . cache . remove (tail. key ); -- count; } } else { // just swap to the head and update value node. value = value; this . moveToHead (node); } } }","title":"double linked list with map (java)"},{"location":"Leetcode/146.-lru-cache/#why-bother-doubly-linked-list","text":"Fast removal. Doubly linked lists let us remove and insert in constant time if we have access to a node directly. The hashtable gives us access to a node directly. If we use a singly linked list we will need to spend O(n) time to remove a node even if we have direct reference to the node that needs to get removed. (This is because to remove in a singly linked list we need to point nodeToDelete's previous node to nodeToDelete's next node. Finding nodeToDelete's previous is expensive if nodeToDelete is the last node in the list.)","title":"why bother doubly linked list"},{"location":"Leetcode/146.-lru-cache/#why-cannot-converted-to-singly-linked-list-in-java","text":"People who are wondering why we have double-linked list here instead of single-linked linked list : Yes, the purpose can be achieved with a single-linked LL with some hacks but NOT in java. Let's say I've to remove node n and it's previous node is p. If n is the last node in the list, I've to modify the next field of p to point to null. This can't be done if I don't have access to p.next since in java, method parameters are actually references of the objects and they are passed by value. So, let's say right now, n and p.next point to the same object (i.e. n of course). If I do n=null, that doesn't makes the object null. The object is still there and p.next points to that object. The only diff is that now n doesn't point to that object. In fact, it doesn't point to anything. n=null doesn't remove n, but just send what it points-to to null public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } if tail.pre is always pointing to head, and head.post always points to tail private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; }","title":"why cannot converted to singly linked list in Java"},{"location":"Leetcode/146.-lru-cache/#cpp","text":"class LRUCache { struct Node { int key, val; Node * next, * pre; Node( int key, int val) : key(key) , val(val) { } }; private : unordered_map < int , Node *> map; int cap; Node * head, * tail; public : LRUCache( int capacity) { cap = capacity; head = NULL , tail = NULL ; } int get( int key) { if ( ! map.count(key)) return -1 ; Node * node = map[key]; if (node != tail) { if (node == head) { head = head -> next; // leave space for head to move node to the back } else { // pre <-> node <-> next => pre <-> next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; // now tail points to the latest node node -> pre = tail; node -> next = NULL ; tail = node; } return node -> val; } void put( int key, int value) { // exist if (map.count(key)) { Node * node = map[key]; node -> val = value; // update value if (node != tail) { // here are the same logic as in get() if (node == head) { // head now points to the second recent used node head = head -> next; } else { // split out node, now node.pre - node.next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL ; tail = node; } } else { // not exit Node * newNode = new Node(key, value); if (cap == 0 ) { // cap == capacity - map.size() Node * temp = head; head = head -> next; // always remove the least recent used node map.erase(temp -> key); cap ++ ; } // what could happen after removal? if (head == NULL && tail == NULL ) { head = newNode; } else { // let tail point to the newly inserted node tail -> next = newNode; newNode -> pre = tail; newNode -> next = NULL ; } tail = newNode; map[key] = newNode; cap -- ; } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ head: least recent used node tail: most recent used node","title":"cpp"},{"location":"Leetcode/148.-sort-list/","text":"Sort List \u00b6 Given the head of a linked list, return the list after sorting it in ascending order **. Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)? Example 1: Input: head = [4,2,1,3] Output: [1,2,3,4] Example 2: Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] Example 3: Input: head = [] Output: [] Constraints: The number of nodes in the list is in the range [0, 5 * 104] . -105 <= Node.val <= 105 Analysis \u00b6 To sort a linkedlist with constant space, we can use merge sort (for array it will be O(N) O(N) space). Let's recap what to do if we are sorting an array: define base case: there is only one element find mid and split array into left - mid and mid+1 - right recurse left part and right part use a temporary array to store the sorted array in range of current left - right reassign back to the original array from the temporary array Convert to linkedlist: define base case: only one node (listnode) use slow-fast pointers to find mid set mid -> next = NULL so it will split left - mid -> NULL and mid + 1 - right recurse left and right create a dummy list node and use two pointers to append append the one with smaller value first since we didn't create a new list, we can just return now Time: O(n \\times log_2{n}) O(n \\times log_2{n}) for each break: O(n) O(n) + for merge: O(n) O(n) + for height O(log_2{n}) O(log_2{n}) Code \u00b6 class Solution { public : ListNode * h(ListNode * head) { if ( ! head || ! head -> next) return head; // find mid ListNode * pre = head, * slow = head -> next, * fast = head -> next; while (fast && fast -> next) { pre = pre -> next; slow = slow -> next; fast = fast -> next -> next; } // break pre -> next = NULL ; ListNode * left = h(head), * right = h(slow); // merge ListNode res ( -1 ); ListNode * curr = & res; while (left && right) { if (left -> val < right -> val) { curr -> next = left; left = left -> next; } else { curr -> next = right; right = right -> next; } curr = curr -> next; } // append the rest if (left) curr -> next = left; if (right) curr -> next = right; return ( & res) -> next; } ListNode * sortList(ListNode * head) { return h (head); } };","title":"Sort List"},{"location":"Leetcode/148.-sort-list/#sort-list","text":"Given the head of a linked list, return the list after sorting it in ascending order **. Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)? Example 1: Input: head = [4,2,1,3] Output: [1,2,3,4] Example 2: Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] Example 3: Input: head = [] Output: [] Constraints: The number of nodes in the list is in the range [0, 5 * 104] . -105 <= Node.val <= 105","title":"Sort List"},{"location":"Leetcode/148.-sort-list/#analysis","text":"To sort a linkedlist with constant space, we can use merge sort (for array it will be O(N) O(N) space). Let's recap what to do if we are sorting an array: define base case: there is only one element find mid and split array into left - mid and mid+1 - right recurse left part and right part use a temporary array to store the sorted array in range of current left - right reassign back to the original array from the temporary array Convert to linkedlist: define base case: only one node (listnode) use slow-fast pointers to find mid set mid -> next = NULL so it will split left - mid -> NULL and mid + 1 - right recurse left and right create a dummy list node and use two pointers to append append the one with smaller value first since we didn't create a new list, we can just return now Time: O(n \\times log_2{n}) O(n \\times log_2{n}) for each break: O(n) O(n) + for merge: O(n) O(n) + for height O(log_2{n}) O(log_2{n})","title":"Analysis"},{"location":"Leetcode/148.-sort-list/#code","text":"class Solution { public : ListNode * h(ListNode * head) { if ( ! head || ! head -> next) return head; // find mid ListNode * pre = head, * slow = head -> next, * fast = head -> next; while (fast && fast -> next) { pre = pre -> next; slow = slow -> next; fast = fast -> next -> next; } // break pre -> next = NULL ; ListNode * left = h(head), * right = h(slow); // merge ListNode res ( -1 ); ListNode * curr = & res; while (left && right) { if (left -> val < right -> val) { curr -> next = left; left = left -> next; } else { curr -> next = right; right = right -> next; } curr = curr -> next; } // append the rest if (left) curr -> next = left; if (right) curr -> next = right; return ( & res) -> next; } ListNode * sortList(ListNode * head) { return h (head); } };","title":"Code"},{"location":"Leetcode/149.-max-points-on-a-line/","text":"Max Points on a line \u00b6 Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line . Example 1: Input: points = [[1,1],[2,2],[3,3]] Output: 3 Example 2: Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Constraints: 1 <= points.length <= 300 points[i].length == 2 -104 <= xi, yi <= 104 All the points are unique . Analysis \u00b6 In order to make sure more than two points are on the same line, any two of the points have to share the same slope. So we can use slope -> # of points with the same slope to calculate the maximum number of points on the slope. To calculate the slope, we cannot just arbitary choose two points, since we don't want to calculate the slope of a, b and b, a twice. To achieve this, we just need two for loop: for i = 0 to n: for j = i + 1 to n: do your thing To do so, there are two special cases to take into consideration: 1. If two points are vertical align, then the slope would be 0 2. If two points are the same, we still need to update the result Time Complexity: O(n^2) O(n^2) Space Complexity: O(n^2) O(n^2) Code \u00b6 class Solution { public : int maxPoints(vector < vector < int >>& points) { if (points.empty()) return 0 ; int res = 1 ; for ( int i = 0 ; i < points.size(); ++ i) { unordered_map < long double , int > m; // slope -> num of points int duplicate = 0 , vertical = 1 ; // set vertical to 1 since itself also counts as one for ( int j = i + 1 ; j < points.size(); ++ j) { if (points[i][ 0 ] == points[j][ 0 ]) { vertical ++ ; if (points[i][ 1 ] == points[j][ 1 ]) duplicate ++ ; } } for ( int j = i + 1 ; j < points.size(); ++ j) { if (points[i][ 0 ] == points[j][ 0 ]) continue ; long double slope = ( long double ) (points[i][ 1 ] - points[j][ 1 ]) / (points[i][ 0 ] - points[j][ 0 ]); if (m[slope] == 0 ) m[slope] = 2 ; else m[slope] ++ ; res = max(res, m[slope] + duplicate); } res = max(res, vertical); } return res; } };","title":"Max Points on a line"},{"location":"Leetcode/149.-max-points-on-a-line/#max-points-on-a-line","text":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line . Example 1: Input: points = [[1,1],[2,2],[3,3]] Output: 3 Example 2: Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Constraints: 1 <= points.length <= 300 points[i].length == 2 -104 <= xi, yi <= 104 All the points are unique .","title":"Max Points on a line"},{"location":"Leetcode/149.-max-points-on-a-line/#analysis","text":"In order to make sure more than two points are on the same line, any two of the points have to share the same slope. So we can use slope -> # of points with the same slope to calculate the maximum number of points on the slope. To calculate the slope, we cannot just arbitary choose two points, since we don't want to calculate the slope of a, b and b, a twice. To achieve this, we just need two for loop: for i = 0 to n: for j = i + 1 to n: do your thing To do so, there are two special cases to take into consideration: 1. If two points are vertical align, then the slope would be 0 2. If two points are the same, we still need to update the result Time Complexity: O(n^2) O(n^2) Space Complexity: O(n^2) O(n^2)","title":"Analysis"},{"location":"Leetcode/149.-max-points-on-a-line/#code","text":"class Solution { public : int maxPoints(vector < vector < int >>& points) { if (points.empty()) return 0 ; int res = 1 ; for ( int i = 0 ; i < points.size(); ++ i) { unordered_map < long double , int > m; // slope -> num of points int duplicate = 0 , vertical = 1 ; // set vertical to 1 since itself also counts as one for ( int j = i + 1 ; j < points.size(); ++ j) { if (points[i][ 0 ] == points[j][ 0 ]) { vertical ++ ; if (points[i][ 1 ] == points[j][ 1 ]) duplicate ++ ; } } for ( int j = i + 1 ; j < points.size(); ++ j) { if (points[i][ 0 ] == points[j][ 0 ]) continue ; long double slope = ( long double ) (points[i][ 1 ] - points[j][ 1 ]) / (points[i][ 0 ] - points[j][ 0 ]); if (m[slope] == 0 ) m[slope] = 2 ; else m[slope] ++ ; res = max(res, m[slope] + duplicate); } res = max(res, vertical); } return res; } };","title":"Code"},{"location":"Leetcode/152.-maximum-product-subarray/","text":"Maximum Product Subarray \u00b6 refer to /tech_notes/Interivew/Maximum Product Subarray","title":"Maximum Product Subarray"},{"location":"Leetcode/152.-maximum-product-subarray/#maximum-product-subarray","text":"refer to /tech_notes/Interivew/Maximum Product Subarray","title":"Maximum Product Subarray"},{"location":"Leetcode/164.-Maximum-Gap/","text":"Maximum Gap \u00b6 Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. Analysis \u00b6 Let's first split the array into multiple equal size ranges, and the total number of ranges is n (the size of the input array). 3, 6, 9, 1 -> we have 4 numbers, so we will have four ranges (] (] (] (] Because we have n ranges, if we can know how big is each range, we can place each number to its correct range. For each range, we will keep a record of the maximum difference between current number and the sorted number. 3, 6, 9, 1 -> Let's assume the size of each range is len (a, a + len] (b, b + len] (c, c + len] (d, d + len] To determine which range should each number be placed into, we use a math trick: idx = \\frac{x-a-1}{n-1} idx = \\frac{x-a-1}{n-1} , where a is the minimal value or the starting value of our ranges. Given these information, we can just find and compare the maximum difference across each two ranges. Now we have n numbers, and there are len - 1 numbers in each range. If we have relatively small length of each range, the maximum difference cannot exist in each range, but across two successive ranges. $ (n-1)(len-1) < Max - Min$, which yield (Max - Min + n - 2)/(n - 1) after rearrangement. Time: O(n) O(n) Space: O(n) O(n) Code \u00b6 class Solution { public : struct Range { int min,max; bool used; Range() : min(INT_MAX), max(INT_MIN), used( false ) {} }; int maximumGap (vector < int >& nums) { int n = nums.size(); int Max = INT_MIN, Min = INT_MAX; for ( int x : nums) { Max = max(Max, x); Min = min(Min, x); } if (n < 2 || Max == Min) return 0 ; vector < Range > r(n -1 ); // average size of each range to make sure // global diff only exists in each range // but not accross any two more more range int len = (Max - Min + n -2 ) / (n -1 ); for ( int x : nums) { if (x == Min) continue ; int idx = (x - Min -1 ) / len; r[idx].min = min(r[idx].min,x); r[idx].max = max(r[idx].max, x); r[idx].used = true ; } int res = 0 ; for ( int i = 0 , last = Min; i < n - 1 ; ++ i) { if (r[i].used) { res = max(res, r[i].min - last); last = r[i].max; } } return res; } };","title":"Maximum Gap"},{"location":"Leetcode/164.-Maximum-Gap/#maximum-gap","text":"Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space.","title":"Maximum Gap"},{"location":"Leetcode/164.-Maximum-Gap/#analysis","text":"Let's first split the array into multiple equal size ranges, and the total number of ranges is n (the size of the input array). 3, 6, 9, 1 -> we have 4 numbers, so we will have four ranges (] (] (] (] Because we have n ranges, if we can know how big is each range, we can place each number to its correct range. For each range, we will keep a record of the maximum difference between current number and the sorted number. 3, 6, 9, 1 -> Let's assume the size of each range is len (a, a + len] (b, b + len] (c, c + len] (d, d + len] To determine which range should each number be placed into, we use a math trick: idx = \\frac{x-a-1}{n-1} idx = \\frac{x-a-1}{n-1} , where a is the minimal value or the starting value of our ranges. Given these information, we can just find and compare the maximum difference across each two ranges. Now we have n numbers, and there are len - 1 numbers in each range. If we have relatively small length of each range, the maximum difference cannot exist in each range, but across two successive ranges. $ (n-1)(len-1) < Max - Min$, which yield (Max - Min + n - 2)/(n - 1) after rearrangement. Time: O(n) O(n) Space: O(n) O(n)","title":"Analysis"},{"location":"Leetcode/164.-Maximum-Gap/#code","text":"class Solution { public : struct Range { int min,max; bool used; Range() : min(INT_MAX), max(INT_MIN), used( false ) {} }; int maximumGap (vector < int >& nums) { int n = nums.size(); int Max = INT_MIN, Min = INT_MAX; for ( int x : nums) { Max = max(Max, x); Min = min(Min, x); } if (n < 2 || Max == Min) return 0 ; vector < Range > r(n -1 ); // average size of each range to make sure // global diff only exists in each range // but not accross any two more more range int len = (Max - Min + n -2 ) / (n -1 ); for ( int x : nums) { if (x == Min) continue ; int idx = (x - Min -1 ) / len; r[idx].min = min(r[idx].min,x); r[idx].max = max(r[idx].max, x); r[idx].used = true ; } int res = 0 ; for ( int i = 0 , last = Min; i < n - 1 ; ++ i) { if (r[i].used) { res = max(res, r[i].min - last); last = r[i].max; } } return res; } };","title":"Code"},{"location":"Leetcode/167.-Two-Sum-II-Input-Array-Is-Sorted/","text":"Two Sum II - Input Array Is Sorted \u00b6 Given a 1-indexed* array of integers numbers that is already sorted in non-decreasing order***, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length . Return the indices of the two numbers, index1 and index2 , added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution . You may not use the same element twice. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: 2 <= numbers.length <= 3 * 104 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order . -1000 <= target <= 1000 The tests are generated such that there is exactly one solution . Analysis \u00b6 Since the input array is sorted, to find the the target sum we can use two pointers to reach the optimal complexity. The comparsion condition is by comparing the current sum and target, if current sum is greater than target then we should minimize the sum, and the only way by doing so is moving the bigger (right pointer) to a smaller value (move to left). Note that left pointer can only move to right and right pointer can only move to left, or the algorithm will fail (infinite loop due to duplicating check). Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : vector < int > twoSum(vector < int >& numbers, int target) { for ( int l = 0 , r = numbers.size() - 1 ; l < r;) { int curr = numbers[l] + numbers[r]; if (target == curr) return {l + 1 , r + 1 }; else if (target < curr) r -- ; else l ++ ; } return {}; } };","title":"Two Sum II - Input Array Is Sorted"},{"location":"Leetcode/167.-Two-Sum-II-Input-Array-Is-Sorted/#two-sum-ii-input-array-is-sorted","text":"Given a 1-indexed* array of integers numbers that is already sorted in non-decreasing order***, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length . Return the indices of the two numbers, index1 and index2 , added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution . You may not use the same element twice. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: 2 <= numbers.length <= 3 * 104 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order . -1000 <= target <= 1000 The tests are generated such that there is exactly one solution .","title":"Two Sum II - Input Array Is Sorted"},{"location":"Leetcode/167.-Two-Sum-II-Input-Array-Is-Sorted/#analysis","text":"Since the input array is sorted, to find the the target sum we can use two pointers to reach the optimal complexity. The comparsion condition is by comparing the current sum and target, if current sum is greater than target then we should minimize the sum, and the only way by doing so is moving the bigger (right pointer) to a smaller value (move to left). Note that left pointer can only move to right and right pointer can only move to left, or the algorithm will fail (infinite loop due to duplicating check). Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/167.-Two-Sum-II-Input-Array-Is-Sorted/#code","text":"class Solution { public : vector < int > twoSum(vector < int >& numbers, int target) { for ( int l = 0 , r = numbers.size() - 1 ; l < r;) { int curr = numbers[l] + numbers[r]; if (target == curr) return {l + 1 , r + 1 }; else if (target < curr) r -- ; else l ++ ; } return {}; } };","title":"Code"},{"location":"Leetcode/169.-majority-element/","text":"Majority Element \u00b6 Given an array nums of size n , return the majority element . The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 <= n <= 5 * 104 -231 <= nums[i] <= 231 - 1 Analysis \u00b6 Using Boyer-Moore majority vote algorithm . Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : int majorityElement(vector < int >& nums) { int cnt = 0 , candidate = nums[ 0 ]; for ( int e : nums) { if (cnt == 0 ) candidate = e, cnt = 1 ; else if (candidate == e) cnt ++ ; else cnt -- ; } return candidate; } };","title":"Majority Element"},{"location":"Leetcode/169.-majority-element/#majority-element","text":"Given an array nums of size n , return the majority element . The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 <= n <= 5 * 104 -231 <= nums[i] <= 231 - 1","title":"Majority Element"},{"location":"Leetcode/169.-majority-element/#analysis","text":"Using Boyer-Moore majority vote algorithm . Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/169.-majority-element/#code","text":"class Solution { public : int majorityElement(vector < int >& nums) { int cnt = 0 , candidate = nums[ 0 ]; for ( int e : nums) { if (cnt == 0 ) candidate = e, cnt = 1 ; else if (candidate == e) cnt ++ ; else cnt -- ; } return candidate; } };","title":"Code"},{"location":"Leetcode/174.-Dungeon-Game/","text":"Dungeon Game \u00b6 The demons had captured the princess ( P ) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight ( K ) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health ( negative integers) upon entering these rooms; other rooms are either empty ( 0's ) or contain magic orbs that increase the knight's health ( positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN . -2 (K) -3 3 -5 -10 1 10 30 -5 (P) Note: The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Analysis \u00b6 For each cell, we have three requirements fullfill: HP is short for health HP > 0 HP + w[i][j + 1] > 0 if you want to move right HP + w[i + 1][j] > 0 if you want to move downward However, you don't need to satisfy case 2 and case 3 at the same time, and you should always choose the direction that could make you easier to reach to your goal. What I mean by \"easier\" is that HP is the least in all three cases. So we can define a f 2D array that represents the minimal health for each cell. To find out the initial minimal health, we just return f[0][0] , and using the rules we have defined previously, the induction rule is: f[i][j]=min(1,f[i][j]-w[i][j+1],f[i][j]-w[i+1][j]) After resolving all the edge cases, we can return our answer. Time: O(m \\times n) O(m \\times n) Space: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public : int calculateMinimumHP(vector < vector < int >>& d) { int res = INT_MAX, m = d.size(), n = d[ 0 ].size(); vector < vector < int >> f(m, vector < int > (n, INT_MAX)); for ( int i = m - 1 ; i >= 0 ; -- i) for ( int j = n - 1 ; j >= 0 ; -- j) { // this is the starting point if (i == m - 1 && j == n - 1 ) f[i][j] = max( 1 , 1 - d[i][j]); else { // check right if (i + 1 < m) f[i][j] = f[i + 1 ][j] - d[i][j]; // check down if (j + 1 < n) f[i][j] = min(f[i][j], f[i][j + 1 ] - d[i][j]); // check 1 f[i][j] = max( 1 , f[i][j]); } } return f[ 0 ][ 0 ]; } };","title":"Dungeon Game"},{"location":"Leetcode/174.-Dungeon-Game/#dungeon-game","text":"The demons had captured the princess ( P ) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight ( K ) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health ( negative integers) upon entering these rooms; other rooms are either empty ( 0's ) or contain magic orbs that increase the knight's health ( positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN . -2 (K) -3 3 -5 -10 1 10 30 -5 (P) Note: The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.","title":"Dungeon Game"},{"location":"Leetcode/174.-Dungeon-Game/#analysis","text":"For each cell, we have three requirements fullfill: HP is short for health HP > 0 HP + w[i][j + 1] > 0 if you want to move right HP + w[i + 1][j] > 0 if you want to move downward However, you don't need to satisfy case 2 and case 3 at the same time, and you should always choose the direction that could make you easier to reach to your goal. What I mean by \"easier\" is that HP is the least in all three cases. So we can define a f 2D array that represents the minimal health for each cell. To find out the initial minimal health, we just return f[0][0] , and using the rules we have defined previously, the induction rule is: f[i][j]=min(1,f[i][j]-w[i][j+1],f[i][j]-w[i+1][j]) After resolving all the edge cases, we can return our answer. Time: O(m \\times n) O(m \\times n) Space: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Leetcode/174.-Dungeon-Game/#code","text":"class Solution { public : int calculateMinimumHP(vector < vector < int >>& d) { int res = INT_MAX, m = d.size(), n = d[ 0 ].size(); vector < vector < int >> f(m, vector < int > (n, INT_MAX)); for ( int i = m - 1 ; i >= 0 ; -- i) for ( int j = n - 1 ; j >= 0 ; -- j) { // this is the starting point if (i == m - 1 && j == n - 1 ) f[i][j] = max( 1 , 1 - d[i][j]); else { // check right if (i + 1 < m) f[i][j] = f[i + 1 ][j] - d[i][j]; // check down if (j + 1 < n) f[i][j] = min(f[i][j], f[i][j + 1 ] - d[i][j]); // check 1 f[i][j] = max( 1 , f[i][j]); } } return f[ 0 ][ 0 ]; } };","title":"Code"},{"location":"Leetcode/189.-Rotate-Array/","text":"Rotate Array \u00b6 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints: 1 <= nums.length <= 105 -231 <= nums[i] <= 231 - 1 0 <= k <= 105 Follow up: Try to come up with as many solutions as you can. There are at least three different ways to solve this problem. Could you do it in-place with O(1) extra space? Analysis \u00b6 This question can be solved by just observing the pattern: For nums = [1,2,3,4,5,6,7], k = 3 case, we can find the resulting array [5,6,7,1,2,3,4] can be splitted into two parts: [5,6,7] and [1,2,3,4] , and the first part is having a length of 3 which is k, and each part is preseving the same order. We can rotate the array from any splice easily (using the standard libary std::reverse is easy), so we can think of using the reverse way to slice our array into two parts: reverse the entire array so we can choose where to split the two parts reverse the first part so we can get the first part in increasing order reverse the second part so we can get the second part in increasing order Time: O(n + k + n - k) O(n + k + n - k) = O(n) O(n) Space: O(1) O(1) \u2013 we don't need the auxiliary array to placehold the reverse Code \u00b6 class Solution { public : void rotate(vector < int >& nums, int k) { k %= nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } }; STL implementaton of reverse \u00b6 STL doesn't require an aux array to swap, ref: https://en.cppreference.com/w/cpp/algorithm/reverse template < class BidirIt > constexpr // since C++20 void reverse(BidirIt first, BidirIt last) { using iter_cat = typename std :: iterator_traits < BidirIt >:: iterator_category; // Tag dispatch, e.g. calling reverse_impl(first, last, iter_cat()), // can be used in C++14 and earlier modes. if constexpr (std :: is_base_of_v < std :: random_access_iterator_tag, iter_cat > ) { if (first == last) return ; for ( -- last; first < last; ( void ) ++ first, -- last) { std :: iter_swap(first, last); } } else { while ((first != last) && (first != -- last)) { std :: iter_swap(first ++ , last); } } }","title":"Rotate Array"},{"location":"Leetcode/189.-Rotate-Array/#rotate-array","text":"Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints: 1 <= nums.length <= 105 -231 <= nums[i] <= 231 - 1 0 <= k <= 105 Follow up: Try to come up with as many solutions as you can. There are at least three different ways to solve this problem. Could you do it in-place with O(1) extra space?","title":"Rotate Array"},{"location":"Leetcode/189.-Rotate-Array/#analysis","text":"This question can be solved by just observing the pattern: For nums = [1,2,3,4,5,6,7], k = 3 case, we can find the resulting array [5,6,7,1,2,3,4] can be splitted into two parts: [5,6,7] and [1,2,3,4] , and the first part is having a length of 3 which is k, and each part is preseving the same order. We can rotate the array from any splice easily (using the standard libary std::reverse is easy), so we can think of using the reverse way to slice our array into two parts: reverse the entire array so we can choose where to split the two parts reverse the first part so we can get the first part in increasing order reverse the second part so we can get the second part in increasing order Time: O(n + k + n - k) O(n + k + n - k) = O(n) O(n) Space: O(1) O(1) \u2013 we don't need the auxiliary array to placehold the reverse","title":"Analysis"},{"location":"Leetcode/189.-Rotate-Array/#code","text":"class Solution { public : void rotate(vector < int >& nums, int k) { k %= nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } };","title":"Code"},{"location":"Leetcode/189.-Rotate-Array/#stl-implementaton-of-reverse","text":"STL doesn't require an aux array to swap, ref: https://en.cppreference.com/w/cpp/algorithm/reverse template < class BidirIt > constexpr // since C++20 void reverse(BidirIt first, BidirIt last) { using iter_cat = typename std :: iterator_traits < BidirIt >:: iterator_category; // Tag dispatch, e.g. calling reverse_impl(first, last, iter_cat()), // can be used in C++14 and earlier modes. if constexpr (std :: is_base_of_v < std :: random_access_iterator_tag, iter_cat > ) { if (first == last) return ; for ( -- last; first < last; ( void ) ++ first, -- last) { std :: iter_swap(first, last); } } else { while ((first != last) && (first != -- last)) { std :: iter_swap(first ++ , last); } } }","title":"STL implementaton of reverse"},{"location":"Leetcode/19.-Remove-Nth-Node-From-End-of-List/","text":"Remove Nth Node From End of List \u00b6 Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1], n = 1 Output: [] Example 3: Input: head = [1,2], n = 1 Output: [1] Constraints: The number of nodes in the list is sz . 1 <= sz <= 30 0 <= Node.val <= 100 1 <= n <= sz Follow up: Could you do this in one pass? Analysis \u00b6 This question can be solved using two pointers method. In order to reach the last nth position, we need to keep a subset of the linkedlist with the length of n, and using it to offset target position. Then we need to handle a special case when n = 1 and we need to remove the first element of the linkedlist. Time: O(n) O(n) Space: O(1) O(1) if ignore the dummy pointer. Code \u00b6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * removeNthFromEnd(ListNode * head, int n) { ListNode * a = new ListNode( -1 , head), * b = head; while (n -- ) { b = b -> next; } while (b) { a = a -> next; b = b -> next; } if (a -> next == head) return head -> next; if (a -> next) a -> next = a -> next -> next; return head; } };","title":"Remove Nth Node From End of List"},{"location":"Leetcode/19.-Remove-Nth-Node-From-End-of-List/#remove-nth-node-from-end-of-list","text":"Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1], n = 1 Output: [] Example 3: Input: head = [1,2], n = 1 Output: [1] Constraints: The number of nodes in the list is sz . 1 <= sz <= 30 0 <= Node.val <= 100 1 <= n <= sz Follow up: Could you do this in one pass?","title":"Remove Nth Node From End of List"},{"location":"Leetcode/19.-Remove-Nth-Node-From-End-of-List/#analysis","text":"This question can be solved using two pointers method. In order to reach the last nth position, we need to keep a subset of the linkedlist with the length of n, and using it to offset target position. Then we need to handle a special case when n = 1 and we need to remove the first element of the linkedlist. Time: O(n) O(n) Space: O(1) O(1) if ignore the dummy pointer.","title":"Analysis"},{"location":"Leetcode/19.-Remove-Nth-Node-From-End-of-List/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * removeNthFromEnd(ListNode * head, int n) { ListNode * a = new ListNode( -1 , head), * b = head; while (n -- ) { b = b -> next; } while (b) { a = a -> next; b = b -> next; } if (a -> next == head) return head -> next; if (a -> next) a -> next = a -> next -> next; return head; } };","title":"Code"},{"location":"Leetcode/1995.-Count-Special-Quadruplets/","text":"Count Special Quadruplets \u00b6 Given a 0-indexed integer array nums , return the number of distinct quadruplets (a, b, c, d) such that: nums[a] + nums[b] + nums[c] == nums[d] , and a < b < c < d Example 1: Input: nums = [1,2,3,6] Output: 1 Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6. Example 2: Input: nums = [3,3,6,4,5] Output: 0 Explanation: There are no such quadruplets in [3,3,6,4,5]. Example 3: Input: nums = [1,1,1,3,5] Output: 4 Explanation: The 4 quadruplets that satisfy the requirement are: - (0, 1, 2, 3): 1 + 1 + 1 == 3 - (0, 1, 3, 4): 1 + 1 + 3 == 5 - (0, 2, 3, 4): 1 + 1 + 3 == 5 - (1, 2, 3, 4): 1 + 1 + 3 == 5 Constraints: 4 <= nums.length <= 50 1 <= nums[i] <= 100 Analysis \u00b6 This question is similar to two sum: break nums[a] + nums[b] + nums[c] == nums[d] into nums[a] + nums[b] = nums[d] - nums[c] it turns out to find how many sum are there for nums[d] - nums[c] If we break the array into two parts: on the left side from nums[0:i] and right side from nums[i:end] . We choose any arbitary numbers from left side to add to the current value nums[i] , and find how many pairs (each pair represent nums[d] - nums[c] ) of number from nums[i+1:end] equals to current value. To accomplish it, we need to use a map or a counter to store all the pair sum that can be formed from the right side, and it has to be done after we set the pivot i so that we can first calculate the possible sum for nums[a] + nums[b] . Time: O(n^2) O(n^2) Space: O(n) O(n) storing all the possible sum, could only have n possible sum Code \u00b6 class Solution : def countQuadruplets ( self , nums: List[ int ]) -> int : # a + b(i) = d - c(i) l = len (nums) res = 0 count = Counter() for i in range (l - 1 , -1 , -1 ): for a in range (i - 1 , -1 , -1 ): # if see the same sum again, the previous configurations should also work, since our i is going from right to left, every previous d and c is greater than current d and c res += count[nums[a] + nums[i]] for d in range (l - 1 , i, -1 ): count[nums[d] - nums[i]] += 1 return res","title":"1995. Count Special Quadruplets"},{"location":"Leetcode/1995.-Count-Special-Quadruplets/#count-special-quadruplets","text":"Given a 0-indexed integer array nums , return the number of distinct quadruplets (a, b, c, d) such that: nums[a] + nums[b] + nums[c] == nums[d] , and a < b < c < d Example 1: Input: nums = [1,2,3,6] Output: 1 Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6. Example 2: Input: nums = [3,3,6,4,5] Output: 0 Explanation: There are no such quadruplets in [3,3,6,4,5]. Example 3: Input: nums = [1,1,1,3,5] Output: 4 Explanation: The 4 quadruplets that satisfy the requirement are: - (0, 1, 2, 3): 1 + 1 + 1 == 3 - (0, 1, 3, 4): 1 + 1 + 3 == 5 - (0, 2, 3, 4): 1 + 1 + 3 == 5 - (1, 2, 3, 4): 1 + 1 + 3 == 5 Constraints: 4 <= nums.length <= 50 1 <= nums[i] <= 100","title":"Count Special Quadruplets"},{"location":"Leetcode/1995.-Count-Special-Quadruplets/#analysis","text":"This question is similar to two sum: break nums[a] + nums[b] + nums[c] == nums[d] into nums[a] + nums[b] = nums[d] - nums[c] it turns out to find how many sum are there for nums[d] - nums[c] If we break the array into two parts: on the left side from nums[0:i] and right side from nums[i:end] . We choose any arbitary numbers from left side to add to the current value nums[i] , and find how many pairs (each pair represent nums[d] - nums[c] ) of number from nums[i+1:end] equals to current value. To accomplish it, we need to use a map or a counter to store all the pair sum that can be formed from the right side, and it has to be done after we set the pivot i so that we can first calculate the possible sum for nums[a] + nums[b] . Time: O(n^2) O(n^2) Space: O(n) O(n) storing all the possible sum, could only have n possible sum","title":"Analysis"},{"location":"Leetcode/1995.-Count-Special-Quadruplets/#code","text":"class Solution : def countQuadruplets ( self , nums: List[ int ]) -> int : # a + b(i) = d - c(i) l = len (nums) res = 0 count = Counter() for i in range (l - 1 , -1 , -1 ): for a in range (i - 1 , -1 , -1 ): # if see the same sum again, the previous configurations should also work, since our i is going from right to left, every previous d and c is greater than current d and c res += count[nums[a] + nums[i]] for d in range (l - 1 , i, -1 ): count[nums[d] - nums[i]] += 1 return res","title":"Code"},{"location":"Leetcode/1996.-The-Number-of-Weak-Characters-in-the-Game/","text":"The Number of Weak Characters in the Game \u00b6 You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense . You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei . Return the number of weak characters . Example 1: Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Example 2: Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. Example 3: Input: properties = [[1,5],[10,4],[4,3]] Output: 1 Explanation: The third character is weak because the second character has a strictly greater attack and defense. Constraints: 2 <= properties.length <= 10^5 properties[i].length == 2 1 <= attacki, defensei <= 10^5 Analysis \u00b6 Notice the data range is 10^5 10^5 , in this case we should think about an algorithm that is with complexity of O(n \\times \\log(n)) O(n \\times \\log(n)) . If we sort the array by attack in decreasing order, we can focus on the defence of any adjactant twos, because we can be sure that for any i < j , p[i][0] > p[j][0] and if p[i][0] == p[j][0] then p[i][1] < p[j][1] However, there is a case when: i < j < k and p[i][1] > p[j][1] > or = p[k][1] , and this will contribute another pair due to p[i][1] > p[k][1] . This will only happen when we see a new largest p[i][1] , and it will only contribute one more pair. So we need to keep track of the largest defence in each round. Time: O(n \\times \\log(n) + n) O(n \\times \\log(n) + n) due to sorting Space: O(1) O(1) quick sort without using the aux array will help to achieve it Code \u00b6 class Solution : def numberOfWeakCharacters ( self , p: List[List[ int ]]) -> int : ## any i < j, p[i][0] > p[j][0] and if p[i][0] == p[j][0] then p[i][1] < p[j][1] p . sort(key = lambda x: ( - x[ 0 ],x[ 1 ])) ans = 0 curr_max = 0 for _, d in p: if d < curr_max: ans += 1 else : curr_max = d return ans # a < b < c < d # a < b, b < c, a < c, c < d, b < d, a < d (1+4)*4/2","title":"1996. The Number of Weak Characters in the Game"},{"location":"Leetcode/1996.-The-Number-of-Weak-Characters-in-the-Game/#the-number-of-weak-characters-in-the-game","text":"You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense . You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei . Return the number of weak characters . Example 1: Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Example 2: Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. Example 3: Input: properties = [[1,5],[10,4],[4,3]] Output: 1 Explanation: The third character is weak because the second character has a strictly greater attack and defense. Constraints: 2 <= properties.length <= 10^5 properties[i].length == 2 1 <= attacki, defensei <= 10^5","title":"The Number of Weak Characters in the Game"},{"location":"Leetcode/1996.-The-Number-of-Weak-Characters-in-the-Game/#analysis","text":"Notice the data range is 10^5 10^5 , in this case we should think about an algorithm that is with complexity of O(n \\times \\log(n)) O(n \\times \\log(n)) . If we sort the array by attack in decreasing order, we can focus on the defence of any adjactant twos, because we can be sure that for any i < j , p[i][0] > p[j][0] and if p[i][0] == p[j][0] then p[i][1] < p[j][1] However, there is a case when: i < j < k and p[i][1] > p[j][1] > or = p[k][1] , and this will contribute another pair due to p[i][1] > p[k][1] . This will only happen when we see a new largest p[i][1] , and it will only contribute one more pair. So we need to keep track of the largest defence in each round. Time: O(n \\times \\log(n) + n) O(n \\times \\log(n) + n) due to sorting Space: O(1) O(1) quick sort without using the aux array will help to achieve it","title":"Analysis"},{"location":"Leetcode/1996.-The-Number-of-Weak-Characters-in-the-Game/#code","text":"class Solution : def numberOfWeakCharacters ( self , p: List[List[ int ]]) -> int : ## any i < j, p[i][0] > p[j][0] and if p[i][0] == p[j][0] then p[i][1] < p[j][1] p . sort(key = lambda x: ( - x[ 0 ],x[ 1 ])) ans = 0 curr_max = 0 for _, d in p: if d < curr_max: ans += 1 else : curr_max = d return ans # a < b < c < d # a < b, b < c, a < c, c < d, b < d, a < d (1+4)*4/2","title":"Code"},{"location":"Leetcode/2.-add-two-numbers/","text":"Add Two Numbers \u00b6 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order , and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100] . 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Analysis \u00b6 Two input linkedlists have already revsered, so we can just use two pointer to make the addition. To deal with carry bit, we need a integer to show the current sum. If the current sum is equal/greater than 10, then carry = 1 and sum %= 10 Time: O(min(size of l1, size of l2)) Code \u00b6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers(ListNode * l1, ListNode * l2) { ListNode * dummy = new ListNode( -1 ), * curr = dummy; int carry = 0 ; while (l1 || l2) { // either one is terminated int val1 = l1 ? l1 -> val : 0 ; int val2 = l2 ? l2 -> val : 0 ; int sum = val1 + val2 + carry; carry = sum / 10 ; // if greater than 10 -> carry > 0 curr -> next = new ListNode(sum % 10 ); curr = curr -> next; if (l1) l1 = l1 -> next; if (l2) l2 = l2 -> next; } if (carry) // final check curr -> next = new ListNode( 1 ); return dummy -> next; } };","title":"Add Two Numbers"},{"location":"Leetcode/2.-add-two-numbers/#add-two-numbers","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order , and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100] . 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros.","title":"Add Two Numbers"},{"location":"Leetcode/2.-add-two-numbers/#analysis","text":"Two input linkedlists have already revsered, so we can just use two pointer to make the addition. To deal with carry bit, we need a integer to show the current sum. If the current sum is equal/greater than 10, then carry = 1 and sum %= 10 Time: O(min(size of l1, size of l2))","title":"Analysis"},{"location":"Leetcode/2.-add-two-numbers/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers(ListNode * l1, ListNode * l2) { ListNode * dummy = new ListNode( -1 ), * curr = dummy; int carry = 0 ; while (l1 || l2) { // either one is terminated int val1 = l1 ? l1 -> val : 0 ; int val2 = l2 ? l2 -> val : 0 ; int sum = val1 + val2 + carry; carry = sum / 10 ; // if greater than 10 -> carry > 0 curr -> next = new ListNode(sum % 10 ); curr = curr -> next; if (l1) l1 = l1 -> next; if (l2) l2 = l2 -> next; } if (carry) // final check curr -> next = new ListNode( 1 ); return dummy -> next; } };","title":"Code"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/","text":"Implement Trie (Prefix Tree) \u00b6 Trie (we pronounce \"try\") or prefix tree is a tree data structure used to retrieve a key in a strings dataset. There are various applications of this very efficient data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() initializes the trie object. void insert(String word) inserts the string word to the trie. boolean search(String word) returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) returns true if there is a previously inserted string word that has the prefix prefix , and false otherwise. Example 1: Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // return True trie.search(\"app\"); // return False trie.startsWith(\"app\"); // return True trie.insert(\"app\"); trie.search(\"app\"); // return True Constraints: 1 <= word.length, prefix.length <= 2000 word and prefix consist of lowercase English letters. At most 3 * 104 calls will be made to insert , search , and startsWith . Property for Trie Tree \u00b6 each node does not store complete word each path has a character, the word to current node is the path with all the characters each leaf node marks as end for telling it's a complete word each leaf can store the frequency (7, 3, 4, 15, 12, 11, 5, 9) in this case in the same level, all the silbilings are not the same if just typing in the prefix, trie can print out all the suggesting silbilings each node can has 26 (all lower case) children - pretty bad space complexity cpp: dynamically generate 26 nodes all the time \u00b6 struct TrieNode { TrieNode * next[ 26 ]; bool is_word; TrieNode( bool b = false ) : is_word(b) { memset(next, 0 , sizeof (next)); // next store address instead of the value itself } }; class Trie { private : TrieNode * root; TrieNode * find (string key) { TrieNode * p = root; for ( int i = 0 ; i < key.size() && p != NULL ; ++ i) { p = p -> next[key[i] - 'a' ]; } return p; } public : /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode * p = root; for ( int i = 0 ; i < word.size(); ++ i) { if (p -> next[word[i] - 'a' ] == NULL ) // not assign any value yet p -> next[word[i] - 'a' ] = new TrieNode(); // only new when p = p -> next[word[i] - 'a' ]; } p -> is_word = true ; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode * p = find(word); return p != NULL && p -> is_word; } /** Returns if there is any word in the trie that starts with the given * prefix. */ bool startsWith(string prefix) { return find (prefix) != NULL ; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_3 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"Implement Trie (Prefix Tree)"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#implement-trie-prefix-tree","text":"Trie (we pronounce \"try\") or prefix tree is a tree data structure used to retrieve a key in a strings dataset. There are various applications of this very efficient data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() initializes the trie object. void insert(String word) inserts the string word to the trie. boolean search(String word) returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) returns true if there is a previously inserted string word that has the prefix prefix , and false otherwise. Example 1: Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // return True trie.search(\"app\"); // return False trie.startsWith(\"app\"); // return True trie.insert(\"app\"); trie.search(\"app\"); // return True Constraints: 1 <= word.length, prefix.length <= 2000 word and prefix consist of lowercase English letters. At most 3 * 104 calls will be made to insert , search , and startsWith .","title":"Implement Trie (Prefix Tree)"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#property-for-trie-tree","text":"each node does not store complete word each path has a character, the word to current node is the path with all the characters each leaf node marks as end for telling it's a complete word each leaf can store the frequency (7, 3, 4, 15, 12, 11, 5, 9) in this case in the same level, all the silbilings are not the same if just typing in the prefix, trie can print out all the suggesting silbilings each node can has 26 (all lower case) children - pretty bad space complexity","title":"Property for Trie Tree"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#cpp-dynamically-generate-26-nodes-all-the-time","text":"struct TrieNode { TrieNode * next[ 26 ]; bool is_word; TrieNode( bool b = false ) : is_word(b) { memset(next, 0 , sizeof (next)); // next store address instead of the value itself } }; class Trie { private : TrieNode * root; TrieNode * find (string key) { TrieNode * p = root; for ( int i = 0 ; i < key.size() && p != NULL ; ++ i) { p = p -> next[key[i] - 'a' ]; } return p; } public : /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode * p = root; for ( int i = 0 ; i < word.size(); ++ i) { if (p -> next[word[i] - 'a' ] == NULL ) // not assign any value yet p -> next[word[i] - 'a' ] = new TrieNode(); // only new when p = p -> next[word[i] - 'a' ]; } p -> is_word = true ; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode * p = find(word); return p != NULL && p -> is_word; } /** Returns if there is any word in the trie that starts with the given * prefix. */ bool startsWith(string prefix) { return find (prefix) != NULL ; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_3 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"cpp: dynamically generate 26 nodes all the time"},{"location":"Leetcode/212.-word-search-ii/","text":"Word Search II \u00b6 Given an m x n board of characters and a list of strings words , return all words on the board . Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example 1: Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] Output: [\"eat\",\"oath\"] Example 2: Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"] Output: [] Constraints: m == board.length n == board[i].length 1 <= m, n <= 12 board[i][j] is a lowercase English letter. 1 <= words.length <= 3 * 104 1 <= words[i].length <= 10 words[i] consists of lowercase English letters. All the strings of words are unique. Analysis \u00b6 Notation: size of words: w board width: n, board height: m average length of words: len Using DFS: for each additional branch (adding a character from all four neighbours), there is no way to know if the additional will work or not, and we can only know until we have iterated through the entire matrix (requires O(m \\times n) O(m \\times n) for a single check). The total time is: O(w \\times m \\times n \\times 4^{len}) O(w \\times m \\times n \\times 4^{len}) Using Trie: we can do better for elimating the unnecessary checks mentioned in the DFS. We can cut off early if the neigbour of current Trie node doesn't exist, and we only proceed if exist. Thus, the optimized time complexity is O(w \\times len + m \\times n \\times 4 ^ {len}) O(w \\times len + m \\times n \\times 4 ^ {len}) [building Trie + dfs search]. Code \u00b6 class Solution { public : struct Node { Node * nei[ 26 ]; bool end = false ; }; Node * root = new Node(); void insert (string s) { Node * curr = root; for ( char c : s) { if ( ! curr -> nei[c - 'a' ]) curr -> nei[c - 'a' ] = new Node(); curr = curr -> nei[c - 'a' ]; } curr -> end = true ; } int dir[ 4 ][ 2 ] = {{ 1 , 0 }, { -1 , 0 }, { 0 , 1 }, { 0 , -1 }}; unordered_set < string > res; vector < vector < char >> matrix; int m, n; bool vis[ 1010 ][ 1010 ] = {{ 0 }}; // O(m * n) void dfs ( int i, int j, string path, Node * curr) { if ( ! curr) return ; if (curr -> end) res.insert(path); vis[i][j] = true ; for ( auto d : dir) { int x = i + d[ 0 ], y = j + d[ 1 ]; if (x < 0 || x >= m || y < 0 || y >= n || ! curr -> nei[matrix[x][y] - 'a' ] || vis[x][y]) continue ; dfs(x, y, path + matrix[x][y], curr -> nei[matrix[x][y] - 'a' ]); } vis[i][j] = false ; } vector < string > findWords(vector < vector < char >> & board, vector < string > & words) { m = board.size(); n = board[ 0 ].size(); for (string & str : words) { insert(str); } matrix = board; for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (root -> nei[matrix[i][j] - 'a' ]) { string s ( 1 , matrix[i][j]); dfs(i, j, s, root -> nei[matrix[i][j] - 'a' ]); } } } return vector < string > (res.begin(), res.end()); } };","title":"Word Search II"},{"location":"Leetcode/212.-word-search-ii/#word-search-ii","text":"Given an m x n board of characters and a list of strings words , return all words on the board . Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example 1: Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] Output: [\"eat\",\"oath\"] Example 2: Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"] Output: [] Constraints: m == board.length n == board[i].length 1 <= m, n <= 12 board[i][j] is a lowercase English letter. 1 <= words.length <= 3 * 104 1 <= words[i].length <= 10 words[i] consists of lowercase English letters. All the strings of words are unique.","title":"Word Search II"},{"location":"Leetcode/212.-word-search-ii/#analysis","text":"Notation: size of words: w board width: n, board height: m average length of words: len Using DFS: for each additional branch (adding a character from all four neighbours), there is no way to know if the additional will work or not, and we can only know until we have iterated through the entire matrix (requires O(m \\times n) O(m \\times n) for a single check). The total time is: O(w \\times m \\times n \\times 4^{len}) O(w \\times m \\times n \\times 4^{len}) Using Trie: we can do better for elimating the unnecessary checks mentioned in the DFS. We can cut off early if the neigbour of current Trie node doesn't exist, and we only proceed if exist. Thus, the optimized time complexity is O(w \\times len + m \\times n \\times 4 ^ {len}) O(w \\times len + m \\times n \\times 4 ^ {len}) [building Trie + dfs search].","title":"Analysis"},{"location":"Leetcode/212.-word-search-ii/#code","text":"class Solution { public : struct Node { Node * nei[ 26 ]; bool end = false ; }; Node * root = new Node(); void insert (string s) { Node * curr = root; for ( char c : s) { if ( ! curr -> nei[c - 'a' ]) curr -> nei[c - 'a' ] = new Node(); curr = curr -> nei[c - 'a' ]; } curr -> end = true ; } int dir[ 4 ][ 2 ] = {{ 1 , 0 }, { -1 , 0 }, { 0 , 1 }, { 0 , -1 }}; unordered_set < string > res; vector < vector < char >> matrix; int m, n; bool vis[ 1010 ][ 1010 ] = {{ 0 }}; // O(m * n) void dfs ( int i, int j, string path, Node * curr) { if ( ! curr) return ; if (curr -> end) res.insert(path); vis[i][j] = true ; for ( auto d : dir) { int x = i + d[ 0 ], y = j + d[ 1 ]; if (x < 0 || x >= m || y < 0 || y >= n || ! curr -> nei[matrix[x][y] - 'a' ] || vis[x][y]) continue ; dfs(x, y, path + matrix[x][y], curr -> nei[matrix[x][y] - 'a' ]); } vis[i][j] = false ; } vector < string > findWords(vector < vector < char >> & board, vector < string > & words) { m = board.size(); n = board[ 0 ].size(); for (string & str : words) { insert(str); } matrix = board; for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (root -> nei[matrix[i][j] - 'a' ]) { string s ( 1 , matrix[i][j]); dfs(i, j, s, root -> nei[matrix[i][j] - 'a' ]); } } } return vector < string > (res.begin(), res.end()); } };","title":"Code"},{"location":"Leetcode/222.-count-complete-tree-node/","text":"Count Complete Tree Nodes \u00b6 Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia , every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h . Example 1: Input: root = [1,2,3,4,5,6] Output: 6 Example 2: Input: root = [] Output: 0 Example 3: Input: root = [1] Output: 1 Constraints: The number of nodes in the tree is in the range [0, 5 * 104] . 0 <= Node.val <= 5 * 104 The tree is guaranteed to be complete . Follow up: Traversing the tree to count the number of nodes in the tree is an easy solution but with O(n) complexity. Could you find a faster algorithm? Analysis \u00b6 Complete binary tree has the special property: at the last level of the binary tree, the nodes will be populated from left to right. There could be empty/null from any points from the last level, but from the first empty/null node, all the rest to the right has to be empty/null as well. If we are given a perfect binary tree, we can use 2^{height} - 1 2^{height} - 1 to calculate the total number of nodes from the tree. The problem now breaks down to find starting at which position, the rest nodes of the leaf nodes become empty/null. We can use binary search to find the pivot node. start from left and right, and traverse \\log(n) \\log(n) levels to see the heights of left and right. if left and right heights are the same, it means we already in perfect binary tree -> we can use the formula to calculate the number of nodes in the current subtree. if left = right + 1, then the pivot should be somewhere between left and right, we should recursively call both. Time: \\log^2 (n) \\log^2 (n) Space: \\log(n) \\log(n) -> it takes \\log(n) \\log(n) times to find the pivot thus it will call the recursion \\log(n) \\log(n) times. Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : int countNodes(TreeNode * root) { if ( ! root) return 0 ; int l = 0 , r = 0 ; TreeNode * a = root, * b = root; while (a) { a = a -> left; l ++ ; } while (b) { b = b -> right; r ++ ; } if (l == r) return pow( 2 , l) - 1 ; return countNodes (root -> left) + countNodes(root -> right) + 1 ; } };","title":"Count Complete Tree Nodes"},{"location":"Leetcode/222.-count-complete-tree-node/#count-complete-tree-nodes","text":"Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia , every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h . Example 1: Input: root = [1,2,3,4,5,6] Output: 6 Example 2: Input: root = [] Output: 0 Example 3: Input: root = [1] Output: 1 Constraints: The number of nodes in the tree is in the range [0, 5 * 104] . 0 <= Node.val <= 5 * 104 The tree is guaranteed to be complete . Follow up: Traversing the tree to count the number of nodes in the tree is an easy solution but with O(n) complexity. Could you find a faster algorithm?","title":"Count Complete Tree Nodes"},{"location":"Leetcode/222.-count-complete-tree-node/#analysis","text":"Complete binary tree has the special property: at the last level of the binary tree, the nodes will be populated from left to right. There could be empty/null from any points from the last level, but from the first empty/null node, all the rest to the right has to be empty/null as well. If we are given a perfect binary tree, we can use 2^{height} - 1 2^{height} - 1 to calculate the total number of nodes from the tree. The problem now breaks down to find starting at which position, the rest nodes of the leaf nodes become empty/null. We can use binary search to find the pivot node. start from left and right, and traverse \\log(n) \\log(n) levels to see the heights of left and right. if left and right heights are the same, it means we already in perfect binary tree -> we can use the formula to calculate the number of nodes in the current subtree. if left = right + 1, then the pivot should be somewhere between left and right, we should recursively call both. Time: \\log^2 (n) \\log^2 (n) Space: \\log(n) \\log(n) -> it takes \\log(n) \\log(n) times to find the pivot thus it will call the recursion \\log(n) \\log(n) times.","title":"Analysis"},{"location":"Leetcode/222.-count-complete-tree-node/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : int countNodes(TreeNode * root) { if ( ! root) return 0 ; int l = 0 , r = 0 ; TreeNode * a = root, * b = root; while (a) { a = a -> left; l ++ ; } while (b) { b = b -> right; r ++ ; } if (l == r) return pow( 2 , l) - 1 ; return countNodes (root -> left) + countNodes(root -> right) + 1 ; } };","title":"Code"},{"location":"Leetcode/229.-majority-element-ii/","text":"Majority Element II \u00b6 Given an integer array of size n , find all elements that appear more than \u230a n/3 \u230b times. Follow-up: Could you solve the problem in linear time and in O(1) space? Example 1: Input: nums = [3,2,3] Output: [3] Example 2: Input: nums = [1] Output: [1] Example 3: Input: nums = [1,2] Output: [1,2] Constraints: 1 <= nums.length <= 5 * 104 -109 <= nums[i] <= 109 Anaysis \u00b6 This problem is an extension to the Majority Element. https://leetcode.com/problems/majority-element-ii/discuss/63520/Boyer-Moore-Majority-Vote-algorithm-and-my-elaboration/112881 there are no elements that appears more than n/3 times, then whatever the algorithm got from 1 st round would be rejected in the second round. there are only one elements that appears more than n/3 times, after 1 st round one of the candicate must be that appears more than n/3 times(<2n/3 other elements could only pair out for <n/3 times), the other candicate is not necessarily be the second most frequent but it would be rejected in 2 nd round. there are two elments appears more than n/3 times, candicates would contain both of them. (<n/3 other elements couldn't pair out any of the majorities.) Code \u00b6 class Solution { public : vector < int > majorityElement(vector < int >& nums) { vector < int > res; int a = 0 , b = 0 , cnt1 = 0 , cnt2 = 0 , n = nums.size(); for ( int num : nums) { if (num == a) { ++ cnt1; } else if (num == b) { ++ cnt2; } else if (cnt1 == 0 ) { a = num; cnt1 = 1 ; } else if (cnt2 == 0 ) { b = num; cnt2 = 1 ; } else { -- cnt1; -- cnt2; } } cnt1 = cnt2 = 0 ; for ( int num : nums) { if (num == a) { ++ cnt1; } else if (num == b) { ++ cnt2; } } if (cnt1 > n / 3 ) { res.push_back(a); } if (cnt2 > n / 3 ) { res.push_back(b); } return res; } };","title":"Majority Element II"},{"location":"Leetcode/229.-majority-element-ii/#majority-element-ii","text":"Given an integer array of size n , find all elements that appear more than \u230a n/3 \u230b times. Follow-up: Could you solve the problem in linear time and in O(1) space? Example 1: Input: nums = [3,2,3] Output: [3] Example 2: Input: nums = [1] Output: [1] Example 3: Input: nums = [1,2] Output: [1,2] Constraints: 1 <= nums.length <= 5 * 104 -109 <= nums[i] <= 109","title":"Majority Element II"},{"location":"Leetcode/229.-majority-element-ii/#anaysis","text":"This problem is an extension to the Majority Element. https://leetcode.com/problems/majority-element-ii/discuss/63520/Boyer-Moore-Majority-Vote-algorithm-and-my-elaboration/112881 there are no elements that appears more than n/3 times, then whatever the algorithm got from 1 st round would be rejected in the second round. there are only one elements that appears more than n/3 times, after 1 st round one of the candicate must be that appears more than n/3 times(<2n/3 other elements could only pair out for <n/3 times), the other candicate is not necessarily be the second most frequent but it would be rejected in 2 nd round. there are two elments appears more than n/3 times, candicates would contain both of them. (<n/3 other elements couldn't pair out any of the majorities.)","title":"Anaysis"},{"location":"Leetcode/229.-majority-element-ii/#code","text":"class Solution { public : vector < int > majorityElement(vector < int >& nums) { vector < int > res; int a = 0 , b = 0 , cnt1 = 0 , cnt2 = 0 , n = nums.size(); for ( int num : nums) { if (num == a) { ++ cnt1; } else if (num == b) { ++ cnt2; } else if (cnt1 == 0 ) { a = num; cnt1 = 1 ; } else if (cnt2 == 0 ) { b = num; cnt2 = 1 ; } else { -- cnt1; -- cnt2; } } cnt1 = cnt2 = 0 ; for ( int num : nums) { if (num == a) { ++ cnt1; } else if (num == b) { ++ cnt2; } } if (cnt1 > n / 3 ) { res.push_back(a); } if (cnt2 > n / 3 ) { res.push_back(b); } return res; } };","title":"Code"},{"location":"Leetcode/239.-sliding-window-maximum/","text":"Sliding Window Maximum \u00b6 You are given an array of integers nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window . Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Example 3: Input: nums = [1,-1], k = 1 Output: [1,-1] Example 4: Input: nums = [9,11], k = 2 Output: [11] Example 5: Input: nums = [4,-2], k = 2 Output: [4] Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104 1 <= k <= nums.length Analysis: using Deque \u00b6 We need to maintain a queue, where the front stores the current max in the sliding window. When we want to push new element to the queue, we first need to kick off all the elements that are not in the range (from i to i + k - 1), and then we need to keep pop_back() the element(s) that is/are less than current nums[i]. In order to achieve the pop_front() and push_back() operations, we need to use std::dequeue data structure in order to achieve these two operations running in O(1) O(1) . Time: O(n) O(n) since each element can get in and get out of the deque only once Space: O(k) O(k) the maximum size of the deque is having all the window size elements (e.g. a decreasing array like: 5,4,3,2,1, so each element will be pushed into the deque). Code 1: using Deque \u00b6 class Solution { public : vector < int > maxSlidingWindow(vector < int >& nums, int k) { deque < int > dq; vector < int > res; for ( int i = 0 ; i < nums.size(); ++ i) { if (dq.empty()) dq.push_back(i); else { // remove idx that is out of bound while ( ! dq.empty() && dq.front() <= i - k) dq.pop_front(); // remove the element in front of current that is less than current while ( ! dq.empty() && (nums[dq.back()] < nums[i])) dq.pop_back(); dq.push_back(i); } if (i >= k - 1 ) { // start pushing when the first window is of size k res.push_back(nums[dq.front()]); } } return res; } }; Analysis: using montonic Deque \u00b6 After the observation of the deque data structure we are using, we find what it stores is a non-increasing array of elements (e.g. 3,2,2,1). We can then abstract the data structure into a class, so that we can just push(int) and pop() from the class. Time: same Space: same Code 2: Montonic Deque \u00b6 class MonoQueue { public : void push( int e) { while ( ! data_.empty() && e > data_.back()) { data_.pop_back(); } data_.push_back(e); } void pop() { data_.pop_front(); } int max() const { return data_.front(); } private : deque < int > data_; }; class Solution { public : vector < int > maxSlidingWindow(vector < int >& nums, int k) { MonoQueue q; vector < int > ans; for ( int i = 0 ; i < nums.size(); ++ i) { q.push(nums[i]); // we can push worry-free if (i - k + 1 >= 0 ) { ans.push_back(q.max()); if (nums[i - k + 1 ] == q.max()) // the front of the queue is the greatest element (duplicate is fine) q.pop(); } } return ans; } };","title":"Sliding Window Maximum"},{"location":"Leetcode/239.-sliding-window-maximum/#sliding-window-maximum","text":"You are given an array of integers nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window . Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Example 3: Input: nums = [1,-1], k = 1 Output: [1,-1] Example 4: Input: nums = [9,11], k = 2 Output: [11] Example 5: Input: nums = [4,-2], k = 2 Output: [4] Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104 1 <= k <= nums.length","title":"Sliding Window Maximum"},{"location":"Leetcode/239.-sliding-window-maximum/#analysis-using-deque","text":"We need to maintain a queue, where the front stores the current max in the sliding window. When we want to push new element to the queue, we first need to kick off all the elements that are not in the range (from i to i + k - 1), and then we need to keep pop_back() the element(s) that is/are less than current nums[i]. In order to achieve the pop_front() and push_back() operations, we need to use std::dequeue data structure in order to achieve these two operations running in O(1) O(1) . Time: O(n) O(n) since each element can get in and get out of the deque only once Space: O(k) O(k) the maximum size of the deque is having all the window size elements (e.g. a decreasing array like: 5,4,3,2,1, so each element will be pushed into the deque).","title":"Analysis: using Deque"},{"location":"Leetcode/239.-sliding-window-maximum/#code-1-using-deque","text":"class Solution { public : vector < int > maxSlidingWindow(vector < int >& nums, int k) { deque < int > dq; vector < int > res; for ( int i = 0 ; i < nums.size(); ++ i) { if (dq.empty()) dq.push_back(i); else { // remove idx that is out of bound while ( ! dq.empty() && dq.front() <= i - k) dq.pop_front(); // remove the element in front of current that is less than current while ( ! dq.empty() && (nums[dq.back()] < nums[i])) dq.pop_back(); dq.push_back(i); } if (i >= k - 1 ) { // start pushing when the first window is of size k res.push_back(nums[dq.front()]); } } return res; } };","title":"Code 1: using Deque"},{"location":"Leetcode/239.-sliding-window-maximum/#analysis-using-montonic-deque","text":"After the observation of the deque data structure we are using, we find what it stores is a non-increasing array of elements (e.g. 3,2,2,1). We can then abstract the data structure into a class, so that we can just push(int) and pop() from the class. Time: same Space: same","title":"Analysis: using montonic Deque"},{"location":"Leetcode/239.-sliding-window-maximum/#code-2-montonic-deque","text":"class MonoQueue { public : void push( int e) { while ( ! data_.empty() && e > data_.back()) { data_.pop_back(); } data_.push_back(e); } void pop() { data_.pop_front(); } int max() const { return data_.front(); } private : deque < int > data_; }; class Solution { public : vector < int > maxSlidingWindow(vector < int >& nums, int k) { MonoQueue q; vector < int > ans; for ( int i = 0 ; i < nums.size(); ++ i) { q.push(nums[i]); // we can push worry-free if (i - k + 1 >= 0 ) { ans.push_back(q.max()); if (nums[i - k + 1 ] == q.max()) // the front of the queue is the greatest element (duplicate is fine) q.pop(); } } return ans; } };","title":"Code 2: Montonic Deque"},{"location":"Leetcode/24.-Swap-Nodes-in-Pairs/","text":"Swap Nodes in Pairs \u00b6 Given a linked list, swap every two adjacent nodes and return its head. Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2: Input: head = [] Output: [] Example 3: Input: head = [1] Output: [1] Constraints: The number of nodes in the list is in the range [0, 100] . 0 <= Node.val <= 100 Follow up: Can you solve the problem without modifying the values in the list's nodes? (i.e., Only nodes themselves may be changed.) Analysis \u00b6 curent state: t -> a -> b -> c target state: t -> b -> a -> c connect t with b connect a with c connect b with a proceed forward t with two more steps Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : ListNode * swapPairs(ListNode * head) { ListNode * dummy = new ListNode( -1 ), * t = dummy; dummy -> next = head; while (t && t -> next && t -> next -> next) { auto * a = t -> next, * b = t -> next -> next, * c = t -> next -> next -> next; t -> next = b; a -> next = c; b -> next = a; t = t -> next -> next; } return dummy -> next; } };","title":"Swap Nodes in Pairs"},{"location":"Leetcode/24.-Swap-Nodes-in-Pairs/#swap-nodes-in-pairs","text":"Given a linked list, swap every two adjacent nodes and return its head. Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2: Input: head = [] Output: [] Example 3: Input: head = [1] Output: [1] Constraints: The number of nodes in the list is in the range [0, 100] . 0 <= Node.val <= 100 Follow up: Can you solve the problem without modifying the values in the list's nodes? (i.e., Only nodes themselves may be changed.)","title":"Swap Nodes in Pairs"},{"location":"Leetcode/24.-Swap-Nodes-in-Pairs/#analysis","text":"curent state: t -> a -> b -> c target state: t -> b -> a -> c connect t with b connect a with c connect b with a proceed forward t with two more steps Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/24.-Swap-Nodes-in-Pairs/#code","text":"class Solution { public : ListNode * swapPairs(ListNode * head) { ListNode * dummy = new ListNode( -1 ), * t = dummy; dummy -> next = head; while (t && t -> next && t -> next -> next) { auto * a = t -> next, * b = t -> next -> next, * c = t -> next -> next -> next; t -> next = b; a -> next = c; b -> next = a; t = t -> next -> next; } return dummy -> next; } };","title":"Code"},{"location":"Leetcode/253.-meeting-rooms-ii/","text":"Meeting Rooms II \u00b6 Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required. Example 1: Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Example 2: Input: [[7,10],[2,4]] Output: 1 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Analysis \u00b6 In interview for this problem, it is always a good idea to first run through an example. Given [0, 30] [1, 5] [2, 3] [7, 10], how to allocate the rooms? Adding [0, 30]: Allocate first room to [0, 30]. Adding [1, 5]: check if any room that isn't used during 1 to 5 (no existing room satisfy, so allocate another new room). Adding [2, 3]: do the same check as 2, but not the earliest used room now changed to room 2 (will be free on 5), but we still cannot attend the meeting because of overlap, so allocate a new room. Adding [7, 10]: now we check if any room that can finish the meeting earlier than 7, and we find [1, 5], so we can reuse this room for [7, 10]. Note : on step 4, why don't we just reuse [2, 3]? Yes, you can reuse that room, but there is a chance that some other interval whose start is less than 5 and greater 3 -- [4, 5]. If we reuse [2, 3], we cannot know if this new interval can be reused by [2,3] since we only keep track of the latest used room. In order to keep track of the earliest finishing time from all the allocated room (from this we can determine if we need to allocate a new room), we can use a priority queue to keep track of all the allocated rooms' ending time (note that it will be a min heap since we want to the smallest element from the queue). Before we adding time to the priority queue, we also need to make sure that for every two interval i and interval i + 1, interval i's start should be less or equal than interval i + 1's start, so that we can allocate in sequence in a greedy manner so that we can make sure our allocation is always the most optimal. Time: O(n \\times log(n)) O(n \\times log(n)) (sort + priority queue) Space: O(n) O(n) for sorting and priority queue. Code \u00b6 int minMeetingRooms (vector < vector < int >> intervals) { // write your solution here auto cmp = [](vector < int >& l, vector < int >& r) { return l[ 0 ] < r[ 0 ];}; sort(intervals.begin(), intervals.end(), cmp); priority_queue < int , vector < int > , greater < int > > pq; for ( auto i : intervals) { if ( ! pq.empty() && pq.top() <= i[ 0 ]) pq.pop(); // if the earliest ending room is less than current room, we can reuse that room pq.push(i[ 1 ]); // allocate new room } return pq.size(); }","title":"Meeting Rooms II"},{"location":"Leetcode/253.-meeting-rooms-ii/#meeting-rooms-ii","text":"Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required. Example 1: Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Example 2: Input: [[7,10],[2,4]] Output: 1 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.","title":"Meeting Rooms II"},{"location":"Leetcode/253.-meeting-rooms-ii/#analysis","text":"In interview for this problem, it is always a good idea to first run through an example. Given [0, 30] [1, 5] [2, 3] [7, 10], how to allocate the rooms? Adding [0, 30]: Allocate first room to [0, 30]. Adding [1, 5]: check if any room that isn't used during 1 to 5 (no existing room satisfy, so allocate another new room). Adding [2, 3]: do the same check as 2, but not the earliest used room now changed to room 2 (will be free on 5), but we still cannot attend the meeting because of overlap, so allocate a new room. Adding [7, 10]: now we check if any room that can finish the meeting earlier than 7, and we find [1, 5], so we can reuse this room for [7, 10]. Note : on step 4, why don't we just reuse [2, 3]? Yes, you can reuse that room, but there is a chance that some other interval whose start is less than 5 and greater 3 -- [4, 5]. If we reuse [2, 3], we cannot know if this new interval can be reused by [2,3] since we only keep track of the latest used room. In order to keep track of the earliest finishing time from all the allocated room (from this we can determine if we need to allocate a new room), we can use a priority queue to keep track of all the allocated rooms' ending time (note that it will be a min heap since we want to the smallest element from the queue). Before we adding time to the priority queue, we also need to make sure that for every two interval i and interval i + 1, interval i's start should be less or equal than interval i + 1's start, so that we can allocate in sequence in a greedy manner so that we can make sure our allocation is always the most optimal. Time: O(n \\times log(n)) O(n \\times log(n)) (sort + priority queue) Space: O(n) O(n) for sorting and priority queue.","title":"Analysis"},{"location":"Leetcode/253.-meeting-rooms-ii/#code","text":"int minMeetingRooms (vector < vector < int >> intervals) { // write your solution here auto cmp = [](vector < int >& l, vector < int >& r) { return l[ 0 ] < r[ 0 ];}; sort(intervals.begin(), intervals.end(), cmp); priority_queue < int , vector < int > , greater < int > > pq; for ( auto i : intervals) { if ( ! pq.empty() && pq.top() <= i[ 0 ]) pq.pop(); // if the earliest ending room is less than current room, we can reuse that room pq.push(i[ 1 ]); // allocate new room } return pq.size(); }","title":"Code"},{"location":"Leetcode/254.-factor-combinations/","text":"Factor Combinations \u00b6 Numbers can be regarded as product of its factors. For example, 8 = 2 x 2 x 2; = 2 x 4. Write a function that takes an integer n and return all possible combinations of its factors. Note: You may assume that n is always positive. Factors should be greater than 1 and less than n . Example 1: Input: 1 Output: [] Example 2: Input: 37 Output:[] Example 3: Input: 12 Output: [ [2, 6], [2, 2, 3], [3, 4] ] Example 4: Input: 32 Output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] Analysis \u00b6 In order to generate all the valid factors, we need to make sure target % factor == 0 . However, there is a problem: how to deal with duplication: We use a variable index to track the current factor, and if we choose current factor, we should not update index , because we can potentially reuse the same factor for multiple times. Note: since all the factors cannot be greater than sqrt(num), in the inner loop, we just need to loop from index to sqrt(n) Code \u00b6 class Solution { public : vector < vector < int >> getFactors( int n) { vector < vector < int >> res; helper(n, 2 , {}, res); return res; } void helper( int n, int start, vector < int > out, vector < vector < int >>& res) { if (n == 1 ) { if (out.size() > 1 ) res.push_back(out); return ; } for ( int i = start; i <= sqrt(n); ++ i) { if (n % i != 0 ) continue ; out.push_back(i); helper(n / i, i, out, res); out.pop_back(); } } };","title":"Factor Combinations"},{"location":"Leetcode/254.-factor-combinations/#factor-combinations","text":"Numbers can be regarded as product of its factors. For example, 8 = 2 x 2 x 2; = 2 x 4. Write a function that takes an integer n and return all possible combinations of its factors. Note: You may assume that n is always positive. Factors should be greater than 1 and less than n . Example 1: Input: 1 Output: [] Example 2: Input: 37 Output:[] Example 3: Input: 12 Output: [ [2, 6], [2, 2, 3], [3, 4] ] Example 4: Input: 32 Output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ]","title":"Factor Combinations"},{"location":"Leetcode/254.-factor-combinations/#analysis","text":"In order to generate all the valid factors, we need to make sure target % factor == 0 . However, there is a problem: how to deal with duplication: We use a variable index to track the current factor, and if we choose current factor, we should not update index , because we can potentially reuse the same factor for multiple times. Note: since all the factors cannot be greater than sqrt(num), in the inner loop, we just need to loop from index to sqrt(n)","title":"Analysis"},{"location":"Leetcode/254.-factor-combinations/#code","text":"class Solution { public : vector < vector < int >> getFactors( int n) { vector < vector < int >> res; helper(n, 2 , {}, res); return res; } void helper( int n, int start, vector < int > out, vector < vector < int >>& res) { if (n == 1 ) { if (out.size() > 1 ) res.push_back(out); return ; } for ( int i = start; i <= sqrt(n); ++ i) { if (n % i != 0 ) continue ; out.push_back(i); helper(n / i, i, out, res); out.pop_back(); } } };","title":"Code"},{"location":"Leetcode/274.-H-Index/","text":"H-Index \u00b6 Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h -index . According to the definition of h-index on Wikipedia : A scientist has an index h if h of their n papers have at least h citations each, and the other n \u2212 h papers have no more than h citations each. If there are several possible values for h , the maximum one is taken as the h -index . Example 1: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2: Input: citations = [1,3,1] Output: 1 Constraints: n == citations.length 1 <= n <= 5000 0 <= citations[i] <= 1000 Analysis: using sort + binary search \u00b6 Given the definition of \"H-index\", we can find out that h is just a measurement of the maximum amount of paper that has the citation number greater or equal to h . So in a sorted array, we just need to find the lower bound of the any h that satisfies this criteria, because finding the lower bound in a sorted array is alway O(\\log(n)) O(\\log(n)) . Note In Cpp, the upper_bound and lower_bound differ in the way of locating the first and last element of the same value with the target value. For upper_bound , it finds the first equal value, and lower_bound finds the last one. Time: O(n \\times \\log(n)) O(n \\times \\log(n)) sorting + finding Space: O(1) O(1) if we use quick sort without auxiliary array Code 1 \u00b6 class Solution { public : int hIndex(vector < int >& a) { //[3,0,6,1,5] h=3: 3, 6, 5 int n = a.size(); sort(a.begin(), a.end()); // try all the possible H from large to small for ( int i = n; ~ i; -- i) { if (n - (lower_bound(a.begin(), a.end(), i) - a.begin()) >= i) return i; } return 0 ; } }; Analysis: using Bucket sort \u00b6 Since our data isn't large (the range is also small), we can use bucket sort to solve this particular problem with O(n) O(n) complexity. Since we are only interested in the h in the range from 0 to n, we can create an array with size of n. Each element in the array represents the frequency of the that amount of citation. Note For all the citations that are greater than n, we put them into n-th bucket, since that is the same effect for the placing the paper into its citation's bucket. Then we start from n, and keep a counter to record the current number of paper that fulfill the requirement, which is counter >= h . If this requirement is fulfilled, then we can return the value from here. Time: O(n) O(n) Space: O(n) O(n) Code 2 \u00b6 class Solution { public : int hIndex(vector < int >& a) { //[3,0,6,1,5] h=3: 3, 6, 5 int n = a.size(); vector < int > b(n + 1 ); for ( int v : a) { if (v >= n) b[n] ++ ; else b[v] ++ ; } int counter = 0 ; for ( int i = n; ~ i; -- i) { counter += b[i]; if (counter >= i) return i; } return 0 ; } };","title":"H-Index"},{"location":"Leetcode/274.-H-Index/#h-index","text":"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h -index . According to the definition of h-index on Wikipedia : A scientist has an index h if h of their n papers have at least h citations each, and the other n \u2212 h papers have no more than h citations each. If there are several possible values for h , the maximum one is taken as the h -index . Example 1: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2: Input: citations = [1,3,1] Output: 1 Constraints: n == citations.length 1 <= n <= 5000 0 <= citations[i] <= 1000","title":"H-Index"},{"location":"Leetcode/274.-H-Index/#analysis-using-sort-binary-search","text":"Given the definition of \"H-index\", we can find out that h is just a measurement of the maximum amount of paper that has the citation number greater or equal to h . So in a sorted array, we just need to find the lower bound of the any h that satisfies this criteria, because finding the lower bound in a sorted array is alway O(\\log(n)) O(\\log(n)) . Note In Cpp, the upper_bound and lower_bound differ in the way of locating the first and last element of the same value with the target value. For upper_bound , it finds the first equal value, and lower_bound finds the last one. Time: O(n \\times \\log(n)) O(n \\times \\log(n)) sorting + finding Space: O(1) O(1) if we use quick sort without auxiliary array","title":"Analysis: using sort + binary search"},{"location":"Leetcode/274.-H-Index/#code-1","text":"class Solution { public : int hIndex(vector < int >& a) { //[3,0,6,1,5] h=3: 3, 6, 5 int n = a.size(); sort(a.begin(), a.end()); // try all the possible H from large to small for ( int i = n; ~ i; -- i) { if (n - (lower_bound(a.begin(), a.end(), i) - a.begin()) >= i) return i; } return 0 ; } };","title":"Code 1"},{"location":"Leetcode/274.-H-Index/#analysis-using-bucket-sort","text":"Since our data isn't large (the range is also small), we can use bucket sort to solve this particular problem with O(n) O(n) complexity. Since we are only interested in the h in the range from 0 to n, we can create an array with size of n. Each element in the array represents the frequency of the that amount of citation. Note For all the citations that are greater than n, we put them into n-th bucket, since that is the same effect for the placing the paper into its citation's bucket. Then we start from n, and keep a counter to record the current number of paper that fulfill the requirement, which is counter >= h . If this requirement is fulfilled, then we can return the value from here. Time: O(n) O(n) Space: O(n) O(n)","title":"Analysis: using Bucket sort"},{"location":"Leetcode/274.-H-Index/#code-2","text":"class Solution { public : int hIndex(vector < int >& a) { //[3,0,6,1,5] h=3: 3, 6, 5 int n = a.size(); vector < int > b(n + 1 ); for ( int v : a) { if (v >= n) b[n] ++ ; else b[v] ++ ; } int counter = 0 ; for ( int i = n; ~ i; -- i) { counter += b[i]; if (counter >= i) return i; } return 0 ; } };","title":"Code 2"},{"location":"Leetcode/283.-Move-Zeroes/","text":"Move Zeroes \u00b6 Given an integer array nums , move all 0 's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] Constraints: 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1 Follow up: Could you minimize the total number of operations done? Analysis \u00b6 All the questions regarding displacing from one to the other can be solved by using two pointers. For this question, we need to track the current zero position ( j ) and current processing position ( i ). We don't need to care about the sequence of zeros, but we need to take care of the sequence of non-zeros. Thus, we should loop from the processing position from begining to the end. If we see any zero while processing, we should move the next element that is non-zero ( i ) to the current zero position ( j ). We should also increase j by 1 since the next zero position to mark current j has been swapped with non-zero. Now, the new j can either be zero or non-zero, but what can be sure is that for next swap the current j will be non-zero and the sequence is always correct. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : void moveZeroes(vector < int >& nums) { for ( int i = 0 , j = 0 ; i < nums.size(); ++ i) { if (nums[i]) { // j will only record the non-zero position swap(nums[j ++ ], nums[i]); } } } };","title":"Move Zeroes"},{"location":"Leetcode/283.-Move-Zeroes/#move-zeroes","text":"Given an integer array nums , move all 0 's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] Constraints: 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1 Follow up: Could you minimize the total number of operations done?","title":"Move Zeroes"},{"location":"Leetcode/283.-Move-Zeroes/#analysis","text":"All the questions regarding displacing from one to the other can be solved by using two pointers. For this question, we need to track the current zero position ( j ) and current processing position ( i ). We don't need to care about the sequence of zeros, but we need to take care of the sequence of non-zeros. Thus, we should loop from the processing position from begining to the end. If we see any zero while processing, we should move the next element that is non-zero ( i ) to the current zero position ( j ). We should also increase j by 1 since the next zero position to mark current j has been swapped with non-zero. Now, the new j can either be zero or non-zero, but what can be sure is that for next swap the current j will be non-zero and the sequence is always correct. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/283.-Move-Zeroes/#code","text":"class Solution { public : void moveZeroes(vector < int >& nums) { for ( int i = 0 , j = 0 ; i < nums.size(); ++ i) { if (nums[i]) { // j will only record the non-zero position swap(nums[j ++ ], nums[i]); } } } };","title":"Code"},{"location":"Leetcode/287.-find-the-duplicate-number/","text":"Find the Duplicate Number \u00b6 Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums , return this repeated number . Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Example 3: Input: nums = [1,1] Output: 1 Example 4: Input: nums = [1,1,2] Output: 1 Constraints: 2 <= n <= 3 * 104 nums.length == n + 1 1 <= nums[i] <= n All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums ? Can you solve the problem without modifying the array nums ? Can you solve the problem using only constant, O(1) extra space? Can you solve the problem with runtime complexity less than O(n2) ? Analysis \u00b6 We can think about this problem similer to linkedlist cycle II . For each element in the array: i has an edge to nums[i] . If we find a cycle, that means there are two index pointing to one same element from the array. For example, nums = [1,3,4,2,2], using graph it will represent: There is one and only one node with in degree of two, which makes the \"linkedlist\" a cycle, and our task is to find the one with in degree of two. using two pointers to get into the cycle: one pointer move by one step each time, the other move by two steps. reset one of the pointers to 0, so that it's outside the cycle, keep going the other one and the current one until they meet. The only node that these two pointers will meet is the one with in-degree of 2. Time: O(2 \\times n) O(2 \\times n) Space: O(1) O(1) Code \u00b6 class Solution { public : int findDuplicate(vector < int >& nums) { int a = 0 , b = 0 ; do { // do while since 0 == 0 is our initial condition a = nums[nums[a]]; b = nums[b]; } while (a != b) ; a = 0 ; while (a != b) { a = nums[a]; b = nums[b]; } return a; } };","title":"Find the Duplicate Number"},{"location":"Leetcode/287.-find-the-duplicate-number/#find-the-duplicate-number","text":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums , return this repeated number . Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Example 3: Input: nums = [1,1] Output: 1 Example 4: Input: nums = [1,1,2] Output: 1 Constraints: 2 <= n <= 3 * 104 nums.length == n + 1 1 <= nums[i] <= n All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums ? Can you solve the problem without modifying the array nums ? Can you solve the problem using only constant, O(1) extra space? Can you solve the problem with runtime complexity less than O(n2) ?","title":"Find the Duplicate Number"},{"location":"Leetcode/287.-find-the-duplicate-number/#analysis","text":"We can think about this problem similer to linkedlist cycle II . For each element in the array: i has an edge to nums[i] . If we find a cycle, that means there are two index pointing to one same element from the array. For example, nums = [1,3,4,2,2], using graph it will represent: There is one and only one node with in degree of two, which makes the \"linkedlist\" a cycle, and our task is to find the one with in degree of two. using two pointers to get into the cycle: one pointer move by one step each time, the other move by two steps. reset one of the pointers to 0, so that it's outside the cycle, keep going the other one and the current one until they meet. The only node that these two pointers will meet is the one with in-degree of 2. Time: O(2 \\times n) O(2 \\times n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/287.-find-the-duplicate-number/#code","text":"class Solution { public : int findDuplicate(vector < int >& nums) { int a = 0 , b = 0 ; do { // do while since 0 == 0 is our initial condition a = nums[nums[a]]; b = nums[b]; } while (a != b) ; a = 0 ; while (a != b) { a = nums[a]; b = nums[b]; } return a; } };","title":"Code"},{"location":"Leetcode/290.-word-pattern/","text":"Word Pattern \u00b6 Given a pattern and a string s , find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s . Example 1: Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true Example 2: Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false Example 3: Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false Example 4: Input: pattern = \"abba\", s = \"dog dog dog dog\" Output: false Constraints: 1 <= pattern.length <= 300 pattern contains only lower-case English letters. 1 <= s.length <= 3000 s contains only lower-case English letters and spaces ' ' . s does not contain any leading or trailing spaces. All the words in s are separated by a single space . Analysis \u00b6 Valid matching: Invalid matching 1: Invalid matching 2: To check if both cases are valid, we can keep two hashmap for storing the current mapping 1. if ps[a] != b return false else put {a,b} to ps 2. if sp[b] != a return false else put {b,a} to sp Time: O(n) O(n) Space: O(n) O(n) Code \u00b6 class Solution { public : bool wordPattern(string pattern, string s) { map < char , string > ps; // pattern to string map < string, char > sp; // string to pattern istringstream ss (s); int p = 0 ; for (string word; ss >> word; ++ p) { char currp = pattern[p]; if (ps.count(currp) && ps[currp] != word) return false ; ps[currp] = word; if (sp.count(word) && sp[word] != currp) return false ; sp[word] = currp; } return p == pattern.size(); } };","title":"Word Pattern"},{"location":"Leetcode/290.-word-pattern/#word-pattern","text":"Given a pattern and a string s , find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s . Example 1: Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true Example 2: Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false Example 3: Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false Example 4: Input: pattern = \"abba\", s = \"dog dog dog dog\" Output: false Constraints: 1 <= pattern.length <= 300 pattern contains only lower-case English letters. 1 <= s.length <= 3000 s contains only lower-case English letters and spaces ' ' . s does not contain any leading or trailing spaces. All the words in s are separated by a single space .","title":"Word Pattern"},{"location":"Leetcode/290.-word-pattern/#analysis","text":"Valid matching: Invalid matching 1: Invalid matching 2: To check if both cases are valid, we can keep two hashmap for storing the current mapping 1. if ps[a] != b return false else put {a,b} to ps 2. if sp[b] != a return false else put {b,a} to sp Time: O(n) O(n) Space: O(n) O(n)","title":"Analysis"},{"location":"Leetcode/290.-word-pattern/#code","text":"class Solution { public : bool wordPattern(string pattern, string s) { map < char , string > ps; // pattern to string map < string, char > sp; // string to pattern istringstream ss (s); int p = 0 ; for (string word; ss >> word; ++ p) { char currp = pattern[p]; if (ps.count(currp) && ps[currp] != word) return false ; ps[currp] = word; if (sp.count(word) && sp[word] != currp) return false ; sp[word] = currp; } return p == pattern.size(); } };","title":"Code"},{"location":"Leetcode/291.-word-pattern-II/","text":"Word Pattern II \u00b6 Given a pattern and a string str , find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str . Example 1: Input: pattern = \"abab\", str = \"redblueredblue\" Output: true Example 2: Input: pattern = pattern = \"aaaa\", str = \"asdasdasdasd\" Output: true Example 3: Input: pattern = \"aabb\", str = \"xyzabcxzyabc\" Output: false Notes: You may assume both pattern and str contains only lowercase letters. Analysis \u00b6 Different from 290, this question requires us to try all the word in the string, and there is no better solution other than brute force search. Code (copied from Grandyang ) \u00b6 class Solution { public : bool wordPatternMatch(string pattern, string str) { unordered_map < char , string > m; // pattern to string return helper (pattern, 0 , str, 0 , m); } bool helper(string pattern, int p, string str, int r, unordered_map < char , string > & m) { if (p == pattern.size() && r == str.size()) return true ; if (p == pattern.size() || r == str.size()) return false ; char c = pattern[p]; for ( int i = r; i < str.size(); ++ i) { string t = str.substr(r, i - r + 1 ); // case 1: already have a matching and match correctly if (m.count(c) && m[c] == t) { if (helper(pattern, p + 1 , str, i + 1 , m)) return true ; // case 2: no matching yet, so start matching } else if ( ! m.count(c)) { bool b = false ; // check if current str has other pattern matching for ( auto it : m) { if (it.second == t) b = true ; } // if not, create new matching if ( ! b) { m[c] = t; if (helper(pattern, p + 1 , str, i + 1 , m)) return true ; m.erase(c); } } } return false ; } };","title":"Word Pattern II"},{"location":"Leetcode/291.-word-pattern-II/#word-pattern-ii","text":"Given a pattern and a string str , find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str . Example 1: Input: pattern = \"abab\", str = \"redblueredblue\" Output: true Example 2: Input: pattern = pattern = \"aaaa\", str = \"asdasdasdasd\" Output: true Example 3: Input: pattern = \"aabb\", str = \"xyzabcxzyabc\" Output: false Notes: You may assume both pattern and str contains only lowercase letters.","title":"Word Pattern II"},{"location":"Leetcode/291.-word-pattern-II/#analysis","text":"Different from 290, this question requires us to try all the word in the string, and there is no better solution other than brute force search.","title":"Analysis"},{"location":"Leetcode/291.-word-pattern-II/#code-copied-from-grandyang","text":"class Solution { public : bool wordPatternMatch(string pattern, string str) { unordered_map < char , string > m; // pattern to string return helper (pattern, 0 , str, 0 , m); } bool helper(string pattern, int p, string str, int r, unordered_map < char , string > & m) { if (p == pattern.size() && r == str.size()) return true ; if (p == pattern.size() || r == str.size()) return false ; char c = pattern[p]; for ( int i = r; i < str.size(); ++ i) { string t = str.substr(r, i - r + 1 ); // case 1: already have a matching and match correctly if (m.count(c) && m[c] == t) { if (helper(pattern, p + 1 , str, i + 1 , m)) return true ; // case 2: no matching yet, so start matching } else if ( ! m.count(c)) { bool b = false ; // check if current str has other pattern matching for ( auto it : m) { if (it.second == t) b = true ; } // if not, create new matching if ( ! b) { m[c] = t; if (helper(pattern, p + 1 , str, i + 1 , m)) return true ; m.erase(c); } } } return false ; } };","title":"Code (copied from Grandyang)"},{"location":"Leetcode/295.-find-median-from-data-stream/","text":"Find Median From Data Stream \u00b6 The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values. For example, for arr = [2,3,4] , the median is 3 . For example, for arr = [2,3] , the median is (2 + 3) / 2 = 2.5 . Implement the MedianFinder class: MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure. double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted. Example 1: ``` Input [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"] [[], [1], [2], [], [3], []] Output [null, null, null, 1.5, null, 2.0] Explanation MedianFinder medianFinder = new MedianFinder(); medianFinder.addNum(1); // arr = [1] medianFinder.addNum(2); // arr = [1, 2] medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2) medianFinder.addNum(3); // arr[1, 2, 3] medianFinder.findMedian(); // return 2.0 ``` Constraints: -105 <= num <= 105 There will be at least one element in the data structure before calling findMedian . At most 5 * 104 calls will be made to addNum and findMedian . Follow up: If all integer numbers from the stream are in the range [0, 100] , how would you optimize your solution? If 99% of all integer numbers from the stream are in the range [0, 100] , how would you optimize your solution? Analysis \u00b6 To find the median, we need to split data into two halfs, and then use (first half's last element + second half's first element) / 2 (even) or first half's last (odd) to find the median. First half's last should be the value that is greater or equal to all the values from the first half of the data, and the second half's first is less than all the elements following. To find such two elements, we can use priority queue. Use one queue for finding the large median (max heap), and use the other queue to find the smaller median (min heap). To make two queues with the size difference at most 1, we need to find a way to balance the two queues. Complexity: Time: add takes O(\\log{n}) O(\\log{n}) + find takes O(1) O(1) Space: two queues take O(n) O(n) Solution 1 [Recommend]: use global odd or even to determine median \u00b6 xxxx m yyyy q1: xxxx q2: yyyy xxxxm yyyy z // push from odd 1. xxxxzm yyyy -> xxxxxx yyyy -> xxxxx yyyyx -> xxxxx yyyyy -> m = (x + y) / 2 2. xxxxm zyyyy -> xxxxm yyyyy -> xxxxx yyyyy -> m = (x + y) / 2 xxxm yyyy z // push from even 1. xxxzm yyyy -> xxxx yyyyx -> xxxxm yyyy 2. xxxm yyyyz -> xxxx yyyyy -> xxxxm yyyy if there are even num of nodes then push to large then push the top of large to small // now it's odd else then push to small then push the top of small to large // now it's even Code \u00b6 class MedianFinder { private : priority_queue < double > small, large; bool even; public : /** initialize your data structure here. */ MedianFinder() { even = true ; // 0 is even } void addNum( int num) { if (even) { // small.size() == large.size() large.push( - num); small.push( - large.top()); large.pop(); } else { // small.size() - large.size() == 1 small.push(num); large.push( - small.top()); small.pop(); } even = ! even; } double findMedian() { return ! even ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Solution 2: without even boolean \u00b6 Use two priority queues to store the streaming element. 2 small: 2 -> empty -> 2 large: -2 -> empty median: 2 2, 3 small: 2 -> 3,2 -> 2 large: empty -> -3 median: \\frac{2 - (-3)}{2} = 2.5 \\frac{2 - (-3)}{2} = 2.5 2, 3, 4 small: 2 -> 4, 2 -> 2 -> 3, 2 large: -3 -> -3, -4 -> -4 median: 3 Code \u00b6 class MedianFinder { private : priority_queue < long > small, large; public : /** initialize your data structure here. */ MedianFinder() {} void addNum( int num) { // blindly push in two pq small.push(num); large.push( - small.top()); // small is always greater than large in size, at most greater by one, equal is fine small.pop(); // leave the new element in large if (small.size() < large.size()) { small.push( - large.top()); large.pop(); // large has one more, so move it to small } } double findMedian() { return small.size() != large.size() ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Followups \u00b6 With all fall in between 0-100? Code O(100) O(100) \u00b6 class MedianFinder { private : int A[ 101 ], n; public : MedianFinder() { n = 0 ; memset(A, 0 , sizeof A); } void addNum( int num) { A[num] ++ ; n ++ ; } double findMedian() { int count = 0 , i = 0 ; while (count < n /2 ) count += A[i ++ ]; int j = i; while (count < n /2 + 1 ) count += A[j ++ ]; return (n % 2 == 1 ) ? j -1 : (i + j - 2 ) / 2.0 ; } }; Further Thoughts: https://leetcode.com/articles/find-median-from-data-stream/ There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across: Buckets ! If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. @mitbbs8080 has an interesting implementation here . Reservoir Sampling . Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or reservoir) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a \" good \" size for your reservoir? Now, that's a whole other challenge. A good explanation for this can be found in this StackOverflow answer . Segment Trees are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations fast and in roughly the same amount of time , always . The only problem is that they are far from trivial to implement. Take a look at my introductory article on Segment Trees if you are interested. Order Statistic Trees are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the k^{th} k^{th} order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. GNU libstdc++ users are in luck! Take a look at this StackOverflow answer . \u21a9","title":"Find Median From Data Stream"},{"location":"Leetcode/295.-find-median-from-data-stream/#find-median-from-data-stream","text":"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values. For example, for arr = [2,3,4] , the median is 3 . For example, for arr = [2,3] , the median is (2 + 3) / 2 = 2.5 . Implement the MedianFinder class: MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure. double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted. Example 1: ``` Input [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"] [[], [1], [2], [], [3], []] Output [null, null, null, 1.5, null, 2.0] Explanation MedianFinder medianFinder = new MedianFinder(); medianFinder.addNum(1); // arr = [1] medianFinder.addNum(2); // arr = [1, 2] medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2) medianFinder.addNum(3); // arr[1, 2, 3] medianFinder.findMedian(); // return 2.0 ``` Constraints: -105 <= num <= 105 There will be at least one element in the data structure before calling findMedian . At most 5 * 104 calls will be made to addNum and findMedian . Follow up: If all integer numbers from the stream are in the range [0, 100] , how would you optimize your solution? If 99% of all integer numbers from the stream are in the range [0, 100] , how would you optimize your solution?","title":"Find Median From Data Stream"},{"location":"Leetcode/295.-find-median-from-data-stream/#analysis","text":"To find the median, we need to split data into two halfs, and then use (first half's last element + second half's first element) / 2 (even) or first half's last (odd) to find the median. First half's last should be the value that is greater or equal to all the values from the first half of the data, and the second half's first is less than all the elements following. To find such two elements, we can use priority queue. Use one queue for finding the large median (max heap), and use the other queue to find the smaller median (min heap). To make two queues with the size difference at most 1, we need to find a way to balance the two queues. Complexity: Time: add takes O(\\log{n}) O(\\log{n}) + find takes O(1) O(1) Space: two queues take O(n) O(n)","title":"Analysis"},{"location":"Leetcode/295.-find-median-from-data-stream/#solution-1-recommend-use-global-odd-or-even-to-determine-median","text":"xxxx m yyyy q1: xxxx q2: yyyy xxxxm yyyy z // push from odd 1. xxxxzm yyyy -> xxxxxx yyyy -> xxxxx yyyyx -> xxxxx yyyyy -> m = (x + y) / 2 2. xxxxm zyyyy -> xxxxm yyyyy -> xxxxx yyyyy -> m = (x + y) / 2 xxxm yyyy z // push from even 1. xxxzm yyyy -> xxxx yyyyx -> xxxxm yyyy 2. xxxm yyyyz -> xxxx yyyyy -> xxxxm yyyy if there are even num of nodes then push to large then push the top of large to small // now it's odd else then push to small then push the top of small to large // now it's even","title":"Solution 1 [Recommend]: use global odd or even to determine median"},{"location":"Leetcode/295.-find-median-from-data-stream/#code","text":"class MedianFinder { private : priority_queue < double > small, large; bool even; public : /** initialize your data structure here. */ MedianFinder() { even = true ; // 0 is even } void addNum( int num) { if (even) { // small.size() == large.size() large.push( - num); small.push( - large.top()); large.pop(); } else { // small.size() - large.size() == 1 small.push(num); large.push( - small.top()); small.pop(); } even = ! even; } double findMedian() { return ! even ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */","title":"Code"},{"location":"Leetcode/295.-find-median-from-data-stream/#solution-2-without-even-boolean","text":"Use two priority queues to store the streaming element. 2 small: 2 -> empty -> 2 large: -2 -> empty median: 2 2, 3 small: 2 -> 3,2 -> 2 large: empty -> -3 median: \\frac{2 - (-3)}{2} = 2.5 \\frac{2 - (-3)}{2} = 2.5 2, 3, 4 small: 2 -> 4, 2 -> 2 -> 3, 2 large: -3 -> -3, -4 -> -4 median: 3","title":"Solution 2: without even boolean"},{"location":"Leetcode/295.-find-median-from-data-stream/#code_1","text":"class MedianFinder { private : priority_queue < long > small, large; public : /** initialize your data structure here. */ MedianFinder() {} void addNum( int num) { // blindly push in two pq small.push(num); large.push( - small.top()); // small is always greater than large in size, at most greater by one, equal is fine small.pop(); // leave the new element in large if (small.size() < large.size()) { small.push( - large.top()); large.pop(); // large has one more, so move it to small } } double findMedian() { return small.size() != large.size() ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */","title":"Code"},{"location":"Leetcode/295.-find-median-from-data-stream/#followups","text":"With all fall in between 0-100?","title":"Followups"},{"location":"Leetcode/295.-find-median-from-data-stream/#code-o100o100","text":"class MedianFinder { private : int A[ 101 ], n; public : MedianFinder() { n = 0 ; memset(A, 0 , sizeof A); } void addNum( int num) { A[num] ++ ; n ++ ; } double findMedian() { int count = 0 , i = 0 ; while (count < n /2 ) count += A[i ++ ]; int j = i; while (count < n /2 + 1 ) count += A[j ++ ]; return (n % 2 == 1 ) ? j -1 : (i + j - 2 ) / 2.0 ; } }; Further Thoughts: https://leetcode.com/articles/find-median-from-data-stream/ There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across: Buckets ! If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. @mitbbs8080 has an interesting implementation here . Reservoir Sampling . Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or reservoir) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a \" good \" size for your reservoir? Now, that's a whole other challenge. A good explanation for this can be found in this StackOverflow answer . Segment Trees are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations fast and in roughly the same amount of time , always . The only problem is that they are far from trivial to implement. Take a look at my introductory article on Segment Trees if you are interested. Order Statistic Trees are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the k^{th} k^{th} order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. GNU libstdc++ users are in luck! Take a look at this StackOverflow answer . \u21a9","title":"Code O(100)O(100)"},{"location":"Leetcode/299.-Bulls-and-Cows/","text":"Bulls and Cows \u00b6 You are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: The number of \"bulls\", which are digits in the guess that are in the correct position. The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls. Given the secret number secret and your friend's guess guess , return the hint for your friend's guess . The hint should be formatted as \"xAyB\" , where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits. Example 1: Input: secret = \"1807\", guess = \"7810\" Output: \"1A3B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1807\" | \"7810\" Example 2: Input: secret = \"1123\", guess = \"0111\" Output: \"1A1B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1123\" \"1123\" | or | \"0111\" \"0111\" Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull. Example 3: Input: secret = \"1\", guess = \"0\" Output: \"0A0B\" Example 4: Input: secret = \"1\", guess = \"1\" Output: \"1A0B\" Constraints: 1 <= secret.length, guess.length <= 1000 secret.length == guess.length secret and guess consist of digits only. Analysis \u00b6 We need to calculate the number of \"bulls\" and \"cows\" given two strings. To calculate \"bulls\" is simple: just check each index of the two strings, and if the elements they are point to each are equal, we increment our \"bulls\" count. Calculating \"cows\" is a little harder. If a character from guess appeared in secret (no matter before current index or after), we increment our \"cows\" count. Besides, if a guess[i] already matched with a secret[j] , we cannot reuse secret[j] again. In order to solve this problem, we can use a map to record how many avalible secret[j] we can use, if there are secret[k] == secret[j] and k != j . After we built this map, we can run a check on each character from guess string, and keep updating the value of the map until it reaches 0. Time: O(n) O(n) Space: O(n) O(n) when all characters in secret string are distinct. Code \u00b6 class Solution { public : string getHint(string secret, string guess) { int cows = 0 , bulls = 0 ; int n = secret.size(); unordered_map < int , int > mp; for ( int i = 0 ; i < n; ++ i) { if (secret[i] == guess[i]) bulls ++ ; else mp[secret[i]] ++ ; } for ( int i = 0 ; i < n; ++ i) { if (secret[i] != guess[i] && mp[guess[i]] -- > 0 ) cows ++ ; } return to_string(bulls) + \"A\" + to_string(cows) + \"B\" ; } };","title":"Bulls and Cows"},{"location":"Leetcode/299.-Bulls-and-Cows/#bulls-and-cows","text":"You are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: The number of \"bulls\", which are digits in the guess that are in the correct position. The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls. Given the secret number secret and your friend's guess guess , return the hint for your friend's guess . The hint should be formatted as \"xAyB\" , where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits. Example 1: Input: secret = \"1807\", guess = \"7810\" Output: \"1A3B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1807\" | \"7810\" Example 2: Input: secret = \"1123\", guess = \"0111\" Output: \"1A1B\" Explanation: Bulls are connected with a '|' and cows are underlined: \"1123\" \"1123\" | or | \"0111\" \"0111\" Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull. Example 3: Input: secret = \"1\", guess = \"0\" Output: \"0A0B\" Example 4: Input: secret = \"1\", guess = \"1\" Output: \"1A0B\" Constraints: 1 <= secret.length, guess.length <= 1000 secret.length == guess.length secret and guess consist of digits only.","title":"Bulls and Cows"},{"location":"Leetcode/299.-Bulls-and-Cows/#analysis","text":"We need to calculate the number of \"bulls\" and \"cows\" given two strings. To calculate \"bulls\" is simple: just check each index of the two strings, and if the elements they are point to each are equal, we increment our \"bulls\" count. Calculating \"cows\" is a little harder. If a character from guess appeared in secret (no matter before current index or after), we increment our \"cows\" count. Besides, if a guess[i] already matched with a secret[j] , we cannot reuse secret[j] again. In order to solve this problem, we can use a map to record how many avalible secret[j] we can use, if there are secret[k] == secret[j] and k != j . After we built this map, we can run a check on each character from guess string, and keep updating the value of the map until it reaches 0. Time: O(n) O(n) Space: O(n) O(n) when all characters in secret string are distinct.","title":"Analysis"},{"location":"Leetcode/299.-Bulls-and-Cows/#code","text":"class Solution { public : string getHint(string secret, string guess) { int cows = 0 , bulls = 0 ; int n = secret.size(); unordered_map < int , int > mp; for ( int i = 0 ; i < n; ++ i) { if (secret[i] == guess[i]) bulls ++ ; else mp[secret[i]] ++ ; } for ( int i = 0 ; i < n; ++ i) { if (secret[i] != guess[i] && mp[guess[i]] -- > 0 ) cows ++ ; } return to_string(bulls) + \"A\" + to_string(cows) + \"B\" ; } };","title":"Code"},{"location":"Leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/","text":"Longest Substring Without Repeating Characters \u00b6 Given a string s , find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Example 4: Input: s = \"\" Output: 0 Constraints: 0 <= s.length <= 5 * 104 s consists of English letters, digits, symbols and spaces. Analysis \u00b6 Method 1: keep a 128 length int cnt array, when moving the sliding window: if current right's cnt == 0: we need to update our global result to see if it's greater than current maximum window length else: we need to move left pointer to right to make the cnt == 0 (this is the only way, since our right is always moving right, so there is no way to \"delete\" any character from the window). Method 2: still use a 128 lenght int array, but we now use it to store the last occurance of the current character's index in each iteration, we first compare current window's left, because the last previous occurance of the current character is going to bound our window (or it will at least has a window with two duplicate character). update our idx map for the most updated index update our global length Time: O(n) O(n) Space: O(128) O(128) or O(n) O(n) depending on the range of character Code 1 \u00b6 class Solution { public : int lengthOfLongestSubstring(string s) { int res = 0 ; int cnt[ 128 ] = { 0 }; for ( int r = 0 , l = 0 ; r < s.size(); ) { if (cnt[s[r]] == 0 ) { res = max(res, r - l + 1 ); cnt[s[r ++ ]] ++ ; } else { cnt[s[l ++ ]] -- ; } } return res; } }; Code 2 \u00b6 class Solution { public : int lengthOfLongestSubstring(string s) { vector < int > idx( 128 , -1 ); int left = -1 , res = 0 ; for ( int i = 0 ; i < s.size(); ++ i) { left = max(left, idx[s[i]]); idx[s[i]] = i; res = max(res, i - left); } return res; } };","title":"Longest Substring Without Repeating Characters"},{"location":"Leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#longest-substring-without-repeating-characters","text":"Given a string s , find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Example 4: Input: s = \"\" Output: 0 Constraints: 0 <= s.length <= 5 * 104 s consists of English letters, digits, symbols and spaces.","title":"Longest Substring Without Repeating Characters"},{"location":"Leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#analysis","text":"Method 1: keep a 128 length int cnt array, when moving the sliding window: if current right's cnt == 0: we need to update our global result to see if it's greater than current maximum window length else: we need to move left pointer to right to make the cnt == 0 (this is the only way, since our right is always moving right, so there is no way to \"delete\" any character from the window). Method 2: still use a 128 lenght int array, but we now use it to store the last occurance of the current character's index in each iteration, we first compare current window's left, because the last previous occurance of the current character is going to bound our window (or it will at least has a window with two duplicate character). update our idx map for the most updated index update our global length Time: O(n) O(n) Space: O(128) O(128) or O(n) O(n) depending on the range of character","title":"Analysis"},{"location":"Leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#code-1","text":"class Solution { public : int lengthOfLongestSubstring(string s) { int res = 0 ; int cnt[ 128 ] = { 0 }; for ( int r = 0 , l = 0 ; r < s.size(); ) { if (cnt[s[r]] == 0 ) { res = max(res, r - l + 1 ); cnt[s[r ++ ]] ++ ; } else { cnt[s[l ++ ]] -- ; } } return res; } };","title":"Code 1"},{"location":"Leetcode/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#code-2","text":"class Solution { public : int lengthOfLongestSubstring(string s) { vector < int > idx( 128 , -1 ); int left = -1 , res = 0 ; for ( int i = 0 ; i < s.size(); ++ i) { left = max(left, idx[s[i]]); idx[s[i]] = i; res = max(res, i - left); } return res; } };","title":"Code 2"},{"location":"Leetcode/312.-Burst-Balloons/","text":"Burst Balloons \u00b6 You are given n balloons, indexed from 0 to n - 1 . Each balloon is painted with a number on it represented by an array nums . You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely . Example 1: Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 Example 2: Input: nums = [1,5] Output: 10 Constraints: n == nums.length 1 <= n <= 500 0 <= nums[i] <= 100 Analysis \u00b6 This is a \"Interval DP\" problem, which means you need to create a 2-d array represent the optimal solution for each interval from start to end . Using dp[start][end] to represent the maximum value. So for this problem, if nums = [3,1,5,8] , then dp[1][4] is our solution. Note We use 1-based index for easy representation, because the boundary case: burst first balloon or last ballon is easier to be calculated. We just need to add two 1s to the beginning and the ending. Next, we just need to try all the smaller segaments first then calculate the final answer. First, we determine the length of each segament, and we start from len = 1 , which means there is only one ballon, and ends at len = n Second, we determine the starting and ending points. We use i to represent start and j to represent the end. Thus the range for start is from 1 to n-len+1 , since we need to leave room for ending. If we have determined our i , then our ending point is fixed, which is i+len-1 . Finally, we need to determine which ballon to be bursted from the i to j range. We use k to represent the bursting point, and we try all the possible point from k = i to k=j . Time: O(n^3) O(n^3) Space: O(n^2) O(n^2) for the extra dp 2-d array Code \u00b6 class Solution { public : int maxCoins(vector < int > & nums) { int n = nums.size(); nums.insert(nums.begin(), 1 ); nums.push_back( 1 ); vector < vector < int >> dp(n + 2 , vector < int > (n + 2 , 0 )); for ( int len = 1 ; len <= n; ++ len) { for ( int i = 1 ; i <= n - len + 1 ; ++ i) { int j = i + len - 1 ; for ( int k = i; k <= j; ++ k) { dp[i][j] = max(dp[i][j], nums[i - 1 ] * nums[k] * nums[j + 1 ] + dp[i][k - 1 ] + dp[k + 1 ][j]); } } } return dp[ 1 ][n]; } };","title":"Burst Balloons"},{"location":"Leetcode/312.-Burst-Balloons/#burst-balloons","text":"You are given n balloons, indexed from 0 to n - 1 . Each balloon is painted with a number on it represented by an array nums . You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely . Example 1: Input: nums = [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 Example 2: Input: nums = [1,5] Output: 10 Constraints: n == nums.length 1 <= n <= 500 0 <= nums[i] <= 100","title":"Burst Balloons"},{"location":"Leetcode/312.-Burst-Balloons/#analysis","text":"This is a \"Interval DP\" problem, which means you need to create a 2-d array represent the optimal solution for each interval from start to end . Using dp[start][end] to represent the maximum value. So for this problem, if nums = [3,1,5,8] , then dp[1][4] is our solution. Note We use 1-based index for easy representation, because the boundary case: burst first balloon or last ballon is easier to be calculated. We just need to add two 1s to the beginning and the ending. Next, we just need to try all the smaller segaments first then calculate the final answer. First, we determine the length of each segament, and we start from len = 1 , which means there is only one ballon, and ends at len = n Second, we determine the starting and ending points. We use i to represent start and j to represent the end. Thus the range for start is from 1 to n-len+1 , since we need to leave room for ending. If we have determined our i , then our ending point is fixed, which is i+len-1 . Finally, we need to determine which ballon to be bursted from the i to j range. We use k to represent the bursting point, and we try all the possible point from k = i to k=j . Time: O(n^3) O(n^3) Space: O(n^2) O(n^2) for the extra dp 2-d array","title":"Analysis"},{"location":"Leetcode/312.-Burst-Balloons/#code","text":"class Solution { public : int maxCoins(vector < int > & nums) { int n = nums.size(); nums.insert(nums.begin(), 1 ); nums.push_back( 1 ); vector < vector < int >> dp(n + 2 , vector < int > (n + 2 , 0 )); for ( int len = 1 ; len <= n; ++ len) { for ( int i = 1 ; i <= n - len + 1 ; ++ i) { int j = i + len - 1 ; for ( int k = i; k <= j; ++ k) { dp[i][j] = max(dp[i][j], nums[i - 1 ] * nums[k] * nums[j + 1 ] + dp[i][k - 1 ] + dp[k + 1 ][j]); } } } return dp[ 1 ][n]; } };","title":"Code"},{"location":"Leetcode/32.-longest-valid-parentheses/","text":"Longest Valid Parentheses \u00b6 Given a string containing just the characters '(' and ')' , find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: s = \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\". Example 2: Input: s = \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\". Example 3: Input: s = \"\" Output: 0 Constraints: 0 <= s.length <= 3 * 104 s[i] is '(' , or ')' . Analysis \u00b6 dp[i]: longest valid parentheses length ending with current [i] i - dp[i] + 1: start index of the previous valid one (dp[i-1]) why +2 : because the dp[prevStart-1] + ( + dp[i-1] + ), there are two elements Code \u00b6 int longestValidParentheses (string s) { if (s.length() <= 1 ) return 0 ; int curMax = 0 ; vector < int > longest(s.size(), 0 ); for ( int i =1 ; i < s.length(); i ++ ){ if (s[i] == ')' ){ /* this block could be ignored because the else block has already calculated it if(s[i-1] == '('){ // valid parethese with previous one longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); } */ else { // if s[i-1] == ')', combine the previous length. int prevStart = i - longest[i -1 ] - 1 ; // the one before the last start valid if (prevStart >= 0 && s[prevStart] == '(' ){ longest[i] = longest[i -1 ] + 2 + ((prevStart - 1 >= 0 ) ? longest[prevStart - 1 ] :0 ); curMax = max(longest[i],curMax); } } } //else if s[i] == '(', skip it, because longest[i] must be 0 } return curMax; }","title":"Longest Valid Parentheses"},{"location":"Leetcode/32.-longest-valid-parentheses/#longest-valid-parentheses","text":"Given a string containing just the characters '(' and ')' , find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: s = \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\". Example 2: Input: s = \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\". Example 3: Input: s = \"\" Output: 0 Constraints: 0 <= s.length <= 3 * 104 s[i] is '(' , or ')' .","title":"Longest Valid Parentheses"},{"location":"Leetcode/32.-longest-valid-parentheses/#analysis","text":"dp[i]: longest valid parentheses length ending with current [i] i - dp[i] + 1: start index of the previous valid one (dp[i-1]) why +2 : because the dp[prevStart-1] + ( + dp[i-1] + ), there are two elements","title":"Analysis"},{"location":"Leetcode/32.-longest-valid-parentheses/#code","text":"int longestValidParentheses (string s) { if (s.length() <= 1 ) return 0 ; int curMax = 0 ; vector < int > longest(s.size(), 0 ); for ( int i =1 ; i < s.length(); i ++ ){ if (s[i] == ')' ){ /* this block could be ignored because the else block has already calculated it if(s[i-1] == '('){ // valid parethese with previous one longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); } */ else { // if s[i-1] == ')', combine the previous length. int prevStart = i - longest[i -1 ] - 1 ; // the one before the last start valid if (prevStart >= 0 && s[prevStart] == '(' ){ longest[i] = longest[i -1 ] + 2 + ((prevStart - 1 >= 0 ) ? longest[prevStart - 1 ] :0 ); curMax = max(longest[i],curMax); } } } //else if s[i] == '(', skip it, because longest[i] must be 0 } return curMax; }","title":"Code"},{"location":"Leetcode/344.-Reverse-String/","text":"Reverse String \u00b6 Write a function that reverses a string. The input string is given as an array of characters s . You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] Constraints: 1 <= s.length <= 105 s[i] is a printable ascii character . Analysis \u00b6 Can be solved using simple two pointers trick. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : void reverseString(vector < char >& s) { for ( int l = 0 , r = s.size() - 1 ; l < r; l ++ , r -- ) { char t = s[l]; s[l] = s[r]; s[r] = t; } } };","title":"Reverse String"},{"location":"Leetcode/344.-Reverse-String/#reverse-string","text":"Write a function that reverses a string. The input string is given as an array of characters s . You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] Constraints: 1 <= s.length <= 105 s[i] is a printable ascii character .","title":"Reverse String"},{"location":"Leetcode/344.-Reverse-String/#analysis","text":"Can be solved using simple two pointers trick. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/344.-Reverse-String/#code","text":"class Solution { public : void reverseString(vector < char >& s) { for ( int l = 0 , r = s.size() - 1 ; l < r; l ++ , r -- ) { char t = s[l]; s[l] = s[r]; s[r] = t; } } };","title":"Code"},{"location":"Leetcode/36.-valid-sudoku/","text":"Valid Sudoku \u00b6 Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules : Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. Example 1: Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: true Example 2: Input: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit or '.' . Analysis \u00b6 There are three things we need to keep track: # of distinct row values, # of distinct columns values, # of box values. To calculate the first twos are fairly simple: keep a boolean array of size of 9, set row i to true for each iteration and check for conflict. To calculate box index, we can use the same method. By observation: For row number 0-2, the box_index can only be 0, 1, or 2, which can be determined by column number divided by 3 : col / 3. For row number 3-5, the box_index is 3, 4, 5, which can be determined by (1 * 3 + col / 3), and 1 = row / 3. Same reason for row number 6-8, the box_index is (2 * 3 + col / 3), and 2 = row / 3. As to why multiply by 3 is because every 3 row from left to right contains 3 boxes. Code \u00b6 class Solution { #define B(i, j) (3 * (i / 3) + j / 3) public : bool isValidSudoku(vector < vector < char >>& board) { if (board.empty() || board[ 0 ].empty()) { return false ; } int m = board.size(), n = board[ 0 ].size(); vector < vector < bool >> row(m, vector < bool > (n, false )); // n = 9 vector < vector < bool >> col(m, vector < bool > (n, false )); vector < vector < bool >> box(m, vector < bool > (n, false )); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (board[i][j] == '.' ) { continue ; } int value = board[i][j] - '1' ; // so that '1' -> 0 if (row[i][value] || col[value][j] || box[B(i, j)][value]) { return false ; } else { row[i][value] = true ; col[value][j] = true ; box[B(i, j)][value] = true ; } } } return true ; } };","title":"Valid Sudoku"},{"location":"Leetcode/36.-valid-sudoku/#valid-sudoku","text":"Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules : Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. Example 1: Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: true Example 2: Input: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit or '.' .","title":"Valid Sudoku"},{"location":"Leetcode/36.-valid-sudoku/#analysis","text":"There are three things we need to keep track: # of distinct row values, # of distinct columns values, # of box values. To calculate the first twos are fairly simple: keep a boolean array of size of 9, set row i to true for each iteration and check for conflict. To calculate box index, we can use the same method. By observation: For row number 0-2, the box_index can only be 0, 1, or 2, which can be determined by column number divided by 3 : col / 3. For row number 3-5, the box_index is 3, 4, 5, which can be determined by (1 * 3 + col / 3), and 1 = row / 3. Same reason for row number 6-8, the box_index is (2 * 3 + col / 3), and 2 = row / 3. As to why multiply by 3 is because every 3 row from left to right contains 3 boxes.","title":"Analysis"},{"location":"Leetcode/36.-valid-sudoku/#code","text":"class Solution { #define B(i, j) (3 * (i / 3) + j / 3) public : bool isValidSudoku(vector < vector < char >>& board) { if (board.empty() || board[ 0 ].empty()) { return false ; } int m = board.size(), n = board[ 0 ].size(); vector < vector < bool >> row(m, vector < bool > (n, false )); // n = 9 vector < vector < bool >> col(m, vector < bool > (n, false )); vector < vector < bool >> box(m, vector < bool > (n, false )); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (board[i][j] == '.' ) { continue ; } int value = board[i][j] - '1' ; // so that '1' -> 0 if (row[i][value] || col[value][j] || box[B(i, j)][value]) { return false ; } else { row[i][value] = true ; col[value][j] = true ; box[B(i, j)][value] = true ; } } } return true ; } };","title":"Code"},{"location":"Leetcode/376.-Wiggle-Subsequence/","text":"Wiggle Subsequence \u00b6 Given an integer array nums , return the length of the longest wiggle sequence **. A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) are alternately positive and negative. In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. A subsequence is obtained by deleting some elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: nums = [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence. Example 2: Input: nums = [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. Example 3: Input: nums = [1,2,3,4,5,6,7,8,9] Output: 2 Constraints: 1 <= nums.length <= 1000 0 <= nums[i] <= 1000 Follow up: Could you solve this in O(n) time? Analysis \u00b6 The brute force solution is using \"choose or not\" method to check for each element from the array, and it takes O(n) O(n) for each result validation (check if is indeed waggle), and the total time complexity is O(n! \\times n) O(n! \\times n) It will result TLE. Dynamic Programming : Another approach is using two arrays to record the current status' longest subsequence count (with the last element being nums[i] ). For each point, we could choose either to append the previous \"raising\" subsequence or \"falling\" subsequence \u2014 thus we need two arrays. The time complexity for this approach is O(n^2) O(n^2) , and the space complexity is O(2 \\times n) O(2 \\times n) . Dynmaic Programming Improved : If we think carefully, there are some correlation between our two arrays. If we mark one array as up[i] and another one as down[i] , we can find that if nums[i] > nums[i-1] (going up), the previous one must be going down, and we will have the maximum value from down[i - 1] , since down[i - 1] >= down[i - 2] \u2026 >= down[0] . Same logic applies to nums[i] < nums[i - 1] . Using this method we don't need to iterate through the nums[i] twice, but just a linear scan should be able to solve this problem. To further improve, since we are only interested in the previous down or up , we don't need to store all the result from down[0] \u2026 down[i-1] , so we can minimize these arrays into two variables. Time complexity will be O(n) O(n) and space is O(1) O(1) . Code: brute force \u00b6 class Solution { public : int dfs(vector < int >& a, int idx, bool status) { int cnt = 0 ; // start checking from current index + 1 for ( int i = idx + 1 ; i < a.size(); ++ i) { // a[prev] < a[i] if ((status && a[i] > a[idx]) || ( // a[prev] > a[i] ! status && a[i] < a[idx])) { cnt = max(cnt, 1 + dfs(a, i, ! status)); // each iteration will change the direction } } return cnt; } int wiggleMaxLength(vector < int >& a) { if (a.size() < 2 ) return a.size(); return 1 + max(dfs(a, 0 , false ), dfs(a, 0 , true )); } }; Code: DP with two arrays \u00b6 class Solution { public : int wiggleMaxLength(vector < int >& a) { int n = a.size(); if (n < 2 ) return n; vector < int > up(n), down(n); for ( int i = 1 ; i < n; ++ i) { for ( int j = 0 ; j < i; ++ j) { if (a[i] < a[j]) { // now: up, prev: down down[i] = max(down[i], up[j] + 1 ); } else if (a[i] > a[j]) { // now: down, prev: up up[i] = max(up[i], down[j] + 1 ); } } } return max(up.back(), down.back()) + 1 ; } }; Code: DP with two variables \u00b6 class Solution { public : int wiggleMaxLength(vector < int >& a) { int n = a.size(); if (n < 2 ) return n; int up = 1 , down = 1 ; for ( int i = 1 ; i < n; ++ i) { if (a[i] < a[i - 1 ]) // now: up, prev: down /* up = max(up, down + 1); we can acutally ignore up, since prev has to be down and if we don't choose, our down variable isn't changed */ up = down + 1 ; else if (a[i] > a[i - 1 ]) /* down = max(down, up + 1) ; same logic here */ down = up + 1 ; } return max(up, down); } };","title":"Wiggle Subsequence"},{"location":"Leetcode/376.-Wiggle-Subsequence/#wiggle-subsequence","text":"Given an integer array nums , return the length of the longest wiggle sequence **. A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) are alternately positive and negative. In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. A subsequence is obtained by deleting some elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: nums = [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence. Example 2: Input: nums = [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. Example 3: Input: nums = [1,2,3,4,5,6,7,8,9] Output: 2 Constraints: 1 <= nums.length <= 1000 0 <= nums[i] <= 1000 Follow up: Could you solve this in O(n) time?","title":"Wiggle Subsequence"},{"location":"Leetcode/376.-Wiggle-Subsequence/#analysis","text":"The brute force solution is using \"choose or not\" method to check for each element from the array, and it takes O(n) O(n) for each result validation (check if is indeed waggle), and the total time complexity is O(n! \\times n) O(n! \\times n) It will result TLE. Dynamic Programming : Another approach is using two arrays to record the current status' longest subsequence count (with the last element being nums[i] ). For each point, we could choose either to append the previous \"raising\" subsequence or \"falling\" subsequence \u2014 thus we need two arrays. The time complexity for this approach is O(n^2) O(n^2) , and the space complexity is O(2 \\times n) O(2 \\times n) . Dynmaic Programming Improved : If we think carefully, there are some correlation between our two arrays. If we mark one array as up[i] and another one as down[i] , we can find that if nums[i] > nums[i-1] (going up), the previous one must be going down, and we will have the maximum value from down[i - 1] , since down[i - 1] >= down[i - 2] \u2026 >= down[0] . Same logic applies to nums[i] < nums[i - 1] . Using this method we don't need to iterate through the nums[i] twice, but just a linear scan should be able to solve this problem. To further improve, since we are only interested in the previous down or up , we don't need to store all the result from down[0] \u2026 down[i-1] , so we can minimize these arrays into two variables. Time complexity will be O(n) O(n) and space is O(1) O(1) .","title":"Analysis"},{"location":"Leetcode/376.-Wiggle-Subsequence/#code-brute-force","text":"class Solution { public : int dfs(vector < int >& a, int idx, bool status) { int cnt = 0 ; // start checking from current index + 1 for ( int i = idx + 1 ; i < a.size(); ++ i) { // a[prev] < a[i] if ((status && a[i] > a[idx]) || ( // a[prev] > a[i] ! status && a[i] < a[idx])) { cnt = max(cnt, 1 + dfs(a, i, ! status)); // each iteration will change the direction } } return cnt; } int wiggleMaxLength(vector < int >& a) { if (a.size() < 2 ) return a.size(); return 1 + max(dfs(a, 0 , false ), dfs(a, 0 , true )); } };","title":"Code: brute force"},{"location":"Leetcode/376.-Wiggle-Subsequence/#code-dp-with-two-arrays","text":"class Solution { public : int wiggleMaxLength(vector < int >& a) { int n = a.size(); if (n < 2 ) return n; vector < int > up(n), down(n); for ( int i = 1 ; i < n; ++ i) { for ( int j = 0 ; j < i; ++ j) { if (a[i] < a[j]) { // now: up, prev: down down[i] = max(down[i], up[j] + 1 ); } else if (a[i] > a[j]) { // now: down, prev: up up[i] = max(up[i], down[j] + 1 ); } } } return max(up.back(), down.back()) + 1 ; } };","title":"Code: DP with two arrays"},{"location":"Leetcode/376.-Wiggle-Subsequence/#code-dp-with-two-variables","text":"class Solution { public : int wiggleMaxLength(vector < int >& a) { int n = a.size(); if (n < 2 ) return n; int up = 1 , down = 1 ; for ( int i = 1 ; i < n; ++ i) { if (a[i] < a[i - 1 ]) // now: up, prev: down /* up = max(up, down + 1); we can acutally ignore up, since prev has to be down and if we don't choose, our down variable isn't changed */ up = down + 1 ; else if (a[i] > a[i - 1 ]) /* down = max(down, up + 1) ; same logic here */ down = up + 1 ; } return max(up, down); } };","title":"Code: DP with two variables"},{"location":"Leetcode/394.-decode-string/","text":"Decode String \u00b6 Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string] , where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k . For example, there won't be input like 3a or 2[4] . Example 1: Input: s = \"3[a]2[bc]\" Output: \"aaabcbc\" Example 2: Input: s = \"3[a2[c]]\" Output: \"accaccacc\" Example 3: Input: s = \"2[abc]3[cd]ef\" Output: \"abcabccdcdcdef\" Example 4: Input: s = \"abc3[cd]xyz\" Output: \"abccdcdcdxyz\" Analysis \u00b6 There are two parts we need to take care of: repeated number: cnt string enclosed by '[]': t So we need to ues two stacks to store the above two information: stack<int> times which store the current repeated number and stack<string> stk which store the current concatenated string. If we see a number, we append the digit to our current partial formed number. If we see '[', we can stop tracking our number string (convert it to integer and push it to the top of time stack), and also we need to start push string to stk . If we see ']', we should start \"duplicating\" times.top() \\times \\times t and push that to our stk . Time; O(n) O(n) Space: O(n) O(n) Code \u00b6 class Solution { public : string decodeString(string s) { stack < int > times; stack < string > stk; int cnt = 0 ; string t = \"\" ; for ( char c : s) { if (c <= '9' && c >= '0' ) { cnt = cnt * 10 + c - '0' ; } else if (c == '[' ) { times.push(cnt); stk.push(t); cnt = 0 ; t = \"\" ; } else if (c == ']' ) { int time = times.top(); times.pop(); for ( int i = 0 ; i < time; ++ i) { stk.top() += t; } t = stk.top(); stk.pop(); } else { t += c; } } return stk.empty() ? t : stk.top(); } };","title":"Decode String"},{"location":"Leetcode/394.-decode-string/#decode-string","text":"Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string] , where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k . For example, there won't be input like 3a or 2[4] . Example 1: Input: s = \"3[a]2[bc]\" Output: \"aaabcbc\" Example 2: Input: s = \"3[a2[c]]\" Output: \"accaccacc\" Example 3: Input: s = \"2[abc]3[cd]ef\" Output: \"abcabccdcdcdef\" Example 4: Input: s = \"abc3[cd]xyz\" Output: \"abccdcdcdxyz\"","title":"Decode String"},{"location":"Leetcode/394.-decode-string/#analysis","text":"There are two parts we need to take care of: repeated number: cnt string enclosed by '[]': t So we need to ues two stacks to store the above two information: stack<int> times which store the current repeated number and stack<string> stk which store the current concatenated string. If we see a number, we append the digit to our current partial formed number. If we see '[', we can stop tracking our number string (convert it to integer and push it to the top of time stack), and also we need to start push string to stk . If we see ']', we should start \"duplicating\" times.top() \\times \\times t and push that to our stk . Time; O(n) O(n) Space: O(n) O(n)","title":"Analysis"},{"location":"Leetcode/394.-decode-string/#code","text":"class Solution { public : string decodeString(string s) { stack < int > times; stack < string > stk; int cnt = 0 ; string t = \"\" ; for ( char c : s) { if (c <= '9' && c >= '0' ) { cnt = cnt * 10 + c - '0' ; } else if (c == '[' ) { times.push(cnt); stk.push(t); cnt = 0 ; t = \"\" ; } else if (c == ']' ) { int time = times.top(); times.pop(); for ( int i = 0 ; i < time; ++ i) { stk.top() += t; } t = stk.top(); stk.pop(); } else { t += c; } } return stk.empty() ? t : stk.top(); } };","title":"Code"},{"location":"Leetcode/4.-median-of-two-sorted-arrays/","text":"Median of Two Sorted Arrays \u00b6 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 <= m <= 1000 0 <= n <= 1000 1 <= m + n <= 2000 -106 <= nums1[i], nums2[i] <= 106 Follow up: The overall run time complexity should be O(log (m+n)) . Anaysis \u00b6 Finding median is basically finding the (m + n) // 2 th elements for the two sorted arrays. We can use binary search to find this element. We will use recursion to implement the binary search: int findKth(vector<int>& nums1, vector<int>& nums2, int i, int j, int k) . i is the iterator pointing at nums1 , and j is the iterator pointing at nums2 , and k is the current k-th element we are interested in starting from nums[i] and nums[j] (note that both i , j , k are varibles, and they will change in each iteration). Now we consider what we do for each iteration. If we have reach to the end of nums1 , which mean i == nums1.size() , then we will give up nums1 and simply return the k-th element from nums2 . In constrast, if we have reach to the end of nums2 , which mean j == nums2.size() , then we will give up nums2 and simply return the k-th element from nums1 . Don't forget there is another base case: k == 1 , which means there is only one element we are interested in, and we should return the smaller one from nums1[i] and nums2[j] . Then we will eagerly grow our poiners as far as possible, and we decide to grow half the size of k. If both i + k/2 - 1 and j + k/2 - 1 are in the range, then we determine the smaller one. Since we are determining the k-th largest element, if we can be sure that all the elements from i to i + k are smaller than j to j + k (assume nums1[i + k/2 - 1] < nums2[j + k/2 - 1] ), then we can safely discard all the elements from i to i + k/2 (they will be used as a \"placeholder\" or \u70ae\u7070 in Chinese for i to i + k/2 ). This logic can apply to the case when nums1[i + k/2 - 1] >= nums2[j + k/2 - 1] as well. Time: O(log_2{m + n}) O(log_2{m + n}) Space: O(1) O(1) Code \u00b6 class Solution { public : double findMedianSortedArrays(vector < int >& nums1, vector < int >& nums2) { int m = nums1.size(), n = nums2.size(); return (findKth(nums1, nums2, 0 , 0 , (m + n + 1 ) >> 1 ) + findKth(nums1, nums2, 0 , 0 , (m + n + 2 ) >> 1 )) / 2.0 ; } int findKth(vector < int >& nums1, vector < int >& nums2, int i, int j, int k) { if (i >= nums1.size()) return nums2[j + k - 1 ]; if (j >= nums2.size()) return nums1[i + k - 1 ]; if (k == 1 ) return min(nums1[i], nums2[j]); int minVal1 = (i + k / 2 - 1 < nums1.size()) ? nums1[i + k / 2 - 1 ] : INT_MAX; int minVal2 = (j + k / 2 - 1 < nums2.size()) ? nums2[j + k / 2 - 1 ] : INT_MAX; if (minVal1 < minVal2) return findKth(nums1, nums2, i + k / 2 , j, k - k / 2 ); else return findKth(nums1, nums2, i, j + k / 2 , k - k / 2 ); } };","title":"Median of Two Sorted Arrays"},{"location":"Leetcode/4.-median-of-two-sorted-arrays/#median-of-two-sorted-arrays","text":"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Example 3: Input: nums1 = [0,0], nums2 = [0,0] Output: 0.00000 Example 4: Input: nums1 = [], nums2 = [1] Output: 1.00000 Example 5: Input: nums1 = [2], nums2 = [] Output: 2.00000 Constraints: nums1.length == m nums2.length == n 0 <= m <= 1000 0 <= n <= 1000 1 <= m + n <= 2000 -106 <= nums1[i], nums2[i] <= 106 Follow up: The overall run time complexity should be O(log (m+n)) .","title":"Median of Two Sorted Arrays"},{"location":"Leetcode/4.-median-of-two-sorted-arrays/#anaysis","text":"Finding median is basically finding the (m + n) // 2 th elements for the two sorted arrays. We can use binary search to find this element. We will use recursion to implement the binary search: int findKth(vector<int>& nums1, vector<int>& nums2, int i, int j, int k) . i is the iterator pointing at nums1 , and j is the iterator pointing at nums2 , and k is the current k-th element we are interested in starting from nums[i] and nums[j] (note that both i , j , k are varibles, and they will change in each iteration). Now we consider what we do for each iteration. If we have reach to the end of nums1 , which mean i == nums1.size() , then we will give up nums1 and simply return the k-th element from nums2 . In constrast, if we have reach to the end of nums2 , which mean j == nums2.size() , then we will give up nums2 and simply return the k-th element from nums1 . Don't forget there is another base case: k == 1 , which means there is only one element we are interested in, and we should return the smaller one from nums1[i] and nums2[j] . Then we will eagerly grow our poiners as far as possible, and we decide to grow half the size of k. If both i + k/2 - 1 and j + k/2 - 1 are in the range, then we determine the smaller one. Since we are determining the k-th largest element, if we can be sure that all the elements from i to i + k are smaller than j to j + k (assume nums1[i + k/2 - 1] < nums2[j + k/2 - 1] ), then we can safely discard all the elements from i to i + k/2 (they will be used as a \"placeholder\" or \u70ae\u7070 in Chinese for i to i + k/2 ). This logic can apply to the case when nums1[i + k/2 - 1] >= nums2[j + k/2 - 1] as well. Time: O(log_2{m + n}) O(log_2{m + n}) Space: O(1) O(1)","title":"Anaysis"},{"location":"Leetcode/4.-median-of-two-sorted-arrays/#code","text":"class Solution { public : double findMedianSortedArrays(vector < int >& nums1, vector < int >& nums2) { int m = nums1.size(), n = nums2.size(); return (findKth(nums1, nums2, 0 , 0 , (m + n + 1 ) >> 1 ) + findKth(nums1, nums2, 0 , 0 , (m + n + 2 ) >> 1 )) / 2.0 ; } int findKth(vector < int >& nums1, vector < int >& nums2, int i, int j, int k) { if (i >= nums1.size()) return nums2[j + k - 1 ]; if (j >= nums2.size()) return nums1[i + k - 1 ]; if (k == 1 ) return min(nums1[i], nums2[j]); int minVal1 = (i + k / 2 - 1 < nums1.size()) ? nums1[i + k / 2 - 1 ] : INT_MAX; int minVal2 = (j + k / 2 - 1 < nums2.size()) ? nums2[j + k / 2 - 1 ] : INT_MAX; if (minVal1 < minVal2) return findKth(nums1, nums2, i + k / 2 , j, k - k / 2 ); else return findKth(nums1, nums2, i, j + k / 2 , k - k / 2 ); } };","title":"Code"},{"location":"Leetcode/42.-trapping-rain-water/","text":"Trapping Rain Water \u00b6 Given n non-negative integers representing an elevation map where the width of each bar is 1 , compute how much water it can trap after raining. Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2: Input: height = [4,2,0,3,2,5] Output: 9 Constraints: n == height.length 0 <= n <= 3 * 104 0 <= height[i] <= 105 Analysis \u00b6 To trap water, there should be a U shape, which means we need to have three points: left (high), mid (low) and right (high). To find satisfied points, we need to maintain a monontonic stack, which only accept points that is less than current one, so that when new points coming in, we can find the satified three points. Taking this example, we can see that for d, it will start trap water for b, c, d first: area = (min(b, d) - c) * (distance between b and d). We can do this calculation for a, b, d as well: area = (min(a, d) - b) * (distance between a and d). By obervation, we can see that we are just calculating the area in the rectangular: lying down with height as the height difference and width is the distance between two bars. Time: O(n) O(n) we push each element exactly once, and we pop each element exactly once. Space: O(n) O(n) stack can contain all the elements. Code \u00b6 class Solution { public : int trap(vector < int >& height) { int n = height.size(), res = 0 ; stack < int > st; for ( int i = 0 ; i < n; ++ i) { if (st.empty()) st.push(i); else { while ( ! st.empty() && height[st.top()] < height[i]) { int t = st.top(); st.pop(); if (st.empty()) break ; res += (i - st.top() - 1 ) * (min(height[i], height[st.top()]) - height[t]); } st.push(i); } } return res; } };","title":"Trapping Rain Water"},{"location":"Leetcode/42.-trapping-rain-water/#trapping-rain-water","text":"Given n non-negative integers representing an elevation map where the width of each bar is 1 , compute how much water it can trap after raining. Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2: Input: height = [4,2,0,3,2,5] Output: 9 Constraints: n == height.length 0 <= n <= 3 * 104 0 <= height[i] <= 105","title":"Trapping Rain Water"},{"location":"Leetcode/42.-trapping-rain-water/#analysis","text":"To trap water, there should be a U shape, which means we need to have three points: left (high), mid (low) and right (high). To find satisfied points, we need to maintain a monontonic stack, which only accept points that is less than current one, so that when new points coming in, we can find the satified three points. Taking this example, we can see that for d, it will start trap water for b, c, d first: area = (min(b, d) - c) * (distance between b and d). We can do this calculation for a, b, d as well: area = (min(a, d) - b) * (distance between a and d). By obervation, we can see that we are just calculating the area in the rectangular: lying down with height as the height difference and width is the distance between two bars. Time: O(n) O(n) we push each element exactly once, and we pop each element exactly once. Space: O(n) O(n) stack can contain all the elements.","title":"Analysis"},{"location":"Leetcode/42.-trapping-rain-water/#code","text":"class Solution { public : int trap(vector < int >& height) { int n = height.size(), res = 0 ; stack < int > st; for ( int i = 0 ; i < n; ++ i) { if (st.empty()) st.push(i); else { while ( ! st.empty() && height[st.top()] < height[i]) { int t = st.top(); st.pop(); if (st.empty()) break ; res += (i - st.top() - 1 ) * (min(height[i], height[st.top()]) - height[t]); } st.push(i); } } return res; } };","title":"Code"},{"location":"Leetcode/437.-path-sum-iii/","text":"Path Sum III \u00b6 You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. \u6837\u4f8b \u00b6 Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 5 -> 3 5 -> 2 -> 1 -3 -> 11 \u7b97\u6cd51 \u00b6 O(2^n) O(2^n) \u00b6 \u5982\u679c\u53ef\u4ee5\u4ece\u4efb\u610f\u70b9\u5f00\u59cb\uff0c\u90a3\u4e48\u8bf4\u660e\u6bcf\u4e2a\u4f4d\u7f6e\u7684node\u90fd\u6709\u53ef\u80fd\u662fstart\uff0c\u90a3\u4e48\u53ea\u8981\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u8fc7\u4e00\u904d\u5c31\u53ef\u4ee5\u4e86\u3002 \u5728\u9012\u5f52\u7684\u65f6\u5019\u7528\u4e00\u4e2a\u53d8\u91cf as_start \u4ee3\u8868\u662f\u5426\u4ece\u5f53\u524d\u8282\u70b9\u5f00\u59cb\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1abrute force\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c1d\u8bd5\u4e00\u904d\uff0c\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e24\u4e2aoperation\uff0c\u5982\u679c\u6709 n\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u4e00\u5171\u67092^n\u79cd\u9009\u6cd5\u3002 C++ \u00b6 class Solution { public : int res; int pathSum (TreeNode * root, int sum) { traverse(root, sum, 0 , true ); return res; } // there are two choice: 1 start from current node 2. keep going from current node void traverse (TreeNode * root, int sum, int curr_sum, bool as_start) { if ( ! root) return ; curr_sum += root -> val; if (curr_sum == sum) res ++ ; traverse(root -> left, sum, curr_sum, false ); traverse(root -> right, sum, curr_sum, false ); if (as_start) { traverse(root -> left, sum, 0 , true ); // start from next node, so sum is 0 traverse(root -> right, sum, 0 , true ); } } }; \u7b97\u6cd52 \u00b6 O(n) O(n) space O(n) O(n) \u00b6 \u7b2c\u4e00\u79cd\u590d\u6742\u5ea6\u9ad8\u7684\u539f\u56e0\u662f\u6bcf\u4e2a\u8282\u70b9\u90fd\u8981\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u4f5c\u4e3a\u5934\u8282\u70b9\uff0c\u8fd9\u6837\u6bcf\u4e2a\u8282\u70b9\u76f8\u5f53\u4e8e\u90fd\u8981\u518d\u8dd1n\u6b21\u3002 \u4f46\u662f\u5176\u5b9e\u6ca1\u6709\u5fc5\u8981\u6bcf\u6b21\u90fd\u67e5\uff0c\u8fd9\u9053\u9898\u53ef\u4ee5\u60f3\u50cf\u6210two sum\u3002 \u6211\u4eec\u6bcf\u6b21\u5b58\u5f53\u524d\u5230root\u7684sum\uff0c\u8fd9\u6837\u6bcf\u6b21\u5230\u67d0\u4e2a\u8282\u70b9\u6211\u4eec\u5c31\u53ea\u8981\u770b\u8d85\u8fc7target\u7684\u90e8\u5206\u662f\u4e0d\u662f\u5df2\u7ecf\u5728\u4e4b\u524d\u5b58\u5728\u8fc7\u4e86\uff08\u56e0\u4e3a\u662froot\u5230\u5f53\u524d\u8282\u70b9\u7684sum\uff0c\u6240\u4ee5\u5fc5\u5b9a\u662f\u8fde\u7eed\u7684\uff09\u3002 \u8fd9\u4e2amap\u6211\u7528m\u6765\u8868\u793a\uff0ckey\u662fsum\u7684\u503c\uff0cvalue\u662f\u4e2a\u6570\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\uff08\u5047\u5982\u6709\u8d1f\u6570\u5b58\u5728\uff09\u3002 two sum\u90a3\u9053\u9898\u5176\u5b9e\u4e5f\u662f\u7c7b\u4f3c\u7684\u601d\u60f3\uff0c\u53ea\u4e0d\u8fc7\u662f\u6709\u4e24\u4e2a\uff0c\u6240\u4ee5\u4e0d\u7528map\u6765\u5b58\u4e2a\u6570\uff0c\u76f4\u63a5\u7528set\u6765\u770b\u5b58\u4e0d\u5b58\u5728\u5c31\u53ef\u4ee5\u4e86\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1a\u6bcf\u4e2a\u8282\u70b9\u53ea\u8981\u8d70\u4e00\u6b21\uff0c\u4f46\u662f\u8981\u727a\u7272space\u6765\u5b58\u4e4b\u524d\u7684sum\uff0c\u6240\u4ee5space\u662fn\uff0ctime\u662fn\u3002 C++ \u00b6 class Solution { public : int res; unordered_map < int , int > m; // sum: number of ways to form this sum int pathSum (TreeNode * root, int sum) { if ( ! root) return 0 ; m[ 0 ] = 1 ; // the node before root: value is 0 and it has 1 way to get that sum traverse(root, sum, root -> val); return res; } void traverse (TreeNode * root, int sum, int curr_sum) { if ( ! root) return ; // check the complements if (m.count(curr_sum - sum)) res += m[curr_sum - sum]; m[curr_sum] ++ ; if (root -> left) traverse(root -> left, sum, curr_sum + root -> left -> val); if (root -> right) traverse(root -> right, sum, curr_sum + root -> right -> val); m[curr_sum] -- ; // don't forget to set it back } };","title":"Path Sum III"},{"location":"Leetcode/437.-path-sum-iii/#path-sum-iii","text":"You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.","title":"Path Sum III"},{"location":"Leetcode/437.-path-sum-iii/#_1","text":"Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 5 -> 3 5 -> 2 -> 1 -3 -> 11","title":"\u6837\u4f8b"},{"location":"Leetcode/437.-path-sum-iii/#1","text":"","title":"\u7b97\u6cd51"},{"location":"Leetcode/437.-path-sum-iii/#o2no2n","text":"\u5982\u679c\u53ef\u4ee5\u4ece\u4efb\u610f\u70b9\u5f00\u59cb\uff0c\u90a3\u4e48\u8bf4\u660e\u6bcf\u4e2a\u4f4d\u7f6e\u7684node\u90fd\u6709\u53ef\u80fd\u662fstart\uff0c\u90a3\u4e48\u53ea\u8981\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u8fc7\u4e00\u904d\u5c31\u53ef\u4ee5\u4e86\u3002 \u5728\u9012\u5f52\u7684\u65f6\u5019\u7528\u4e00\u4e2a\u53d8\u91cf as_start \u4ee3\u8868\u662f\u5426\u4ece\u5f53\u524d\u8282\u70b9\u5f00\u59cb\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1abrute force\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c1d\u8bd5\u4e00\u904d\uff0c\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e24\u4e2aoperation\uff0c\u5982\u679c\u6709 n\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u4e00\u5171\u67092^n\u79cd\u9009\u6cd5\u3002","title":"O(2^n)O(2^n)"},{"location":"Leetcode/437.-path-sum-iii/#c","text":"class Solution { public : int res; int pathSum (TreeNode * root, int sum) { traverse(root, sum, 0 , true ); return res; } // there are two choice: 1 start from current node 2. keep going from current node void traverse (TreeNode * root, int sum, int curr_sum, bool as_start) { if ( ! root) return ; curr_sum += root -> val; if (curr_sum == sum) res ++ ; traverse(root -> left, sum, curr_sum, false ); traverse(root -> right, sum, curr_sum, false ); if (as_start) { traverse(root -> left, sum, 0 , true ); // start from next node, so sum is 0 traverse(root -> right, sum, 0 , true ); } } };","title":"C++"},{"location":"Leetcode/437.-path-sum-iii/#2","text":"","title":"\u7b97\u6cd52"},{"location":"Leetcode/437.-path-sum-iii/#onon-space-onon","text":"\u7b2c\u4e00\u79cd\u590d\u6742\u5ea6\u9ad8\u7684\u539f\u56e0\u662f\u6bcf\u4e2a\u8282\u70b9\u90fd\u8981\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u4f5c\u4e3a\u5934\u8282\u70b9\uff0c\u8fd9\u6837\u6bcf\u4e2a\u8282\u70b9\u76f8\u5f53\u4e8e\u90fd\u8981\u518d\u8dd1n\u6b21\u3002 \u4f46\u662f\u5176\u5b9e\u6ca1\u6709\u5fc5\u8981\u6bcf\u6b21\u90fd\u67e5\uff0c\u8fd9\u9053\u9898\u53ef\u4ee5\u60f3\u50cf\u6210two sum\u3002 \u6211\u4eec\u6bcf\u6b21\u5b58\u5f53\u524d\u5230root\u7684sum\uff0c\u8fd9\u6837\u6bcf\u6b21\u5230\u67d0\u4e2a\u8282\u70b9\u6211\u4eec\u5c31\u53ea\u8981\u770b\u8d85\u8fc7target\u7684\u90e8\u5206\u662f\u4e0d\u662f\u5df2\u7ecf\u5728\u4e4b\u524d\u5b58\u5728\u8fc7\u4e86\uff08\u56e0\u4e3a\u662froot\u5230\u5f53\u524d\u8282\u70b9\u7684sum\uff0c\u6240\u4ee5\u5fc5\u5b9a\u662f\u8fde\u7eed\u7684\uff09\u3002 \u8fd9\u4e2amap\u6211\u7528m\u6765\u8868\u793a\uff0ckey\u662fsum\u7684\u503c\uff0cvalue\u662f\u4e2a\u6570\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\uff08\u5047\u5982\u6709\u8d1f\u6570\u5b58\u5728\uff09\u3002 two sum\u90a3\u9053\u9898\u5176\u5b9e\u4e5f\u662f\u7c7b\u4f3c\u7684\u601d\u60f3\uff0c\u53ea\u4e0d\u8fc7\u662f\u6709\u4e24\u4e2a\uff0c\u6240\u4ee5\u4e0d\u7528map\u6765\u5b58\u4e2a\u6570\uff0c\u76f4\u63a5\u7528set\u6765\u770b\u5b58\u4e0d\u5b58\u5728\u5c31\u53ef\u4ee5\u4e86\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1a\u6bcf\u4e2a\u8282\u70b9\u53ea\u8981\u8d70\u4e00\u6b21\uff0c\u4f46\u662f\u8981\u727a\u7272space\u6765\u5b58\u4e4b\u524d\u7684sum\uff0c\u6240\u4ee5space\u662fn\uff0ctime\u662fn\u3002","title":"O(n)O(n) space O(n)O(n)"},{"location":"Leetcode/437.-path-sum-iii/#c_1","text":"class Solution { public : int res; unordered_map < int , int > m; // sum: number of ways to form this sum int pathSum (TreeNode * root, int sum) { if ( ! root) return 0 ; m[ 0 ] = 1 ; // the node before root: value is 0 and it has 1 way to get that sum traverse(root, sum, root -> val); return res; } void traverse (TreeNode * root, int sum, int curr_sum) { if ( ! root) return ; // check the complements if (m.count(curr_sum - sum)) res += m[curr_sum - sum]; m[curr_sum] ++ ; if (root -> left) traverse(root -> left, sum, curr_sum + root -> left -> val); if (root -> right) traverse(root -> right, sum, curr_sum + root -> right -> val); m[curr_sum] -- ; // don't forget to set it back } };","title":"C++"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/","text":"Sliding Window Pattern \u00b6 https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem public class Solution { public List < Integer > slidingWindowTemplateByHarryChaoyangHe(String s, String t) { //init a collection or int value to save the result according the question. List < Integer > result = new LinkedList <> (); if (t.length() > s.length()) return result; //create a hashmap to save the Characters of the target substring. //(K, V) = (Character, Frequence of the Characters) Map < Character, Integer > map = new HashMap <> (); for ( char c : t.toCharArray()){ map.put(c, map.getOrDefault(c, 0 ) + 1 ); } //maintain a counter to check whether match the target string. int counter = map.size(); //must be the map size, NOT the string size because the char may be duplicate. //Two Pointers: begin - left pointer of the window; end - right pointer of the window int begin = 0 , end = 0 ; //the length of the substring which match the target string. int len = Integer.MAX_VALUE; //loop at the begining of the source string while (end < s.length()){ char c = s.charAt(end); //get a character if ( map.containsKey(c) ){ map.put(c, map.get(c) -1 ); // plus or minus one if (map.get(c) == 0 ) counter -- ; //modify the counter according the requirement(different condition). } end ++ ; //increase begin pointer to make it invalid/valid again while (counter == 0 /* counter condition. different question may have different condition */ ){ char tempc = s.charAt(begin); //***be careful here: choose the char at begin pointer, NOT the end pointer if (map.containsKey(tempc)){ map.put(tempc, map.get(tempc) + 1 ); //plus or minus one if (map.get(tempc) > 0 ) counter ++ ; //modify the counter according the requirement(different condition). } /* save / update(min/max) the result if find a target*/ // result collections or result int value begin ++ ; } } return result; } } 438. Find All Anagrams in a String \u00b6 Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". class Solution { public : vector < int > findAnagrams(string s, string p) { if (s.empty()) return {}; vector < int > res, m( 256 , 0 ); int left = 0 , right = 0 , cnt = p.size(), n = s.size(); for ( char c : p) ++ m[c]; while (right < n) { if (m[s[right ++ ]] -- >= 1 ) -- cnt; if (cnt == 0 ) res.push_back(left); if (right - left == p.size() && m[s[left ++ ]] ++ >= 0 ) ++ cnt; } } }; 76. Minimum Window Substring \u00b6 Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. class Solution { public : string minWindow(string s, string t) { unordered_map < char , int > m; for ( char c : t) { m[c] ++ ; } int sz = m.size(); string res; for ( int i = 0 , j = 0 , cnt = 0 ; i < s.size(); ++ i) { if (m[s[i]] == 1 ) cnt ++ ; m[s[i]] -- ; while (m[s[j]] < 0 ) { m[s[j ++ ]] ++ ; } if (cnt == sz) { if (res.empty() || res.size() > i - j + 1 ) res = s.substr(j, i - j + 1 ); } } return res; } }; 3. Longest Substring Without Repeating Characters \u00b6 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. class Solution { public : int lengthOfLongestSubstring(string s) { int start = 0 , end = 0 ; vector < int > v( 128 , 0 ); int res = 0 ; for ( int i = 0 , j = 0 ; i < s.size(); ++ i) { v[s[i]] ++ ; while (v[s[i]] > 1 ) { v[s[j ++ ]] -- ; } res = max(res, i - j + 1 ); } return res; } }; 30. Substring with Concatenation of All Words \u00b6 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public : vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total -1 ) * len); } } return res; } }; 30. Substring with Concatenation of All Words \u00b6 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public : vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total -1 ) * len); } } return res; } }; 159. Longest Substring with At Most Two Distinct Characters \u00b6 Given a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: tis \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: tis \"aabbb\" which its length is 5. Analysis \u00b6 Use left only Use map<char, int> to record the frequency of character in the range of left - i (inclusive). Once the keys is greater than 2, try moves left by 1 unit and update the map if the frequency is 0. Time: O(n), Space: O(1) because size if always 2 entry of key-value pair. class Solution { public : int lengthOfLongestSubstringTwoDistinct(string s) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { m[s[i]] ++ ; while (m.size() > 2 ) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } }; Use left and right Space is optimized, but a little unintuitive. Use two pointers to represent the window. If s[i] == s[i-1], there is no update to the count of distinct elements. If right is not equal to the current one, that means there is a update (+1) to the total count, so we stop and update our res with the current i - left (window is now left - i). Because it only allows two characters, we should skip the ith character and start from right + 1 as left. #include <bits/stdc++.h> using namespace std; int main () { cin >> s; int left = 0 , right = -1 , res = 0 , sz = s.size(); for ( int i = 1 ; i < sz; ++ i) { if (s[i] == s[i - 1 ]) continue ; if (right >= 0 && s[right] != s[i]) { res = max(res, i - left); left = right + 1 ; } right = i - 1 ; } cout << max(res, sz - left); return 0 ; } Variation: with K different words \u00b6 if the character is in range of 'a' to 'z', then maintain a int array with size of 26. class Solution { public : string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt < k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt == k && len < r - l) { // case 1: cnt still in the range so, r doesn't overcount len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // case 2: cnt is greater than k by 1, r overcount by 1 len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } }; class Solution { public : int lengthOfLongestSubstringKDistinct(string s, int k) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { ++ m[s[i]]; while (m.size() > k) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } };","title":"Sliding Window Pattern"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#sliding-window-pattern","text":"https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem public class Solution { public List < Integer > slidingWindowTemplateByHarryChaoyangHe(String s, String t) { //init a collection or int value to save the result according the question. List < Integer > result = new LinkedList <> (); if (t.length() > s.length()) return result; //create a hashmap to save the Characters of the target substring. //(K, V) = (Character, Frequence of the Characters) Map < Character, Integer > map = new HashMap <> (); for ( char c : t.toCharArray()){ map.put(c, map.getOrDefault(c, 0 ) + 1 ); } //maintain a counter to check whether match the target string. int counter = map.size(); //must be the map size, NOT the string size because the char may be duplicate. //Two Pointers: begin - left pointer of the window; end - right pointer of the window int begin = 0 , end = 0 ; //the length of the substring which match the target string. int len = Integer.MAX_VALUE; //loop at the begining of the source string while (end < s.length()){ char c = s.charAt(end); //get a character if ( map.containsKey(c) ){ map.put(c, map.get(c) -1 ); // plus or minus one if (map.get(c) == 0 ) counter -- ; //modify the counter according the requirement(different condition). } end ++ ; //increase begin pointer to make it invalid/valid again while (counter == 0 /* counter condition. different question may have different condition */ ){ char tempc = s.charAt(begin); //***be careful here: choose the char at begin pointer, NOT the end pointer if (map.containsKey(tempc)){ map.put(tempc, map.get(tempc) + 1 ); //plus or minus one if (map.get(tempc) > 0 ) counter ++ ; //modify the counter according the requirement(different condition). } /* save / update(min/max) the result if find a target*/ // result collections or result int value begin ++ ; } } return result; } }","title":"Sliding Window Pattern"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#438-find-all-anagrams-in-a-string","text":"Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". class Solution { public : vector < int > findAnagrams(string s, string p) { if (s.empty()) return {}; vector < int > res, m( 256 , 0 ); int left = 0 , right = 0 , cnt = p.size(), n = s.size(); for ( char c : p) ++ m[c]; while (right < n) { if (m[s[right ++ ]] -- >= 1 ) -- cnt; if (cnt == 0 ) res.push_back(left); if (right - left == p.size() && m[s[left ++ ]] ++ >= 0 ) ++ cnt; } } };","title":"438. Find All Anagrams in a String"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#76-minimum-window-substring","text":"Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. class Solution { public : string minWindow(string s, string t) { unordered_map < char , int > m; for ( char c : t) { m[c] ++ ; } int sz = m.size(); string res; for ( int i = 0 , j = 0 , cnt = 0 ; i < s.size(); ++ i) { if (m[s[i]] == 1 ) cnt ++ ; m[s[i]] -- ; while (m[s[j]] < 0 ) { m[s[j ++ ]] ++ ; } if (cnt == sz) { if (res.empty() || res.size() > i - j + 1 ) res = s.substr(j, i - j + 1 ); } } return res; } };","title":"76. Minimum Window Substring"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#3-longest-substring-without-repeating-characters","text":"Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. class Solution { public : int lengthOfLongestSubstring(string s) { int start = 0 , end = 0 ; vector < int > v( 128 , 0 ); int res = 0 ; for ( int i = 0 , j = 0 ; i < s.size(); ++ i) { v[s[i]] ++ ; while (v[s[i]] > 1 ) { v[s[j ++ ]] -- ; } res = max(res, i - j + 1 ); } return res; } };","title":"3. Longest Substring Without Repeating Characters"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#30-substring-with-concatenation-of-all-words","text":"You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public : vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total -1 ) * len); } } return res; } };","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#30-substring-with-concatenation-of-all-words_1","text":"You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public : vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total -1 ) * len); } } return res; } };","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#159-longest-substring-with-at-most-two-distinct-characters","text":"Given a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: tis \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: tis \"aabbb\" which its length is 5.","title":"159. Longest Substring with At Most Two Distinct Characters"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#analysis","text":"Use left only Use map<char, int> to record the frequency of character in the range of left - i (inclusive). Once the keys is greater than 2, try moves left by 1 unit and update the map if the frequency is 0. Time: O(n), Space: O(1) because size if always 2 entry of key-value pair. class Solution { public : int lengthOfLongestSubstringTwoDistinct(string s) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { m[s[i]] ++ ; while (m.size() > 2 ) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } }; Use left and right Space is optimized, but a little unintuitive. Use two pointers to represent the window. If s[i] == s[i-1], there is no update to the count of distinct elements. If right is not equal to the current one, that means there is a update (+1) to the total count, so we stop and update our res with the current i - left (window is now left - i). Because it only allows two characters, we should skip the ith character and start from right + 1 as left. #include <bits/stdc++.h> using namespace std; int main () { cin >> s; int left = 0 , right = -1 , res = 0 , sz = s.size(); for ( int i = 1 ; i < sz; ++ i) { if (s[i] == s[i - 1 ]) continue ; if (right >= 0 && s[right] != s[i]) { res = max(res, i - left); left = right + 1 ; } right = i - 1 ; } cout << max(res, sz - left); return 0 ; }","title":"Analysis"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#variation-with-k-different-words","text":"if the character is in range of 'a' to 'z', then maintain a int array with size of 26. class Solution { public : string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt < k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt == k && len < r - l) { // case 1: cnt still in the range so, r doesn't overcount len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // case 2: cnt is greater than k by 1, r overcount by 1 len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } }; class Solution { public : int lengthOfLongestSubstringKDistinct(string s, int k) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { ++ m[s[i]]; while (m.size() > k) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } };","title":"Variation: with K different words"},{"location":"Leetcode/46.-Permutations/","text":"Permutations \u00b6 Given an array nums of distinct integers, return all the possible permutations . You can return the answer in any order . Example 1: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2: Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3: Input: nums = [1] Output: [[1]] Constraints: 1 <= nums.length <= 6 -10 <= nums[i] <= 10 All the integers of nums are unique . Analysis \u00b6 Traditional DFS \u00b6 There are two recursive ways to solve this problem. One way is the traditional DFS with the help of using an additional memory to record any existed configuration. For each iteration, we use an index to locate which index we are going to place our number, and the base case is when this index reaches the end. When placing our number to this index, we should try out all the numbers from nums[0] to nums[end] , and compare them with the current visited memory to decide if we can put that number to the index. This process for each iteration will take up O(n) O(n) complexity, and there will be n! results at the bottom level, so the total time complexity is $O(n \\times n!) $","title":"Permutations"},{"location":"Leetcode/46.-Permutations/#permutations","text":"Given an array nums of distinct integers, return all the possible permutations . You can return the answer in any order . Example 1: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2: Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3: Input: nums = [1] Output: [[1]] Constraints: 1 <= nums.length <= 6 -10 <= nums[i] <= 10 All the integers of nums are unique .","title":"Permutations"},{"location":"Leetcode/46.-Permutations/#analysis","text":"","title":"Analysis"},{"location":"Leetcode/46.-Permutations/#traditional-dfs","text":"There are two recursive ways to solve this problem. One way is the traditional DFS with the help of using an additional memory to record any existed configuration. For each iteration, we use an index to locate which index we are going to place our number, and the base case is when this index reaches the end. When placing our number to this index, we should try out all the numbers from nums[0] to nums[end] , and compare them with the current visited memory to decide if we can put that number to the index. This process for each iteration will take up O(n) O(n) complexity, and there will be n! results at the bottom level, so the total time complexity is $O(n \\times n!) $","title":"Traditional DFS"},{"location":"Leetcode/496.-next-greater-element-i/","text":"Next Greater Element I \u00b6 You are given two integer arrays nums1 and nums2 both of unique elements, where nums1 is a subset of nums2 . Find all the next greater numbers for nums1 's elements in the corresponding places of nums2 . The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2 . If it does not exist, return -1 for this number. Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Constraints: 1 <= nums1.length <= nums2.length <= 1000 0 <= nums1[i], nums2[i] <= 104 All integers in nums1 and nums2 are unique . All the integers of nums1 also appear in nums2 . Follow up: Could you find an O(nums1.length + nums2.length) solution? Analysis \u00b6 The naive solution is doing two linear scans: for each element in nums1 , we check the current element's index and find the first index from nums2 and return the element that it is pointing to. However, we want to improve this algorithm into O(n) O(n) . For almost all the \"find next greater/less\" type of problem, we can thinking about using a monotonic stack to solve it with O(n) O(n) time complexity. We basically want to build up a mapping between nums1[i] and nums2[j] where nums2[j] is the next immediate greater element to current nums1[i] . We can use a map to store this info. We also need a stack to mimic the monotonic stack operation. For monotonic stack part, we can follow the below template: for i, e in enumerate (arr): while stack is not empty and stack top < e: # for \"next greater\" stack . pop( 0 ) # we remove the top since current element is the new \"next greater\" \"\"\"ok, now we have the next greater element to arr[i-1], we could do something here do your calculation\"\"\" stack . push(e) # use for next iteration As you can see, the worst case for the while loop to run multiple times is when we are having a decreasing order array followed by the last element being the greatest. However, don't forget for all the previous iterations, since the array is decreasing, we never get a chance to execute this while loop once (in all the previous iterations). So if you add it up, the precise complexity is O(2 \\times n) O(2 \\times n) , which is still O(n) O(n) . Now we have a stack that records all the \"next greater\" element, and we want to know which element it was greater to. To build up the mapping, we simply add the map in between. for i, e in enumerate (arr): while stack is not empty and stack top < e: # for \"next greater\" stack . pop( 0 ) # we remove the top since current element is the new \"next greater\" \"\"\"ok, now we have the next greater element to arr[i-1], we could do something here do your calculation\"\"\" # TODO: add to your map here stack . push(e) # use for next iteration Don't forget we also might see element that doesn't have element greater than itself, and those elements are storing in our stack. Reason is being we only keep the previous \"unfounded yet\" element in our stack. Using that info, we can correctly update our map to \"-1\". Finally we just need to extract the map's info to a new array, which only takes O(n) O(n) . Note Don't forget all the elements in nums1 are also in nums2 , which means all keys are avalible. So we don't need to update our map. Time: O(n) O(n) Space: O(n) O(n) for decreasing order nums2 case and the output array. Code \u00b6 class Solution { public : vector < int > nextGreaterElement(vector < int > & nums1, vector < int > & nums2) { stack < int > idx; // store current greater's index map < int , int > mp; for ( int i = 0 ; i < nums2.size(); ++ i) { while ( ! idx.empty() && nums2[idx.top()] < nums2[i]) { mp[nums2[idx.top()]] = nums2[i]; idx.pop(); } idx.push(i); } while ( ! idx.empty()) { mp[nums2[idx.top()]] = -1 ; idx.pop(); } vector < int > res(nums1.size()); for ( int i = 0 ; i < nums1.size(); ++ i) { res[i] = mp[nums1[i]]; } return res; } };","title":"Next Greater Element I"},{"location":"Leetcode/496.-next-greater-element-i/#next-greater-element-i","text":"You are given two integer arrays nums1 and nums2 both of unique elements, where nums1 is a subset of nums2 . Find all the next greater numbers for nums1 's elements in the corresponding places of nums2 . The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2 . If it does not exist, return -1 for this number. Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Constraints: 1 <= nums1.length <= nums2.length <= 1000 0 <= nums1[i], nums2[i] <= 104 All integers in nums1 and nums2 are unique . All the integers of nums1 also appear in nums2 . Follow up: Could you find an O(nums1.length + nums2.length) solution?","title":"Next Greater Element I"},{"location":"Leetcode/496.-next-greater-element-i/#analysis","text":"The naive solution is doing two linear scans: for each element in nums1 , we check the current element's index and find the first index from nums2 and return the element that it is pointing to. However, we want to improve this algorithm into O(n) O(n) . For almost all the \"find next greater/less\" type of problem, we can thinking about using a monotonic stack to solve it with O(n) O(n) time complexity. We basically want to build up a mapping between nums1[i] and nums2[j] where nums2[j] is the next immediate greater element to current nums1[i] . We can use a map to store this info. We also need a stack to mimic the monotonic stack operation. For monotonic stack part, we can follow the below template: for i, e in enumerate (arr): while stack is not empty and stack top < e: # for \"next greater\" stack . pop( 0 ) # we remove the top since current element is the new \"next greater\" \"\"\"ok, now we have the next greater element to arr[i-1], we could do something here do your calculation\"\"\" stack . push(e) # use for next iteration As you can see, the worst case for the while loop to run multiple times is when we are having a decreasing order array followed by the last element being the greatest. However, don't forget for all the previous iterations, since the array is decreasing, we never get a chance to execute this while loop once (in all the previous iterations). So if you add it up, the precise complexity is O(2 \\times n) O(2 \\times n) , which is still O(n) O(n) . Now we have a stack that records all the \"next greater\" element, and we want to know which element it was greater to. To build up the mapping, we simply add the map in between. for i, e in enumerate (arr): while stack is not empty and stack top < e: # for \"next greater\" stack . pop( 0 ) # we remove the top since current element is the new \"next greater\" \"\"\"ok, now we have the next greater element to arr[i-1], we could do something here do your calculation\"\"\" # TODO: add to your map here stack . push(e) # use for next iteration Don't forget we also might see element that doesn't have element greater than itself, and those elements are storing in our stack. Reason is being we only keep the previous \"unfounded yet\" element in our stack. Using that info, we can correctly update our map to \"-1\". Finally we just need to extract the map's info to a new array, which only takes O(n) O(n) . Note Don't forget all the elements in nums1 are also in nums2 , which means all keys are avalible. So we don't need to update our map. Time: O(n) O(n) Space: O(n) O(n) for decreasing order nums2 case and the output array.","title":"Analysis"},{"location":"Leetcode/496.-next-greater-element-i/#code","text":"class Solution { public : vector < int > nextGreaterElement(vector < int > & nums1, vector < int > & nums2) { stack < int > idx; // store current greater's index map < int , int > mp; for ( int i = 0 ; i < nums2.size(); ++ i) { while ( ! idx.empty() && nums2[idx.top()] < nums2[i]) { mp[nums2[idx.top()]] = nums2[i]; idx.pop(); } idx.push(i); } while ( ! idx.empty()) { mp[nums2[idx.top()]] = -1 ; idx.pop(); } vector < int > res(nums1.size()); for ( int i = 0 ; i < nums1.size(); ++ i) { res[i] = mp[nums1[i]]; } return res; } };","title":"Code"},{"location":"Leetcode/520.-detect-capital/","text":"Detect Capital \u00b6 Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like \"USA\". All letters in this word are not capitals, like \"leetcode\". Only the first letter in this word is capital, like \"Google\". Otherwise, we define that this word doesn't use capitals in a right way. Example 1: Input: \"USA\" Output: True Example 2: Input: \"FlaG\" Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.Analysis There are two cases (it's actually three but we can merge the first two together) to consider: 1. If first character is upper case, then the rest has to be all upper case or all lower case. 2. If the first character is lower case, then the rest has to be all lower case. After the observation, we find we essentially just need three variables: allCap : excluding first character, the rest of the substring are all captials. allLower : excluding first character, the rest of the substring are all captials. firstCap : first character is capital. Note that !allCap is not allLower . Code \u00b6 class Solution { public : bool detectCapitalUse(string word) { if (word.empty()) return true ; bool allCap = true , firstCap = false , allLower = true ; for ( int i = 0 ; i < word.size(); ++ i) { if (i == 0 && isupper(word[i])) firstCap = true ; if (i != 0 && ! isupper(word[i])) allCap = false ; if (i != 0 && isupper(word[i])) allLower = false ; } return allLower || (firstCap && allCap); } };","title":"Detect Capital"},{"location":"Leetcode/520.-detect-capital/#detect-capital","text":"Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like \"USA\". All letters in this word are not capitals, like \"leetcode\". Only the first letter in this word is capital, like \"Google\". Otherwise, we define that this word doesn't use capitals in a right way. Example 1: Input: \"USA\" Output: True Example 2: Input: \"FlaG\" Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.Analysis There are two cases (it's actually three but we can merge the first two together) to consider: 1. If first character is upper case, then the rest has to be all upper case or all lower case. 2. If the first character is lower case, then the rest has to be all lower case. After the observation, we find we essentially just need three variables: allCap : excluding first character, the rest of the substring are all captials. allLower : excluding first character, the rest of the substring are all captials. firstCap : first character is capital. Note that !allCap is not allLower .","title":"Detect Capital"},{"location":"Leetcode/520.-detect-capital/#code","text":"class Solution { public : bool detectCapitalUse(string word) { if (word.empty()) return true ; bool allCap = true , firstCap = false , allLower = true ; for ( int i = 0 ; i < word.size(); ++ i) { if (i == 0 && isupper(word[i])) firstCap = true ; if (i != 0 && ! isupper(word[i])) allCap = false ; if (i != 0 && isupper(word[i])) allLower = false ; } return allLower || (firstCap && allCap); } };","title":"Code"},{"location":"Leetcode/532.-k-diff-pairs-in-an-array/","text":"K diff Pairs in an Array \u00b6 Given an array of integers nums and an integer k , return the number of unique k-diff pairs in the array . A k-diff pair is an integer pair (nums[i], nums[j]) , where the following are true: 0 <= i, j < nums.length i != j |nums[i] - nums[j]| == k Notice that |val| denotes the absolute value of val . Example 1: Input: nums = [3,1,4,1,5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5). Although we have two 1s in the input, we should only return the number of unique pairs. Example 2: Input: nums = [1,2,3,4,5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3: Input: nums = [1,3,1,5,4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1). Example 4: Input: nums = [1,2,4,4,3,3,0,9,2,3], k = 3 Output: 2 Example 5: Input: nums = [-1,-2,-3], k = 1 Output: 2 Constraints: 1 <= nums.length <= 104 -10^7 <= nums[i] <= 10^7 0 <= k <= 10^7 Analysis \u00b6 Edge cases: 1. k == 0, in this case, we need to return the pair that they two elements are equal to each other. 2. k < 0, should return 0. 3. handling duplicates pairs: (i, j) = (j, i) Use a unordered_map<int, int> to keep track of the cnt of each appeared elements. if k == 0, we just need to filter out all the elements that have the count greater than 1. else check the complement (curr element + k) if exist in the map. don't need to check element - k. Time: O(n) O(n) Space: O(n) O(n) for the unordered_map Code \u00b6 class Solution { public : int findPairs(vector < int >& nums, int k) { int res = 0 ; unordered_map < int , int > m; for ( int num : nums) ++ m[num]; for ( auto a : m) { if (k == 0 && a.second > 1 ) ++ res; // multiple duplicate if (k > 0 && m.count(a.first + k)) ++ res; } return res; } };","title":"K diff Pairs in an Array"},{"location":"Leetcode/532.-k-diff-pairs-in-an-array/#k-diff-pairs-in-an-array","text":"Given an array of integers nums and an integer k , return the number of unique k-diff pairs in the array . A k-diff pair is an integer pair (nums[i], nums[j]) , where the following are true: 0 <= i, j < nums.length i != j |nums[i] - nums[j]| == k Notice that |val| denotes the absolute value of val . Example 1: Input: nums = [3,1,4,1,5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5). Although we have two 1s in the input, we should only return the number of unique pairs. Example 2: Input: nums = [1,2,3,4,5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3: Input: nums = [1,3,1,5,4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1). Example 4: Input: nums = [1,2,4,4,3,3,0,9,2,3], k = 3 Output: 2 Example 5: Input: nums = [-1,-2,-3], k = 1 Output: 2 Constraints: 1 <= nums.length <= 104 -10^7 <= nums[i] <= 10^7 0 <= k <= 10^7","title":"K diff Pairs in an Array"},{"location":"Leetcode/532.-k-diff-pairs-in-an-array/#analysis","text":"Edge cases: 1. k == 0, in this case, we need to return the pair that they two elements are equal to each other. 2. k < 0, should return 0. 3. handling duplicates pairs: (i, j) = (j, i) Use a unordered_map<int, int> to keep track of the cnt of each appeared elements. if k == 0, we just need to filter out all the elements that have the count greater than 1. else check the complement (curr element + k) if exist in the map. don't need to check element - k. Time: O(n) O(n) Space: O(n) O(n) for the unordered_map","title":"Analysis"},{"location":"Leetcode/532.-k-diff-pairs-in-an-array/#code","text":"class Solution { public : int findPairs(vector < int >& nums, int k) { int res = 0 ; unordered_map < int , int > m; for ( int num : nums) ++ m[num]; for ( auto a : m) { if (k == 0 && a.second > 1 ) ++ res; // multiple duplicate if (k > 0 && m.count(a.first + k)) ++ res; } return res; } };","title":"Code"},{"location":"Leetcode/54.-spiral-matrix/","text":"Spiral Matrix \u00b6 Given an m x n matrix , return all elements of the matrix in spiral order . Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 10 -100 <= matrix[i][j] <= 100 Analysis \u00b6 Split the matrix into four parts: 1. right: column can move in the range of [l, r], after finish, ++u 2. down: row can move in the range of [u, d], after finish, --r 3. left: column can move in the range of [l, r], after finish, ++d 4. up: row can move in the range of [u, d], after finish, ++l Code \u00b6 class Solution { public : vector < int > spiral(vector < vector < int >> matrix) { // write your solution here if (matrix.empty() || matrix[ 0 ].empty()) return {}; int m = matrix.size(), n = matrix[ 0 ].size(); vector < int > res(m * n); int u = 0 , d = m - 1 , l = 0 , r = n - 1 , k = 0 ; while ( 1 ) { // right: l <= col <= r for ( int col = l; col <= r; ++ col) res[k ++ ] = matrix[u][col]; if ( ++ u > d) break ; // down: u <= row <= d for ( int row = u; row <= d; ++ row) res[k ++ ] = matrix[row][r]; if ( -- r < l) break ; // left: l <= col <= r for ( int col = r; col >= l; -- col) res[k ++ ] = matrix[d][col]; if ( -- d < u) break ; // up: u <= row <= d for ( int row = d; row >= u; -- row) res[k ++ ] = matrix[row][l]; if ( ++ l > r) break ; } return res; } };","title":"Spiral Matrix"},{"location":"Leetcode/54.-spiral-matrix/#spiral-matrix","text":"Given an m x n matrix , return all elements of the matrix in spiral order . Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 10 -100 <= matrix[i][j] <= 100","title":"Spiral Matrix"},{"location":"Leetcode/54.-spiral-matrix/#analysis","text":"Split the matrix into four parts: 1. right: column can move in the range of [l, r], after finish, ++u 2. down: row can move in the range of [u, d], after finish, --r 3. left: column can move in the range of [l, r], after finish, ++d 4. up: row can move in the range of [u, d], after finish, ++l","title":"Analysis"},{"location":"Leetcode/54.-spiral-matrix/#code","text":"class Solution { public : vector < int > spiral(vector < vector < int >> matrix) { // write your solution here if (matrix.empty() || matrix[ 0 ].empty()) return {}; int m = matrix.size(), n = matrix[ 0 ].size(); vector < int > res(m * n); int u = 0 , d = m - 1 , l = 0 , r = n - 1 , k = 0 ; while ( 1 ) { // right: l <= col <= r for ( int col = l; col <= r; ++ col) res[k ++ ] = matrix[u][col]; if ( ++ u > d) break ; // down: u <= row <= d for ( int row = u; row <= d; ++ row) res[k ++ ] = matrix[row][r]; if ( -- r < l) break ; // left: l <= col <= r for ( int col = r; col >= l; -- col) res[k ++ ] = matrix[d][col]; if ( -- d < u) break ; // up: u <= row <= d for ( int row = d; row >= u; -- row) res[k ++ ] = matrix[row][l]; if ( ++ l > r) break ; } return res; } };","title":"Code"},{"location":"Leetcode/542.-01-Matrix/","text":"01 Matrix \u00b6 Given an m x n binary matrix mat , return the distance of the nearest 0 for each cell . The distance between two adjacent cells is 1 . Example 1: Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]] Example 2: Input: mat = [[0,0,0],[0,1,0],[1,1,1]] Output: [[0,0,0],[0,1,0],[1,2,1]] Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 104 1 <= m * n <= 104 mat[i][j] is either 0 or 1 . There is at least one 0 in mat . Analysis \u00b6 Using BFS to find the shortest path for each point \u00b6 Compare to single source BFS, we can regard each \"0\" as a source and run the search from each point. BFS will guarantee shortest path, so we can return the search results immediately after each search. Scan through all the \"0\" and insert their coordinates into the search queue.","title":"01 Matrix"},{"location":"Leetcode/542.-01-Matrix/#01-matrix","text":"Given an m x n binary matrix mat , return the distance of the nearest 0 for each cell . The distance between two adjacent cells is 1 . Example 1: Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]] Example 2: Input: mat = [[0,0,0],[0,1,0],[1,1,1]] Output: [[0,0,0],[0,1,0],[1,2,1]] Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 104 1 <= m * n <= 104 mat[i][j] is either 0 or 1 . There is at least one 0 in mat .","title":"01 Matrix"},{"location":"Leetcode/542.-01-Matrix/#analysis","text":"","title":"Analysis"},{"location":"Leetcode/542.-01-Matrix/#using-bfs-to-find-the-shortest-path-for-each-point","text":"Compare to single source BFS, we can regard each \"0\" as a source and run the search from each point. BFS will guarantee shortest path, so we can return the search results immediately after each search. Scan through all the \"0\" and insert their coordinates into the search queue.","title":"Using BFS to find the shortest path for each point"},{"location":"Leetcode/557.-Reverse-Words-in-a-String-III/","text":"Reverse Words in a String III \u00b6 Given a string s , reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: s = \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" Example 2: Input: s = \"God Ding\" Output: \"doG gniD\" Constraints: 1 <= s.length <= 5 * 104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s . All the words in s are separated by a single space. Analysis \u00b6 When seeing space or pointing to the end of the string, we can do a small trick by combining these two cases: adding an extra space at the end and remove it before return. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 With trick: class Solution { public : string reverseWords(string s) { s += ' ' ; for ( int i = 0 , j = 0 ; j < s.size(); ++ j) { if (s[j] == ' ' ) { reverse(s.begin() + i, s.begin() + j); i = j + 1 ; } } s.pop_back(); return s; } }; Without trick: class Solution { public : string reverseWords(string s) { for ( int i = 0 , j = 0 ; j < s.size(); ++ j) { if (s[j] == ' ' ) { reverse(s.begin() + i, s.begin() + j); i = j + 1 ; } if (j == s.size() - 1 ) reverse(s.begin() + i, s.end()); } return s; } };","title":"Reverse Words in a String III"},{"location":"Leetcode/557.-Reverse-Words-in-a-String-III/#reverse-words-in-a-string-iii","text":"Given a string s , reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: s = \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" Example 2: Input: s = \"God Ding\" Output: \"doG gniD\" Constraints: 1 <= s.length <= 5 * 104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s . All the words in s are separated by a single space.","title":"Reverse Words in a String III"},{"location":"Leetcode/557.-Reverse-Words-in-a-String-III/#analysis","text":"When seeing space or pointing to the end of the string, we can do a small trick by combining these two cases: adding an extra space at the end and remove it before return. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/557.-Reverse-Words-in-a-String-III/#code","text":"With trick: class Solution { public : string reverseWords(string s) { s += ' ' ; for ( int i = 0 , j = 0 ; j < s.size(); ++ j) { if (s[j] == ' ' ) { reverse(s.begin() + i, s.begin() + j); i = j + 1 ; } } s.pop_back(); return s; } }; Without trick: class Solution { public : string reverseWords(string s) { for ( int i = 0 , j = 0 ; j < s.size(); ++ j) { if (s[j] == ' ' ) { reverse(s.begin() + i, s.begin() + j); i = j + 1 ; } if (j == s.size() - 1 ) reverse(s.begin() + i, s.end()); } return s; } };","title":"Code"},{"location":"Leetcode/560.-Subarray-Sum-Equals-K/","text":"Subarray Sum Equals K \u00b6 Given an array of integers nums and an integer k , return the total number of continuous subarrays whose sum equals to k . Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2 Constraints: 1 <= nums.length <= 2 * 104 -1000 <= nums[i] <= 1000 -107 <= k <= 107 Analysis \u00b6 We can reduce to one forloop to solve this problem. At any point, if we know how many subarrays in front of the current processing point, that the area is equal to curr_sum - k , then we can solve this problem in one loop. Or meaning: curr_sum - x = k , where x is our target complement sum. So we create a map for that, and keep a record of all the previous sum and their freqency. Time: O(n) O(n) Space: O(n) O(n) there could have at most n difference sum Code \u00b6 class Solution { public : int subarraySum(vector < int >& nums, int k) { int n = ( int )nums.size(); // key: sum from 0 to i, value: # of this sum occurred unordered_map < int , int > m; int res = 0 ; int curr_sum = 0 ; m[ 0 ] = 1 ; for ( int i = 0 ; i < n; ++ i) { curr_sum += nums[i]; res += m[curr_sum - k]; m[curr_sum] ++ ; } return res; } };","title":"Subarray Sum Equals K"},{"location":"Leetcode/560.-Subarray-Sum-Equals-K/#subarray-sum-equals-k","text":"Given an array of integers nums and an integer k , return the total number of continuous subarrays whose sum equals to k . Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2 Constraints: 1 <= nums.length <= 2 * 104 -1000 <= nums[i] <= 1000 -107 <= k <= 107","title":"Subarray Sum Equals K"},{"location":"Leetcode/560.-Subarray-Sum-Equals-K/#analysis","text":"We can reduce to one forloop to solve this problem. At any point, if we know how many subarrays in front of the current processing point, that the area is equal to curr_sum - k , then we can solve this problem in one loop. Or meaning: curr_sum - x = k , where x is our target complement sum. So we create a map for that, and keep a record of all the previous sum and their freqency. Time: O(n) O(n) Space: O(n) O(n) there could have at most n difference sum","title":"Analysis"},{"location":"Leetcode/560.-Subarray-Sum-Equals-K/#code","text":"class Solution { public : int subarraySum(vector < int >& nums, int k) { int n = ( int )nums.size(); // key: sum from 0 to i, value: # of this sum occurred unordered_map < int , int > m; int res = 0 ; int curr_sum = 0 ; m[ 0 ] = 1 ; for ( int i = 0 ; i < n; ++ i) { curr_sum += nums[i]; res += m[curr_sum - k]; m[curr_sum] ++ ; } return res; } };","title":"Code"},{"location":"Leetcode/568.-maximum-vacation-days/","text":"Maximum Vacation Days \u00b6 LeetCode wants to give one of its best employees the option to travel among N cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow. Rules and restrictions: You can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday . The cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0 ; Otherwise, flights[i][j] = 1 . Also, flights[i][i] = 0 for all i. You totally have K weeks ( each week has 7 days ) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time. For each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j] , it represents the maximum days you could take vacation in the city i in the week j . You're given the flights matrix and days matrix, and you need to output the maximum vacation days you could take during K weeks. Example 1: Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]] Output: 12 Explanation: Ans = 6 + 3 + 3 = 12. One of the best strategies is: 1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. (Although you start at city 0, we could also fly to and start at other cities since it is Monday.) 2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days. 3rd week : stay at city 2, and play 3 days and work 4 days. Example 2: Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]] Output: 3 Explanation: Ans = 1 + 1 + 1 = 3. Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. For each week, you only have one day to play and six days to work. So the maximum number of vacation days is 3. Example 3: Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]] Output: 21 Explanation: Ans = 7 + 7 + 7 = 21 One of the best strategies is: 1st week : stay at city 0, and play 7 days. 2nd week : fly from city 0 to city 1 on Monday, and play 7 days. 3rd week : fly from city 1 to city 2 on Monday, and play 7 days. Note: N and K are positive integers, which are in the range of [1, 100]. In the matrix flights , all the values are integers in the range of [0, 1]. In the matrix days , all the values are integers in the range [0, 7]. You could stay at a city beyond the number of vacation days, but you should work on the extra days, which won't be counted as vacation days. If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week. We don't consider the impact of flight hours towards the calculation of vacation days. Analysis \u00b6 I've created an illustration for this problem: From the days matrix, we can only move from left to right (except for day 1, which we can move up and down) or left to down right by certain amount of unit. Now the problem becomes find the highest weight path from top left to down right (with restriction of flights matrix and direction). Let's discuss more about the moving direction. In the days matrix, row represents the city number, and column represents the week number. We can fly from any city to another one if there is a flight from the flights matrix. Or: if flights[i][j] == 1: then we can update from day[i][current week] to day[j][current week + 1] We have n cities to try, so we need to loop to check all of the cities. for j in 0 to n: if flights[i][j] == 1: then we can update from day[i][current week] to day[j][current week + 1] We need something to hold the current maximum, but we also know local maximum cannot represent the global optimal, so we use dynamic programming. We use dp[i][j] to represent on city i, week j, what is the maximum vacation to take. As we make progress to another week, we bascially just try out all the previous maximum with current choice, and see if we should make the current decision. for k in 0 to k - 1: try all weeks for i in 0 to n: try all starting cities for j in 0 to n: try all destination cities if flights[i][j] == 1: if there is flight between then we can update dp[i][k] from dp[i][k] to dp[i][k] + day[j][k + 1] Time: O(n^3) O(n^3) Space: O(n^2) O(n^2) for the dp matrix Code \u00b6 Since I don't have prime for leetcode, this code is copied and pasted from Grandyang's blog class Solution { public : int maxVacationDays(vector < vector < int >>& flights, vector < vector < int >>& days) { int n = flights.size(), k = days[ 0 ].size(), res = 0 ; vector < vector < int >> dp(n, vector < int > (k, 0 )); for ( int j = k - 1 ; j >= 0 ; -- j) { // week j for ( int i = 0 ; i < n; ++ i) { // city 1 dp[i][j] = days[i][j]; for ( int p = 0 ; p < n; ++ p) { // city 2 if ((i == p || flights[i][p]) // city 1 == city 2 or there is flight && j < k - 1 ) { // and it's not the last week dp[i][j] = max(dp[i][j], dp[p][j + 1 ] // since we progress down, we populated the week j + 1 before week j + days[i][j]); } if (j == 0 // we only update res when we reach starting city 0 && (i == 0 || flights[ 0 ][i])) // either current city is already city 0 or there is flight from current city to city 0 res = max(res, dp[i][ 0 ]); } } } return res; } };","title":"Maximum Vacation Days"},{"location":"Leetcode/568.-maximum-vacation-days/#maximum-vacation-days","text":"LeetCode wants to give one of its best employees the option to travel among N cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow. Rules and restrictions: You can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday . The cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0 ; Otherwise, flights[i][j] = 1 . Also, flights[i][i] = 0 for all i. You totally have K weeks ( each week has 7 days ) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time. For each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j] , it represents the maximum days you could take vacation in the city i in the week j . You're given the flights matrix and days matrix, and you need to output the maximum vacation days you could take during K weeks. Example 1: Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]] Output: 12 Explanation: Ans = 6 + 3 + 3 = 12. One of the best strategies is: 1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. (Although you start at city 0, we could also fly to and start at other cities since it is Monday.) 2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days. 3rd week : stay at city 2, and play 3 days and work 4 days. Example 2: Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]] Output: 3 Explanation: Ans = 1 + 1 + 1 = 3. Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. For each week, you only have one day to play and six days to work. So the maximum number of vacation days is 3. Example 3: Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]] Output: 21 Explanation: Ans = 7 + 7 + 7 = 21 One of the best strategies is: 1st week : stay at city 0, and play 7 days. 2nd week : fly from city 0 to city 1 on Monday, and play 7 days. 3rd week : fly from city 1 to city 2 on Monday, and play 7 days. Note: N and K are positive integers, which are in the range of [1, 100]. In the matrix flights , all the values are integers in the range of [0, 1]. In the matrix days , all the values are integers in the range [0, 7]. You could stay at a city beyond the number of vacation days, but you should work on the extra days, which won't be counted as vacation days. If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week. We don't consider the impact of flight hours towards the calculation of vacation days.","title":"Maximum Vacation Days"},{"location":"Leetcode/568.-maximum-vacation-days/#analysis","text":"I've created an illustration for this problem: From the days matrix, we can only move from left to right (except for day 1, which we can move up and down) or left to down right by certain amount of unit. Now the problem becomes find the highest weight path from top left to down right (with restriction of flights matrix and direction). Let's discuss more about the moving direction. In the days matrix, row represents the city number, and column represents the week number. We can fly from any city to another one if there is a flight from the flights matrix. Or: if flights[i][j] == 1: then we can update from day[i][current week] to day[j][current week + 1] We have n cities to try, so we need to loop to check all of the cities. for j in 0 to n: if flights[i][j] == 1: then we can update from day[i][current week] to day[j][current week + 1] We need something to hold the current maximum, but we also know local maximum cannot represent the global optimal, so we use dynamic programming. We use dp[i][j] to represent on city i, week j, what is the maximum vacation to take. As we make progress to another week, we bascially just try out all the previous maximum with current choice, and see if we should make the current decision. for k in 0 to k - 1: try all weeks for i in 0 to n: try all starting cities for j in 0 to n: try all destination cities if flights[i][j] == 1: if there is flight between then we can update dp[i][k] from dp[i][k] to dp[i][k] + day[j][k + 1] Time: O(n^3) O(n^3) Space: O(n^2) O(n^2) for the dp matrix","title":"Analysis"},{"location":"Leetcode/568.-maximum-vacation-days/#code","text":"Since I don't have prime for leetcode, this code is copied and pasted from Grandyang's blog class Solution { public : int maxVacationDays(vector < vector < int >>& flights, vector < vector < int >>& days) { int n = flights.size(), k = days[ 0 ].size(), res = 0 ; vector < vector < int >> dp(n, vector < int > (k, 0 )); for ( int j = k - 1 ; j >= 0 ; -- j) { // week j for ( int i = 0 ; i < n; ++ i) { // city 1 dp[i][j] = days[i][j]; for ( int p = 0 ; p < n; ++ p) { // city 2 if ((i == p || flights[i][p]) // city 1 == city 2 or there is flight && j < k - 1 ) { // and it's not the last week dp[i][j] = max(dp[i][j], dp[p][j + 1 ] // since we progress down, we populated the week j + 1 before week j + days[i][j]); } if (j == 0 // we only update res when we reach starting city 0 && (i == 0 || flights[ 0 ][i])) // either current city is already city 0 or there is flight from current city to city 0 res = max(res, dp[i][ 0 ]); } } } return res; } };","title":"Code"},{"location":"Leetcode/58.-Length-of-Last-Word/","text":"Length of Last Word \u00b6 Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0 . A word is a maximal substring consisting of non-space characters only. Example 1: Input: s = \"Hello World\" Output: 5 Example 2: Input: s = \" \" Output: 0 Constraints: 1 <= s.length <= 104 s consists of only English letters and spaces ' ' . Analysis \u00b6 Our goal is to find first word that is either between two spaces or the left char is a space. In order to do so, we just need to check from the right most pos to left, once we find a character that is not space, we update our counter. If the counter is greater than one and we meet another space, that means we have already found our target string, and we can just return the couter. The worst case is when the whole world is space OR no space at all -- in such case, we need to iterate the entire string from the end to the start. Time: O(n) O(n) Space: O(1) O(1) Code \u00b6 class Solution { public : int lengthOfLastWord(string s) { int res = 0 ; for ( int i = s.size() - 1 ; i >= 0 ; -- i) { if (res > 0 && s[i] == ' ' ) return res; if (s[i] != ' ' ) res ++ ; } return res; } };","title":"Length of Last Word"},{"location":"Leetcode/58.-Length-of-Last-Word/#length-of-last-word","text":"Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0 . A word is a maximal substring consisting of non-space characters only. Example 1: Input: s = \"Hello World\" Output: 5 Example 2: Input: s = \" \" Output: 0 Constraints: 1 <= s.length <= 104 s consists of only English letters and spaces ' ' .","title":"Length of Last Word"},{"location":"Leetcode/58.-Length-of-Last-Word/#analysis","text":"Our goal is to find first word that is either between two spaces or the left char is a space. In order to do so, we just need to check from the right most pos to left, once we find a character that is not space, we update our counter. If the counter is greater than one and we meet another space, that means we have already found our target string, and we can just return the couter. The worst case is when the whole world is space OR no space at all -- in such case, we need to iterate the entire string from the end to the start. Time: O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/58.-Length-of-Last-Word/#code","text":"class Solution { public : int lengthOfLastWord(string s) { int res = 0 ; for ( int i = s.size() - 1 ; i >= 0 ; -- i) { if (res > 0 && s[i] == ' ' ) return res; if (s[i] != ' ' ) res ++ ; } return res; } };","title":"Code"},{"location":"Leetcode/617.-Merge-Two-Binary-Trees/","text":"Merge Two Binary Trees \u00b6 You are given two binary trees root1 and root2 . Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree . Note: The merging process must start from the root nodes of both trees. Example 1: Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] Output: [3,4,5,5,4,null,7] Example 2: Input: root1 = [1], root2 = [1,2] Output: [2,2] Constraints: The number of nodes in both trees is in the range [0, 2000] . -104 <= Node.val <= 104 Analysis \u00b6 This question can be solved using DFS. For each DFS call, we should check if root1 is null root2 is null root1 and root2 are not null Also, depending on the requirement, if we can modify on the existing input, we can just modify any values already on the input trees. If not, we should create a new node everytime we traverse the tree. Time: O(n) O(n) number of node in the tree Space: O(n) O(n) for linkedlist case Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * mergeTrees(TreeNode * root1, TreeNode * root2) { // this check will handle all the case when any of the node is null if ( ! root1 || ! root2) return root1 ? root1 : root2; // At this point, all two nodes are not null root1 -> val += root2 -> val; // modify the existing tree root1 -> left = mergeTrees(root1 -> left, root2 -> left); root1 -> right = mergeTrees(root1 -> right, root2 -> right); return root1; /* create new node TreeNode *newNode = new TreeNode(root1 -> val + root2 -> val); newNode -> left = mergeTrees(root1 -> left, root2 -> left); newNode -> right = mergeTrees(root1 -> right, root2 -> right); return newNode; */ } };","title":"Merge Two Binary Trees"},{"location":"Leetcode/617.-Merge-Two-Binary-Trees/#merge-two-binary-trees","text":"You are given two binary trees root1 and root2 . Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree . Note: The merging process must start from the root nodes of both trees. Example 1: Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] Output: [3,4,5,5,4,null,7] Example 2: Input: root1 = [1], root2 = [1,2] Output: [2,2] Constraints: The number of nodes in both trees is in the range [0, 2000] . -104 <= Node.val <= 104","title":"Merge Two Binary Trees"},{"location":"Leetcode/617.-Merge-Two-Binary-Trees/#analysis","text":"This question can be solved using DFS. For each DFS call, we should check if root1 is null root2 is null root1 and root2 are not null Also, depending on the requirement, if we can modify on the existing input, we can just modify any values already on the input trees. If not, we should create a new node everytime we traverse the tree. Time: O(n) O(n) number of node in the tree Space: O(n) O(n) for linkedlist case","title":"Analysis"},{"location":"Leetcode/617.-Merge-Two-Binary-Trees/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : TreeNode * mergeTrees(TreeNode * root1, TreeNode * root2) { // this check will handle all the case when any of the node is null if ( ! root1 || ! root2) return root1 ? root1 : root2; // At this point, all two nodes are not null root1 -> val += root2 -> val; // modify the existing tree root1 -> left = mergeTrees(root1 -> left, root2 -> left); root1 -> right = mergeTrees(root1 -> right, root2 -> right); return root1; /* create new node TreeNode *newNode = new TreeNode(root1 -> val + root2 -> val); newNode -> left = mergeTrees(root1 -> left, root2 -> left); newNode -> right = mergeTrees(root1 -> right, root2 -> right); return newNode; */ } };","title":"Code"},{"location":"Leetcode/636.-exclusive-time-of-functions/","text":"Exclusive Time of Functions \u00b6 On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1 . Function calls are stored in a call stack : when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed . Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs , where logs[i] represents the ith log message formatted as a string \"{function_id}:{\"start\" | \"end\"}:{timestamp}\" . For example, \"0:start:3\" means a function call with function ID 0 started at the beginning of timestamp 3 , and \"1:end:2\" means a function call with function ID 1 ended at the end of timestamp 2 . Note that a function can be called multiple times, possibly recursively . A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3 . Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i . Example 1: Input: n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"] Output: [3,4] Explanation: Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1. Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5. Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time. So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing. Example 2: Input: n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"] Output: [8] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls itself again. Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time. Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time. So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing. Example 3: Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"] Output: [7,1] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls function 1. Function 1 starts at the beginning of time 6, executes 1 units of time, and ends at the end of time 6. Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time. So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing. Example 4: Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"] Output: [8,1] Example 5: Input: n = 1, logs = [\"0:start:0\",\"0:end:0\"] Output: [1] Constraints: 1 <= n <= 100 1 <= logs.length <= 500 0 <= function_id < n 0 <= timestamp <= 109 No two start events will happen at the same timestamp. No two end events will happen at the same timestamp. Each function has an \"end\" log for each \"start\" log. Analysis \u00b6 By observation, we can find that two ids cannot interlace with each other (this is invalid: [\"0:start:0\",\"1:start:2\",\"0 3\",\"1 5\"]), so we can maintain a stack that records the start time's id, so when finish we pop the top one (which is guarantee to be the last started id). if new one is another \"start\" timestamp, we push to the stack and update the top id's execuation time. if new one is another \"end\" timestamp, we pop the top one and update the resulting time. Time: O(n) since each element is going to run into the stack once Space: O(n) Code \u00b6 class Solution { public : vector < string > inline parse(string & str) { string id, status, timestamp; for ( int i = 0 , j = 0 ; i < str.length(); ++ i) { if (str[i] == ':' && ! j) { id = str.substr( 0 , i); j = i + 1 ; } else if (str[i] == ':' && j) { status = str.substr(j, i - j); j = i + 1 ; } else if (i == str.length() - 1 ) { timestamp = str.substr(j); } } return {id, status, timestamp}; } vector < int > exclusiveTime( int n, vector < string >& logs) { vector < int > time(n); auto first = parse(logs[ 0 ]); stack < int > st{{ stoi(first[ 0 ]) }}; for ( int i = 1 , prev = stoi(first[ 2 ]); i < logs.size(); ++ i) { auto raw = parse(logs[i]); if (raw[ 1 ] == \"start\" ) { if ( ! st.empty()) time[st.top()] += stoi(raw[ 2 ]) - prev; st.push(stoi(raw[ 0 ])); prev = stoi(raw[ 2 ]); } else { time[st.top()] += stoi(raw[ 2 ]) - prev + 1 ; st.pop(); prev = stoi(raw[ 2 ]) + 1 ; } } return time; } };","title":"Exclusive Time of Functions"},{"location":"Leetcode/636.-exclusive-time-of-functions/#exclusive-time-of-functions","text":"On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1 . Function calls are stored in a call stack : when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed . Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs , where logs[i] represents the ith log message formatted as a string \"{function_id}:{\"start\" | \"end\"}:{timestamp}\" . For example, \"0:start:3\" means a function call with function ID 0 started at the beginning of timestamp 3 , and \"1:end:2\" means a function call with function ID 1 ended at the end of timestamp 2 . Note that a function can be called multiple times, possibly recursively . A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3 . Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i . Example 1: Input: n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"] Output: [3,4] Explanation: Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1. Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5. Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time. So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing. Example 2: Input: n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"] Output: [8] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls itself again. Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time. Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time. So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing. Example 3: Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"] Output: [7,1] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls function 1. Function 1 starts at the beginning of time 6, executes 1 units of time, and ends at the end of time 6. Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time. So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing. Example 4: Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"] Output: [8,1] Example 5: Input: n = 1, logs = [\"0:start:0\",\"0:end:0\"] Output: [1] Constraints: 1 <= n <= 100 1 <= logs.length <= 500 0 <= function_id < n 0 <= timestamp <= 109 No two start events will happen at the same timestamp. No two end events will happen at the same timestamp. Each function has an \"end\" log for each \"start\" log.","title":"Exclusive Time of Functions"},{"location":"Leetcode/636.-exclusive-time-of-functions/#analysis","text":"By observation, we can find that two ids cannot interlace with each other (this is invalid: [\"0:start:0\",\"1:start:2\",\"0 3\",\"1 5\"]), so we can maintain a stack that records the start time's id, so when finish we pop the top one (which is guarantee to be the last started id). if new one is another \"start\" timestamp, we push to the stack and update the top id's execuation time. if new one is another \"end\" timestamp, we pop the top one and update the resulting time. Time: O(n) since each element is going to run into the stack once Space: O(n)","title":"Analysis"},{"location":"Leetcode/636.-exclusive-time-of-functions/#code","text":"class Solution { public : vector < string > inline parse(string & str) { string id, status, timestamp; for ( int i = 0 , j = 0 ; i < str.length(); ++ i) { if (str[i] == ':' && ! j) { id = str.substr( 0 , i); j = i + 1 ; } else if (str[i] == ':' && j) { status = str.substr(j, i - j); j = i + 1 ; } else if (i == str.length() - 1 ) { timestamp = str.substr(j); } } return {id, status, timestamp}; } vector < int > exclusiveTime( int n, vector < string >& logs) { vector < int > time(n); auto first = parse(logs[ 0 ]); stack < int > st{{ stoi(first[ 0 ]) }}; for ( int i = 1 , prev = stoi(first[ 2 ]); i < logs.size(); ++ i) { auto raw = parse(logs[i]); if (raw[ 1 ] == \"start\" ) { if ( ! st.empty()) time[st.top()] += stoi(raw[ 2 ]) - prev; st.push(stoi(raw[ 0 ])); prev = stoi(raw[ 2 ]); } else { time[st.top()] += stoi(raw[ 2 ]) - prev + 1 ; st.pop(); prev = stoi(raw[ 2 ]) + 1 ; } } return time; } };","title":"Code"},{"location":"Leetcode/646.-maximum-length-of-pair-chain/","text":"Maximum Length of Pair Chain \u00b6 You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c . Chain of pairs can be formed in this fashion. Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order. Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4] Note: The number of given pairs will be in the range [1, 1000]. Analysis \u00b6 tldr: the question is given a list of interval, find the maximum number of intervals can be formed without any intersection. two intervals can add to the chain only if first.end < second.first. For interval question can always use greedy algorithm to solve, and by using greedy is usually sorting. In this question we sort by interval end in ascending order. After sorting, we can do a linear scan to find the maximum size of the chain. If there is an intersection between two consective intervals, we always choose the first one and update our current maximum right boundary. So the question become why do we choose first one instead of the second one? To answer this, we can simulate if we choose the second one from two consective intervals, which means we need to update our right boundary to second.end, where first.end < second.end. To fit in more intervals in the future scan, we should always lower the right boundary, so we shouldn't choose the second one but the first one. Code \u00b6 class Solution { public : int findLongestChain(vector < vector < int >>& pairs) { sort(pairs.begin(), pairs.end(), [](vector < int >& l, vector < int >& r) { return l[ 1 ] < r[ 1 ];}); int res = 0 ; // note that pairs[i] can be negative, so we init right_bounary to INT_MIN for ( int i = 0 , right_bounary = INT_MIN; i < pairs.size(); ++ i) { if (right_bounary < pairs[i][ 0 ]) { right_bounary = pairs[i][ 1 ]; res ++ ; } } return res; } };","title":"Maximum Length of Pair Chain"},{"location":"Leetcode/646.-maximum-length-of-pair-chain/#maximum-length-of-pair-chain","text":"You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c . Chain of pairs can be formed in this fashion. Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order. Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4] Note: The number of given pairs will be in the range [1, 1000].","title":"Maximum Length of Pair Chain"},{"location":"Leetcode/646.-maximum-length-of-pair-chain/#analysis","text":"tldr: the question is given a list of interval, find the maximum number of intervals can be formed without any intersection. two intervals can add to the chain only if first.end < second.first. For interval question can always use greedy algorithm to solve, and by using greedy is usually sorting. In this question we sort by interval end in ascending order. After sorting, we can do a linear scan to find the maximum size of the chain. If there is an intersection between two consective intervals, we always choose the first one and update our current maximum right boundary. So the question become why do we choose first one instead of the second one? To answer this, we can simulate if we choose the second one from two consective intervals, which means we need to update our right boundary to second.end, where first.end < second.end. To fit in more intervals in the future scan, we should always lower the right boundary, so we shouldn't choose the second one but the first one.","title":"Analysis"},{"location":"Leetcode/646.-maximum-length-of-pair-chain/#code","text":"class Solution { public : int findLongestChain(vector < vector < int >>& pairs) { sort(pairs.begin(), pairs.end(), [](vector < int >& l, vector < int >& r) { return l[ 1 ] < r[ 1 ];}); int res = 0 ; // note that pairs[i] can be negative, so we init right_bounary to INT_MIN for ( int i = 0 , right_bounary = INT_MIN; i < pairs.size(); ++ i) { if (right_bounary < pairs[i][ 0 ]) { right_bounary = pairs[i][ 1 ]; res ++ ; } } return res; } };","title":"Code"},{"location":"Leetcode/647.-palindromic-substrings/","text":"Palindromic Substrings \u00b6 Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: \"abc\" Output: 3 Explanation: Three palindromic strings: \"a\", \"b\", \"c\". Example 2: Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Note: The input string length won't exceed 1000. Analysis \u00b6 create a 2d dp, which stands for if dp[i][j] == true, then s[i:j] is a palindrome Outter loop: iterate all the length (0 - n) for the substring. Inner loop: iterate all the starting index of the substring. (ends at starting idx + length) Edge case: when length <= 2, just set the to true and no need to check previous state Time: O(n^2) O(n^2) Space: O(n^2) O(n^2) Code \u00b6 class Solution { public : int countSubstrings(string s) { int n = s.size(); bool pal[n][n]; int res = 0 ; memset(pal, 0 , sizeof pal); for ( int d = 0 ; d < n; ++ d) { // length for ( int i = 0 ; i + d < n; ++ i) { // start pos int j = i + d; if (s[i] == s[j]) { // if length <= 2 AND s[i] == s[j], simply set pal[i][j] to true pal[i][j] = (d <= 2 ) || pal[i + 1 ][j - 1 ]; } if (pal[i][j]) res ++ ; } } return res; } };","title":"Palindromic Substrings"},{"location":"Leetcode/647.-palindromic-substrings/#palindromic-substrings","text":"Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: \"abc\" Output: 3 Explanation: Three palindromic strings: \"a\", \"b\", \"c\". Example 2: Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Note: The input string length won't exceed 1000.","title":"Palindromic Substrings"},{"location":"Leetcode/647.-palindromic-substrings/#analysis","text":"create a 2d dp, which stands for if dp[i][j] == true, then s[i:j] is a palindrome Outter loop: iterate all the length (0 - n) for the substring. Inner loop: iterate all the starting index of the substring. (ends at starting idx + length) Edge case: when length <= 2, just set the to true and no need to check previous state Time: O(n^2) O(n^2) Space: O(n^2) O(n^2)","title":"Analysis"},{"location":"Leetcode/647.-palindromic-substrings/#code","text":"class Solution { public : int countSubstrings(string s) { int n = s.size(); bool pal[n][n]; int res = 0 ; memset(pal, 0 , sizeof pal); for ( int d = 0 ; d < n; ++ d) { // length for ( int i = 0 ; i + d < n; ++ i) { // start pos int j = i + d; if (s[i] == s[j]) { // if length <= 2 AND s[i] == s[j], simply set pal[i][j] to true pal[i][j] = (d <= 2 ) || pal[i + 1 ][j - 1 ]; } if (pal[i][j]) res ++ ; } } return res; } };","title":"Code"},{"location":"Leetcode/684.-Redundant-Connection/","text":"Redundant Connection \u00b6 In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges . Each element of edges is a pair [u, v] with u < v , that represents an undirected edge connecting nodes u and v . Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u < v . Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this: 1 / \\ 2 - 3 Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Update (2017-09-26):* We have overhauled the problem description + test cases and specified clearly the graph is an undirected* graph. For the directed* graph follow up please see Redundant Connection II *). We apologize for any inconvenience caused. Analysis \u00b6 To fast determine if there is a cycle given edges, we can check if any two given two nodes already sharing the same parent, with Union-Find with path compression, we can \"almost\" get in done with O(1). Before Compression After Compression -- as you can see to determine if one node belong to any root we can run it with O(1) Code \u00b6 class Solution { public : vector < int > p; int find ( int x) { if (x != p[x]) p[x] = find(p[x]); return p[x]; } vector < int > findRedundantConnection(vector < vector < int >>& edges) { p = vector < int > (edges.size() + 1 ); for ( int i = 1 ; i <= edges.size(); ++ i) p[i] = i; for ( auto e : edges) { int u = e[ 0 ], v = e[ 1 ]; int r1 = find(u), r2 = find(v); if (r1 == r2) return e; else p[r1] = r2; } return { 0 , 0 }; } };","title":"Redundant Connection"},{"location":"Leetcode/684.-Redundant-Connection/#redundant-connection","text":"In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges . Each element of edges is a pair [u, v] with u < v , that represents an undirected edge connecting nodes u and v . Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u < v . Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this: 1 / \\ 2 - 3 Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Update (2017-09-26):* We have overhauled the problem description + test cases and specified clearly the graph is an undirected* graph. For the directed* graph follow up please see Redundant Connection II *). We apologize for any inconvenience caused.","title":"Redundant Connection"},{"location":"Leetcode/684.-Redundant-Connection/#analysis","text":"To fast determine if there is a cycle given edges, we can check if any two given two nodes already sharing the same parent, with Union-Find with path compression, we can \"almost\" get in done with O(1). Before Compression After Compression -- as you can see to determine if one node belong to any root we can run it with O(1)","title":"Analysis"},{"location":"Leetcode/684.-Redundant-Connection/#code","text":"class Solution { public : vector < int > p; int find ( int x) { if (x != p[x]) p[x] = find(p[x]); return p[x]; } vector < int > findRedundantConnection(vector < vector < int >>& edges) { p = vector < int > (edges.size() + 1 ); for ( int i = 1 ; i <= edges.size(); ++ i) p[i] = i; for ( auto e : edges) { int u = e[ 0 ], v = e[ 1 ]; int r1 = find(u), r2 = find(v); if (r1 == r2) return e; else p[r1] = r2; } return { 0 , 0 }; } };","title":"Code"},{"location":"Leetcode/69.-sqrt%28x%29/","text":"Sqrt(t) \u00b6 Implement int sqrt(int x) . Compute and return the square root of x , where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Analysis \u00b6 we could \"try\" all the values from 0 to x, and find the largest value y where y * y is less than x. y is our answer \u2014 we can use binary search for this problem. Don't forget to subtract 1 after calculation, since the question want to discard all the digits after the decimal (1.2->1). Newton Iteration: to find x^2=n x^2=n , we can first rearrange our function into f(x)=n-x^2 f(x)=n-x^2 , and we want to find the solution when f(x)=0 f(x)=0 . The key point is the average result is calculate by \"ans = (ans + x / ans) / 2\"; For instance, when calculate sqrt(2) : Guess Result Quotient Average Result 1 2 / 1 = 2 (2 + 1) / 2 = 1.5 1.5 2 / 1.5 = 1.3333 (1.3333 + 1.5) / 2 = 1.4167 1.4167 2 / 1.4167 = 1.4118 (1.4167 + 1.4118) / 2 = 1.4142 ... ... Code 1 \u00b6 class Solution { public : int mySqrt( int x) { if (x <= 1 ) return x; // left is our candidate, right is our target int left = 0 , right = x; while (left < right) { int mid = left + (right - left) / 2 ; if (x / mid >= mid) left = mid + 1 ; else right = mid; } return right - 1 ; } }; Code 2 \u00b6 class Solution { public : int mySqrt( int x) { if (x == 0 ) return 0 ; double res = 1 , pre = 0 ; while (abs(res - pre) > 1e-6 ) { pre = res; res = (res + x / res) / 2 ; } return int (res); } };","title":"Sqrt(t)"},{"location":"Leetcode/69.-sqrt%28x%29/#sqrtt","text":"Implement int sqrt(int x) . Compute and return the square root of x , where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.","title":"Sqrt(t)"},{"location":"Leetcode/69.-sqrt%28x%29/#analysis","text":"we could \"try\" all the values from 0 to x, and find the largest value y where y * y is less than x. y is our answer \u2014 we can use binary search for this problem. Don't forget to subtract 1 after calculation, since the question want to discard all the digits after the decimal (1.2->1). Newton Iteration: to find x^2=n x^2=n , we can first rearrange our function into f(x)=n-x^2 f(x)=n-x^2 , and we want to find the solution when f(x)=0 f(x)=0 . The key point is the average result is calculate by \"ans = (ans + x / ans) / 2\"; For instance, when calculate sqrt(2) : Guess Result Quotient Average Result 1 2 / 1 = 2 (2 + 1) / 2 = 1.5 1.5 2 / 1.5 = 1.3333 (1.3333 + 1.5) / 2 = 1.4167 1.4167 2 / 1.4167 = 1.4118 (1.4167 + 1.4118) / 2 = 1.4142 ... ...","title":"Analysis"},{"location":"Leetcode/69.-sqrt%28x%29/#code-1","text":"class Solution { public : int mySqrt( int x) { if (x <= 1 ) return x; // left is our candidate, right is our target int left = 0 , right = x; while (left < right) { int mid = left + (right - left) / 2 ; if (x / mid >= mid) left = mid + 1 ; else right = mid; } return right - 1 ; } };","title":"Code 1"},{"location":"Leetcode/69.-sqrt%28x%29/#code-2","text":"class Solution { public : int mySqrt( int x) { if (x == 0 ) return 0 ; double res = 1 , pre = 0 ; while (abs(res - pre) > 1e-6 ) { pre = res; res = (res + x / res) / 2 ; } return int (res); } };","title":"Code 2"},{"location":"Leetcode/695.-Max-Area-of-Island/","text":"Max Area of Island \u00b6 You are given an m x n binary matrix grid . An island is a group of 1 's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid . If there is no island, return 0 . Example 1: Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2: Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 grid[i][j] is either 0 or 1 . Analysis \u00b6 We can use DFS to solve this problem. Once we see a location marked as 1, we will run a DFS to search all the surrounded area whose value is also 1, and keep a count and return it. Finally, we just need to compare all the independent areas and return the maximum. One thing to be mindful is that we need to keep track of all the counted area, we can either 1. rewrite another value to the 1's location if we can alter the orginal grid, 2. use a set or a map to keep a record of the the visited address. Time: O(n^2) O(n^2) Space: O(n^2) O(n^2) Code \u00b6 class Solution { public : int maxAreaOfIsland(vector < vector < int >>& grid) { int res = 0 ; for ( int x = 0 ; x < grid.size(); ++ x) for ( int y = 0 ; y < grid[ 0 ].size(); ++ y) if (grid[x][y] == 1 ) res = max(res, dfs(x, y, grid)); return res; } int dir[ 4 ][ 2 ] = {{ 1 , 0 }, { -1 , 0 }, { 0 , 1 }, { 0 , -1 }}; int dfs ( int x, int y, vector < vector < int >>& g) { if (x < 0 || x >= g.size() || y >= g[ 0 ].size() || g[x][y] != 1 ) /* !visited.count({x, y}) if not allowed to write the original grid */ return 0 ; g[x][y] = 2 ; // rewrite it with a special value int res = 1 ; for ( auto d : dir) { /* visited.insert({x + d[0], y + d[1]}); */ res += dfs(x + d[ 0 ], y + d[ 1 ], g); } return res; } };","title":"Max Area of Island"},{"location":"Leetcode/695.-Max-Area-of-Island/#max-area-of-island","text":"You are given an m x n binary matrix grid . An island is a group of 1 's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid . If there is no island, return 0 . Example 1: Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2: Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 grid[i][j] is either 0 or 1 .","title":"Max Area of Island"},{"location":"Leetcode/695.-Max-Area-of-Island/#analysis","text":"We can use DFS to solve this problem. Once we see a location marked as 1, we will run a DFS to search all the surrounded area whose value is also 1, and keep a count and return it. Finally, we just need to compare all the independent areas and return the maximum. One thing to be mindful is that we need to keep track of all the counted area, we can either 1. rewrite another value to the 1's location if we can alter the orginal grid, 2. use a set or a map to keep a record of the the visited address. Time: O(n^2) O(n^2) Space: O(n^2) O(n^2)","title":"Analysis"},{"location":"Leetcode/695.-Max-Area-of-Island/#code","text":"class Solution { public : int maxAreaOfIsland(vector < vector < int >>& grid) { int res = 0 ; for ( int x = 0 ; x < grid.size(); ++ x) for ( int y = 0 ; y < grid[ 0 ].size(); ++ y) if (grid[x][y] == 1 ) res = max(res, dfs(x, y, grid)); return res; } int dir[ 4 ][ 2 ] = {{ 1 , 0 }, { -1 , 0 }, { 0 , 1 }, { 0 , -1 }}; int dfs ( int x, int y, vector < vector < int >>& g) { if (x < 0 || x >= g.size() || y >= g[ 0 ].size() || g[x][y] != 1 ) /* !visited.count({x, y}) if not allowed to write the original grid */ return 0 ; g[x][y] = 2 ; // rewrite it with a special value int res = 1 ; for ( auto d : dir) { /* visited.insert({x + d[0], y + d[1]}); */ res += dfs(x + d[ 0 ], y + d[ 1 ], g); } return res; } };","title":"Code"},{"location":"Leetcode/72.-edit-distance/","text":"Edit Distance \u00b6 Given two strings word1 and word2 , return the minimum number of operations required to convert word1 to word2 . You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Constraints: 0 <= word1.length, word2.length <= 500 word1 and word2 consist of lowercase English letters. Analysis \u00b6 dp[i][j]: # of ops to transfer word1[0:i] to word2[0:j] Code \u00b6 int dp_sol (string word1, string word2){ int m = word1.size(), n = word2.size(); vector < vector < int >> dp(m + 1 , vector < int > (n + 1 )); for ( int i = 0 ; i <= m; ++ i) { dp[i][ 0 ] = i; // can only remove all from word2[0:i] to form an empty word1 } for ( int i = 0 ; i <= n; ++ i) { dp[ 0 ][i] = i; // same as above } for ( int i = 1 ; i <= m; ++ i) { for ( int j = 1 ; j <= n; ++ j) { if (word1[i - 1 ] == word2[j - 1 ]) { // nothing needs to be changed, because they are the same dp[i][j] = dp[i - 1 ][j - 1 ]; } else { // now you can either remove previous one from word1, add is equal to remove one from word2, or replace current one (no change) dp[i][j] = min(dp[i - 1 ][j - 1 ], min(dp[i - 1 ][j], dp[i][j - 1 ])) + 1 ; // +1 for the current op } } } return dp[m][n]; }","title":"Edit Distance"},{"location":"Leetcode/72.-edit-distance/#edit-distance","text":"Given two strings word1 and word2 , return the minimum number of operations required to convert word1 to word2 . You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Constraints: 0 <= word1.length, word2.length <= 500 word1 and word2 consist of lowercase English letters.","title":"Edit Distance"},{"location":"Leetcode/72.-edit-distance/#analysis","text":"dp[i][j]: # of ops to transfer word1[0:i] to word2[0:j]","title":"Analysis"},{"location":"Leetcode/72.-edit-distance/#code","text":"int dp_sol (string word1, string word2){ int m = word1.size(), n = word2.size(); vector < vector < int >> dp(m + 1 , vector < int > (n + 1 )); for ( int i = 0 ; i <= m; ++ i) { dp[i][ 0 ] = i; // can only remove all from word2[0:i] to form an empty word1 } for ( int i = 0 ; i <= n; ++ i) { dp[ 0 ][i] = i; // same as above } for ( int i = 1 ; i <= m; ++ i) { for ( int j = 1 ; j <= n; ++ j) { if (word1[i - 1 ] == word2[j - 1 ]) { // nothing needs to be changed, because they are the same dp[i][j] = dp[i - 1 ][j - 1 ]; } else { // now you can either remove previous one from word1, add is equal to remove one from word2, or replace current one (no change) dp[i][j] = min(dp[i - 1 ][j - 1 ], min(dp[i - 1 ][j], dp[i][j - 1 ])) + 1 ; // +1 for the current op } } } return dp[m][n]; }","title":"Code"},{"location":"Leetcode/723.-Candy-Crush/","text":"Candy Crush \u00b6 This question is about implementing a basic elimination algorithm for Candy Crush. Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules: If three or more candies of the same type are adjacent vertically or horizontally, \"crush\" them all at the same time - these positions become empty. After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.) After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps. If there does not exist more candies that can be crushed (ie. the board is stable ), then return the current board. You need to perform the above rules until the board becomes stable, then return the current board. Example: Input: board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]] Output: [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]] Explanation: Note: The length of board will be in the range [3, 50]. The length of board[i] will be in the range [3, 50]. Each board[i][j] will initially start as an integer in the range [1, 2000]. Analysis \u00b6 There are three cases will cause a \"crush\": Vertically aligned with three same candies Horizontally algined with three same candies After \"fell down\" by gravity, above two cases could possibly happen again. Note that we don't need to write another helper function for checking if the current state is stable or not, because the check is essentially the same logic as the next call to the function (so we use recursion) We just need to follow these three cases to write the code. Note that for step 3, we need to use the same logic after we have fallen down all the candies, thus we need to use recrusion for that case. Code \u00b6 class Solution { public : vector < vector < int >> candyCrush(vector < vector < int >>& board) { int m = board.size(); if (m == 0 ) return board; int n = board[ 0 ].size(); if (n == 0 ) return board; bool todo = false ; // step 1: mark all three-algined candy to negative with **up and down** directions for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n -2 ; ++ j) { int v = abs(board[i][j]); if (v != 0 && v == abs(board[i][j +1 ]) && v == abs(board[i][j +2 ])) { board[i][j] = - v; board[i][j +1 ] = - v; board[i][j +2 ] = - v; todo = true ; } } } // step 2: mark all three-algined candy to negative with **left and right** directions for ( int j = 0 ; j < n; ++ j) { for ( int i = 0 ; i < m -2 ; ++ i) { int v = abs(board[i][j]); if (v != 0 && v == abs(board[i +1 ][j]) && v == abs(board[i +2 ][j])) { board[i][j] = - v; board[i +1 ][j] = - v; board[i +2 ][j] = - v; todo = true ; } } } // step 3: gravity part if (todo) { for ( int j = 0 ; j < n; ++ j) { int row = m -1 ; // pointing at bottom for ( int i = m -1 ; i >= 0 ; -- i) { // shift down if (board[i][j] > 0 ) board[row -- ][j] = board[i][j]; } while (row >= 0 ) // fill the original candy loc to 0 board[row -- ][j] = 0 ; } return candyCrush(board); } return board; } };","title":"Candy Crush"},{"location":"Leetcode/723.-Candy-Crush/#candy-crush","text":"This question is about implementing a basic elimination algorithm for Candy Crush. Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules: If three or more candies of the same type are adjacent vertically or horizontally, \"crush\" them all at the same time - these positions become empty. After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.) After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps. If there does not exist more candies that can be crushed (ie. the board is stable ), then return the current board. You need to perform the above rules until the board becomes stable, then return the current board. Example: Input: board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]] Output: [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]] Explanation: Note: The length of board will be in the range [3, 50]. The length of board[i] will be in the range [3, 50]. Each board[i][j] will initially start as an integer in the range [1, 2000].","title":"Candy Crush"},{"location":"Leetcode/723.-Candy-Crush/#analysis","text":"There are three cases will cause a \"crush\": Vertically aligned with three same candies Horizontally algined with three same candies After \"fell down\" by gravity, above two cases could possibly happen again. Note that we don't need to write another helper function for checking if the current state is stable or not, because the check is essentially the same logic as the next call to the function (so we use recursion) We just need to follow these three cases to write the code. Note that for step 3, we need to use the same logic after we have fallen down all the candies, thus we need to use recrusion for that case.","title":"Analysis"},{"location":"Leetcode/723.-Candy-Crush/#code","text":"class Solution { public : vector < vector < int >> candyCrush(vector < vector < int >>& board) { int m = board.size(); if (m == 0 ) return board; int n = board[ 0 ].size(); if (n == 0 ) return board; bool todo = false ; // step 1: mark all three-algined candy to negative with **up and down** directions for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n -2 ; ++ j) { int v = abs(board[i][j]); if (v != 0 && v == abs(board[i][j +1 ]) && v == abs(board[i][j +2 ])) { board[i][j] = - v; board[i][j +1 ] = - v; board[i][j +2 ] = - v; todo = true ; } } } // step 2: mark all three-algined candy to negative with **left and right** directions for ( int j = 0 ; j < n; ++ j) { for ( int i = 0 ; i < m -2 ; ++ i) { int v = abs(board[i][j]); if (v != 0 && v == abs(board[i +1 ][j]) && v == abs(board[i +2 ][j])) { board[i][j] = - v; board[i +1 ][j] = - v; board[i +2 ][j] = - v; todo = true ; } } } // step 3: gravity part if (todo) { for ( int j = 0 ; j < n; ++ j) { int row = m -1 ; // pointing at bottom for ( int i = m -1 ; i >= 0 ; -- i) { // shift down if (board[i][j] > 0 ) board[row -- ][j] = board[i][j]; } while (row >= 0 ) // fill the original candy loc to 0 board[row -- ][j] = 0 ; } return candyCrush(board); } return board; } };","title":"Code"},{"location":"Leetcode/733.-Flood-Fill/","text":"Flood Fill \u00b6 An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr , sc , and newColor . You should perform a flood fill on the image starting from the pixel image[sr][sc] . To perform a flood fill , consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor . Return the modified image after performing the flood fill . Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2: Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2 Output: [[2,2,2],[2,2,2]] Constraints: m == image.length n == image[i].length 1 <= m, n <= 50 0 <= image[i][j], newColor < 216 0 <= sr < m 0 <= sc < n Analysis \u00b6 We can use both DFS or BFS to solve this problem, and depending on the requirement, DFS would require to set the call stack space to hold the recursion tree, and BFS requires to create a stack space that is at most equal to the size of grid. Time: O(n^2) O(n^2) or O(w * h) O(w * h) Space: O(n^2) O(n^2) or O(w * h) O(w * h) Code: DFS \u00b6 class Solution { public : int dir[ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , -1 }, { 1 , 0 }, { -1 , 0 }}; void dfs ( int x, int y, int org, int color, vector < vector < int >> & g) { if (x < 0 || x >= g.size() || y < 0 || y >= g[ 0 ].size() || g[x][y] != org || g[x][y] == color) return ; g[x][y] = color; for ( auto d : dir) { dfs(x + d[ 0 ], y + d[ 1 ], org, color, g); } } vector < vector < int >> floodFill(vector < vector < int >> & image, int sr, int sc, int newColor) { dfs(sr, sc, image[sr][sc], newColor, image); return image; } }; Code: BFS \u00b6 class Solution { public : vector < vector < int >> floodFill(vector < vector < int >>& image, int sr, int sc, int newColor) { int color = image[sr][sc]; if (newColor == color) return image; queue < pair < int , int >> q{{{sr, sc}}}; int dir[ 4 ][ 2 ] = {{ 0 , 1 },{ 0 , -1 },{ 1 , 0 },{ -1 , 0 }}; while ( ! q.empty()) { int x, y; tie(x, y) = q.front(); q.pop(); image[x][y] = newColor; for ( auto d : dir) { int dx = x + d[ 0 ], dy = y + d[ 1 ]; if (dx < 0 || dx >= image.size() || dy < 0 || dy >= image[ 0 ].size() || image[dx][dy] != color) continue ; q.push({dx, dy}); } } return image; } };","title":"Flood Fill"},{"location":"Leetcode/733.-Flood-Fill/#flood-fill","text":"An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr , sc , and newColor . You should perform a flood fill on the image starting from the pixel image[sr][sc] . To perform a flood fill , consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor . Return the modified image after performing the flood fill . Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2: Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2 Output: [[2,2,2],[2,2,2]] Constraints: m == image.length n == image[i].length 1 <= m, n <= 50 0 <= image[i][j], newColor < 216 0 <= sr < m 0 <= sc < n","title":"Flood Fill"},{"location":"Leetcode/733.-Flood-Fill/#analysis","text":"We can use both DFS or BFS to solve this problem, and depending on the requirement, DFS would require to set the call stack space to hold the recursion tree, and BFS requires to create a stack space that is at most equal to the size of grid. Time: O(n^2) O(n^2) or O(w * h) O(w * h) Space: O(n^2) O(n^2) or O(w * h) O(w * h)","title":"Analysis"},{"location":"Leetcode/733.-Flood-Fill/#code-dfs","text":"class Solution { public : int dir[ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , -1 }, { 1 , 0 }, { -1 , 0 }}; void dfs ( int x, int y, int org, int color, vector < vector < int >> & g) { if (x < 0 || x >= g.size() || y < 0 || y >= g[ 0 ].size() || g[x][y] != org || g[x][y] == color) return ; g[x][y] = color; for ( auto d : dir) { dfs(x + d[ 0 ], y + d[ 1 ], org, color, g); } } vector < vector < int >> floodFill(vector < vector < int >> & image, int sr, int sc, int newColor) { dfs(sr, sc, image[sr][sc], newColor, image); return image; } };","title":"Code: DFS"},{"location":"Leetcode/733.-Flood-Fill/#code-bfs","text":"class Solution { public : vector < vector < int >> floodFill(vector < vector < int >>& image, int sr, int sc, int newColor) { int color = image[sr][sc]; if (newColor == color) return image; queue < pair < int , int >> q{{{sr, sc}}}; int dir[ 4 ][ 2 ] = {{ 0 , 1 },{ 0 , -1 },{ 1 , 0 },{ -1 , 0 }}; while ( ! q.empty()) { int x, y; tie(x, y) = q.front(); q.pop(); image[x][y] = newColor; for ( auto d : dir) { int dx = x + d[ 0 ], dy = y + d[ 1 ]; if (dx < 0 || dx >= image.size() || dy < 0 || dy >= image[ 0 ].size() || image[dx][dy] != color) continue ; q.push({dx, dy}); } } return image; } };","title":"Code: BFS"},{"location":"Leetcode/754.-Reach-a-Number/","text":"Reach a Number \u00b6 You are standing at position 0 on an infinite number line. There is a goal at position target . On each move, you can either go left or right. During the n -th move (starting from 1), you take n steps. Return the minimum number of steps required to reach the destination. Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3. Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step from 1 to -1. On the third move we step from -1 to 2. Note: target will be a non-zero integer in the range [-10^9, 10^9] . Analysis \u00b6 It's a math problem, and we can use Pythagorean theorem to calculate the minimal steps to reach or be greater than target number, and then by flipping one or some of the step(s), we can finally reach the perfect number. There are two cases when our first minimal steps exceeds the target, and we represent the difference as diff : diff is an odd number: in this case, we just need to keep proceeding (step ++), because by flipping any number from 1 to step, it will result in a 2 * step number, which guarantees to be a even number. diff is even: great, we can just flip a step within 1 to step, since we can guarantee diff is always less than latest step, we can be sure that there is a flip step exist so that 2 * flip step = diff. Time: O(1) O(1) by using math Space: O(1) O(1) Why it can guarantee to be the optimal solution? leetcode url Code \u00b6 Without using math: class Solution { public : int reachNumber( int target) { target = abs(target); int step = 0 , sum = 0 ; for (; sum < target; sum += step) step ++ ; while ((sum - target) % 2 != 0 ) { sum += ++ step; } return step; } }; Using Pythagorean theorem: class Solution { public : int reachNumber( int64_t target) { target = std :: abs(target); int64_t steps = 0.5* (sqrt( 8* target) -1 ) +1 , sum{(steps +1 ) * steps /2 }, diff{sum - target}; if (diff % 2 == 0 ) return steps; else if (steps % 2 == 0 ) return steps + 1 ; return steps + 2 ; } };","title":"Reach a Number"},{"location":"Leetcode/754.-Reach-a-Number/#reach-a-number","text":"You are standing at position 0 on an infinite number line. There is a goal at position target . On each move, you can either go left or right. During the n -th move (starting from 1), you take n steps. Return the minimum number of steps required to reach the destination. Example 1: Input: target = 3 Output: 2 Explanation: On the first move we step from 0 to 1. On the second step we step from 1 to 3. Example 2: Input: target = 2 Output: 3 Explanation: On the first move we step from 0 to 1. On the second move we step from 1 to -1. On the third move we step from -1 to 2. Note: target will be a non-zero integer in the range [-10^9, 10^9] .","title":"Reach a Number"},{"location":"Leetcode/754.-Reach-a-Number/#analysis","text":"It's a math problem, and we can use Pythagorean theorem to calculate the minimal steps to reach or be greater than target number, and then by flipping one or some of the step(s), we can finally reach the perfect number. There are two cases when our first minimal steps exceeds the target, and we represent the difference as diff : diff is an odd number: in this case, we just need to keep proceeding (step ++), because by flipping any number from 1 to step, it will result in a 2 * step number, which guarantees to be a even number. diff is even: great, we can just flip a step within 1 to step, since we can guarantee diff is always less than latest step, we can be sure that there is a flip step exist so that 2 * flip step = diff. Time: O(1) O(1) by using math Space: O(1) O(1) Why it can guarantee to be the optimal solution? leetcode url","title":"Analysis"},{"location":"Leetcode/754.-Reach-a-Number/#code","text":"Without using math: class Solution { public : int reachNumber( int target) { target = abs(target); int step = 0 , sum = 0 ; for (; sum < target; sum += step) step ++ ; while ((sum - target) % 2 != 0 ) { sum += ++ step; } return step; } }; Using Pythagorean theorem: class Solution { public : int reachNumber( int64_t target) { target = std :: abs(target); int64_t steps = 0.5* (sqrt( 8* target) -1 ) +1 , sum{(steps +1 ) * steps /2 }, diff{sum - target}; if (diff % 2 == 0 ) return steps; else if (steps % 2 == 0 ) return steps + 1 ; return steps + 2 ; } };","title":"Code"},{"location":"Leetcode/815.-Bus-Routes/","text":"Bus Routes \u00b6 You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever. For example, if routes[0] = [1, 5, 7] , this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever. You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target . You can travel between bus stops by buses only. Return the least number of buses you must take to travel from source to target . Return -1 if it is not possible. Example 1: Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6 Output: 2 Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Example 2: Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12 Output: -1 Constraints: 1 <= routes.length <= 500 . 1 <= routes[i].length <= 105 All the values of routes[i] are unique . sum(routes[i].length) <= 105 0 <= routes[i][j] < 106 0 <= source, target < 106 Analysis \u00b6 Method 1: BFS with sort, using each route as a node \u00b6 Seeing each route as a node, the edge can only be formed when two routes share one or more stops. Create a map<index, set<index>> indicates the index from routes can be used as the node. To construct this map, we will need to do a O(n^2 \\times m) O(n^2 \\times m) loop to iterate and find which two routes have intersections, m is the average stop size of each route and n is the number of routes. To efficiently find the intersections, we can do a two-pointer trick, but we first need to sort each stop in each route. Then we will run a multi-source BFS to find the shortest path, which will take O(n) O(n) . Method 2: BFS using each stop as a node \u00b6 Since we only care about which two stops are our source and target, and we want to know finding their related route, an easier way to construct our graph is simply by using the stop as a node. The map now looks like map<stop, vector<index>> , and it will only take O(n \\times m) O(n \\times m) where n is route size and m is the average size of each route's stops. Now if we run the multi-source BFS again, we might iterate through the same route multiple times, but the total times are bounded by the total number of stops, so it will be O(n \\times m) O(n \\times m) . Code \u00b6 // using route as node class Solution { public : int numBusesToDestination(vector < vector < int >> & routes, int source, int target) { if (source == target) return 0 ; map < int , set < int >> graph; // index -> index int n = routes.size(); set < int > s, e; // could be multiple source/target // build graph & find start and end node for ( int i = 0 ; i < n; ++ i) { set < int > a(routes[i].begin(), routes[i].end()); if (a.count(source)) s.insert(i); if (a.count(target)) e.insert(i); if (a.count(target) && a.count(source)) return 1 ; int j = 0 ; for ( int r : a) routes[i][j ++ ] = r; } for ( int i = 0 ; i < n; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (j == i) continue ; // no self loop bool intersect = false ; for ( int a = 0 , b = 0 ; a < routes[i].size() && b < routes[j].size();) { if (routes[i][a] == routes[j][b]) { graph[i].insert(j); break ; } else if (routes[i][a] < routes[j][b]) { a ++ ; } else { b ++ ; } } } } if (s.empty() || e.empty()) return -1 ; // bfs queue < pair < int , int >> q; for ( int start : s) { q.push(make_pair(start, 1 )); } set < int > visited(s.begin(), s.end()); int res = INT_MAX; while ( ! q.empty()) { auto p = q.front(); q.pop(); int t = p.first, level = p.second; if (e.count(t)) { res = min(res, level); } for ( int neighbour : graph[t]) { if ( ! visited.count(neighbour)) { q.push(make_pair(neighbour, level + 1 )); visited.insert(neighbour); } } } return res == INT_MAX ? -1 : res; } }; Method 2 \u00b6 // ref: // https://leetcode.com/problems/bus-routes/discuss/122771/C++JavaPython-BFS-Solution int numBusesToDestination (vector < vector < int >> & routes, int S, int T) { unordered_map < int , vector < int >> to_routes; for ( int i = 0 ; i < routes.size(); ++ i) for ( int j : routes[i]) to_routes[j].push_back(i); queue < pair < int , int >> bfs; bfs.push({S, 0 }); unordered_set < int > seen = {S}; while ( ! bfs.empty()) { int stop = bfs.front().first, bus = bfs.front().second; bfs.pop(); if (stop == T) return bus; for ( int i : to_routes[stop]) { for ( int j : routes[i]) { if (seen.find(j) == seen.end()) { seen.insert(j); bfs.push({j, bus + 1 }); } } routes[i].clear(); } } return -1 ; }","title":"Bus Routes"},{"location":"Leetcode/815.-Bus-Routes/#bus-routes","text":"You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever. For example, if routes[0] = [1, 5, 7] , this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever. You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target . You can travel between bus stops by buses only. Return the least number of buses you must take to travel from source to target . Return -1 if it is not possible. Example 1: Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6 Output: 2 Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Example 2: Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12 Output: -1 Constraints: 1 <= routes.length <= 500 . 1 <= routes[i].length <= 105 All the values of routes[i] are unique . sum(routes[i].length) <= 105 0 <= routes[i][j] < 106 0 <= source, target < 106","title":"Bus Routes"},{"location":"Leetcode/815.-Bus-Routes/#analysis","text":"","title":"Analysis"},{"location":"Leetcode/815.-Bus-Routes/#method-1-bfs-with-sort-using-each-route-as-a-node","text":"Seeing each route as a node, the edge can only be formed when two routes share one or more stops. Create a map<index, set<index>> indicates the index from routes can be used as the node. To construct this map, we will need to do a O(n^2 \\times m) O(n^2 \\times m) loop to iterate and find which two routes have intersections, m is the average stop size of each route and n is the number of routes. To efficiently find the intersections, we can do a two-pointer trick, but we first need to sort each stop in each route. Then we will run a multi-source BFS to find the shortest path, which will take O(n) O(n) .","title":"Method 1: BFS with sort, using each route as a node"},{"location":"Leetcode/815.-Bus-Routes/#method-2-bfs-using-each-stop-as-a-node","text":"Since we only care about which two stops are our source and target, and we want to know finding their related route, an easier way to construct our graph is simply by using the stop as a node. The map now looks like map<stop, vector<index>> , and it will only take O(n \\times m) O(n \\times m) where n is route size and m is the average size of each route's stops. Now if we run the multi-source BFS again, we might iterate through the same route multiple times, but the total times are bounded by the total number of stops, so it will be O(n \\times m) O(n \\times m) .","title":"Method 2: BFS using each stop as a node"},{"location":"Leetcode/815.-Bus-Routes/#code","text":"// using route as node class Solution { public : int numBusesToDestination(vector < vector < int >> & routes, int source, int target) { if (source == target) return 0 ; map < int , set < int >> graph; // index -> index int n = routes.size(); set < int > s, e; // could be multiple source/target // build graph & find start and end node for ( int i = 0 ; i < n; ++ i) { set < int > a(routes[i].begin(), routes[i].end()); if (a.count(source)) s.insert(i); if (a.count(target)) e.insert(i); if (a.count(target) && a.count(source)) return 1 ; int j = 0 ; for ( int r : a) routes[i][j ++ ] = r; } for ( int i = 0 ; i < n; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (j == i) continue ; // no self loop bool intersect = false ; for ( int a = 0 , b = 0 ; a < routes[i].size() && b < routes[j].size();) { if (routes[i][a] == routes[j][b]) { graph[i].insert(j); break ; } else if (routes[i][a] < routes[j][b]) { a ++ ; } else { b ++ ; } } } } if (s.empty() || e.empty()) return -1 ; // bfs queue < pair < int , int >> q; for ( int start : s) { q.push(make_pair(start, 1 )); } set < int > visited(s.begin(), s.end()); int res = INT_MAX; while ( ! q.empty()) { auto p = q.front(); q.pop(); int t = p.first, level = p.second; if (e.count(t)) { res = min(res, level); } for ( int neighbour : graph[t]) { if ( ! visited.count(neighbour)) { q.push(make_pair(neighbour, level + 1 )); visited.insert(neighbour); } } } return res == INT_MAX ? -1 : res; } };","title":"Code"},{"location":"Leetcode/815.-Bus-Routes/#method-2","text":"// ref: // https://leetcode.com/problems/bus-routes/discuss/122771/C++JavaPython-BFS-Solution int numBusesToDestination (vector < vector < int >> & routes, int S, int T) { unordered_map < int , vector < int >> to_routes; for ( int i = 0 ; i < routes.size(); ++ i) for ( int j : routes[i]) to_routes[j].push_back(i); queue < pair < int , int >> bfs; bfs.push({S, 0 }); unordered_set < int > seen = {S}; while ( ! bfs.empty()) { int stop = bfs.front().first, bus = bfs.front().second; bfs.pop(); if (stop == T) return bus; for ( int i : to_routes[stop]) { for ( int j : routes[i]) { if (seen.find(j) == seen.end()) { seen.insert(j); bfs.push({j, bus + 1 }); } } routes[i].clear(); } } return -1 ; }","title":"Method 2"},{"location":"Leetcode/85.-maximal-rectangle/","text":"Maximal Rectangle \u00b6 Given a rows x cols binary matrix filled with 0 's and 1 's, find the largest rectangle containing only 1 's and return its area . Example 1: Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2: Input: matrix = [] Output: 0 Example 3: Input: matrix = [[\"0\"]] Output: 0 Example 4: Input: matrix = [[\"1\"]] Output: 1 Example 5: Input: matrix = [[\"0\",\"0\"]] Output: 0 Constraints: rows == matrix.length cols == matrix[i].length 0 <= row, cols <= 200 matrix[i][j] is '0' or '1' . Analysis \u00b6 height[i] record the current number of countinous '1' in column i; left[i] record the left most index j which satisfies that for any index k from j to i, height[k] >= height[i]; right[i] record the right most index j which satifies that for any index k from i to j, height[k] >= height[i]; if j doesn't exist, then use size of matrix to represent j for right, use 0 to represent j for left matrix 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 height 0 0 0 1 0 0 0 0 0 1 2 1 0 0 0 1 2 3 2 1 0 left 0 0 0 3 0 0 0 0 0 2 3 2 0 0 0 1 2 3 2 1 0 right 7 7 7 4 7 7 7 // at index i from right to left, if height[i] >= height[i+1], set right[i]=i or keep going 7 7 5 4 5 7 7 7 6 5 4 5 4 7 result 0 0 0 1 0 0 0 0 0 3 2 3 0 0 0 5 6 3 6 5 0 Code \u00b6 class Solution { public : int maximalRectangle(vector < vector < char > > & matrix) { if (matrix.empty()) return 0 ; const int m = matrix.size(); const int n = matrix[ 0 ].size(); int left[n], right[n], height[n]; fill_n(left,n, 0 ); fill_n(right,n,n); fill_n(height,n, 0 ); int maxA = 0 ; for ( int i =0 ; i < m; i ++ ) { int cur_left =0 , cur_right = n; for ( int j =0 ; j < n; j ++ ) { // compute height (can do this from either side) if (matrix[i][j] == '1' ) height[j] ++ ; else height[j] =0 ; } for ( int j =0 ; j < n; j ++ ) { // compute left (from left to right) if (matrix[i][j] == '1' ) left[j] = max(left[j],cur_left); else {left[j] =0 ; cur_left = j +1 ;} } // compute right (from right to left) for ( int j = n -1 ; j >=0 ; j -- ) { if (matrix[i][j] == '1' ) right[j] = min(right[j],cur_right); else {right[j] = n; cur_right = j;} } // compute the area of rectangle (can do this from either side) for ( int j =0 ; j < n; j ++ ) maxA = max(maxA,(right[j] - left[j]) * height[j]); } return maxA; }","title":"Maximal Rectangle"},{"location":"Leetcode/85.-maximal-rectangle/#maximal-rectangle","text":"Given a rows x cols binary matrix filled with 0 's and 1 's, find the largest rectangle containing only 1 's and return its area . Example 1: Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2: Input: matrix = [] Output: 0 Example 3: Input: matrix = [[\"0\"]] Output: 0 Example 4: Input: matrix = [[\"1\"]] Output: 1 Example 5: Input: matrix = [[\"0\",\"0\"]] Output: 0 Constraints: rows == matrix.length cols == matrix[i].length 0 <= row, cols <= 200 matrix[i][j] is '0' or '1' .","title":"Maximal Rectangle"},{"location":"Leetcode/85.-maximal-rectangle/#analysis","text":"height[i] record the current number of countinous '1' in column i; left[i] record the left most index j which satisfies that for any index k from j to i, height[k] >= height[i]; right[i] record the right most index j which satifies that for any index k from i to j, height[k] >= height[i]; if j doesn't exist, then use size of matrix to represent j for right, use 0 to represent j for left matrix 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 height 0 0 0 1 0 0 0 0 0 1 2 1 0 0 0 1 2 3 2 1 0 left 0 0 0 3 0 0 0 0 0 2 3 2 0 0 0 1 2 3 2 1 0 right 7 7 7 4 7 7 7 // at index i from right to left, if height[i] >= height[i+1], set right[i]=i or keep going 7 7 5 4 5 7 7 7 6 5 4 5 4 7 result 0 0 0 1 0 0 0 0 0 3 2 3 0 0 0 5 6 3 6 5 0","title":"Analysis"},{"location":"Leetcode/85.-maximal-rectangle/#code","text":"class Solution { public : int maximalRectangle(vector < vector < char > > & matrix) { if (matrix.empty()) return 0 ; const int m = matrix.size(); const int n = matrix[ 0 ].size(); int left[n], right[n], height[n]; fill_n(left,n, 0 ); fill_n(right,n,n); fill_n(height,n, 0 ); int maxA = 0 ; for ( int i =0 ; i < m; i ++ ) { int cur_left =0 , cur_right = n; for ( int j =0 ; j < n; j ++ ) { // compute height (can do this from either side) if (matrix[i][j] == '1' ) height[j] ++ ; else height[j] =0 ; } for ( int j =0 ; j < n; j ++ ) { // compute left (from left to right) if (matrix[i][j] == '1' ) left[j] = max(left[j],cur_left); else {left[j] =0 ; cur_left = j +1 ;} } // compute right (from right to left) for ( int j = n -1 ; j >=0 ; j -- ) { if (matrix[i][j] == '1' ) right[j] = min(right[j],cur_right); else {right[j] = n; cur_right = j;} } // compute the area of rectangle (can do this from either side) for ( int j =0 ; j < n; j ++ ) maxA = max(maxA,(right[j] - left[j]) * height[j]); } return maxA; }","title":"Code"},{"location":"Leetcode/87.-scramble-string/","text":"Scramble String \u00b6 We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s , divide it to x and y where s = x + y . Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x . Apply step 1 recursively on each of the two substrings x and y . Given two strings s1 and s2 of the same length , return true if s2 is a scrambled string of s1 , otherwise, return false . Example 1: Input: s1 = \"great\", s2 = \"rgeat\" Output: true Explanation: One possible scenario applied on s1 is: \"great\" --> \"gr/eat\" // divide at random index. \"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order. \"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at ranom index each of them. \"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order. \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\". \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order. The algorithm stops now and the result string is \"rgeat\" which is s2. As there is one possible scenario that led s1 to be scrambled to s2, we return true. Example 2: Input: s1 = \"abcde\", s2 = \"caebd\" Output: false Example 3: Input: s1 = \"a\", s2 = \"a\" Output: true Constraints: s1.length == s2.length 1 <= s1.length <= 30 s1 and s2 consist of lower-case English letters. Using cache + recursion \u00b6 class Solution { bool DP_helper (unordered_map < string, bool > & isScramblePair, string s1, string s2) { int i,len = s1.size(); bool res = false ; if ( 0== len) return true ; else if ( 1== len) return s1 == s2; else { if (isScramblePair.count(s1 + s2)) return isScramblePair[s1 + s2]; // checked before, return intermediate result directly if (s1 == s2) res = true ; else { for (i =1 ; i < len && ! res; ++ i) { //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr( 0 ,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr(i,len - i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr(len - i,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr( 0 ,len - i))); } } return isScramblePair[s1 + s2] = res; //save the intermediate results } } public : bool isScramble(string s1, string s2) { unordered_map < string, bool > isScramblePair; return DP_helper (isScramblePair, s1, s2); } }; A string can be rotated anyway. There are four things to compare between two strings: s1: 111i222len s2: 333i444len 111 && 333 222 && 444 or 111 && 444 222 && 333 DP bottom-up \u00b6 class Solution { public : bool isScramble(string s1, string s2) { int sSize = s1.size(), len, i, j, k; if ( 0== sSize) return true ; if ( 1== sSize) return s1 == s2; bool isS[sSize +1 ][sSize][sSize]; for (i =0 ; i < sSize; ++ i) for (j =0 ; j < sSize; ++ j) isS[ 1 ][i][j] = s1[i] == s2[j]; for (len =2 ; len <= sSize; ++ len) for (i =0 ; i <= sSize - len; ++ i) for (j =0 ; j <= sSize - len; ++ j) { isS[len][i][j] = false ; for (k =1 ; k < len && ! isS[len][i][j]; ++ k) { isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len - k][i + k][j + k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i + len - k][j] && isS[len - k][i][j + k]); } } return isS[sSize][ 0 ][ 0 ]; } }; dp[len][i][j]: s1[i..i+len-1] is a scramble of s2[j..j+len-1] 1. init: all single char can match if they are the same (line 11) 2. dp[len][i][j] = (dp[k][i][j] && dp[len-k][i+k][j+k]) || (dp[k][i+len-k][j] && dp[len-k][i][j+k]) Time Complexity \u00b6 n^4 for all cases","title":"Scramble String"},{"location":"Leetcode/87.-scramble-string/#scramble-string","text":"We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s , divide it to x and y where s = x + y . Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x . Apply step 1 recursively on each of the two substrings x and y . Given two strings s1 and s2 of the same length , return true if s2 is a scrambled string of s1 , otherwise, return false . Example 1: Input: s1 = \"great\", s2 = \"rgeat\" Output: true Explanation: One possible scenario applied on s1 is: \"great\" --> \"gr/eat\" // divide at random index. \"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order. \"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at ranom index each of them. \"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order. \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\". \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order. The algorithm stops now and the result string is \"rgeat\" which is s2. As there is one possible scenario that led s1 to be scrambled to s2, we return true. Example 2: Input: s1 = \"abcde\", s2 = \"caebd\" Output: false Example 3: Input: s1 = \"a\", s2 = \"a\" Output: true Constraints: s1.length == s2.length 1 <= s1.length <= 30 s1 and s2 consist of lower-case English letters.","title":"Scramble String"},{"location":"Leetcode/87.-scramble-string/#using-cache-recursion","text":"class Solution { bool DP_helper (unordered_map < string, bool > & isScramblePair, string s1, string s2) { int i,len = s1.size(); bool res = false ; if ( 0== len) return true ; else if ( 1== len) return s1 == s2; else { if (isScramblePair.count(s1 + s2)) return isScramblePair[s1 + s2]; // checked before, return intermediate result directly if (s1 == s2) res = true ; else { for (i =1 ; i < len && ! res; ++ i) { //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr( 0 ,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr(i,len - i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr(len - i,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr( 0 ,len - i))); } } return isScramblePair[s1 + s2] = res; //save the intermediate results } } public : bool isScramble(string s1, string s2) { unordered_map < string, bool > isScramblePair; return DP_helper (isScramblePair, s1, s2); } }; A string can be rotated anyway. There are four things to compare between two strings: s1: 111i222len s2: 333i444len 111 && 333 222 && 444 or 111 && 444 222 && 333","title":"Using cache + recursion"},{"location":"Leetcode/87.-scramble-string/#dp-bottom-up","text":"class Solution { public : bool isScramble(string s1, string s2) { int sSize = s1.size(), len, i, j, k; if ( 0== sSize) return true ; if ( 1== sSize) return s1 == s2; bool isS[sSize +1 ][sSize][sSize]; for (i =0 ; i < sSize; ++ i) for (j =0 ; j < sSize; ++ j) isS[ 1 ][i][j] = s1[i] == s2[j]; for (len =2 ; len <= sSize; ++ len) for (i =0 ; i <= sSize - len; ++ i) for (j =0 ; j <= sSize - len; ++ j) { isS[len][i][j] = false ; for (k =1 ; k < len && ! isS[len][i][j]; ++ k) { isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len - k][i + k][j + k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i + len - k][j] && isS[len - k][i][j + k]); } } return isS[sSize][ 0 ][ 0 ]; } }; dp[len][i][j]: s1[i..i+len-1] is a scramble of s2[j..j+len-1] 1. init: all single char can match if they are the same (line 11) 2. dp[len][i][j] = (dp[k][i][j] && dp[len-k][i+k][j+k]) || (dp[k][i+len-k][j] && dp[len-k][i][j+k])","title":"DP bottom-up"},{"location":"Leetcode/87.-scramble-string/#time-complexity","text":"n^4 for all cases","title":"Time Complexity"},{"location":"Leetcode/876.-Middle-of-the-Linked-List/","text":"Middle of the Linked List \u00b6 Given the head of a singly linked list, return the middle node of the linked list . If there are two middle nodes, return the second middle node. Example 1: Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints: The number of nodes in the list is in the range [1, 100] . 1 <= Node.val <= 100 Analysis \u00b6 This question can be solved by two pointers: one pointer moves one step each turn and the other moves two steps, so when the fast pointer has reached to the end of the linkedlist, the slow pointer will be at the middle of the linkedlist. Since we want to return the second middle pointer from the linkedlist, we need to make sure the fast pointer is pointing to the next, which is null, of the last pointer. Time: O(n / 2) O(n / 2) or O(n) O(n) Space: O(1) O(1) Code \u00b6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode(ListNode * head) { ListNode * a = head, * b = head; while (b && b -> next) { a = a -> next; b = b -> next -> next; } return a; } };","title":"Middle of the Linked List"},{"location":"Leetcode/876.-Middle-of-the-Linked-List/#middle-of-the-linked-list","text":"Given the head of a singly linked list, return the middle node of the linked list . If there are two middle nodes, return the second middle node. Example 1: Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints: The number of nodes in the list is in the range [1, 100] . 1 <= Node.val <= 100","title":"Middle of the Linked List"},{"location":"Leetcode/876.-Middle-of-the-Linked-List/#analysis","text":"This question can be solved by two pointers: one pointer moves one step each turn and the other moves two steps, so when the fast pointer has reached to the end of the linkedlist, the slow pointer will be at the middle of the linkedlist. Since we want to return the second middle pointer from the linkedlist, we need to make sure the fast pointer is pointing to the next, which is null, of the last pointer. Time: O(n / 2) O(n / 2) or O(n) O(n) Space: O(1) O(1)","title":"Analysis"},{"location":"Leetcode/876.-Middle-of-the-Linked-List/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode(ListNode * head) { ListNode * a = head, * b = head; while (b && b -> next) { a = a -> next; b = b -> next -> next; } return a; } };","title":"Code"},{"location":"Leetcode/91.-decode-ways/","text":"Decode Ways \u00b6 A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer. Example 1: Input: s = \"12\" Output: 2 Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: s = \"226\" Output: 3 Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Example 3: Input: s = \"0\" Output: 0 Explanation: There is no character that is mapped to a number starting with '0'. We cannot ignore a zero when we face it while decoding. So, each '0' should be part of \"10\" --> 'J' or \"20\" --> 'T'. Example 4: Input: s = \"1\" Output: 1 Constraints: 1 <= s.length <= 100 s contains only digits and may contain leading zero(s). java \u00b6 public class Solution { public int numDecodings (String s) { if (s == null || s. length () == 0 ) { return 0 ; } int n = s. length (); int [] dp = new int [ n +1] ; dp [0] = 1 ; // # of ways to decode for empty s dp [1] = s. charAt ( 0 ) != '0' ? 1 : 0 ; // 0 cannot be leading element for a number for ( int i = 2 ; i <= n; i ++ ) { int first = Integer. valueOf (s. substring (i -1 , i)); // s[i-1:i] int second = Integer. valueOf (s. substring (i -2 , i)); // s[i-2:i] if (first >= 1 && first <= 9 ) { dp [ i ] += dp [ i -1] ; } if (second >= 10 && second <= 26 ) { dp [ i ] += dp [ i -2] ; } } return dp [ n ] ; } } dp[i]: number of ways to decode 1. dp[i] += dp[i-1] if s[i-1:i] is valid (single digit: range from 0-9) 2. dp[i] += dp[i-2] if s[i-2:i] is valid (two digits: range from 10-26) cpp \u00b6 int numDecodings (string s) { int n = s.size(); vector < int > dp(n +1 ); dp[n] = 1 ; for ( int i = n - 1 ; ~ i; i -- ) { // from back to front if (s[i] == '0' ) dp[i] =0 ; else { dp[i] = dp[i +1 ]; if (i < n -1 && (s[i] == '1' || s[i] == '2' && s[i +1 ] < '7' )) dp[i] += dp[i +2 ]; } } return s.empty() ? 0 : dp[ 0 ]; } dp[i] += dp[i+2] if 1. s[i] == 1, so that any s[i+2] is valid, s[i:i+1] is in range 10-19 2. s[i] == 2 and s[i+1] < 7, so that s[i:i+1] is in range 20-26 if s[i] == 0, then dp[i] = 0, because 0 cannot be leading optimize with constant space \u00b6 class Solution { public : int numDecodings(string s) { int n = s.size(); int pre = 1 , prepre = 1 , curr = 1 ; for ( int i = n -1 ;i >=0 ;i -- ) { // from back to front if (s[i] == '0' ) curr =0 ; else { curr = pre; if (i < n -1 && (s[i] == '1' || s[i] == '2' && s[i +1 ] < '7' )) curr += prepre; } prepre = pre; pre = curr; curr = 1 ; } return s.empty() ? 0 : pre; } }; only needs two more states from current state, so 1. pre: s[i:i+1] 2. prepre: s[i:i+2]","title":"Decode Ways"},{"location":"Leetcode/91.-decode-ways/#decode-ways","text":"A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer. Example 1: Input: s = \"12\" Output: 2 Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: s = \"226\" Output: 3 Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Example 3: Input: s = \"0\" Output: 0 Explanation: There is no character that is mapped to a number starting with '0'. We cannot ignore a zero when we face it while decoding. So, each '0' should be part of \"10\" --> 'J' or \"20\" --> 'T'. Example 4: Input: s = \"1\" Output: 1 Constraints: 1 <= s.length <= 100 s contains only digits and may contain leading zero(s).","title":"Decode Ways"},{"location":"Leetcode/91.-decode-ways/#java","text":"public class Solution { public int numDecodings (String s) { if (s == null || s. length () == 0 ) { return 0 ; } int n = s. length (); int [] dp = new int [ n +1] ; dp [0] = 1 ; // # of ways to decode for empty s dp [1] = s. charAt ( 0 ) != '0' ? 1 : 0 ; // 0 cannot be leading element for a number for ( int i = 2 ; i <= n; i ++ ) { int first = Integer. valueOf (s. substring (i -1 , i)); // s[i-1:i] int second = Integer. valueOf (s. substring (i -2 , i)); // s[i-2:i] if (first >= 1 && first <= 9 ) { dp [ i ] += dp [ i -1] ; } if (second >= 10 && second <= 26 ) { dp [ i ] += dp [ i -2] ; } } return dp [ n ] ; } } dp[i]: number of ways to decode 1. dp[i] += dp[i-1] if s[i-1:i] is valid (single digit: range from 0-9) 2. dp[i] += dp[i-2] if s[i-2:i] is valid (two digits: range from 10-26)","title":"java"},{"location":"Leetcode/91.-decode-ways/#cpp","text":"int numDecodings (string s) { int n = s.size(); vector < int > dp(n +1 ); dp[n] = 1 ; for ( int i = n - 1 ; ~ i; i -- ) { // from back to front if (s[i] == '0' ) dp[i] =0 ; else { dp[i] = dp[i +1 ]; if (i < n -1 && (s[i] == '1' || s[i] == '2' && s[i +1 ] < '7' )) dp[i] += dp[i +2 ]; } } return s.empty() ? 0 : dp[ 0 ]; } dp[i] += dp[i+2] if 1. s[i] == 1, so that any s[i+2] is valid, s[i:i+1] is in range 10-19 2. s[i] == 2 and s[i+1] < 7, so that s[i:i+1] is in range 20-26 if s[i] == 0, then dp[i] = 0, because 0 cannot be leading","title":"cpp"},{"location":"Leetcode/91.-decode-ways/#optimize-with-constant-space","text":"class Solution { public : int numDecodings(string s) { int n = s.size(); int pre = 1 , prepre = 1 , curr = 1 ; for ( int i = n -1 ;i >=0 ;i -- ) { // from back to front if (s[i] == '0' ) curr =0 ; else { curr = pre; if (i < n -1 && (s[i] == '1' || s[i] == '2' && s[i +1 ] < '7' )) curr += prepre; } prepre = pre; pre = curr; curr = 1 ; } return s.empty() ? 0 : pre; } }; only needs two more states from current state, so 1. pre: s[i:i+1] 2. prepre: s[i:i+2]","title":"optimize with constant space"},{"location":"Leetcode/93.-restore-ip-addresses/","text":"Restore IP addresses \u00b6 Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s . You can return them in any order. A valid IP address consists of exactly four integers, each integer is between 0 and 255 , separated by single dots and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses and \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses. Example 1: Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] Example 2: Input: s = \"0000\" Output: [\"0.0.0.0\"] Example 3: Input: s = \"1111\" Output: [\"1.1.1.1\"] Example 4: Input: s = \"010010\" Output: [\"0.10.0.10\",\"0.100.1.0\"] Example 5: Input: s = \"101023\" Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] Constraints: 0 <= s.length <= 3000 s consists of digits only. Analysis \u00b6 find all the possible location i for inserting '.' check if the resulting segament is valid insert the '.' try next possible location Time: O(n^n) O(n^n) n branches (for loop) and n height (idx in [0, n]) Space: O(n) O(n) height of the recurison tree Code \u00b6 class Solution { public : vector < string > res; bool inline valid(string sub) { int d = atoi(sub.c_str()); if (sub[ 0 ] == '0' ) return d == 0 && sub.size() == 1 ; // only if '0' else return d < 256 && sub.size() <= 3 ; // only if less than 256 and has a digits less than 3 } // idx: starting pos of the ip segament to try void h( int idx, int part, string ip) { if (part == 3 ) { if (valid(ip.substr(idx))) res.push_back(ip); return ; } for ( int i = 1 ; i <= 3 && idx + i < ip.size(); ++ i) { if ( ! valid(ip.substr(idx, i))) continue ; ip.insert(idx + i, \".\" ); h(idx + i + 1 , part + 1 , ip); ip.erase(idx + i, 1 ); } } vector < string > restoreIpAddresses(string s) { h( 0 , 0 , s); return res; } };","title":"Restore IP addresses"},{"location":"Leetcode/93.-restore-ip-addresses/#restore-ip-addresses","text":"Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s . You can return them in any order. A valid IP address consists of exactly four integers, each integer is between 0 and 255 , separated by single dots and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses and \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses. Example 1: Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] Example 2: Input: s = \"0000\" Output: [\"0.0.0.0\"] Example 3: Input: s = \"1111\" Output: [\"1.1.1.1\"] Example 4: Input: s = \"010010\" Output: [\"0.10.0.10\",\"0.100.1.0\"] Example 5: Input: s = \"101023\" Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] Constraints: 0 <= s.length <= 3000 s consists of digits only.","title":"Restore IP addresses"},{"location":"Leetcode/93.-restore-ip-addresses/#analysis","text":"find all the possible location i for inserting '.' check if the resulting segament is valid insert the '.' try next possible location Time: O(n^n) O(n^n) n branches (for loop) and n height (idx in [0, n]) Space: O(n) O(n) height of the recurison tree","title":"Analysis"},{"location":"Leetcode/93.-restore-ip-addresses/#code","text":"class Solution { public : vector < string > res; bool inline valid(string sub) { int d = atoi(sub.c_str()); if (sub[ 0 ] == '0' ) return d == 0 && sub.size() == 1 ; // only if '0' else return d < 256 && sub.size() <= 3 ; // only if less than 256 and has a digits less than 3 } // idx: starting pos of the ip segament to try void h( int idx, int part, string ip) { if (part == 3 ) { if (valid(ip.substr(idx))) res.push_back(ip); return ; } for ( int i = 1 ; i <= 3 && idx + i < ip.size(); ++ i) { if ( ! valid(ip.substr(idx, i))) continue ; ip.insert(idx + i, \".\" ); h(idx + i + 1 , part + 1 , ip); ip.erase(idx + i, 1 ); } } vector < string > restoreIpAddresses(string s) { h( 0 , 0 , s); return res; } };","title":"Code"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/","text":"Unique Binary Search Trees II \u00b6 Given an integer n , return all the structurally unique BST' s (binary search trees), which has exactly n nodes of unique values from 1 to n . Return the answer in any order . Example 1: Input: n = 3 Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] Example 2: Input: n = 1 Output: [[1]] Constraints: 1 <= n <= 8 Analysis \u00b6 start.... i .....end for all left from start to i - 1: for all right from i + 1 to end: root -> left = choose one from all left root -> right = choose one from all right Time Compleixty: O(n!) O(n!) since each node could be the root node, and for each root there could have n - 1 configuration of left (so does right subtree), and doing the process recursively will yield n \\times (n - 1) ... \\times 1 = n! n \\times (n - 1) ... \\times 1 = n! c++ \u00b6 class Solution { public : vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; return helper ( 1 , n); } vector < TreeNode *> helper( int start, int end) { if (start > end) return {nullptr}; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 ), right = helper(i + 1 , end); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return res; } }; with MEMO + DP class Solution { public : vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; vector < vector < vector < TreeNode *>>> memo(n, vector < vector < TreeNode *>> (n)); return helper ( 1 , n, memo); } vector < TreeNode *> helper( int start, int end, vector < vector < vector < TreeNode *>>>& memo) { if (start > end) return { nullptr }; if ( ! memo[start - 1 ][end - 1 ].empty()) return memo[start - 1 ][end - 1 ]; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 , memo), right = helper(i + 1 , end, memo); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return memo[start - 1 ][end - 1 ] = res; } }; memo[i][j][k]: save current tree (root) with left starts from i - 1, right starts from j - 1","title":"Unique Binary Search Trees II"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#unique-binary-search-trees-ii","text":"Given an integer n , return all the structurally unique BST' s (binary search trees), which has exactly n nodes of unique values from 1 to n . Return the answer in any order . Example 1: Input: n = 3 Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] Example 2: Input: n = 1 Output: [[1]] Constraints: 1 <= n <= 8","title":"Unique Binary Search Trees II"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#analysis","text":"start.... i .....end for all left from start to i - 1: for all right from i + 1 to end: root -> left = choose one from all left root -> right = choose one from all right Time Compleixty: O(n!) O(n!) since each node could be the root node, and for each root there could have n - 1 configuration of left (so does right subtree), and doing the process recursively will yield n \\times (n - 1) ... \\times 1 = n! n \\times (n - 1) ... \\times 1 = n!","title":"Analysis"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#c","text":"class Solution { public : vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; return helper ( 1 , n); } vector < TreeNode *> helper( int start, int end) { if (start > end) return {nullptr}; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 ), right = helper(i + 1 , end); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return res; } }; with MEMO + DP class Solution { public : vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; vector < vector < vector < TreeNode *>>> memo(n, vector < vector < TreeNode *>> (n)); return helper ( 1 , n, memo); } vector < TreeNode *> helper( int start, int end, vector < vector < vector < TreeNode *>>>& memo) { if (start > end) return { nullptr }; if ( ! memo[start - 1 ][end - 1 ].empty()) return memo[start - 1 ][end - 1 ]; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 , memo), right = helper(i + 1 , end, memo); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return memo[start - 1 ][end - 1 ] = res; } }; memo[i][j][k]: save current tree (root) with left starts from i - 1, right starts from j - 1","title":"c++"},{"location":"Leetcode/952.-largest-component-size-by-common-factor/","text":"Largest Component Size by Common Factor \u00b6 Given a non-empty array of unique positive integers A , consider the following graph: There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. Example 1: Input: [4,6,15,35] Output: 4 Example 2: Input: [20,50,9,63] Output: 2 Example 3: Input: [2,3,6,7,4,12,21,39] Output: 8 Note: 1 <= A.length <= 20000 1 <= A[i] <= 100000 Analysis - Union-Find w/o Math \u00b6 tldr: By using map we can save the space from max(array) to sqrt(max(array)). This question is basically asking the largest connected component in a forest. In order to do so, we need to find a way to \"group\" all the nodes whose common divisor (one by one, not among any two) is greater than 1 together to a single tree, and we need a \"root\" as an id to quantify how many kids does this tree hold. This leads to Union-Find. step 1 build the graph: * start with all the nodes themselves, they are \"self-connected\" step 2 find all the divisor of current node * after we put node value to the tree, we also need to group all the divisor >= 2 with current root node. * this can be done with sqrt(n) times, since any two divisor a * b < n, a has to be less than sqrt(n). step 3 check the root and do the counting * now we have built our tree, and we can easily find the root node (or id) for each node, we can just count the number of id and find the max. Code \u00b6 class Solution { public : unordered_map < int , int > p; int find ( int a) { if ( ! p.count(a)) return p[a] = a; if (p[a] == a) return a; return p[a] = find(p[a]); } int largestComponentSize (vector < int >& A) { int n = A.size(); for ( int a : A) p[a] = a; for ( int a : A) for ( int i = 2 ; i <= sqrt(a); ++ i) { if (a % i == 0 ) { p[find(a)] = p[find(i)]; p[find(a)] = p[find(a / i)]; } } unordered_map < int , int > cnt; int res = 1 ; for ( int a : A) res = max(res, ++ cnt[find(a)]); return res; } }; Q&A: why for (int a : A) for (int i = 2; i <= sqrt(a); ++i) if (a % i == 0) { p[find(a)] = p[find(i)]; p[find(a)] = p[find(a / i)]; } instead of for (int a : A) for (int i = 2; i <= sqrt(a); ++i) { int root = find(a); if (a % i == 0) { p[root] = p[find(i)]; p[root] = p[find(a / i)]; } } Because our root is going to change every time when the p map is updated. Analysis: Union-Find w/ Prime Sieve \u00b6 Code \u00b6 class Solution { const static int N = 100001 ; int parent[N]; int m[N]; int size[N]; int root ( int val){ while (val != parent[val]) { parent[val] = parent[parent[val]]; val = parent[val]; } return val; } int unionize ( int x, int y){ int r1 = root(x); int r2 = root(y); if (r1 == r2) return size[r1]; parent[r1] = r2; size[r2] += size[r1]; return size[r2]; } // sieve algo void findPrime (vector < int > & prime){ prime.resize(N, 0 ); for ( int i = 2 ; i * i < N; i ++ ) if (prime[i] == 0 ) for ( int j = i * i; j < N; j += i) prime[j] = i; for ( int i = 2 ; i < N; ++ i) if (prime[i] == 0 ) prime[i] = i; } void init ( int n){ for ( int i = 0 ; i < n; ++ i){ parent[i] = i; size[i] = 1 ; m[i] = -1 ; } } public : int largestComponentSize(vector < int >& A) { static vector < int > prime; init ( * max_element(A.begin(), A.end())); int res = 0 ; if (prime.empty()) findPrime(prime); for ( auto a : A) { int cur = a; while (a > 1 ){ int p = prime[a]; if (m[p] == -1 ) m[p] = cur; res = max(res , unionize(m[p],cur)); //remove all prime factors p from a while (prime[a] == p) a /= p; } } return res; } };","title":"Largest Component Size by Common Factor"},{"location":"Leetcode/952.-largest-component-size-by-common-factor/#largest-component-size-by-common-factor","text":"Given a non-empty array of unique positive integers A , consider the following graph: There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. Example 1: Input: [4,6,15,35] Output: 4 Example 2: Input: [20,50,9,63] Output: 2 Example 3: Input: [2,3,6,7,4,12,21,39] Output: 8 Note: 1 <= A.length <= 20000 1 <= A[i] <= 100000","title":"Largest Component Size by Common Factor"},{"location":"Leetcode/952.-largest-component-size-by-common-factor/#analysis-union-find-wo-math","text":"tldr: By using map we can save the space from max(array) to sqrt(max(array)). This question is basically asking the largest connected component in a forest. In order to do so, we need to find a way to \"group\" all the nodes whose common divisor (one by one, not among any two) is greater than 1 together to a single tree, and we need a \"root\" as an id to quantify how many kids does this tree hold. This leads to Union-Find. step 1 build the graph: * start with all the nodes themselves, they are \"self-connected\" step 2 find all the divisor of current node * after we put node value to the tree, we also need to group all the divisor >= 2 with current root node. * this can be done with sqrt(n) times, since any two divisor a * b < n, a has to be less than sqrt(n). step 3 check the root and do the counting * now we have built our tree, and we can easily find the root node (or id) for each node, we can just count the number of id and find the max.","title":"Analysis - Union-Find w/o Math"},{"location":"Leetcode/952.-largest-component-size-by-common-factor/#code","text":"class Solution { public : unordered_map < int , int > p; int find ( int a) { if ( ! p.count(a)) return p[a] = a; if (p[a] == a) return a; return p[a] = find(p[a]); } int largestComponentSize (vector < int >& A) { int n = A.size(); for ( int a : A) p[a] = a; for ( int a : A) for ( int i = 2 ; i <= sqrt(a); ++ i) { if (a % i == 0 ) { p[find(a)] = p[find(i)]; p[find(a)] = p[find(a / i)]; } } unordered_map < int , int > cnt; int res = 1 ; for ( int a : A) res = max(res, ++ cnt[find(a)]); return res; } }; Q&A: why for (int a : A) for (int i = 2; i <= sqrt(a); ++i) if (a % i == 0) { p[find(a)] = p[find(i)]; p[find(a)] = p[find(a / i)]; } instead of for (int a : A) for (int i = 2; i <= sqrt(a); ++i) { int root = find(a); if (a % i == 0) { p[root] = p[find(i)]; p[root] = p[find(a / i)]; } } Because our root is going to change every time when the p map is updated.","title":"Code"},{"location":"Leetcode/952.-largest-component-size-by-common-factor/#analysis-union-find-w-prime-sieve","text":"","title":"Analysis: Union-Find w/ Prime Sieve"},{"location":"Leetcode/952.-largest-component-size-by-common-factor/#code_1","text":"class Solution { const static int N = 100001 ; int parent[N]; int m[N]; int size[N]; int root ( int val){ while (val != parent[val]) { parent[val] = parent[parent[val]]; val = parent[val]; } return val; } int unionize ( int x, int y){ int r1 = root(x); int r2 = root(y); if (r1 == r2) return size[r1]; parent[r1] = r2; size[r2] += size[r1]; return size[r2]; } // sieve algo void findPrime (vector < int > & prime){ prime.resize(N, 0 ); for ( int i = 2 ; i * i < N; i ++ ) if (prime[i] == 0 ) for ( int j = i * i; j < N; j += i) prime[j] = i; for ( int i = 2 ; i < N; ++ i) if (prime[i] == 0 ) prime[i] = i; } void init ( int n){ for ( int i = 0 ; i < n; ++ i){ parent[i] = i; size[i] = 1 ; m[i] = -1 ; } } public : int largestComponentSize(vector < int >& A) { static vector < int > prime; init ( * max_element(A.begin(), A.end())); int res = 0 ; if (prime.empty()) findPrime(prime); for ( auto a : A) { int cur = a; while (a > 1 ){ int p = prime[a]; if (m[p] == -1 ) m[p] = cur; res = max(res , unionize(m[p],cur)); //remove all prime factors p from a while (prime[a] == p) a /= p; } } return res; } };","title":"Code"},{"location":"Leetcode/96.-unique-binary-search-trees-%E2%80%94-my-method/","text":"Unique Binary Search Trees -- My Method \u00b6 Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Analysis \u00b6 We don't need to find the detail configuration for the trees, so we can use DP. DP[i]: from 0~i, total number of subtrees DP[i + 1] = left subtree * right subtree = dp[left to root] * dp[root to right] Time Complexity: O(n^2) O(n^2) Space Complexity: O(n) O(n) Code \u00b6 class Solution { public : int numTrees( int n) { int dp[n + 1 ]; memset(dp, 0 , sizeof dp); dp[ 1 ] = 1 ; dp[ 0 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) // j is root dp[i] += dp[j - 1 ] * dp[i - j]; // left subtree * right subtree } return dp[n]; } };","title":"Unique Binary Search Trees -- My Method"},{"location":"Leetcode/96.-unique-binary-search-trees-%E2%80%94-my-method/#unique-binary-search-trees-my-method","text":"Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5","title":"Unique Binary Search Trees -- My Method"},{"location":"Leetcode/96.-unique-binary-search-trees-%E2%80%94-my-method/#analysis","text":"We don't need to find the detail configuration for the trees, so we can use DP. DP[i]: from 0~i, total number of subtrees DP[i + 1] = left subtree * right subtree = dp[left to root] * dp[root to right] Time Complexity: O(n^2) O(n^2) Space Complexity: O(n) O(n)","title":"Analysis"},{"location":"Leetcode/96.-unique-binary-search-trees-%E2%80%94-my-method/#code","text":"class Solution { public : int numTrees( int n) { int dp[n + 1 ]; memset(dp, 0 , sizeof dp); dp[ 1 ] = 1 ; dp[ 0 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) // j is root dp[i] += dp[j - 1 ] * dp[i - j]; // left subtree * right subtree } return dp[n]; } };","title":"Code"},{"location":"Leetcode/96.-unique-binary-search-trees/","text":"Unique Binary Search Trees \u00b6 Given an integer n , return the number of structurally unique BST' s (binary search trees) which has exactly n nodes of unique values from 1 to n . Example 1: Input: n = 3 Output: 5 Example 2: Input: n = 1 Output: 1 Constraints: 1 <= n <= 19 Analysis \u00b6 The problem can be solved in a dynamic programming way. I\u2019ll explain the intuition and formulas in the following. Given a sequence 1\u2026n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1\u2026(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)\u2026n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique , since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 <= i <= n: the number of unique BST , where the number i is the root of BST , and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root. i.e. G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree). i.e. G(0)=1, G(1)=1. Given a sequence 1\u2026n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. F(i, n) = G(i-1) * G(n-i) 1 <= i <= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \u2026 + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) \u2026 G(n-1). With the above explanation and formulas, here is the implementation in Java. public int numTrees( int n) { int [] G = new int [n +1 ]; G[ 0 ] = G[ 1 ] = 1 ; for ( int i =2 ; i <= n; ++ i) { for ( int j =1 ; j <= i; ++ j) { G[i] += G[j -1 ] * G[i - j]; } } return G[n]; } in cpp \u00b6 public int numTrees( int n) { int G[n +1 ]; fill_n(G, n +1 , 0 ); G[ 0 ] = G[ 1 ] = 1 ; for ( int i =2 ; i <= n; ++ i) { for ( int j =1 ; j <= i; ++ j) { G[i] += G[j -1 ] * G[i - j]; } } return G[n]; }","title":"Unique Binary Search Trees"},{"location":"Leetcode/96.-unique-binary-search-trees/#unique-binary-search-trees","text":"Given an integer n , return the number of structurally unique BST' s (binary search trees) which has exactly n nodes of unique values from 1 to n . Example 1: Input: n = 3 Output: 5 Example 2: Input: n = 1 Output: 1 Constraints: 1 <= n <= 19","title":"Unique Binary Search Trees"},{"location":"Leetcode/96.-unique-binary-search-trees/#analysis","text":"The problem can be solved in a dynamic programming way. I\u2019ll explain the intuition and formulas in the following. Given a sequence 1\u2026n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1\u2026(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)\u2026n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique , since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 <= i <= n: the number of unique BST , where the number i is the root of BST , and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root. i.e. G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree). i.e. G(0)=1, G(1)=1. Given a sequence 1\u2026n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. F(i, n) = G(i-1) * G(n-i) 1 <= i <= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \u2026 + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) \u2026 G(n-1). With the above explanation and formulas, here is the implementation in Java. public int numTrees( int n) { int [] G = new int [n +1 ]; G[ 0 ] = G[ 1 ] = 1 ; for ( int i =2 ; i <= n; ++ i) { for ( int j =1 ; j <= i; ++ j) { G[i] += G[j -1 ] * G[i - j]; } } return G[n]; }","title":"Analysis"},{"location":"Leetcode/96.-unique-binary-search-trees/#in-cpp","text":"public int numTrees( int n) { int G[n +1 ]; fill_n(G, n +1 , 0 ); G[ 0 ] = G[ 1 ] = 1 ; for ( int i =2 ; i <= n; ++ i) { for ( int j =1 ; j <= i; ++ j) { G[i] += G[j -1 ] * G[i - j]; } } return G[n]; }","title":"in cpp"},{"location":"Leetcode/97.-interleaving-string/","text":"Interleaving String \u00b6 Given strings s1 , s2 , and s3 , find whether s3 is formed by an interleaving of s1 and s2 . An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that: s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| <= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2+ t3 + s3 + ... Note: a + b is the concatenation of strings a and b . Example 1: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" Output: true Example 2: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" Output: false Example 3: Input: s1 = \"\", s2 = \"\", s3 = \"\" Output: true Constraints: 0 <= s1.length, s2.length <= 100 0 <= s3.length <= 200 s1 , s2 , and s3 consist of lower-case English letters. Analysis \u00b6 dp[i][j] : from s1[0:i] and s2[0:j] can be combined to s3[0:i+j-1] if current s[i+j-1] == s1[i] or s[i+j-1] == s2[j]: then meaning s[i+j-1] is possible to be formed by one of the two strings else set to false Time: O(m \\times n) O(m \\times n) where m is size of s1, and n is size of s2 Space: O(m \\times n) O(m \\times n) since need to populate the entire dp matrix Code \u00b6 class Solution { public : bool isInterleave(string s1, string s2, string s3) { int m = s1.size(), n = s2.size(), k = s3.size(); if (m + n != k) return false ; bool dp[m +1 ][n +1 ]; memset(dp, false , sizeof dp); for ( int i = 0 ; i <= m; ++ i) { for ( int j = 0 ; j <= n; ++ j) { if (i == 0 && j == 0 ) dp[i][j] = true ; else if (i == 0 ) dp[i][j] = dp[i][j -1 ] && s2[j -1 ] == s3[i + j -1 ]; else if (j == 0 ) dp[i][j] = dp[i -1 ][j] && s1[i -1 ] == s3[i + j -1 ]; else dp[i][j] = (dp[i -1 ][j] && s1[i -1 ] == s3[i + j -1 ]) || (dp[i][j -1 ] && s2[j -1 ] == s3[i + j -1 ]); } } return dp[m][n]; } };","title":"Interleaving String"},{"location":"Leetcode/97.-interleaving-string/#interleaving-string","text":"Given strings s1 , s2 , and s3 , find whether s3 is formed by an interleaving of s1 and s2 . An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that: s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| <= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2+ t3 + s3 + ... Note: a + b is the concatenation of strings a and b . Example 1: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" Output: true Example 2: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" Output: false Example 3: Input: s1 = \"\", s2 = \"\", s3 = \"\" Output: true Constraints: 0 <= s1.length, s2.length <= 100 0 <= s3.length <= 200 s1 , s2 , and s3 consist of lower-case English letters.","title":"Interleaving String"},{"location":"Leetcode/97.-interleaving-string/#analysis","text":"dp[i][j] : from s1[0:i] and s2[0:j] can be combined to s3[0:i+j-1] if current s[i+j-1] == s1[i] or s[i+j-1] == s2[j]: then meaning s[i+j-1] is possible to be formed by one of the two strings else set to false Time: O(m \\times n) O(m \\times n) where m is size of s1, and n is size of s2 Space: O(m \\times n) O(m \\times n) since need to populate the entire dp matrix","title":"Analysis"},{"location":"Leetcode/97.-interleaving-string/#code","text":"class Solution { public : bool isInterleave(string s1, string s2, string s3) { int m = s1.size(), n = s2.size(), k = s3.size(); if (m + n != k) return false ; bool dp[m +1 ][n +1 ]; memset(dp, false , sizeof dp); for ( int i = 0 ; i <= m; ++ i) { for ( int j = 0 ; j <= n; ++ j) { if (i == 0 && j == 0 ) dp[i][j] = true ; else if (i == 0 ) dp[i][j] = dp[i][j -1 ] && s2[j -1 ] == s3[i + j -1 ]; else if (j == 0 ) dp[i][j] = dp[i -1 ][j] && s1[i -1 ] == s3[i + j -1 ]; else dp[i][j] = (dp[i -1 ][j] && s1[i -1 ] == s3[i + j -1 ]) || (dp[i][j -1 ] && s2[j -1 ] == s3[i + j -1 ]); } } return dp[m][n]; } };","title":"Code"},{"location":"Leetcode/977.-Squares-of-a-Sorted-Array/","text":"Squares of a Sorted Array \u00b6 Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order . Example 1: Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2: Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums is sorted in non-decreasing order. Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach? Analysis \u00b6 This question can be solved using two pointers method to achieve linear time complexity. Since the given array has negative values, there is a possible case when nums[left] ^ 2 nums[left] ^ 2 is greater than nums[right] ^ 2 nums[right] ^ 2 . However, it is also true that from any points from left or from right, the square of each element is montonic increasing. The only exception to the previous statement is when left == right \u2013 when the two pointers met, and we can use that as the termination condition. Time: O(n) O(n) Space: O(n) O(n) for the solution array Code \u00b6 #define abs(x) (x > 0 ? x : -x) class Solution { public : vector < int > sortedSquares(vector < int >& nums) { int sz = nums.size(); vector < int > res(sz); for ( int l = 0 , r = sz - 1 , p = sz - 1 ; l <= r; -- p) { res[p] = (max(nums[l] * nums[l], nums[r] * nums[r])); // choose the next greatest one by eliminating the current largest one if (abs(nums[l]) > abs(nums[r])) l ++ ; else r -- ; } return res; } };","title":"Squares of a Sorted Array"},{"location":"Leetcode/977.-Squares-of-a-Sorted-Array/#squares-of-a-sorted-array","text":"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order . Example 1: Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2: Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums is sorted in non-decreasing order. Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?","title":"Squares of a Sorted Array"},{"location":"Leetcode/977.-Squares-of-a-Sorted-Array/#analysis","text":"This question can be solved using two pointers method to achieve linear time complexity. Since the given array has negative values, there is a possible case when nums[left] ^ 2 nums[left] ^ 2 is greater than nums[right] ^ 2 nums[right] ^ 2 . However, it is also true that from any points from left or from right, the square of each element is montonic increasing. The only exception to the previous statement is when left == right \u2013 when the two pointers met, and we can use that as the termination condition. Time: O(n) O(n) Space: O(n) O(n) for the solution array","title":"Analysis"},{"location":"Leetcode/977.-Squares-of-a-Sorted-Array/#code","text":"#define abs(x) (x > 0 ? x : -x) class Solution { public : vector < int > sortedSquares(vector < int >& nums) { int sz = nums.size(); vector < int > res(sz); for ( int l = 0 , r = sz - 1 , p = sz - 1 ; l <= r; -- p) { res[p] = (max(nums[l] * nums[l], nums[r] * nums[r])); // choose the next greatest one by eliminating the current largest one if (abs(nums[l]) > abs(nums[r])) l ++ ; else r -- ; } return res; } };","title":"Code"},{"location":"Leetcode/987.-Vertical-Order-Traversal-of-a-binary-tree/","text":"Vertical Order Traversal of a Binary Tree \u00b6 Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y) , its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1) . Running a vertical line from X = -infinity to X = +infinity , whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1: Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2). Example 2: Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is smaller than 6. Note: The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000 . Analysis \u00b6 To obtain the vertical order, we first need to understand how to \"order\" all the nodes in each vertical level. If we mark the root node as level 0, then for all the nodes on the left will be: -1, -2, -3 \u2026 -n. Vice versa, for all the nodes on the rght will be 1, 2, 3 \u2026 n. Depending on the position of the nodes, we can categorize all the nodes base on the level. However, there is one thing to be consider: if two nodes are on the same vertical and horizontal level (see last test case), we have to sort the nodes base on their value. This is a special case we need to consider, and thus besides the vertical order, we also need to record the horizontal order. To do so, we need a sorted map which looks like: {vertical level, {horizonal level, sorted value}} Which yield: map<int, map<int, set<int>> (here we assume all the nodes have different values, if there could have same values, then we can use multiset ). Time: $ O(n)$ since need to traverse all the nodes Space: O(n) O(n) since need to store all the nodes Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> verticalTraversal(TreeNode * root) { map < int , map < int , set < int >>> nodes; queue < tuple < TreeNode * , int , int >> todo; todo.push({root, 0 , 0 }); while ( ! todo.empty()) { auto [node, x, y] = todo.front(); todo.pop(); nodes[x][y].insert(node -> val); if (node -> left) { todo.push({node -> left, x - 1 , y + 1 }); } if (node -> right) { todo.push({node -> right, x + 1 , y + 1 }); } } vector < vector < int >> ans; for ( auto p : nodes) { vector < int > col; for ( auto q : p.second) { col.insert(col.end(), q.second.begin(), q.second.end()); } ans.push_back(col); } return ans; } };","title":"Vertical Order Traversal of a Binary Tree"},{"location":"Leetcode/987.-Vertical-Order-Traversal-of-a-binary-tree/#vertical-order-traversal-of-a-binary-tree","text":"Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y) , its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1) . Running a vertical line from X = -infinity to X = +infinity , whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1: Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2). Example 2: Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is smaller than 6. Note: The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000 .","title":"Vertical Order Traversal of a Binary Tree"},{"location":"Leetcode/987.-Vertical-Order-Traversal-of-a-binary-tree/#analysis","text":"To obtain the vertical order, we first need to understand how to \"order\" all the nodes in each vertical level. If we mark the root node as level 0, then for all the nodes on the left will be: -1, -2, -3 \u2026 -n. Vice versa, for all the nodes on the rght will be 1, 2, 3 \u2026 n. Depending on the position of the nodes, we can categorize all the nodes base on the level. However, there is one thing to be consider: if two nodes are on the same vertical and horizontal level (see last test case), we have to sort the nodes base on their value. This is a special case we need to consider, and thus besides the vertical order, we also need to record the horizontal order. To do so, we need a sorted map which looks like: {vertical level, {horizonal level, sorted value}} Which yield: map<int, map<int, set<int>> (here we assume all the nodes have different values, if there could have same values, then we can use multiset ). Time: $ O(n)$ since need to traverse all the nodes Space: O(n) O(n) since need to store all the nodes","title":"Analysis"},{"location":"Leetcode/987.-Vertical-Order-Traversal-of-a-binary-tree/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : vector < vector < int >> verticalTraversal(TreeNode * root) { map < int , map < int , set < int >>> nodes; queue < tuple < TreeNode * , int , int >> todo; todo.push({root, 0 , 0 }); while ( ! todo.empty()) { auto [node, x, y] = todo.front(); todo.pop(); nodes[x][y].insert(node -> val); if (node -> left) { todo.push({node -> left, x - 1 , y + 1 }); } if (node -> right) { todo.push({node -> right, x + 1 , y + 1 }); } } vector < vector < int >> ans; for ( auto p : nodes) { vector < int > col; for ( auto q : p.second) { col.insert(col.end(), q.second.begin(), q.second.end()); } ans.push_back(col); } return ans; } };","title":"Code"},{"location":"Leetcode/99.-recover-binary-search-tree/","text":"Recover Binary Search Tree \u00b6 You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure . Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Example 1: Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid. Example 2: Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid. Constraints: The number of nodes in the tree is in the range [2, 1000] . -231 <= Node.val <= 231 - 1 Analysis \u00b6 Use in-order tree traverse, we can find that all the left < root > right. If there is any invalid nodes, we should find left(prev) > root. We keep track of last level's root as prev where current root is it's left child. There are two situations: 1. first isn't populated, so the first two node should be swapped are pre and root. 2. first is populated, then we traverse all the way down to find the last pre that is greater than root. Time Complexity: O(n) O(n) as it's an in-order traversal Space Complexity: O(n) O(n) worst case the tree is a linkedlist Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), * right(right) {} * }; */ class Solution { public : TreeNode * first = NULL ; TreeNode * second = NULL ; TreeNode * prev = new TreeNode(INT_MIN); void recoverTree (TreeNode * root) { help(root); swap(first -> val, second -> val); } void help (TreeNode * root) { if (root == NULL ) return ; help(root -> left); if (first == NULL && prev -> val > root -> val) first = prev; if (first != NULL && prev -> val > root -> val) second = root; prev = root; help(root -> right); }","title":"Recover Binary Search Tree"},{"location":"Leetcode/99.-recover-binary-search-tree/#recover-binary-search-tree","text":"You are given the root of a binary search tree (BST), where exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure . Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Example 1: Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid. Example 2: Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid. Constraints: The number of nodes in the tree is in the range [2, 1000] . -231 <= Node.val <= 231 - 1","title":"Recover Binary Search Tree"},{"location":"Leetcode/99.-recover-binary-search-tree/#analysis","text":"Use in-order tree traverse, we can find that all the left < root > right. If there is any invalid nodes, we should find left(prev) > root. We keep track of last level's root as prev where current root is it's left child. There are two situations: 1. first isn't populated, so the first two node should be swapped are pre and root. 2. first is populated, then we traverse all the way down to find the last pre that is greater than root. Time Complexity: O(n) O(n) as it's an in-order traversal Space Complexity: O(n) O(n) worst case the tree is a linkedlist","title":"Analysis"},{"location":"Leetcode/99.-recover-binary-search-tree/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), * right(right) {} * }; */ class Solution { public : TreeNode * first = NULL ; TreeNode * second = NULL ; TreeNode * prev = new TreeNode(INT_MIN); void recoverTree (TreeNode * root) { help(root); swap(first -> val, second -> val); } void help (TreeNode * root) { if (root == NULL ) return ; help(root -> left); if (first == NULL && prev -> val > root -> val) first = prev; if (first != NULL && prev -> val > root -> val) second = root; prev = root; help(root -> right); }","title":"Code"},{"location":"Leetcode/994.-rotting-oranges/","text":"Rotting Oranges \u00b6 You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange . If this is impossible, return -1 . Example 1: Input: grid = [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2: Input: grid = [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3: Input: grid = [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 grid[i][j] is 0 , 1 , or 2 . Analysis \u00b6 Using bfs to expand level by level, using a counter to keep track of how many levels are there, which is the anser of our problem. Time Complexity: O(N) O(N) since you need to iterate through all the cells. Space Complexity: O(N) O(N) since the worst case is when you put all the 1s into the queue. Code \u00b6 class Solution { public : int orangesRotting(vector < vector < int >>& g) { // step 1: check if possible int m = g.size(), n = g[ 0 ].size(); queue < pair < int , int >> q; vector < pair < int , int >> ones; for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) { if (g[i][j] == 2 ) q.push({i,j}); else if (g[i][j] == 1 ) ones.push_back({i,j}); } // step 2: iterate all the neigbours who are currently 1 int dir[ 4 ][ 2 ] = {{ 0 , 1 },{ 0 , -1 },{ 1 , 0 },{ -1 , 0 }}; int minutes = 0 ; while ( ! q.empty()) { minutes ++ ; int sz = q.size(); for ( int i = 0 ; i < sz; ++ i) { int x, y; tie(x, y) = q.front(); q.pop(); for ( auto d : dir) { int dx = x + d[ 0 ], dy = y + d[ 1 ]; // error check and then set to 2 and put it to queue if (dx < 0 || dx >= m || dy < 0 || dy >= n || g[dx][dy] != 1 ) continue ; g[dx][dy] = 2 ; q.push({dx,dy}); } } } // step 3: error checking for ( auto coord : ones) if (g[coord.first][coord.second] == 1 ) return -1 ; // if answer is 0, then return 0 return max ( 0 , minutes - 1 ); } };","title":"Rotting Oranges"},{"location":"Leetcode/994.-rotting-oranges/#rotting-oranges","text":"You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange . If this is impossible, return -1 . Example 1: Input: grid = [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2: Input: grid = [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3: Input: grid = [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 grid[i][j] is 0 , 1 , or 2 .","title":"Rotting Oranges"},{"location":"Leetcode/994.-rotting-oranges/#analysis","text":"Using bfs to expand level by level, using a counter to keep track of how many levels are there, which is the anser of our problem. Time Complexity: O(N) O(N) since you need to iterate through all the cells. Space Complexity: O(N) O(N) since the worst case is when you put all the 1s into the queue.","title":"Analysis"},{"location":"Leetcode/994.-rotting-oranges/#code","text":"class Solution { public : int orangesRotting(vector < vector < int >>& g) { // step 1: check if possible int m = g.size(), n = g[ 0 ].size(); queue < pair < int , int >> q; vector < pair < int , int >> ones; for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) { if (g[i][j] == 2 ) q.push({i,j}); else if (g[i][j] == 1 ) ones.push_back({i,j}); } // step 2: iterate all the neigbours who are currently 1 int dir[ 4 ][ 2 ] = {{ 0 , 1 },{ 0 , -1 },{ 1 , 0 },{ -1 , 0 }}; int minutes = 0 ; while ( ! q.empty()) { minutes ++ ; int sz = q.size(); for ( int i = 0 ; i < sz; ++ i) { int x, y; tie(x, y) = q.front(); q.pop(); for ( auto d : dir) { int dx = x + d[ 0 ], dy = y + d[ 1 ]; // error check and then set to 2 and put it to queue if (dx < 0 || dx >= m || dy < 0 || dy >= n || g[dx][dy] != 1 ) continue ; g[dx][dy] = 2 ; q.push({dx,dy}); } } } // step 3: error checking for ( auto coord : ones) if (g[coord.first][coord.second] == 1 ) return -1 ; // if answer is 0, then return 0 return max ( 0 , minutes - 1 ); } };","title":"Code"},{"location":"Leetcode/dp-pattern/","text":"DP pattern summary \u00b6 https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns Minimum (Maximum) Path to Reach a Target \u00b6 Given a target find minimum (maximum) cost / path / sum to reach the target. 746. Min Cost Climbing Stairs \u00b6 On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. dp[i] min cost to reach ith stair. for ( int i = 2 ; i <= n; ++ i) { dp[i] = min(dp[i -1 ], dp[i -2 ]) + (i == n ? 0 : cost[i]); // on last step, there is no need to proceed further. } return dp[n] with optimization int p1 = 0 , p2 = 0 ; for ( int i = 2 ; i <= cost.size(); ++ i) { int p = min(p1 + cost[i - 1 ], p2 + cost[i - 2 ]); p2 = p1; p1 = p; } return p1; 64. Minimum Path Sum \u00b6 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum. dp[i][j]: min sum to reach x=i,y=j, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] for ( int i = 1 ; i < n; ++ i) { for ( int j = 1 ; j < m; ++ j) { grid[i][j] = min(grid[i -1 ][j], grid[i][j -1 ]) + grid[i][j]; } } return grid[n -1 ][m -1 ] 322. Coin Change \u00b6 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin. dp[j]: min # of coins to be used for j amount for ( int j = 1 ; j <= amount; ++ j) { for ( int i = 0 ; i < coins.size(); ++ i) { // try all coins if (coins[i] <= j) { // only try the one that is less than total required dp[j] = min(dp[j], dp[j - coins[i]] + 1 ); } } } return dp[amount]; Why this cannot be solved by greedy algorithm? \u00b6 Exception: But for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set {1, 15, 25} and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice. In any case where there is no coin whose value, when added to the lowest denomination, is lower than twice that of the denomination immediately less than it, the greedy algorithm works. i.e. {1,2,3} works because [1,3] and [2,2] add to the same value however {1, 15, 25} doesn't work because (for the change 30) 15+15>25+1 931. Minimum Falling Path Sum \u00b6 Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. A[i][j]: min sum from all upper level to current level i and position j, to get the ans, just find the min on the last row int minFallingPathSum (vector < vector < int >>& A) { int m = A.size(), n = A[ 0 ].size(); int res = INT_MAX; for ( int i = 1 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { A[i][j] += min( {A[i - 1 ][j], A[i - 1 ][max( 0 , j - 1 )], A[i - 1 ][min(m - 1 , j + 1 )]}); } } for ( int i = 0 ; i < n; ++ i) res = min(res, A[m - 1 ][i]); return res; } 983. Minimum Cost For Tickets \u00b6 In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = 2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = \u200b7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = 2, which covered day 20. In total you spent 11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel. Note: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 dp[i]: min cost for ith day. Note: if there is no travel plan, the cost will stay the same as the i-1 th day. int mincostTickets (vector < int >& days, vector < int >& costs) { unordered_set < int > travel(begin(days), end(days)); int dp[ 366 ] = {}; for ( int i = 1 ; i < 366 ; ++ i) { if (travel.find(i) == travel.end()) dp[i] = dp[i - 1 ]; else dp[i] = min({ dp[i - 1 ] + costs[ 0 ], dp[max( 0 , i - 7 )] + costs[ 1 ], dp[max( 0 , i - 30 )] + costs[ 2 ]}); } return dp[ 365 ]; } 650. 2 Keys Keyboard \u00b6 Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. dp[i]: min steps to get to get i 'A' characters. int dp[n + 1 ]; memset(dp, 0 , sizeof dp); for ( int i = 2 ; i <= n; ++ i) { dp[i] = i; // initially assume copy one and paste one by one for ( int j = i - 1 ; j >= 1 ; -- j) { if (i % j == 0 ) { dp[i] = dp[j] + i / j; // j is the maximum, so no need to check the rest break ; } } } return dp[n]; Optimize int s = 0 ; for ( int d = 2 ; d <= n; d ++ ) { while (n % d == 0 ) { s += d; n /= d; } } return s; 279. Perfect Squares \u00b6 Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. dp[i]: min # of perfect squares to form i int numSquares ( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; } 1049. Last Stone Weight II \u00b6 We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 <= stones.length <= 30 1 <= stones[i] <= 100 int lastStoneWeightII (vector < int >& stones) { int n = stones.size(), sum = 0 ; for ( int s : stones) sum += s; vector < bool > dp(sum + 1 , false ); dp[ 0 ] = true ; for ( int i = 0 ; i < n; ++ i) { for ( int j = sum / 2 ; j >= stones[i]; -- j) dp[j] = dp[j] | dp[j - stones[i]]; } for ( int i = sum / 2 ; i >= 0 ; -- i) if (dp[i]) return sum - i - i; return sum; } 120. Triangle \u00b6 Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i]: min cost from bottom to i-th row int minimumTotal (vector < vector < int >>& triangle) { vector < int > dp(triangle.back()); int n = triangle.size(); for ( int i = n - 2 ; i >= 0 ; -- i) { // rows for ( int j = 0 ; j <= i; ++ j) { // num of elem in each row = i + 1 dp[j] = min(dp[j], dp[j + 1 ]) + triangle[i][j]; // left: dp[j], right: dp[j + 1] } } return dp[ 0 ]; } 474. Ones and Zeroes \u00b6 Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\". Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\". My dp[i][j] means with i zeros and j ones, what is the max strings to be chosen from the strs. In order to calculate it, we find there is a relationship between # of 1 and 0, which is # of 1 + # of 0 = string size, this pattern of constraint usually leads to a knapsack problem. We can visualize it with the problem of knapsack: choose current string means dp[i-# of zero for current string][j - # of one for current string] + 1. not choose current string means dp[i][j] which means there is nothing changed as previous state. Why it has to start from m, n and decrease to 1 (or making sure there is at least # of 0 or 1 spots left in our case)? Because it prevents invalid counting. As we can see, our dp[m][n] is going to be updated sz times, and before we calculate i - zero[k] and j - one[k], they has to be valid. If we start from 0 and increase to m, n, these values will never be updated beforehand. int findMaxForm (vector < string >& strs, int m, int n) { int sz = strs.size(); int one[sz], zero[sz]; for ( int i = 0 ; i < sz; ++ i) { int c1 = 0 , c2 = 0 ; for ( char c : strs[i]) { if (c == '1' ) c2 ++ ; if (c == '0' ) c1 ++ ; } zero[i] = c1, one[i] = c2; } int dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int k = 0 ; k < sz; ++ k) { for ( int i = m; i >= zero[k]; -- i) { for ( int j = n; j >= one[k]; -- j) { dp[i][j] = max(dp[i][j], dp[i - zero[k]][j - one[k]] + 1 ); } } } return dp[m][n]; } 221. Maximal Square \u00b6 Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Here the dp[i][j] the same as matrix[i][j] , and it means the maximum width of the square that includes matrix[i][j] as the right down side of the resulting square. To expand the area to any directions (right, down), we check the matrix[i][j-1] , matrix[i-1][j] and matrix[i-1][j-1] and choose the minimal from them. The final answer is the maximum matrix[i][j] * matrix[i][j] from all the values we have filled. for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (matrix[i][j] == '0' || i == 0 || j == 0 ) continue ; matrix[i][j] = min({matrix[i][j - 1 ] - '0' , matrix[i - 1 ][j] - '0' , matrix[i - 1 ][j - 1 ] - '0' }) + '1' ; res = max(res, matrix[i][j] - '0' ); } } return res * res; 1240. Tiling a Rectangle with the Fewest Squares \u00b6 analysis link 174. Dungeon Game \u00b6 analysis link Distinct Ways \u00b6 Merging Intervals \u00b6 DP on Strings \u00b6 Decision Making \u00b6","title":"DP pattern summary"},{"location":"Leetcode/dp-pattern/#dp-pattern-summary","text":"https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns","title":"DP pattern summary"},{"location":"Leetcode/dp-pattern/#minimum-maximum-path-to-reach-a-target","text":"Given a target find minimum (maximum) cost / path / sum to reach the target.","title":"Minimum (Maximum) Path to Reach a Target"},{"location":"Leetcode/dp-pattern/#746-min-cost-climbing-stairs","text":"On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. dp[i] min cost to reach ith stair. for ( int i = 2 ; i <= n; ++ i) { dp[i] = min(dp[i -1 ], dp[i -2 ]) + (i == n ? 0 : cost[i]); // on last step, there is no need to proceed further. } return dp[n] with optimization int p1 = 0 , p2 = 0 ; for ( int i = 2 ; i <= cost.size(); ++ i) { int p = min(p1 + cost[i - 1 ], p2 + cost[i - 2 ]); p2 = p1; p1 = p; } return p1;","title":"746. Min Cost Climbing Stairs"},{"location":"Leetcode/dp-pattern/#64-minimum-path-sum","text":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum. dp[i][j]: min sum to reach x=i,y=j, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] for ( int i = 1 ; i < n; ++ i) { for ( int j = 1 ; j < m; ++ j) { grid[i][j] = min(grid[i -1 ][j], grid[i][j -1 ]) + grid[i][j]; } } return grid[n -1 ][m -1 ]","title":"64. Minimum Path Sum"},{"location":"Leetcode/dp-pattern/#322-coin-change","text":"You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin. dp[j]: min # of coins to be used for j amount for ( int j = 1 ; j <= amount; ++ j) { for ( int i = 0 ; i < coins.size(); ++ i) { // try all coins if (coins[i] <= j) { // only try the one that is less than total required dp[j] = min(dp[j], dp[j - coins[i]] + 1 ); } } } return dp[amount];","title":"322. Coin Change"},{"location":"Leetcode/dp-pattern/#why-this-cannot-be-solved-by-greedy-algorithm","text":"Exception: But for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set {1, 15, 25} and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice. In any case where there is no coin whose value, when added to the lowest denomination, is lower than twice that of the denomination immediately less than it, the greedy algorithm works. i.e. {1,2,3} works because [1,3] and [2,2] add to the same value however {1, 15, 25} doesn't work because (for the change 30) 15+15>25+1","title":"Why this cannot be solved by greedy algorithm?"},{"location":"Leetcode/dp-pattern/#931-minimum-falling-path-sum","text":"Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. A[i][j]: min sum from all upper level to current level i and position j, to get the ans, just find the min on the last row int minFallingPathSum (vector < vector < int >>& A) { int m = A.size(), n = A[ 0 ].size(); int res = INT_MAX; for ( int i = 1 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { A[i][j] += min( {A[i - 1 ][j], A[i - 1 ][max( 0 , j - 1 )], A[i - 1 ][min(m - 1 , j + 1 )]}); } } for ( int i = 0 ; i < n; ++ i) res = min(res, A[m - 1 ][i]); return res; }","title":"931. Minimum Falling Path Sum"},{"location":"Leetcode/dp-pattern/#983-minimum-cost-for-tickets","text":"In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = 2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = \u200b7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = 2, which covered day 20. In total you spent 11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel. Note: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 dp[i]: min cost for ith day. Note: if there is no travel plan, the cost will stay the same as the i-1 th day. int mincostTickets (vector < int >& days, vector < int >& costs) { unordered_set < int > travel(begin(days), end(days)); int dp[ 366 ] = {}; for ( int i = 1 ; i < 366 ; ++ i) { if (travel.find(i) == travel.end()) dp[i] = dp[i - 1 ]; else dp[i] = min({ dp[i - 1 ] + costs[ 0 ], dp[max( 0 , i - 7 )] + costs[ 1 ], dp[max( 0 , i - 30 )] + costs[ 2 ]}); } return dp[ 365 ]; }","title":"983. Minimum Cost For Tickets"},{"location":"Leetcode/dp-pattern/#650-2-keys-keyboard","text":"Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. dp[i]: min steps to get to get i 'A' characters. int dp[n + 1 ]; memset(dp, 0 , sizeof dp); for ( int i = 2 ; i <= n; ++ i) { dp[i] = i; // initially assume copy one and paste one by one for ( int j = i - 1 ; j >= 1 ; -- j) { if (i % j == 0 ) { dp[i] = dp[j] + i / j; // j is the maximum, so no need to check the rest break ; } } } return dp[n]; Optimize int s = 0 ; for ( int d = 2 ; d <= n; d ++ ) { while (n % d == 0 ) { s += d; n /= d; } } return s;","title":"650. 2 Keys Keyboard"},{"location":"Leetcode/dp-pattern/#279-perfect-squares","text":"Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. dp[i]: min # of perfect squares to form i int numSquares ( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; }","title":"279. Perfect Squares"},{"location":"Leetcode/dp-pattern/#1049-last-stone-weight-ii","text":"We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 <= stones.length <= 30 1 <= stones[i] <= 100 int lastStoneWeightII (vector < int >& stones) { int n = stones.size(), sum = 0 ; for ( int s : stones) sum += s; vector < bool > dp(sum + 1 , false ); dp[ 0 ] = true ; for ( int i = 0 ; i < n; ++ i) { for ( int j = sum / 2 ; j >= stones[i]; -- j) dp[j] = dp[j] | dp[j - stones[i]]; } for ( int i = sum / 2 ; i >= 0 ; -- i) if (dp[i]) return sum - i - i; return sum; }","title":"1049. Last Stone Weight II"},{"location":"Leetcode/dp-pattern/#120-triangle","text":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i]: min cost from bottom to i-th row int minimumTotal (vector < vector < int >>& triangle) { vector < int > dp(triangle.back()); int n = triangle.size(); for ( int i = n - 2 ; i >= 0 ; -- i) { // rows for ( int j = 0 ; j <= i; ++ j) { // num of elem in each row = i + 1 dp[j] = min(dp[j], dp[j + 1 ]) + triangle[i][j]; // left: dp[j], right: dp[j + 1] } } return dp[ 0 ]; }","title":"120. Triangle"},{"location":"Leetcode/dp-pattern/#474-ones-and-zeroes","text":"Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\". Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\". My dp[i][j] means with i zeros and j ones, what is the max strings to be chosen from the strs. In order to calculate it, we find there is a relationship between # of 1 and 0, which is # of 1 + # of 0 = string size, this pattern of constraint usually leads to a knapsack problem. We can visualize it with the problem of knapsack: choose current string means dp[i-# of zero for current string][j - # of one for current string] + 1. not choose current string means dp[i][j] which means there is nothing changed as previous state. Why it has to start from m, n and decrease to 1 (or making sure there is at least # of 0 or 1 spots left in our case)? Because it prevents invalid counting. As we can see, our dp[m][n] is going to be updated sz times, and before we calculate i - zero[k] and j - one[k], they has to be valid. If we start from 0 and increase to m, n, these values will never be updated beforehand. int findMaxForm (vector < string >& strs, int m, int n) { int sz = strs.size(); int one[sz], zero[sz]; for ( int i = 0 ; i < sz; ++ i) { int c1 = 0 , c2 = 0 ; for ( char c : strs[i]) { if (c == '1' ) c2 ++ ; if (c == '0' ) c1 ++ ; } zero[i] = c1, one[i] = c2; } int dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int k = 0 ; k < sz; ++ k) { for ( int i = m; i >= zero[k]; -- i) { for ( int j = n; j >= one[k]; -- j) { dp[i][j] = max(dp[i][j], dp[i - zero[k]][j - one[k]] + 1 ); } } } return dp[m][n]; }","title":"474. Ones and Zeroes"},{"location":"Leetcode/dp-pattern/#221-maximal-square","text":"Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Here the dp[i][j] the same as matrix[i][j] , and it means the maximum width of the square that includes matrix[i][j] as the right down side of the resulting square. To expand the area to any directions (right, down), we check the matrix[i][j-1] , matrix[i-1][j] and matrix[i-1][j-1] and choose the minimal from them. The final answer is the maximum matrix[i][j] * matrix[i][j] from all the values we have filled. for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { if (matrix[i][j] == '0' || i == 0 || j == 0 ) continue ; matrix[i][j] = min({matrix[i][j - 1 ] - '0' , matrix[i - 1 ][j] - '0' , matrix[i - 1 ][j - 1 ] - '0' }) + '1' ; res = max(res, matrix[i][j] - '0' ); } } return res * res;","title":"221. Maximal Square"},{"location":"Leetcode/dp-pattern/#1240-tiling-a-rectangle-with-the-fewest-squares","text":"analysis link","title":"1240. Tiling a Rectangle with the Fewest Squares"},{"location":"Leetcode/dp-pattern/#174-dungeon-game","text":"analysis link","title":"174. Dungeon Game"},{"location":"Leetcode/dp-pattern/#distinct-ways","text":"","title":"Distinct Ways"},{"location":"Leetcode/dp-pattern/#merging-intervals","text":"","title":"Merging Intervals"},{"location":"Leetcode/dp-pattern/#dp-on-strings","text":"","title":"DP on Strings"},{"location":"Leetcode/dp-pattern/#decision-making","text":"","title":"Decision Making"},{"location":"LibreOJ/10000/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 1\u300d\u6d3b\u52a8\u5b89\u6392 \u00b6 https://loj.ac/problem/10000 Analysis \u00b6 \u7c7b\u4f3ccourse schedule, O(n\\log(n)) O(n\\log(n)) Code \u00b6 /* * \u6d3b\u52a8\u5b89\u6392.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; pair < int , int > arr[ 1010 ]; int main ( int argc, char * argv[]) { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> arr[i].second >> arr[i].first; } sort(arr, arr + n); int start = -1 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (arr[i].second >= start) { // find new end time start = arr[i].first; ++ res; } } cout << res; return 0 ; }","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 1\u300d\u6d3b\u52a8\u5b89\u6392"},{"location":"LibreOJ/10000/#11-1","text":"https://loj.ac/problem/10000","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 1\u300d\u6d3b\u52a8\u5b89\u6392"},{"location":"LibreOJ/10000/#analysis","text":"\u7c7b\u4f3ccourse schedule, O(n\\log(n)) O(n\\log(n))","title":"Analysis"},{"location":"LibreOJ/10000/#code","text":"/* * \u6d3b\u52a8\u5b89\u6392.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; pair < int , int > arr[ 1010 ]; int main ( int argc, char * argv[]) { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> arr[i].second >> arr[i].first; } sort(arr, arr + n); int start = -1 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (arr[i].second >= start) { // find new end time start = arr[i].first; ++ res; } } cout << res; return 0 ; }","title":"Code"},{"location":"LibreOJ/10001/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 2\u300d\u79cd\u6811 \u00b6 https://loj.ac/problem/10001 Analysis \u00b6 \u4ece\u524d\u5f80\u540e\u79cd\u6811\uff0c\u5982\u679c\u4e4b\u524d\u79cd\u8fc7\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5skip\u6389\u3002\u5982\u679c\u8fd8\u6709\u8981\u6c42\u6ca1\u6709\u8fbe\u6210\uff0c\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u7ee7\u7eed\u904d\u5386\uff0c\u6dfb\u52a0\u672a\u79cd\u7684\u5730\u65b9\u3002 e.g. x01000x010100101001 \u5728x x\u4e2d\u9700\u8981\u79cd\u4e09\u9897\u6811\uff1ab = 0, e = 5, t = 3 x01011x010100101001 b = 1, e = 6, t = 4 0x10110x10100101001 Time: O(h \\times max(e - a)) O(h \\times max(e - a)) Code \u00b6 /* * \u79cd\u6811.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; struct line { int b, e, t; } a[ 5010 ]; bool used[ 30010 ]; int main ( int argc, char * argv[]) { int n, h; cin >> n >> h; for ( int i = 0 ; i < h; ++ i) { cin >> a[i].b >> a[i].e >> a[i].t; } sort(a, a + h, []( const line & l, const line & r) { return l.e < r.e; }); // sort by finish time int res = 0 ; for ( int i = 0 ; i < h; ++ i) { int cnt = 0 ; for ( int j = a[i].b; j <= a[i].e; ++ j) { // first check if already satified if (used[j]) cnt ++ ; } if (cnt < a[i].t) { for ( int j = a[i].e; j >= a[i].b && cnt < a[i].t; -- j) { if ( ! used[j]) { used[j] = 1 ; cnt ++ ; res ++ ; } } } } cout << res; return 0 ; }","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 2\u300d\u79cd\u6811"},{"location":"LibreOJ/10001/#11-2","text":"https://loj.ac/problem/10001","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 2\u300d\u79cd\u6811"},{"location":"LibreOJ/10001/#analysis","text":"\u4ece\u524d\u5f80\u540e\u79cd\u6811\uff0c\u5982\u679c\u4e4b\u524d\u79cd\u8fc7\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5skip\u6389\u3002\u5982\u679c\u8fd8\u6709\u8981\u6c42\u6ca1\u6709\u8fbe\u6210\uff0c\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u7ee7\u7eed\u904d\u5386\uff0c\u6dfb\u52a0\u672a\u79cd\u7684\u5730\u65b9\u3002 e.g. x01000x010100101001 \u5728x x\u4e2d\u9700\u8981\u79cd\u4e09\u9897\u6811\uff1ab = 0, e = 5, t = 3 x01011x010100101001 b = 1, e = 6, t = 4 0x10110x10100101001 Time: O(h \\times max(e - a)) O(h \\times max(e - a))","title":"Analysis"},{"location":"LibreOJ/10001/#code","text":"/* * \u79cd\u6811.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; struct line { int b, e, t; } a[ 5010 ]; bool used[ 30010 ]; int main ( int argc, char * argv[]) { int n, h; cin >> n >> h; for ( int i = 0 ; i < h; ++ i) { cin >> a[i].b >> a[i].e >> a[i].t; } sort(a, a + h, []( const line & l, const line & r) { return l.e < r.e; }); // sort by finish time int res = 0 ; for ( int i = 0 ; i < h; ++ i) { int cnt = 0 ; for ( int j = a[i].b; j <= a[i].e; ++ j) { // first check if already satified if (used[j]) cnt ++ ; } if (cnt < a[i].t) { for ( int j = a[i].e; j >= a[i].b && cnt < a[i].t; -- j) { if ( ! used[j]) { used[j] = 1 ; cnt ++ ; res ++ ; } } } } cout << res; return 0 ; }","title":"Code"},{"location":"LibreOJ/10002/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 3\u300d\u55b7\u6c34\u88c5\u7f6e \u00b6 https://loj.ac/problem/10002 Analysis \u00b6 \u6bcf\u6b21\u8bb0\u5f55\u4e2d\u5fc3\u70b9\u7684\u4e24\u7aef\uff0c\u4e24\u7aef\u53ea\u80fd\u53d6\u84dd\u8272\u7684\u957f\u5ea6\uff0c\u56e0\u4e3a\u53ea\u6709\u84dd\u8272\u957f\u5ea6\u624d\u53ef\u4ee5\u4fdd\u8bc1\u6240\u6709\u7684\u70b9\u4ece\u4e2d\u5fc3\u70b9\u5230\u7ec8\u70b9\u662f\u5b8c\u5168cover\u5230\u7684\u3002\u7136\u540e\u6839\u636e\u5de6\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u6bcf\u6b21greedy\u53d6\u53ef\u4ee5cover\u5230\u7684\u6700\u53f3\u70b9\uff0c\u5f53\u53ef\u4ee5\u53d6\u5230\u7684\u6700\u53f3\u70b9\u6bd4\u5f53\u524d\u7684\u9762\u79ef\u7684\u957f\u5ea6\u8981\u5927\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4fbf\u505c\u6b62\u3002 Code \u00b6 /* * \u55b7\u6c34\u88c5\u7f6e.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int maxn = 2e4 + 5 ; int cnt; int n, L, W; struct line { double x, y; }; line lines[maxn]; bool cmp (line a, line b) { return a.x < b.x; } void read () { cin >> n >> L >> W; cnt = 0 ; int x, r; for ( int i = 1 ; i <= n; i ++ ) { cin >> x >> r; if (r <= W / 2 ) continue ; // skip if height cannot cover cnt ++ ; double len = sqrt(r * r - W * W / 4.0 ); // blue len lines[cnt].x = x - len; lines[cnt].y = x + len; } } void work () { sort(lines + 1 , lines + cnt + 1 , cmp); double last = 0 ; int ans = 0 ; while (last < L) { ans ++ ; double s = last; for ( int i = 1 ; i <= cnt; i ++ ) { if (lines[i].x <= s) { last = max(last, lines[i].y); } else { break ; } } if (last == s && s < L) { cout << -1 << endl; return ; } } cout << ans << endl; } int main () { int k; cin >> k; for ( int j = 0 ; j < k; j ++ ) { read(); work(); } return 0 ; }","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 3\u300d\u55b7\u6c34\u88c5\u7f6e"},{"location":"LibreOJ/10002/#11-3","text":"https://loj.ac/problem/10002","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 3\u300d\u55b7\u6c34\u88c5\u7f6e"},{"location":"LibreOJ/10002/#analysis","text":"\u6bcf\u6b21\u8bb0\u5f55\u4e2d\u5fc3\u70b9\u7684\u4e24\u7aef\uff0c\u4e24\u7aef\u53ea\u80fd\u53d6\u84dd\u8272\u7684\u957f\u5ea6\uff0c\u56e0\u4e3a\u53ea\u6709\u84dd\u8272\u957f\u5ea6\u624d\u53ef\u4ee5\u4fdd\u8bc1\u6240\u6709\u7684\u70b9\u4ece\u4e2d\u5fc3\u70b9\u5230\u7ec8\u70b9\u662f\u5b8c\u5168cover\u5230\u7684\u3002\u7136\u540e\u6839\u636e\u5de6\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u6bcf\u6b21greedy\u53d6\u53ef\u4ee5cover\u5230\u7684\u6700\u53f3\u70b9\uff0c\u5f53\u53ef\u4ee5\u53d6\u5230\u7684\u6700\u53f3\u70b9\u6bd4\u5f53\u524d\u7684\u9762\u79ef\u7684\u957f\u5ea6\u8981\u5927\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4fbf\u505c\u6b62\u3002","title":"Analysis"},{"location":"LibreOJ/10002/#code","text":"/* * \u55b7\u6c34\u88c5\u7f6e.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int maxn = 2e4 + 5 ; int cnt; int n, L, W; struct line { double x, y; }; line lines[maxn]; bool cmp (line a, line b) { return a.x < b.x; } void read () { cin >> n >> L >> W; cnt = 0 ; int x, r; for ( int i = 1 ; i <= n; i ++ ) { cin >> x >> r; if (r <= W / 2 ) continue ; // skip if height cannot cover cnt ++ ; double len = sqrt(r * r - W * W / 4.0 ); // blue len lines[cnt].x = x - len; lines[cnt].y = x + len; } } void work () { sort(lines + 1 , lines + cnt + 1 , cmp); double last = 0 ; int ans = 0 ; while (last < L) { ans ++ ; double s = last; for ( int i = 1 ; i <= cnt; i ++ ) { if (lines[i].x <= s) { last = max(last, lines[i].y); } else { break ; } } if (last == s && s < L) { cout << -1 << endl; return ; } } cout << ans << endl; } int main () { int k; cin >> k; for ( int j = 0 ; j < k; j ++ ) { read(); work(); } return 0 ; }","title":"Code"},{"location":"LibreOJ/10003/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 4\u300d\u52a0\u5de5\u751f\u4ea7\u8c03\u5ea6 \u00b6 https://loj.ac/problem/10003 Analysis \u00b6 \u56e0\u4e3aB\u4e00\u5b9a\u8981\u5728A\u4e4b\u540e\u624d\u53ef\u4ee5\u8fdb\u884c\uff0c\u6240\u4ee5\u603b\u65f6\u95f4\u6700\u5c0f\u7684\u8bdd\u8981\u5148\u628a\u9700\u8981A\u548c\u9700\u8981B\u7684\u5c0f\u7684\u65f6\u95f4\u653e\u5230\u6700\u524d\u9762\uff0c\u7136\u540e\u4f7f\u7528\u53cc\u6307\u9488\uff1a \u5982\u679c\u662fA\u90a3\u4e48\u4ece\u524d\u5f80\u540e\u6392\u5e8f \u5982\u679c\u662fB\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u6392\u5e8f Code \u00b6 #include <bits/stdc++.h> using namespace std; struct point { int i, minn, x, y; }; point a[ 1010 ]; int ans[ 1010 ]; const int inf = 0x3f3f3f3f ; int main () { int n; cin >> n; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].x; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].y; for ( int i = 1 ; i <= n; ++ i) { a[i].minn = min(a[i].x, a[i].y); // find the min a[i].i = i; } sort(a + 1 , a + n + 1 , []( const point & l, const point & r) { return l.minn < r.minn; }); int x = 1 , y = n; for ( int i = 1 ; i <= n; ++ i) { if (a[i].minn == a[i].x) // A should finish first ans[x ++ ] = a[i].i; else ans[y -- ] = a[i].i; } int timea = 0 , timeb = 0 , mina = inf, minb = inf; for ( int i = 1 ; i <= n; ++ i) { timea += a[i].x; timeb += a[i].y; mina = min(mina, a[i].x); minb = min(minb, a[i].y); } cout << max(timea + minb, timeb + mina) << endl; for ( int i = 1 ; i <= n; ++ i) cout << ans[i] << \" \" ; return 0 ; }","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 4\u300d\u52a0\u5de5\u751f\u4ea7\u8c03\u5ea6"},{"location":"LibreOJ/10003/#11-4","text":"https://loj.ac/problem/10003","title":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 4\u300d\u52a0\u5de5\u751f\u4ea7\u8c03\u5ea6"},{"location":"LibreOJ/10003/#analysis","text":"\u56e0\u4e3aB\u4e00\u5b9a\u8981\u5728A\u4e4b\u540e\u624d\u53ef\u4ee5\u8fdb\u884c\uff0c\u6240\u4ee5\u603b\u65f6\u95f4\u6700\u5c0f\u7684\u8bdd\u8981\u5148\u628a\u9700\u8981A\u548c\u9700\u8981B\u7684\u5c0f\u7684\u65f6\u95f4\u653e\u5230\u6700\u524d\u9762\uff0c\u7136\u540e\u4f7f\u7528\u53cc\u6307\u9488\uff1a \u5982\u679c\u662fA\u90a3\u4e48\u4ece\u524d\u5f80\u540e\u6392\u5e8f \u5982\u679c\u662fB\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u6392\u5e8f","title":"Analysis"},{"location":"LibreOJ/10003/#code","text":"#include <bits/stdc++.h> using namespace std; struct point { int i, minn, x, y; }; point a[ 1010 ]; int ans[ 1010 ]; const int inf = 0x3f3f3f3f ; int main () { int n; cin >> n; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].x; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].y; for ( int i = 1 ; i <= n; ++ i) { a[i].minn = min(a[i].x, a[i].y); // find the min a[i].i = i; } sort(a + 1 , a + n + 1 , []( const point & l, const point & r) { return l.minn < r.minn; }); int x = 1 , y = n; for ( int i = 1 ; i <= n; ++ i) { if (a[i].minn == a[i].x) // A should finish first ans[x ++ ] = a[i].i; else ans[y -- ] = a[i].i; } int timea = 0 , timeb = 0 , mina = inf, minb = inf; for ( int i = 1 ; i <= n; ++ i) { timea += a[i].x; timeb += a[i].y; mina = min(mina, a[i].x); minb = min(minb, a[i].y); } cout << max(timea + minb, timeb + mina) << endl; for ( int i = 1 ; i <= n; ++ i) cout << ans[i] << \" \" ; return 0 ; }","title":"Code"},{"location":"Misc/CSS/","text":"Example css file \u00b6 @ CHARSET \"UTF-8\" ; html { height : 100 % ; } hr { margin-right : 10 px ; margin-left : 10 px ; height : 2 px ; background : url ( http://ibrahimjabbari.com/english/images/hr-11.png ) repeat-x 0 0 ; border-top : 1 px dashed #866760 ; } table { border-radius : 10 px ; border-collapse : collapse ; } th { background-color : #7c7dca ; color : white ; border-bottom : 2 px dashed white ; } input [ type = text ] : focus { background-color : #d9e6e5 ; } input [ type = text ] : hover { width : 170 px ; } input [ type = text ] { width : 200 px ; box-sizing : border-box ; border : 2 px solid #ccc ; border-radius : 4 px ; font-size : 16 px ; padding : 5 px 5 px 5 px 10 px ; -webkit- transition : width 0.4 s ease-in-out ; transition : width 0.4 s ease-in-out ; } body { background-image : linear-gradient ( to bottom , rgba ( 33 , 97 , 140 , 0.3 ) 0 % , rgba ( 213 , 219 , 219 , 0.3 ) 100 % ); width : 100 % ; background-repeat : no-repeat ; background-size : cover ; background-attachment : fixed ; } th { font-family : 'Macondo' , Cursive; } a : hover { background-color : rgba ( 230 , 230 , 230 , 0.6 ); } a { text-decoration : none ; color : #5f609a ; } # leftTd { position : fixed ; } input { animation :showInput 3 s ease 1 forwards ; } # centerTd { animation :showTable 1 s ease 1 forwards ; margin-bottom : 100 px ; } # uscImage { -webkit- animation :spin 8 s linear infinite ; -moz- animation :spin 8 s linear infinite ; animation :spin 8 s linear infinite ; } @ keyframes spin { 100 % { -webkit- transform : rotate ( 360 deg ); transform : rotate ( 360 deg ); } } @ -moz-keyframes spin { 100 % { -moz- transform : rotate ( 360 deg ); } } @ -webkit-keyframes spin { 100 % { -webkit- transform : rotate ( 360 deg ); } } @ -webkit-keyframes showInput { 0 % { opacity : 0 ; width : 100 px ; } 50 % { opacity : 0.5 ; width : 90 px ; } 100 % { opacity : 1 ; width : 100 px ; } } @ -webkit-keyframes showTable { 0 % { opacity : 0 ; } 50 % { opacity : 0.5 ; } 100 % { opacity : 1 ; } }","title":"Example css file"},{"location":"Misc/CSS/#example-css-file","text":"@ CHARSET \"UTF-8\" ; html { height : 100 % ; } hr { margin-right : 10 px ; margin-left : 10 px ; height : 2 px ; background : url ( http://ibrahimjabbari.com/english/images/hr-11.png ) repeat-x 0 0 ; border-top : 1 px dashed #866760 ; } table { border-radius : 10 px ; border-collapse : collapse ; } th { background-color : #7c7dca ; color : white ; border-bottom : 2 px dashed white ; } input [ type = text ] : focus { background-color : #d9e6e5 ; } input [ type = text ] : hover { width : 170 px ; } input [ type = text ] { width : 200 px ; box-sizing : border-box ; border : 2 px solid #ccc ; border-radius : 4 px ; font-size : 16 px ; padding : 5 px 5 px 5 px 10 px ; -webkit- transition : width 0.4 s ease-in-out ; transition : width 0.4 s ease-in-out ; } body { background-image : linear-gradient ( to bottom , rgba ( 33 , 97 , 140 , 0.3 ) 0 % , rgba ( 213 , 219 , 219 , 0.3 ) 100 % ); width : 100 % ; background-repeat : no-repeat ; background-size : cover ; background-attachment : fixed ; } th { font-family : 'Macondo' , Cursive; } a : hover { background-color : rgba ( 230 , 230 , 230 , 0.6 ); } a { text-decoration : none ; color : #5f609a ; } # leftTd { position : fixed ; } input { animation :showInput 3 s ease 1 forwards ; } # centerTd { animation :showTable 1 s ease 1 forwards ; margin-bottom : 100 px ; } # uscImage { -webkit- animation :spin 8 s linear infinite ; -moz- animation :spin 8 s linear infinite ; animation :spin 8 s linear infinite ; } @ keyframes spin { 100 % { -webkit- transform : rotate ( 360 deg ); transform : rotate ( 360 deg ); } } @ -moz-keyframes spin { 100 % { -moz- transform : rotate ( 360 deg ); } } @ -webkit-keyframes spin { 100 % { -webkit- transform : rotate ( 360 deg ); } } @ -webkit-keyframes showInput { 0 % { opacity : 0 ; width : 100 px ; } 50 % { opacity : 0.5 ; width : 90 px ; } 100 % { opacity : 1 ; width : 100 px ; } } @ -webkit-keyframes showTable { 0 % { opacity : 0 ; } 50 % { opacity : 0.5 ; } 100 % { opacity : 1 ; } }","title":"Example css file"},{"location":"Misc/rsa-en%26decryption/","text":"RSA encryption and decryption \u00b6 Symbolics \u00b6 p and q are two very large primes n = p * q : Modulus phi = (p-1) * (q-1) : Totient e Public Key: is the prime number chosen in the range [3, phi(n)] d Secret Key Calculate d and Encrypt the message \u00b6 using extended-Euclid's algorithm to find the resulting equation when gcd = 1: it should always look like this: 1 = (a) * phi + (b) * e And d = phi * k - b (k is any integer that could make d > 0) To verify: e * d = 1 mod phi, this could be done easily Encrypt the message using public key e and n: M ^ e mod n the result C is the encrypted message Decrypt C using private key \u00b6 M = c ^ d mod n Sometimes it's being called the signature sign","title":"RSA encryption and decryption"},{"location":"Misc/rsa-en%26decryption/#rsa-encryption-and-decryption","text":"","title":"RSA encryption and decryption"},{"location":"Misc/rsa-en%26decryption/#symbolics","text":"p and q are two very large primes n = p * q : Modulus phi = (p-1) * (q-1) : Totient e Public Key: is the prime number chosen in the range [3, phi(n)] d Secret Key","title":"Symbolics"},{"location":"Misc/rsa-en%26decryption/#calculate-d-and-encrypt-the-message","text":"using extended-Euclid's algorithm to find the resulting equation when gcd = 1: it should always look like this: 1 = (a) * phi + (b) * e And d = phi * k - b (k is any integer that could make d > 0) To verify: e * d = 1 mod phi, this could be done easily Encrypt the message using public key e and n: M ^ e mod n the result C is the encrypted message","title":"Calculate d and Encrypt the message"},{"location":"Misc/rsa-en%26decryption/#decrypt-c-using-private-key","text":"M = c ^ d mod n Sometimes it's being called the signature sign","title":"Decrypt C using private key"},{"location":"Operating%20System/cs124/","text":"CS-124: Operating Class from CalTech \u00b6 Protection and Security \u00b6 Feature 1: multiple processor operating modes -- kernel mode (part of OS running) + user mode Feature 2: virtual memory The processor maps virual address with physical address using a page table The memory management unit (MMU) performs this translation Translation Lookaside Buffer (TLB) cache page table entries to avoid memory access overhead when translating address. Only the kernel can manipulate the MMU's configuration. -- if user-mode code tries to access kernel space, processor notifies OS. Virual memory allows OS to give each process its own isolated address space. Console and FileIO \u00b6 read and write for standard input: basic_istream& read( char_type* s, std::streamsize count ); : read count size of input from s . basic_ostream& write( const char_type* s, std::streamsize count ); : write count size of data input s . EOF indicates by 0 return-value, error indicated by values < 0. Both read and write are syscalls, which takes a long time (milliseconds or microseconds because of context switches to another proces until I/O subsystem fires an interrupt to signal completion). filedes : file descriptor (ID represents a specific file or device). If there are multiple files open, all the filedes will be stored in an array (as pointers pointing to file object). Each file consists of current read/write offset within the file. UNIX command shell Operation \u00b6 Wait for a command to be entered on the shell's stdin Tokenize the command into an array of tokens If token[0] is an internal shell command, then handle the internal command and go back to 1. Otherwise, fork() off a child process to execute the program. wait() for the child process to terminate, then go back to 1. child process 1. If the parsed command specifies any redirection, modify stdin/stdout/stderr based on the command, and remove these tokens from the tokenized command 2. execve() the program specified in tokens[0] , passing tokens as the program\u2019s arguments 3. If we got here, execution failed (e.g. file not found)! Report error. IA32 Architecture \u00b6 supports several different memory addressing mechanisms IA32 has a segmented memory model: mapping from logical to linear address linear_address = gdt[segment_selector].base_address + offset Hard Disk Addressing \u00b6 Disk Sector Addressing Cylinder-Head-Sector (CHS) hard disk addressing: BIOS generally allows disks to have up to 1024 cylinders, 255 heads, and 63 sectors/track Sector is historically 512 bytes: 1024 \\times 255 \\times 63 \\times 512=7.8 GB 1024 \\times 255 \\times 63 \\times 512=7.8 GB Process Lifecycle \u00b6 New \u00b6 Created by the OS when startup (init) Created when a user invokes a program via command line or GUI Created when a process spawns another process Ready and Running \u00b6 Only one process may be running on each CPU at a time When a process is in \"running\" state , it holds the CPU Other processes that could run, but don't currently have the CPU, are in the \"ready\" state Interaction between Ready and Running \u00b6 New processes don't necessarily get the CPU right away: initially go into ready state The OS only allows the currently running prcess to hold the CPU for a specific amount of time When time-slice exprires, running prcess is preemped and the OS chooses another process to get the CPU Blocked \u00b6 Processes often perform long-running tasks e.g. read from hard disk, network, or some other external device e.g. process waits for another process (e.g. a signal or termination) The process becomes blocked until the resource is available Instead of holding everyone up, kernel removes process from CPU, and chooses another ready process to run When the long-running task is completed, the blocked process can resume execution proces is moved back into the ready state will eventually be chosen by the OS to run on the CPU again Terminated \u00b6 Processes eventually terminate Serveral tasks must be completed at process termination\\ Any \"at-exit\" operations must be performed Reclaim resources the process is still holding Other processes may need to observe terminating process' status Processes can terminate for serveral reasons: Voluntary terminate by the process itself (e.g. called exit() or returns from main() , either with success or error status Involuntary termination due to an unrecoverable fault in the process (e.g. segmentation fault due to dereferencing a NULL pointer). Involuntary termination due to a signal from another proces (e.g. another process issuess a SIGINT(^C) , SIGTERM or SIGKILL ) (Additional State: ready_suspended and block_suspended) \u00b6 Ability to suspend/resume processes A suspended process will not be scheduled until it is resumed A user can suspend a process with e.g. Ctrl-Z at command shell A process can send SIGDTOP to another process to suspend it The process being suspended might also have been blocked on a long-running operation Introduce another state to manage such processes Process Control Block (PCB) \u00b6 Kernel manages a mapping of Process ID to Process Control Blocks Linux uses a hashtable, with bins containing linked-lists of PCBs Process Status Information \u00b6 Process control block also includes scheduling details Running: Process is currently running on a CPU Ready: Process is ready to run, but waiting for a CPU Blocked: Process cannot proceed until receives a recoure or a message Status data can be used for: Specifying pending reource-request for this process Specifying other processes in the same state and priority Process Context-Switch \u00b6 When the OS switches from running a given process, the process' context must be saved into the process' PCB CPU state: registers, program counter, stack pointer, status flags Similarly, when the OS switches to another process, the new process' context must be restored from the PCB Context-swtches require a certain amount of time: Entering into the kernel: CPU handles the interrrupt (save prog ctr/stack, stack-switch) Handler saves CPU state of current process into the process' PCB Kernel often has to invoke the scheduler in order to choose what process to execute next Some syscalls don't cause a context-switch, but most tend to Leaving the kernel: kernel must restore CPU state from new process' PCB Kernel must also switch to new process' memory state Each process has its own page-table hierarchyt in its own PCB Must switch the virtual memory system to using the new process' memory mapping When kernel changes the memory mapping, it must also clear the MMU's Translation Lookaside Buffers (basically clear the cache) During a context-switch, the OS isn't doing useful work By \"useful work\", we maen \"running the user's application\" Want to minimize amount of time a context-switch takes e.g. make the scheduler fast, save/load CPU state fast, etc. Also want to minimize the frequency of context-swtiches If our system performs many context-switches, it will be spending less time doing useful work Ready and Blocked Processes \u00b6 The OS must manage multiple collections of processes (implemented as queue) Processes frequently block on long-running operations e.g. read data from a file on disk/CD-ROM/flash drive/etc. e.g. read data from a network socket e.g. wait for another process to terminate Need to remove such processes from the ready queue and put them into a collectioon of blocked processes Blocked processes usually become unblocked in interrupt handlers Processes and Threads \u00b6 Processes have one sequential thread of execution Why Multithreaded Processes? \u00b6 Performance (lot of ways that multithreading can improve performance) A cleaner abstraction for concurrent operations Race Condition \u00b6 A race condition is a scenario where: Two or more control paths [threads, processes, etc.] manipulate the same shared state The outcome is dependent on the order that the interactions take place (i.e. who winsthe race) Manifestation of race conditions is dependent on timing They don't always happend and very hard to fix Critical Sections \u00b6 Race conditions can be avoided by preventing multiple control paths from acccessing shared state concurrently Threads, processes, etc. A critical section is a piece of code that must not be executed concurretly by multiple control paths Mutual exclusion : carefully control entry into the critical section to allow only one thread of execution at a time Many different tools to enforce mutual exculusion in critical secions (semaphores, mutexes, read-write locks, etc.) Generally, these locks block threads (passive waiting) until they can entre the critical section OS kernels frequently requrie additional tools that are compatible with use in interrupt context (i.e. nonblocking) two process P_0 P_0 and P_1 P_1 repeatedly entering a critical section while ( true ) { flag[i] = true ; // i=0 for P_0, i=1 for P_1;j=1-i turn = j; // state intention to enter critical section while (flag[j] && turn == j); // wait to enter critical section //... critical section flag[i] = false ; //... non-critical section } a process P_i P_i can only exit the while-loop if one of these is true: flag[j]==false ( P_j P_j is outside te critical section) turn=i (it's P_i P_i 's turn to enter the critical section) Locks and Deadlocks \u00b6 Locking mechanisms for synchronization introduce the possibility of multiple prcesses entering into deadlock A set of prcesses is deadlockde if each process in the set is waiting for an event that only another process in the set can cause. Requirements for deadlock (satisfy anyone): Mutual exclusion : resources must be held in non-shareable mode Hold and wait : a process must be holding one resource, and waiting to acquire another resource that is currently unavailable No preemption : a resource cannot be preempted; the process must voluntarily release the resource Circular wait : the set of process {P_1, P_2,\u2026, P_n} {P_1, P_2,\u2026, P_n} can be ordered such that P_1 P_1 is wating for a resource held by P_2 P_2 , P_2 P_2 is waiting for a resource held by P_3, \u2026, P_{n-1} P_3, \u2026, P_{n-1} is waiting for a resource held by P_n P_n and P_n P_n is waiting for a resource held by P_1 P_1 Solution for deadlock: Breaking \"no preemption\" or the \"circular wait\" requirement of deadlock No preemption: if a process cannot acquire a resource, it cannot lock the resource (not practical) Circular wait: impose a total ordering over all lockable resources that all processes must follow As long as resources are only locked in the total ordering, deadlock can never occur If a process acquires a later resource in the ordering, must release all its locks and start over Usually not imposed by the OS; must be imposed by the programmer Deadlock Avoidane \u00b6 The system selectively fail resource requests in order to prevent deadlocks, system detects when allowing a request to block would cause a deadlock and reports an immediate failure on the request. Algorithm to use to detect deadlock: Banker's Algorithm . https://en.wikipedia.org/wiki/Banker%27s_algorithm#:~:text=The%20Banker%20algorithm%2C%20sometimes%20referred,state%22%20check%20to%20test%20for Total system resources are: A B C D 6 5 7 6 Available system resources are: A B C D 3 1 1 2 Processes (currently allocated resources): A B C D P1 1 2 2 1 P2 1 0 3 3 P3 1 2 1 0 Processes (maximum resources): A B C D P1 3 3 2 2 P2 1 2 3 4 P3 1 3 5 0 Need = maximum resources - currently allocated resources Processes (possibly needed resources): A B C D P1 2 1 0 1 P2 0 2 0 1 P3 0 1 4 0 Resolve Deadlock \u00b6 Semaphores are common synchronization mechanism Allows two or more processes to coordinate their actions Cannot use Semaphores in interrupt context Two operations: wait() and signal() \u2014> these to operations have to be enclosed in critical sections. Implementation of wait() : while sem.value==0: add this thread to sem.waiting list passively block the thread sem.value-- Implementation of signal() : sem.value++ if sem.waiting list is not empty: t=remove a thread from sem.waiting unblock t sem.value : how many times wait() can be called without blocking Use it to represent how much of a given resource is available Doesn't ensure mutual exclusion","title":"CS-124: Operating Class from CalTech"},{"location":"Operating%20System/cs124/#cs-124-operating-class-from-caltech","text":"","title":"CS-124: Operating Class from CalTech"},{"location":"Operating%20System/cs124/#protection-and-security","text":"Feature 1: multiple processor operating modes -- kernel mode (part of OS running) + user mode Feature 2: virtual memory The processor maps virual address with physical address using a page table The memory management unit (MMU) performs this translation Translation Lookaside Buffer (TLB) cache page table entries to avoid memory access overhead when translating address. Only the kernel can manipulate the MMU's configuration. -- if user-mode code tries to access kernel space, processor notifies OS. Virual memory allows OS to give each process its own isolated address space.","title":"Protection and Security"},{"location":"Operating%20System/cs124/#console-and-fileio","text":"read and write for standard input: basic_istream& read( char_type* s, std::streamsize count ); : read count size of input from s . basic_ostream& write( const char_type* s, std::streamsize count ); : write count size of data input s . EOF indicates by 0 return-value, error indicated by values < 0. Both read and write are syscalls, which takes a long time (milliseconds or microseconds because of context switches to another proces until I/O subsystem fires an interrupt to signal completion). filedes : file descriptor (ID represents a specific file or device). If there are multiple files open, all the filedes will be stored in an array (as pointers pointing to file object). Each file consists of current read/write offset within the file.","title":"Console and FileIO"},{"location":"Operating%20System/cs124/#unix-command-shell-operation","text":"Wait for a command to be entered on the shell's stdin Tokenize the command into an array of tokens If token[0] is an internal shell command, then handle the internal command and go back to 1. Otherwise, fork() off a child process to execute the program. wait() for the child process to terminate, then go back to 1. child process 1. If the parsed command specifies any redirection, modify stdin/stdout/stderr based on the command, and remove these tokens from the tokenized command 2. execve() the program specified in tokens[0] , passing tokens as the program\u2019s arguments 3. If we got here, execution failed (e.g. file not found)! Report error.","title":"UNIX command shell Operation"},{"location":"Operating%20System/cs124/#ia32-architecture","text":"supports several different memory addressing mechanisms IA32 has a segmented memory model: mapping from logical to linear address linear_address = gdt[segment_selector].base_address + offset","title":"IA32 Architecture"},{"location":"Operating%20System/cs124/#hard-disk-addressing","text":"Disk Sector Addressing Cylinder-Head-Sector (CHS) hard disk addressing: BIOS generally allows disks to have up to 1024 cylinders, 255 heads, and 63 sectors/track Sector is historically 512 bytes: 1024 \\times 255 \\times 63 \\times 512=7.8 GB 1024 \\times 255 \\times 63 \\times 512=7.8 GB","title":"Hard Disk Addressing"},{"location":"Operating%20System/cs124/#process-lifecycle","text":"","title":"Process Lifecycle"},{"location":"Operating%20System/cs124/#new","text":"Created by the OS when startup (init) Created when a user invokes a program via command line or GUI Created when a process spawns another process","title":"New"},{"location":"Operating%20System/cs124/#ready-and-running","text":"Only one process may be running on each CPU at a time When a process is in \"running\" state , it holds the CPU Other processes that could run, but don't currently have the CPU, are in the \"ready\" state","title":"Ready and Running"},{"location":"Operating%20System/cs124/#interaction-between-ready-and-running","text":"New processes don't necessarily get the CPU right away: initially go into ready state The OS only allows the currently running prcess to hold the CPU for a specific amount of time When time-slice exprires, running prcess is preemped and the OS chooses another process to get the CPU","title":"Interaction between Ready and Running"},{"location":"Operating%20System/cs124/#blocked","text":"Processes often perform long-running tasks e.g. read from hard disk, network, or some other external device e.g. process waits for another process (e.g. a signal or termination) The process becomes blocked until the resource is available Instead of holding everyone up, kernel removes process from CPU, and chooses another ready process to run When the long-running task is completed, the blocked process can resume execution proces is moved back into the ready state will eventually be chosen by the OS to run on the CPU again","title":"Blocked"},{"location":"Operating%20System/cs124/#terminated","text":"Processes eventually terminate Serveral tasks must be completed at process termination\\ Any \"at-exit\" operations must be performed Reclaim resources the process is still holding Other processes may need to observe terminating process' status Processes can terminate for serveral reasons: Voluntary terminate by the process itself (e.g. called exit() or returns from main() , either with success or error status Involuntary termination due to an unrecoverable fault in the process (e.g. segmentation fault due to dereferencing a NULL pointer). Involuntary termination due to a signal from another proces (e.g. another process issuess a SIGINT(^C) , SIGTERM or SIGKILL )","title":"Terminated"},{"location":"Operating%20System/cs124/#additional-state-ready_suspended-and-block_suspended","text":"Ability to suspend/resume processes A suspended process will not be scheduled until it is resumed A user can suspend a process with e.g. Ctrl-Z at command shell A process can send SIGDTOP to another process to suspend it The process being suspended might also have been blocked on a long-running operation Introduce another state to manage such processes","title":"(Additional State: ready_suspended and block_suspended)"},{"location":"Operating%20System/cs124/#process-control-block-pcb","text":"Kernel manages a mapping of Process ID to Process Control Blocks Linux uses a hashtable, with bins containing linked-lists of PCBs","title":"Process Control Block (PCB)"},{"location":"Operating%20System/cs124/#process-status-information","text":"Process control block also includes scheduling details Running: Process is currently running on a CPU Ready: Process is ready to run, but waiting for a CPU Blocked: Process cannot proceed until receives a recoure or a message Status data can be used for: Specifying pending reource-request for this process Specifying other processes in the same state and priority","title":"Process Status Information"},{"location":"Operating%20System/cs124/#process-context-switch","text":"When the OS switches from running a given process, the process' context must be saved into the process' PCB CPU state: registers, program counter, stack pointer, status flags Similarly, when the OS switches to another process, the new process' context must be restored from the PCB Context-swtches require a certain amount of time: Entering into the kernel: CPU handles the interrrupt (save prog ctr/stack, stack-switch) Handler saves CPU state of current process into the process' PCB Kernel often has to invoke the scheduler in order to choose what process to execute next Some syscalls don't cause a context-switch, but most tend to Leaving the kernel: kernel must restore CPU state from new process' PCB Kernel must also switch to new process' memory state Each process has its own page-table hierarchyt in its own PCB Must switch the virtual memory system to using the new process' memory mapping When kernel changes the memory mapping, it must also clear the MMU's Translation Lookaside Buffers (basically clear the cache) During a context-switch, the OS isn't doing useful work By \"useful work\", we maen \"running the user's application\" Want to minimize amount of time a context-switch takes e.g. make the scheduler fast, save/load CPU state fast, etc. Also want to minimize the frequency of context-swtiches If our system performs many context-switches, it will be spending less time doing useful work","title":"Process Context-Switch"},{"location":"Operating%20System/cs124/#ready-and-blocked-processes","text":"The OS must manage multiple collections of processes (implemented as queue) Processes frequently block on long-running operations e.g. read data from a file on disk/CD-ROM/flash drive/etc. e.g. read data from a network socket e.g. wait for another process to terminate Need to remove such processes from the ready queue and put them into a collectioon of blocked processes Blocked processes usually become unblocked in interrupt handlers","title":"Ready and Blocked Processes"},{"location":"Operating%20System/cs124/#processes-and-threads","text":"Processes have one sequential thread of execution","title":"Processes and Threads"},{"location":"Operating%20System/cs124/#why-multithreaded-processes","text":"Performance (lot of ways that multithreading can improve performance) A cleaner abstraction for concurrent operations","title":"Why Multithreaded Processes?"},{"location":"Operating%20System/cs124/#race-condition","text":"A race condition is a scenario where: Two or more control paths [threads, processes, etc.] manipulate the same shared state The outcome is dependent on the order that the interactions take place (i.e. who winsthe race) Manifestation of race conditions is dependent on timing They don't always happend and very hard to fix","title":"Race Condition"},{"location":"Operating%20System/cs124/#critical-sections","text":"Race conditions can be avoided by preventing multiple control paths from acccessing shared state concurrently Threads, processes, etc. A critical section is a piece of code that must not be executed concurretly by multiple control paths Mutual exclusion : carefully control entry into the critical section to allow only one thread of execution at a time Many different tools to enforce mutual exculusion in critical secions (semaphores, mutexes, read-write locks, etc.) Generally, these locks block threads (passive waiting) until they can entre the critical section OS kernels frequently requrie additional tools that are compatible with use in interrupt context (i.e. nonblocking) two process P_0 P_0 and P_1 P_1 repeatedly entering a critical section while ( true ) { flag[i] = true ; // i=0 for P_0, i=1 for P_1;j=1-i turn = j; // state intention to enter critical section while (flag[j] && turn == j); // wait to enter critical section //... critical section flag[i] = false ; //... non-critical section } a process P_i P_i can only exit the while-loop if one of these is true: flag[j]==false ( P_j P_j is outside te critical section) turn=i (it's P_i P_i 's turn to enter the critical section)","title":"Critical Sections"},{"location":"Operating%20System/cs124/#locks-and-deadlocks","text":"Locking mechanisms for synchronization introduce the possibility of multiple prcesses entering into deadlock A set of prcesses is deadlockde if each process in the set is waiting for an event that only another process in the set can cause. Requirements for deadlock (satisfy anyone): Mutual exclusion : resources must be held in non-shareable mode Hold and wait : a process must be holding one resource, and waiting to acquire another resource that is currently unavailable No preemption : a resource cannot be preempted; the process must voluntarily release the resource Circular wait : the set of process {P_1, P_2,\u2026, P_n} {P_1, P_2,\u2026, P_n} can be ordered such that P_1 P_1 is wating for a resource held by P_2 P_2 , P_2 P_2 is waiting for a resource held by P_3, \u2026, P_{n-1} P_3, \u2026, P_{n-1} is waiting for a resource held by P_n P_n and P_n P_n is waiting for a resource held by P_1 P_1 Solution for deadlock: Breaking \"no preemption\" or the \"circular wait\" requirement of deadlock No preemption: if a process cannot acquire a resource, it cannot lock the resource (not practical) Circular wait: impose a total ordering over all lockable resources that all processes must follow As long as resources are only locked in the total ordering, deadlock can never occur If a process acquires a later resource in the ordering, must release all its locks and start over Usually not imposed by the OS; must be imposed by the programmer","title":"Locks and Deadlocks"},{"location":"Operating%20System/cs124/#deadlock-avoidane","text":"The system selectively fail resource requests in order to prevent deadlocks, system detects when allowing a request to block would cause a deadlock and reports an immediate failure on the request. Algorithm to use to detect deadlock: Banker's Algorithm . https://en.wikipedia.org/wiki/Banker%27s_algorithm#:~:text=The%20Banker%20algorithm%2C%20sometimes%20referred,state%22%20check%20to%20test%20for Total system resources are: A B C D 6 5 7 6 Available system resources are: A B C D 3 1 1 2 Processes (currently allocated resources): A B C D P1 1 2 2 1 P2 1 0 3 3 P3 1 2 1 0 Processes (maximum resources): A B C D P1 3 3 2 2 P2 1 2 3 4 P3 1 3 5 0 Need = maximum resources - currently allocated resources Processes (possibly needed resources): A B C D P1 2 1 0 1 P2 0 2 0 1 P3 0 1 4 0","title":"Deadlock Avoidane"},{"location":"Operating%20System/cs124/#resolve-deadlock","text":"Semaphores are common synchronization mechanism Allows two or more processes to coordinate their actions Cannot use Semaphores in interrupt context Two operations: wait() and signal() \u2014> these to operations have to be enclosed in critical sections. Implementation of wait() : while sem.value==0: add this thread to sem.waiting list passively block the thread sem.value-- Implementation of signal() : sem.value++ if sem.waiting list is not empty: t=remove a thread from sem.waiting unblock t sem.value : how many times wait() can be called without blocking Use it to represent how much of a given resource is available Doesn't ensure mutual exclusion","title":"Resolve Deadlock"},{"location":"Python/Tips/","text":"Python Tips \u00b6 Counter vs defaultdict \u00b6 https://stackoverflow.com/a/19883180 Key difference: Counter won't add new keys to the dict when you query for missing keys. So, if your queries include keys that may not be present in the dict then better use Counter . However, Counter is slower than defaultdict : https://stackoverflow.com/a/27802189 range keyword \u00b6 Start from 0 to 5: for i in range ( 0 , 6 ): print (i) ## 0, 1, 2, 3, 4, 5 Start from 5 to 0: for i in range ( 5 , -1 , -1 ): print (i) ## 5, 4, 3, 2, 1, 0 The range is (parameter order): [start, end) and the last parameter is the increment amount Sorting \u00b6 Python 3 doesn't encourage to use custom comparater as a function any more, and it recommended to use a lambda expression for sorting, for example: We have a list of tuple p , and each tuple p[i] has two elements p[i][0] and p[i][1] . Default: sort the tuple p in increasing order, and if p[i][0] is equal to p[i+1][0] , we compare p[i][1] with p[i+1][1] , and choose the smaller one. What if: sort the tuple p in increasing order, and if p[i][0] is equal to p[i+1][0] , we compare p[i][1] with p[i+1][1] , and choose the larger one. ## 1. default sort p . sort() ## nothing to feed the key ## 2. what if p . sort(key = lambda x : (x[ 0 ], - x[ 1 ])) ## sort by p[i][0] in increasing order, and then sort p[i][1] in decreasing order Notice the lambda expression here: on the right hand side, it feeds in to two paramters, which are actually expended by one p[i] because we use a parenthesis to enclose them. For each And there are two ways to sort, according to Python doc: Python lists have a built-in list.sort() method that modifies the list in-place. There is also a sorted() built-in function that builds a new sorted list from an iterable. Binary search \u00b6 https://docs.python.org/3/library/bisect.html def index (a, x): 'Locate the leftmost value exactly equal to x' i = bisect_left(a, x) if i != len (a) and a[i] == x: return i raise ValueError def find_lt (a, x): 'Find rightmost value less than x' i = bisect_left(a, x) if i: return a[i -1 ] raise ValueError def find_le (a, x): 'Find rightmost value less than or equal to x' i = bisect_right(a, x) if i: return a[i -1 ] raise ValueError def find_gt (a, x): 'Find leftmost value greater than x' i = bisect_right(a, x) if i != len (a): return a[i] raise ValueError def find_ge (a, x): 'Find leftmost item greater than or equal to x' i = bisect_left(a, x) if i != len (a): return a[i] raise ValueError Visually: 1, 1, 2, 2, 3, 4, 4, 5 find(2) ^ bisect_left (<) ^ bisect/bisect_right (<=) Note : for bisect and bisect_right it always returns the target index + 1, so don't forget to subtract 1 from it! String \u00b6 replace by pattern/substring \u00b6 str.replace(*old*, *new*[, *count*]) Return a copy of the string with all occurrences of substring old replaced by new . If the optional argument count is given, only the first count occurrences are replaced. Check if is alpha (english letter) \u00b6 S[j].isalpha()","title":"Tips"},{"location":"Python/Tips/#python-tips","text":"","title":"Python Tips"},{"location":"Python/Tips/#counter-vs-defaultdict","text":"https://stackoverflow.com/a/19883180 Key difference: Counter won't add new keys to the dict when you query for missing keys. So, if your queries include keys that may not be present in the dict then better use Counter . However, Counter is slower than defaultdict : https://stackoverflow.com/a/27802189","title":"Counter vs defaultdict"},{"location":"Python/Tips/#range-keyword","text":"Start from 0 to 5: for i in range ( 0 , 6 ): print (i) ## 0, 1, 2, 3, 4, 5 Start from 5 to 0: for i in range ( 5 , -1 , -1 ): print (i) ## 5, 4, 3, 2, 1, 0 The range is (parameter order): [start, end) and the last parameter is the increment amount","title":"range keyword"},{"location":"Python/Tips/#sorting","text":"Python 3 doesn't encourage to use custom comparater as a function any more, and it recommended to use a lambda expression for sorting, for example: We have a list of tuple p , and each tuple p[i] has two elements p[i][0] and p[i][1] . Default: sort the tuple p in increasing order, and if p[i][0] is equal to p[i+1][0] , we compare p[i][1] with p[i+1][1] , and choose the smaller one. What if: sort the tuple p in increasing order, and if p[i][0] is equal to p[i+1][0] , we compare p[i][1] with p[i+1][1] , and choose the larger one. ## 1. default sort p . sort() ## nothing to feed the key ## 2. what if p . sort(key = lambda x : (x[ 0 ], - x[ 1 ])) ## sort by p[i][0] in increasing order, and then sort p[i][1] in decreasing order Notice the lambda expression here: on the right hand side, it feeds in to two paramters, which are actually expended by one p[i] because we use a parenthesis to enclose them. For each And there are two ways to sort, according to Python doc: Python lists have a built-in list.sort() method that modifies the list in-place. There is also a sorted() built-in function that builds a new sorted list from an iterable.","title":"Sorting"},{"location":"Python/Tips/#binary-search","text":"https://docs.python.org/3/library/bisect.html def index (a, x): 'Locate the leftmost value exactly equal to x' i = bisect_left(a, x) if i != len (a) and a[i] == x: return i raise ValueError def find_lt (a, x): 'Find rightmost value less than x' i = bisect_left(a, x) if i: return a[i -1 ] raise ValueError def find_le (a, x): 'Find rightmost value less than or equal to x' i = bisect_right(a, x) if i: return a[i -1 ] raise ValueError def find_gt (a, x): 'Find leftmost value greater than x' i = bisect_right(a, x) if i != len (a): return a[i] raise ValueError def find_ge (a, x): 'Find leftmost item greater than or equal to x' i = bisect_left(a, x) if i != len (a): return a[i] raise ValueError Visually: 1, 1, 2, 2, 3, 4, 4, 5 find(2) ^ bisect_left (<) ^ bisect/bisect_right (<=) Note : for bisect and bisect_right it always returns the target index + 1, so don't forget to subtract 1 from it!","title":"Binary search"},{"location":"Python/Tips/#string","text":"","title":"String"},{"location":"Python/Tips/#replace-by-patternsubstring","text":"str.replace(*old*, *new*[, *count*]) Return a copy of the string with all occurrences of substring old replaced by new . If the optional argument count is given, only the first count occurrences are replaced.","title":"replace by pattern/substring"},{"location":"Python/Tips/#check-if-is-alpha-english-letter","text":"S[j].isalpha()","title":"Check if is alpha (english letter)"},{"location":"c/functional-programming-with-futures-to-implement-quick-sort/","text":"Functional Programming in C \u00b6 content quoted from C++ Concurreny in Action by Anthony Williams The term functional programming (FP) refers to a style of programming where the result of a function call depends solely on the parameters to that function and doesn\u2019t depend on any external state. This is related to the mathematical concept of a func- tion, and it means that if you invoke a function twice with the same parameters, the result is exactly the same. This is a property of many of the mathematical functions in the C++ Standard Library, such as sin, cos, and sqrt, and simple operations on basic types, such as 3+3, 6*9, or 1.\u00be.7. A pure function doesn\u2019t modify any external state either; the effects of the function are entirely limited to the return value. C++ is a multiparadigm language, and it\u2019s entirely possible to write programs in the FP style. This is even easier in C++11 than it was in C++98, with the advent of lambda functions (see appendix A, section A.6), the incorporation of std::bind from Boost and TR1, and the introduction of automatic type deduction for variables (see appendix A, section A.7). Futures are the final piece of the puzzle that makes FP-style concurrency viable in C++; a future can be passed around between threads to allow the result of one computation to depend on the result of another, without any explicit access to shared data. The big change here is that rather than sorting the lower portion on the current thread, you sort it on another thread using std::async() By recursively calling parallel_ quick_sort(), you can take advantage of the available hardware concurrency. If std::async() starts a new thread every time, then if you recurse down three times, you\u2019ll have eight threads running; if you recurse down 10 times (for ~1000 ele- ments), you\u2019ll have 1,024 threads running if the hardware can handle it. If the library decides there are too many spawned tasks (perhaps because the number of tasks has exceeded the available hardware concurrency), it may switch to spawning the new The upper portion of the list is sorted with direct recursion as before Because you just used direct recursion to get new_higher, you can splice it into place as before But new_lower is now std::future <std::list<T>> rather than a list, so you need to call get() to retrieve the value before you can call splice(). This then waits for the background task to complete and moves the result into the splice() call; get() returns an rvalue reference to the contained result, so it can be moved out.","title":"Functional Programming in C"},{"location":"c/functional-programming-with-futures-to-implement-quick-sort/#functional-programming-in-c","text":"content quoted from C++ Concurreny in Action by Anthony Williams The term functional programming (FP) refers to a style of programming where the result of a function call depends solely on the parameters to that function and doesn\u2019t depend on any external state. This is related to the mathematical concept of a func- tion, and it means that if you invoke a function twice with the same parameters, the result is exactly the same. This is a property of many of the mathematical functions in the C++ Standard Library, such as sin, cos, and sqrt, and simple operations on basic types, such as 3+3, 6*9, or 1.\u00be.7. A pure function doesn\u2019t modify any external state either; the effects of the function are entirely limited to the return value. C++ is a multiparadigm language, and it\u2019s entirely possible to write programs in the FP style. This is even easier in C++11 than it was in C++98, with the advent of lambda functions (see appendix A, section A.6), the incorporation of std::bind from Boost and TR1, and the introduction of automatic type deduction for variables (see appendix A, section A.7). Futures are the final piece of the puzzle that makes FP-style concurrency viable in C++; a future can be passed around between threads to allow the result of one computation to depend on the result of another, without any explicit access to shared data. The big change here is that rather than sorting the lower portion on the current thread, you sort it on another thread using std::async() By recursively calling parallel_ quick_sort(), you can take advantage of the available hardware concurrency. If std::async() starts a new thread every time, then if you recurse down three times, you\u2019ll have eight threads running; if you recurse down 10 times (for ~1000 ele- ments), you\u2019ll have 1,024 threads running if the hardware can handle it. If the library decides there are too many spawned tasks (perhaps because the number of tasks has exceeded the available hardware concurrency), it may switch to spawning the new The upper portion of the list is sorted with direct recursion as before Because you just used direct recursion to get new_higher, you can splice it into place as before But new_lower is now std::future <std::list<T>> rather than a list, so you need to call get() to retrieve the value before you can call splice(). This then waits for the background task to complete and moves the result into the splice() call; get() returns an rvalue reference to the contained result, so it can be moved out.","title":"Functional Programming in C"},{"location":"c/marcos-vs-functions/","text":"Marcos vs Functions \u00b6 Marco Definition \u00b6 Macros are pre-processed which means that all the macros would be processed before your program compiles. However, functions are not preprocessed but compiled. Comparsion \u00b6 Marco Preprocessed No type checking done in Marco Faster Useful when small code is repeated many times Doesn't check compile time error Function Compiled Type checking is performed Slower Large code piece Check compile-time error","title":"Marcos vs Functions"},{"location":"c/marcos-vs-functions/#marcos-vs-functions","text":"","title":"Marcos vs Functions"},{"location":"c/marcos-vs-functions/#marco-definition","text":"Macros are pre-processed which means that all the macros would be processed before your program compiles. However, functions are not preprocessed but compiled.","title":"Marco Definition"},{"location":"c/marcos-vs-functions/#comparsion","text":"Marco Preprocessed No type checking done in Marco Faster Useful when small code is repeated many times Doesn't check compile time error Function Compiled Type checking is performed Slower Large code piece Check compile-time error","title":"Comparsion"},{"location":"c/misc/","text":"Cpp\u9762\u8bd5 \u00b6 http://blog.providencezhang.cn/2019/02/18/lang-notebook/ decltype:\u6709\u65f6\u6211\u4eec\u5e0c\u671b\u4ece\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u63a8\u65ad\u51fa\u8981\u5b9a\u4e49\u7684\u53d8\u91cf\u7c7b\u578b\uff0c\u4f46\u662f\u4e0d\u60f3\u7528\u8be5\u8868\u8fbe\u5f0f\u7684\u503c\u521d\u59cb\u5316\u53d8\u91cf\uff08\u521d\u59cb\u5316\u53ef\u4ee5\u7528auto\uff09\u3002\u4e3a\u4e86\u6ee1\u8db3\u8fd9\u4e00\u9700\u6c42\uff0cC++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86decltype\u7c7b\u578b\u8bf4\u660e\u7b26\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\uff0c\u7f16\u8bd1\u5668\u5206\u6790\u8868\u8fbe\u5f0f\u5e76\u5f97\u5230\u5b83\u7684\u7c7b\u578b\uff0c\u5374\u4e0d\u5b9e\u9645\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7684\u503c\u3002 int getSize (); int main ( void ) { int tempA = 2 ; /*1.dclTempA\u4e3aint.*/ decltype(tempA) dclTempA; /*2.dclTempB\u4e3aint\uff0c\u5bf9\u4e8egetSize\u6839\u672c\u6ca1\u6709\u5b9a\u4e49\uff0c\u4f46\u662f\u7a0b\u5e8f\u4f9d\u65e7\u6b63\u5e38\uff0c\u56e0\u4e3adecltype\u53ea\u505a\u5206\u6790\uff0c\u5e76\u4e0d\u8c03\u7528getSize().*/ decltype(getSize()) dclTempB; \u200b return 0 ; } mod \u00b6 1024 % 10 ; // = 4 -1024 % 10 ; //-4 inf \u00b6 use 0x3f3f3f3f if there is a need to do addition else use 0x7fffffff Tuple \u00b6 // packing/unpacking tuples #include <iostream> // std::cout #include <tuple> // std::tuple, std::make_tuple, std::tie int main () { int myint; char mychar; std :: tuple < int , float , char > mytuple; mytuple = std :: make_tuple ( 10 , 2.6 , 'a' ); // packing values into tuple std :: tie (myint, std :: ignore, mychar) = mytuple; // unpacking tuple into variables std :: cout << \"myint contains: \" << myint << '\\n' ; std :: cout << \"mychar contains: \" << mychar << '\\n' ; return 0 ; } Operator \u00b6 &: left & right in compiler doesn't have fix order (either left to right or right to left) : neg divide isn't right -> e.g. -3 / 2 = 101 >> 1 = 110 = -2 which is wrong set kth bit to zero: x & ~(1 << k) Customize Hashing for your class \u00b6 #include <iostream> #include <iomanip> #include <functional> #include <string> #include <unordered_set> struct S { std :: string first_name; std :: string last_name; }; bool operator == ( const S & lhs, const S & rhs) { return lhs.first_name == rhs.first_name && lhs.last_name == rhs.last_name; } // custom hash can be a standalone function object: struct MyHash { std :: size_t operator()(S const & s) const noexcept { std :: size_t h1 = std :: hash < std :: string > {}(s.first_name); std :: size_t h2 = std :: hash < std :: string > {}(s.last_name); return h1 ^ (h2 << 1 ); // or use boost::hash_combine (see Discussion) } }; // custom specialization of std::hash can be injected in namespace std namespace std { template <> struct hash < S > { std :: size_t operator()(S const & s) const noexcept { std :: size_t h1 = std :: hash < std :: string > {}(s.first_name); std :: size_t h2 = std :: hash < std :: string > {}(s.last_name); return h1 ^ (h2 << 1 ); // or use boost::hash_combine } }; } int main() { std :: string str = \"Meet the new boss...\" ; std :: size_t str_hash = std :: hash < std :: string > {}(str); std :: cout << \"hash(\" << std :: quoted(str) << \") = \" << str_hash << '\\n' ; S obj = { \"Hubert\" , \"Farnsworth\" }; // using the standalone function object std :: cout << \"hash(\" << std :: quoted(obj.first_name) << ',' << std :: quoted(obj.last_name) << \") = \" << MyHash{}(obj) << \" (using MyHash) \\n or \" << std :: hash < S > {}(obj) << \" (using injected std::hash<S> specialization) \\n \" ; // custom hash makes it possible to use custom types in unordered containers // The example will use the injected std::hash<S> specialization above, // to use MyHash instead, pass it as a second template argument std :: unordered_set < S > names = {obj, { \"Bender\" , \"Rodriguez\" }, { \"Turanga\" , \"Leela\" } }; for ( auto & s : names) std :: cout << std :: quoted(s.first_name) << ' ' << std :: quoted(s.last_name) << '\\n' ; } hash(\"Meet the new boss...\") = 1861821886482076440 hash(\"Hubert\",\"Farnsworth\") = 17622465712001802105 (using MyHash) or 17622465712001802105 (using injected std::hash<S> specialization) \"Turanga\" \"Leela\" \"Bender\" \"Rodriguez\" \"Hubert\" \"Farnsworth\" Parse string to int \u00b6 use atoi(s.c_str()); because it can handle leading zero (drop it). what it does is convert the s to char*.","title":"Misc"},{"location":"c/misc/#cpp","text":"http://blog.providencezhang.cn/2019/02/18/lang-notebook/ decltype:\u6709\u65f6\u6211\u4eec\u5e0c\u671b\u4ece\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u63a8\u65ad\u51fa\u8981\u5b9a\u4e49\u7684\u53d8\u91cf\u7c7b\u578b\uff0c\u4f46\u662f\u4e0d\u60f3\u7528\u8be5\u8868\u8fbe\u5f0f\u7684\u503c\u521d\u59cb\u5316\u53d8\u91cf\uff08\u521d\u59cb\u5316\u53ef\u4ee5\u7528auto\uff09\u3002\u4e3a\u4e86\u6ee1\u8db3\u8fd9\u4e00\u9700\u6c42\uff0cC++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86decltype\u7c7b\u578b\u8bf4\u660e\u7b26\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\uff0c\u7f16\u8bd1\u5668\u5206\u6790\u8868\u8fbe\u5f0f\u5e76\u5f97\u5230\u5b83\u7684\u7c7b\u578b\uff0c\u5374\u4e0d\u5b9e\u9645\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7684\u503c\u3002 int getSize (); int main ( void ) { int tempA = 2 ; /*1.dclTempA\u4e3aint.*/ decltype(tempA) dclTempA; /*2.dclTempB\u4e3aint\uff0c\u5bf9\u4e8egetSize\u6839\u672c\u6ca1\u6709\u5b9a\u4e49\uff0c\u4f46\u662f\u7a0b\u5e8f\u4f9d\u65e7\u6b63\u5e38\uff0c\u56e0\u4e3adecltype\u53ea\u505a\u5206\u6790\uff0c\u5e76\u4e0d\u8c03\u7528getSize().*/ decltype(getSize()) dclTempB; \u200b return 0 ; }","title":"Cpp\u9762\u8bd5"},{"location":"c/misc/#mod","text":"1024 % 10 ; // = 4 -1024 % 10 ; //-4","title":"mod"},{"location":"c/misc/#inf","text":"use 0x3f3f3f3f if there is a need to do addition else use 0x7fffffff","title":"inf"},{"location":"c/misc/#tuple","text":"// packing/unpacking tuples #include <iostream> // std::cout #include <tuple> // std::tuple, std::make_tuple, std::tie int main () { int myint; char mychar; std :: tuple < int , float , char > mytuple; mytuple = std :: make_tuple ( 10 , 2.6 , 'a' ); // packing values into tuple std :: tie (myint, std :: ignore, mychar) = mytuple; // unpacking tuple into variables std :: cout << \"myint contains: \" << myint << '\\n' ; std :: cout << \"mychar contains: \" << mychar << '\\n' ; return 0 ; }","title":"Tuple"},{"location":"c/misc/#operator","text":"&: left & right in compiler doesn't have fix order (either left to right or right to left) : neg divide isn't right -> e.g. -3 / 2 = 101 >> 1 = 110 = -2 which is wrong set kth bit to zero: x & ~(1 << k)","title":"Operator"},{"location":"c/misc/#customize-hashing-for-your-class","text":"#include <iostream> #include <iomanip> #include <functional> #include <string> #include <unordered_set> struct S { std :: string first_name; std :: string last_name; }; bool operator == ( const S & lhs, const S & rhs) { return lhs.first_name == rhs.first_name && lhs.last_name == rhs.last_name; } // custom hash can be a standalone function object: struct MyHash { std :: size_t operator()(S const & s) const noexcept { std :: size_t h1 = std :: hash < std :: string > {}(s.first_name); std :: size_t h2 = std :: hash < std :: string > {}(s.last_name); return h1 ^ (h2 << 1 ); // or use boost::hash_combine (see Discussion) } }; // custom specialization of std::hash can be injected in namespace std namespace std { template <> struct hash < S > { std :: size_t operator()(S const & s) const noexcept { std :: size_t h1 = std :: hash < std :: string > {}(s.first_name); std :: size_t h2 = std :: hash < std :: string > {}(s.last_name); return h1 ^ (h2 << 1 ); // or use boost::hash_combine } }; } int main() { std :: string str = \"Meet the new boss...\" ; std :: size_t str_hash = std :: hash < std :: string > {}(str); std :: cout << \"hash(\" << std :: quoted(str) << \") = \" << str_hash << '\\n' ; S obj = { \"Hubert\" , \"Farnsworth\" }; // using the standalone function object std :: cout << \"hash(\" << std :: quoted(obj.first_name) << ',' << std :: quoted(obj.last_name) << \") = \" << MyHash{}(obj) << \" (using MyHash) \\n or \" << std :: hash < S > {}(obj) << \" (using injected std::hash<S> specialization) \\n \" ; // custom hash makes it possible to use custom types in unordered containers // The example will use the injected std::hash<S> specialization above, // to use MyHash instead, pass it as a second template argument std :: unordered_set < S > names = {obj, { \"Bender\" , \"Rodriguez\" }, { \"Turanga\" , \"Leela\" } }; for ( auto & s : names) std :: cout << std :: quoted(s.first_name) << ' ' << std :: quoted(s.last_name) << '\\n' ; } hash(\"Meet the new boss...\") = 1861821886482076440 hash(\"Hubert\",\"Farnsworth\") = 17622465712001802105 (using MyHash) or 17622465712001802105 (using injected std::hash<S> specialization) \"Turanga\" \"Leela\" \"Bender\" \"Rodriguez\" \"Hubert\" \"Farnsworth\"","title":"Customize Hashing for your class"},{"location":"c/misc/#parse-string-to-int","text":"use atoi(s.c_str()); because it can handle leading zero (drop it). what it does is convert the s to char*.","title":"Parse string to int"},{"location":"c/overloading-operator/","text":"Overloading Operator \u00b6 Sort Operator on Struct \u00b6 struct Edge { int a, b, w; bool operator < ( const Edge & t) const { return w < t.w; // will sort from small to big, aka, increasing order } }e[M]; sort(e, e + m);","title":"Overloading Operator"},{"location":"c/overloading-operator/#overloading-operator","text":"","title":"Overloading Operator"},{"location":"c/overloading-operator/#sort-operator-on-struct","text":"struct Edge { int a, b, w; bool operator < ( const Edge & t) const { return w < t.w; // will sort from small to big, aka, increasing order } }e[M]; sort(e, e + m);","title":"Sort Operator on Struct"},{"location":"c/smart-pointers/","text":"Smart Pointer \u00b6 https://www.educative.io/edpresso/what-are-smart-pointers Definition \u00b6 Smart pointers are just classes that wrap the raw pointer and overload the -> and * operators; this allows them to offer the same syntax as a raw pointer. C++11 has three types of smart pointers that are defined in the <memory> header of the Standard Library. They are: std::unique_ptr : only itself can reference it, if you want to copy, call std::move(ptr) std::shared_ptr : allow multiple references, keep track of the reference with reference counting , when the count == 0, the object is destroyed. Using ptr.std::reset() to destroy one reference to the ptr pointer. std::weak_ptr : std::weak_ptr models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, std::weak_ptr is used to track the object, and it is converted to std::shared_ptr to assume temporary ownership. If the original std::shared_ptr is destroyed at this time, the object's lifetime is extended until the temporary std::shared_ptr is destroyed as well. Another use for std::weak_ptr is to break reference cycles formed by objects managed by std::shared_ptr. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak. cppreference.com","title":"Smart Pointer"},{"location":"c/smart-pointers/#smart-pointer","text":"https://www.educative.io/edpresso/what-are-smart-pointers","title":"Smart Pointer"},{"location":"c/smart-pointers/#definition","text":"Smart pointers are just classes that wrap the raw pointer and overload the -> and * operators; this allows them to offer the same syntax as a raw pointer. C++11 has three types of smart pointers that are defined in the <memory> header of the Standard Library. They are: std::unique_ptr : only itself can reference it, if you want to copy, call std::move(ptr) std::shared_ptr : allow multiple references, keep track of the reference with reference counting , when the count == 0, the object is destroyed. Using ptr.std::reset() to destroy one reference to the ptr pointer. std::weak_ptr : std::weak_ptr models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, std::weak_ptr is used to track the object, and it is converted to std::shared_ptr to assume temporary ownership. If the original std::shared_ptr is destroyed at this time, the object's lifetime is extended until the temporary std::shared_ptr is destroyed as well. Another use for std::weak_ptr is to break reference cycles formed by objects managed by std::shared_ptr. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak. cppreference.com","title":"Definition"},{"location":"c/stl-complexity/","text":"STL Complexity \u00b6 String \u00b6 substr Space: O(n) O(n) , Time: O(n) O(n) \u00b6 s.substr(pos, n) Return a string containing n characters from s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos. string s ( \"hello world\" ); string s2 = s.substr( 0 , 5 ); // s2 = hello string s3 = s.substr( 6 ); // s3 = world string s4 = s.substr( 6 , 11 ); // s4 = world string s5 = s.substr( 12 ); // throws an out_of_range exception","title":"STL Complexity"},{"location":"c/stl-complexity/#stl-complexity","text":"","title":"STL Complexity"},{"location":"c/stl-complexity/#string","text":"","title":"String"},{"location":"c/stl-complexity/#substr-space-onon-time-onon","text":"s.substr(pos, n) Return a string containing n characters from s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos. string s ( \"hello world\" ); string s2 = s.substr( 0 , 5 ); // s2 = hello string s3 = s.substr( 6 ); // s3 = world string s4 = s.substr( 6 , 11 ); // s4 = world string s5 = s.substr( 12 ); // throws an out_of_range exception","title":"substr Space: O(n)O(n), Time: O(n)O(n)"},{"location":"golang/Intro-To-Golang/","text":"Notes for reading Caleb Doxsey - Introducing Go_ Build Reliable, Scalable Programs \u00b6 defer , panic , and recover keywords \u00b6 url Some advantages for using defer : It keeps our Close call near our Open call so it\u2019s easier to understand. If our function had multiple return statements (perhaps one in an if and one in an else), Close will happen before both of them. Deferred functions are run even if a runtime panic occurs. func CopyFile(dstName, srcName string ) (written int64 , err error ) { src, err := os.Open(srcName) if err != nil { return } dst, err := os.Create(dstName) if err != nil { return } written, err = io.Copy(dst, src) dst.Close() src.Close() return } If the call to os.Create fails, the function will return without closing the source file. This can be easily remedied by putting a call to src.Close before the second return statement, but if the function were more complex the problem might not be so easily noticed and resolved. By introducing defer statements we can ensure that the files are always closed: func CopyFile(dstName, srcName string ) (written int64 , err error ) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() // this will be called before line 4 if err != nil dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() // this will be called before line 10 if err != nil return io.Copy(dst, src) } However, there are some pitfalls: func a() { i := 0 defer fmt.Println(i) i ++ return } Instead of printing 1, it will print 0, although the fmt.Println(i) is being called after i++. defer will save the current state of the function \u2014 including local variable \u2014 to run before the very last line of the function. func b() { for i := 0 ; i < 4 ; i ++ { defer fmt.Print(i) } } If there are multiple defer , the final order will be called as LIFO or like a stack: 0 defer first, so it's at the bottom of the stack, 1 second, so second place of the stack, etc. The final output will be 3 -> 2 -> 1 -> 0 It's a bit hard to understand, stackoverflow : Deferred functions may read and assign to the returning function's named return values. You can specify the return value and its type in the function signacture: func a() (i int ) { // return 2 since it return nothing i = 2 return } func b() (i int ) { // return 1 since it \"override\" what should be returned i = 2 return 1 } So func c() (i int ) { defer func () { i ++ }() return 1 } This deferred func() just specify the return value and type, and it got executed after 1 is returned Receiver \u00b6 // instead of using &c to pass as reference to the function func circleArea(c * Circle) float64 { return math.Pi * c.r * c.r } c := Circle{ 0 , 0 , 5 } fmt.Println(circleArea( & c)) // use receiver func (c * Circle) area() float64 { return math.Pi * c.r * c.r } fmt.Println(c.area()) Has-a relationship with receiver type Person struct { Name string } type Android struct { // Person Person // this will work, but doesn't full utilize the has-a relationship Person // type, this is better, so that we can all a.Talk() Model string } // has-a relationship using receiver a := new (Android) a.Person.Talk() // this will work a.Talk() // will work as well, since a person can talk, an android is a person, therefore an android can talk Interface \u00b6 url To use interface, there is no specific keyword such as extends in Java or implement in C++, we just implement all the method. package main import ( \"fmt\" \"math\" ) // interface type Shape interface { area() float64 } type MultiShape struct { shapes []Shape } // this two struct will implement Shape type Circle struct { x, y, r float64 } type Rectangle struct { x1, y1, x2, y2 float64 } // aux functions func distance(x1, y1, x2, y2 float64 ) float64 { a := x2 - x1 b := y2 - y1 return math.Sqrt(a * a + b * b) } func rectangleArea(x1, y1, x2, y2 float64 ) float64 { l := distance(x1, y1, x1, y2) w := distance(x1, y1, x2, y1) return l * w } // by implementinng the area() method (receiver), it will implement the Shape interface func (c Circle) area() float64 { return math.Pi * c.r * c.r } // by implementinng the area() method (receiver), it will implement the Shape interface func (r Rectangle) area() float64 { l := distance(r.x1, r.y1, r.x1, r.y2) w := distance(r.x1, r.y1, r.x2, r.y1) return l * w } func (m * MultiShape) area() float64 { var area float64 for _, s := range m.shapes { area += s.area() } return area } func main() { multiShape := MultiShape{ shapes: []Shape{ Circle{ 0 , 0 , 5 }, // in slice literal, cannot declare pointer Rectangle{ 0 , 0 , 10 , 10 }, }, } fmt.Println(multiShape.area()) } In short, Rectangle and Circle both implement the area() method, so that they can all be categorized as Shape type. Difference between method and function in Golang: method has a receiver, while function doesn't have one. func () a() float64 {} vs func a() float64 {} Fast way to create an slice/array \u00b6 fmt.Println(strings.Join([] string { \"a\" , \"b\" }, \"-\" )) Reuse variable \u00b6 This will work: // err variable is reused dir, err := os.Open( \".\" ) if err != nil { return } defer dir.Close() fileInfos, err := dir.Readdir( -1 ) if err != nil { return } \u200b This will not work: // this will not work err := 3 err := 4 a, b := 1 , 2 a, b := 3 , 2 and will throw # command-line-arguments ./main.go:110:6: no new variables on left side of := Read all the file recursively under specified directory \u00b6 import ( \"fmt\" \"os\" \"path/filepath\" ) func walkFolder() { filepath.Walk( \".\" , func (path string , info os.FileInfo, err error ) error { fmt.Println(path) return nil }) } Why use go keyword \u00b6 stackoverflow In writing a go server: to see the difference in action, try connecting twice (at the same time) to your server. You will find that without the word go, you will not accept the second tcp connection until the first one is done. Use flag to parse input argument \u00b6 package main import ( \"flag\" \"fmt\" \"math/rand\" ) func main() { // use -max flag, use \"the max value\" as the help message /* $ go run args.go -help will display: * Usage of /var/folders/84/zs57njyx4hx911_xchm8mp7c0000gn/T/go-build805909142/b001/exe/args: * -max int * the max value (default 6) * exit status 2 */ maxp := flag.Int( \"max\" , 6 , \"the max value\" ) flag.Parse() fmt.Println(Intn( * maxp)) } Import alias \u00b6 import m \"golang-book/chapter8/math\" func main() { xs := [] float64 { 1 , 2 , 3 , 4 } avg := m.Average(xs) } Similar to Python's import xyz as x","title":"Notes for reading *Caleb Doxsey - Introducing Go_ Build Reliable, Scalable Programs*"},{"location":"golang/Intro-To-Golang/#notes-for-reading-caleb-doxsey-introducing-go_-build-reliable-scalable-programs","text":"","title":"Notes for reading Caleb Doxsey - Introducing Go_ Build Reliable, Scalable Programs"},{"location":"golang/Intro-To-Golang/#defer-panic-and-recover-keywords","text":"url Some advantages for using defer : It keeps our Close call near our Open call so it\u2019s easier to understand. If our function had multiple return statements (perhaps one in an if and one in an else), Close will happen before both of them. Deferred functions are run even if a runtime panic occurs. func CopyFile(dstName, srcName string ) (written int64 , err error ) { src, err := os.Open(srcName) if err != nil { return } dst, err := os.Create(dstName) if err != nil { return } written, err = io.Copy(dst, src) dst.Close() src.Close() return } If the call to os.Create fails, the function will return without closing the source file. This can be easily remedied by putting a call to src.Close before the second return statement, but if the function were more complex the problem might not be so easily noticed and resolved. By introducing defer statements we can ensure that the files are always closed: func CopyFile(dstName, srcName string ) (written int64 , err error ) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() // this will be called before line 4 if err != nil dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() // this will be called before line 10 if err != nil return io.Copy(dst, src) } However, there are some pitfalls: func a() { i := 0 defer fmt.Println(i) i ++ return } Instead of printing 1, it will print 0, although the fmt.Println(i) is being called after i++. defer will save the current state of the function \u2014 including local variable \u2014 to run before the very last line of the function. func b() { for i := 0 ; i < 4 ; i ++ { defer fmt.Print(i) } } If there are multiple defer , the final order will be called as LIFO or like a stack: 0 defer first, so it's at the bottom of the stack, 1 second, so second place of the stack, etc. The final output will be 3 -> 2 -> 1 -> 0 It's a bit hard to understand, stackoverflow : Deferred functions may read and assign to the returning function's named return values. You can specify the return value and its type in the function signacture: func a() (i int ) { // return 2 since it return nothing i = 2 return } func b() (i int ) { // return 1 since it \"override\" what should be returned i = 2 return 1 } So func c() (i int ) { defer func () { i ++ }() return 1 } This deferred func() just specify the return value and type, and it got executed after 1 is returned","title":"defer, panic, and recover keywords"},{"location":"golang/Intro-To-Golang/#receiver","text":"// instead of using &c to pass as reference to the function func circleArea(c * Circle) float64 { return math.Pi * c.r * c.r } c := Circle{ 0 , 0 , 5 } fmt.Println(circleArea( & c)) // use receiver func (c * Circle) area() float64 { return math.Pi * c.r * c.r } fmt.Println(c.area()) Has-a relationship with receiver type Person struct { Name string } type Android struct { // Person Person // this will work, but doesn't full utilize the has-a relationship Person // type, this is better, so that we can all a.Talk() Model string } // has-a relationship using receiver a := new (Android) a.Person.Talk() // this will work a.Talk() // will work as well, since a person can talk, an android is a person, therefore an android can talk","title":"Receiver"},{"location":"golang/Intro-To-Golang/#interface","text":"url To use interface, there is no specific keyword such as extends in Java or implement in C++, we just implement all the method. package main import ( \"fmt\" \"math\" ) // interface type Shape interface { area() float64 } type MultiShape struct { shapes []Shape } // this two struct will implement Shape type Circle struct { x, y, r float64 } type Rectangle struct { x1, y1, x2, y2 float64 } // aux functions func distance(x1, y1, x2, y2 float64 ) float64 { a := x2 - x1 b := y2 - y1 return math.Sqrt(a * a + b * b) } func rectangleArea(x1, y1, x2, y2 float64 ) float64 { l := distance(x1, y1, x1, y2) w := distance(x1, y1, x2, y1) return l * w } // by implementinng the area() method (receiver), it will implement the Shape interface func (c Circle) area() float64 { return math.Pi * c.r * c.r } // by implementinng the area() method (receiver), it will implement the Shape interface func (r Rectangle) area() float64 { l := distance(r.x1, r.y1, r.x1, r.y2) w := distance(r.x1, r.y1, r.x2, r.y1) return l * w } func (m * MultiShape) area() float64 { var area float64 for _, s := range m.shapes { area += s.area() } return area } func main() { multiShape := MultiShape{ shapes: []Shape{ Circle{ 0 , 0 , 5 }, // in slice literal, cannot declare pointer Rectangle{ 0 , 0 , 10 , 10 }, }, } fmt.Println(multiShape.area()) } In short, Rectangle and Circle both implement the area() method, so that they can all be categorized as Shape type. Difference between method and function in Golang: method has a receiver, while function doesn't have one. func () a() float64 {} vs func a() float64 {}","title":"Interface"},{"location":"golang/Intro-To-Golang/#fast-way-to-create-an-slicearray","text":"fmt.Println(strings.Join([] string { \"a\" , \"b\" }, \"-\" ))","title":"Fast way to create an slice/array"},{"location":"golang/Intro-To-Golang/#reuse-variable","text":"This will work: // err variable is reused dir, err := os.Open( \".\" ) if err != nil { return } defer dir.Close() fileInfos, err := dir.Readdir( -1 ) if err != nil { return } \u200b This will not work: // this will not work err := 3 err := 4 a, b := 1 , 2 a, b := 3 , 2 and will throw # command-line-arguments ./main.go:110:6: no new variables on left side of :=","title":"Reuse variable"},{"location":"golang/Intro-To-Golang/#read-all-the-file-recursively-under-specified-directory","text":"import ( \"fmt\" \"os\" \"path/filepath\" ) func walkFolder() { filepath.Walk( \".\" , func (path string , info os.FileInfo, err error ) error { fmt.Println(path) return nil }) }","title":"Read all the file recursively under specified directory"},{"location":"golang/Intro-To-Golang/#why-use-go-keyword","text":"stackoverflow In writing a go server: to see the difference in action, try connecting twice (at the same time) to your server. You will find that without the word go, you will not accept the second tcp connection until the first one is done.","title":"Why use go keyword"},{"location":"golang/Intro-To-Golang/#use-flag-to-parse-input-argument","text":"package main import ( \"flag\" \"fmt\" \"math/rand\" ) func main() { // use -max flag, use \"the max value\" as the help message /* $ go run args.go -help will display: * Usage of /var/folders/84/zs57njyx4hx911_xchm8mp7c0000gn/T/go-build805909142/b001/exe/args: * -max int * the max value (default 6) * exit status 2 */ maxp := flag.Int( \"max\" , 6 , \"the max value\" ) flag.Parse() fmt.Println(Intn( * maxp)) }","title":"Use flag to parse input argument"},{"location":"golang/Intro-To-Golang/#import-alias","text":"import m \"golang-book/chapter8/math\" func main() { xs := [] float64 { 1 , 2 , 3 , 4 } avg := m.Average(xs) } Similar to Python's import xyz as x","title":"Import alias"},{"location":"golang/data-structure/","text":"Data structure and algorithm using golang \u00b6 Most questions are from Leetcode. Map \u00b6 Declaration \u00b6 Declare a map using m := make(map[int]int) Check if exist \u00b6 func twoSum(nums [] int , target int ) [] int { m := make ( map [ int ] int ) // map[key]value for k, v := range nums { // k: idx, v: value // check if targe - v is in the map if idx, ok := m[target - v]; ok { return [] int {idx, k} } m[v] = k } return nil } Linkedlist \u00b6 Initialize a new struct object (a ListNode ) using head := &ListNode{Val: 0} /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 * ListNode, l2 * ListNode) * ListNode { head := & ListNode{Val: 0 } n1, n2, carry, current := 0 , 0 , 0 , head // no while loop in Go for l1 != nil || l2 != nil || carry != 0 { if l1 == nil { n1 = 0 } else { n1 = l1.Val l1 = l1.Next } if l2 == nil { n2 = 0 } else { n2 = l2.Val l2 = l2.Next } current.Next = & ListNode{Val: (n1 + n2 + carry) % 10 } current = current.Next carry = (n1 + n2 + carry) / 10 } return head.Next } Casting \u00b6 Down/Up casting: a, b = 0 , 0 float64 (a + b) / 2 // this will convert interger to float64 Slice and Array \u00b6 Declaration of slice \u00b6 Using arr := make([]rune, 0) to declare an array with rune (alias to int32 ) and with the size of 0 . Declaration of array \u00b6 Declare an 2d array with length : Note the difference between slice and array is array need to provide a constant size c := [ 5 ][ 5 ] uint8 {} fmt.Println(c) /* [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] */ Create 2d slice: \u00b6 a := make ([][] uint8 , dy) // dy is the number of rows for i := range a { // have to write a loop to initialize the columns a[i] = make ([] uint8 , dx) } Initialize slice with default values \u00b6 if you have default values (composite literal): a := [][] uint8 { { 0 , 1 , 2 , 3 }, { 4 , 5 , 6 , 7 }, } fmt.Println(a) // Output is [[0 1 2 3] [4 5 6 7]] b := [] uint { 10 : 1 , 2 } // first 10 values are 1s fmt.Println(b) // Prints [0 0 0 0 0 0 0 0 0 0 1 2] Append \u00b6 newS := make ([] rune , 0 ) // create an array newS = append (newS, '#' ) // append to the end for _, c := range s { newS = append (newS, c) newS = append (newS, '#' ) // add a # for each character } Select \u00b6 primes := [ 6 ] int { 2 , 3 , 5 , 7 , 11 , 13 } var s [] int = primes[ 1 : 4 ] // selected [3 5 7] s := [] int { 2 , 3 , 5 , 7 , 11 , 13 } // Slice the slice to give it zero length. s = s[: 0 ] printSlice(s) // Extend its length. s = s[: 4 ] printSlice(s) // Drop its first two values. s = s[ 2 :] printSlice(s) Length and capacity of a slice \u00b6 s := [] int { 2 , 3 , 5 , 7 , 11 , 13 } fmt.Printf( \"len=%d cap=%d %v\\n\" , len (s), cap (s), s)","title":"Data structure"},{"location":"golang/data-structure/#data-structure-and-algorithm-using-golang","text":"Most questions are from Leetcode.","title":"Data structure and algorithm using golang"},{"location":"golang/data-structure/#map","text":"","title":"Map"},{"location":"golang/data-structure/#declaration","text":"Declare a map using m := make(map[int]int)","title":"Declaration"},{"location":"golang/data-structure/#check-if-exist","text":"func twoSum(nums [] int , target int ) [] int { m := make ( map [ int ] int ) // map[key]value for k, v := range nums { // k: idx, v: value // check if targe - v is in the map if idx, ok := m[target - v]; ok { return [] int {idx, k} } m[v] = k } return nil }","title":"Check if exist"},{"location":"golang/data-structure/#linkedlist","text":"Initialize a new struct object (a ListNode ) using head := &ListNode{Val: 0} /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 * ListNode, l2 * ListNode) * ListNode { head := & ListNode{Val: 0 } n1, n2, carry, current := 0 , 0 , 0 , head // no while loop in Go for l1 != nil || l2 != nil || carry != 0 { if l1 == nil { n1 = 0 } else { n1 = l1.Val l1 = l1.Next } if l2 == nil { n2 = 0 } else { n2 = l2.Val l2 = l2.Next } current.Next = & ListNode{Val: (n1 + n2 + carry) % 10 } current = current.Next carry = (n1 + n2 + carry) / 10 } return head.Next }","title":"Linkedlist"},{"location":"golang/data-structure/#casting","text":"Down/Up casting: a, b = 0 , 0 float64 (a + b) / 2 // this will convert interger to float64","title":"Casting"},{"location":"golang/data-structure/#slice-and-array","text":"","title":"Slice and Array"},{"location":"golang/data-structure/#declaration-of-slice","text":"Using arr := make([]rune, 0) to declare an array with rune (alias to int32 ) and with the size of 0 .","title":"Declaration of slice"},{"location":"golang/data-structure/#declaration-of-array","text":"Declare an 2d array with length : Note the difference between slice and array is array need to provide a constant size c := [ 5 ][ 5 ] uint8 {} fmt.Println(c) /* [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] */","title":"Declaration of array"},{"location":"golang/data-structure/#create-2d-slice","text":"a := make ([][] uint8 , dy) // dy is the number of rows for i := range a { // have to write a loop to initialize the columns a[i] = make ([] uint8 , dx) }","title":"Create 2d slice:"},{"location":"golang/data-structure/#initialize-slice-with-default-values","text":"if you have default values (composite literal): a := [][] uint8 { { 0 , 1 , 2 , 3 }, { 4 , 5 , 6 , 7 }, } fmt.Println(a) // Output is [[0 1 2 3] [4 5 6 7]] b := [] uint { 10 : 1 , 2 } // first 10 values are 1s fmt.Println(b) // Prints [0 0 0 0 0 0 0 0 0 0 1 2]","title":"Initialize slice with default values"},{"location":"golang/data-structure/#append","text":"newS := make ([] rune , 0 ) // create an array newS = append (newS, '#' ) // append to the end for _, c := range s { newS = append (newS, c) newS = append (newS, '#' ) // add a # for each character }","title":"Append"},{"location":"golang/data-structure/#select","text":"primes := [ 6 ] int { 2 , 3 , 5 , 7 , 11 , 13 } var s [] int = primes[ 1 : 4 ] // selected [3 5 7] s := [] int { 2 , 3 , 5 , 7 , 11 , 13 } // Slice the slice to give it zero length. s = s[: 0 ] printSlice(s) // Extend its length. s = s[: 4 ] printSlice(s) // Drop its first two values. s = s[ 2 :] printSlice(s)","title":"Select"},{"location":"golang/data-structure/#length-and-capacity-of-a-slice","text":"s := [] int { 2 , 3 , 5 , 7 , 11 , 13 } fmt.Printf( \"len=%d cap=%d %v\\n\" , len (s), cap (s), s)","title":"Length and capacity of a slice"},{"location":"golang/intro-learning-notes/","text":"Learning notes from geektutu \u00b6 Array and Slice \u00b6 Array: var arr [ 5 ] int // declare 1-d array var arr [ 5 ][ 5 ] int // declare 2-d array var arr = [ 5 ] int { 1 , 2 , 3 , 4 , 5 } var arr = [ ... ] int { 1 , 2 , 3 , 4 } // compiler will count the array elements for you Slice: Slice is just a pointer that is pointing to the underlying array var slice = [] int { 1 , 2 , 3 } // note that there is nothing inside the [] Can also use make to declare a slice: slice := make ([] int , 4 , 5 ) // with size of 4 and capacity of 5 slice := make ([] int , 4 ) // with size of 4 and capacity equals to size (4) Appending two slices: append ([] int { 1 , 2 }, [] int { 3 , 4 } ... ) // don't forget the ... at the end Map \u00b6 Declare a map: m1 = make ( map [ string ] int ) Enum \u00b6 There is no enum in Go, but it uses const to represent: type Gender int8 const ( MALE Gender = 1 // variable name, type, assigned value FEMALE Gender = 2 ) gender := MALE switch gender { case FEMALE: fmt.Println( \"female\" ) case MALE: fmt.Println( \"male\" ) default : fmt.Println( \"unknown\" ) } // male Defer and recover \u00b6 Use defer and recover when as try and catch : func get(index int ) (ret int ) { defer func () { if r := recover (); r != nil { // it will be called after the panic occurs fmt.Println( \"Some error happened!\" , r) ret = -1 } }() arr := [ 3 ] int { 2 , 3 , 4 } return arr[index] } func main() { fmt.Println(get( 5 )) fmt.Println( \"finished\" ) } Struct \u00b6 Use method to call struct instance: type Student struct { name string age int } func (stu * Student) hello(person string ) string { return fmt.Sprintf( \"hello %s, I am %s\" , person, stu.name) } func main() { stu := & Student{ name: \"Tom\" , } // this will also work, now studnet stu := Student{ name: \"Tom\" , } msg := stu.hello( \"Jack\" ) fmt.Println(msg) // hello Jack, I am Tom } In Go, a function can return the reference of a local variable: func myFunction() ( * MyStructType, error ) { var chunk * MyStructType = new (HeaderChunk) ... return chunk, nil } func myFunction() ( * MyStructType, error ) { var chunk MyStructType ... return & chunk, nil // this will work } Quoted from Golang: How do I know whether a variable is allocated on the heap or the stack? From a correctness standpoint, you don't need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language. The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack. In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack. Package \u00b6 If function/interface/type/method/statement is capitalized, then these will be accessible from other files in the other package(s). If not capitalized, then it will not be accessible. Trick \u00b6 Use empty interface to represent any type: func main() { m := make ( map [ string ] interface {}) m[ \"name\" ] = \"Tom\" m[ \"age\" ] = 18 m[ \"scores\" ] = [ 3 ] int { 98 , 99 , 85 } fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]] }","title":"Learning notes from [geektutu](https://geektutu.com/post/quick-golang.html)"},{"location":"golang/intro-learning-notes/#learning-notes-from-geektutu","text":"","title":"Learning notes from geektutu"},{"location":"golang/intro-learning-notes/#array-and-slice","text":"Array: var arr [ 5 ] int // declare 1-d array var arr [ 5 ][ 5 ] int // declare 2-d array var arr = [ 5 ] int { 1 , 2 , 3 , 4 , 5 } var arr = [ ... ] int { 1 , 2 , 3 , 4 } // compiler will count the array elements for you Slice: Slice is just a pointer that is pointing to the underlying array var slice = [] int { 1 , 2 , 3 } // note that there is nothing inside the [] Can also use make to declare a slice: slice := make ([] int , 4 , 5 ) // with size of 4 and capacity of 5 slice := make ([] int , 4 ) // with size of 4 and capacity equals to size (4) Appending two slices: append ([] int { 1 , 2 }, [] int { 3 , 4 } ... ) // don't forget the ... at the end","title":"Array and Slice"},{"location":"golang/intro-learning-notes/#map","text":"Declare a map: m1 = make ( map [ string ] int )","title":"Map"},{"location":"golang/intro-learning-notes/#enum","text":"There is no enum in Go, but it uses const to represent: type Gender int8 const ( MALE Gender = 1 // variable name, type, assigned value FEMALE Gender = 2 ) gender := MALE switch gender { case FEMALE: fmt.Println( \"female\" ) case MALE: fmt.Println( \"male\" ) default : fmt.Println( \"unknown\" ) } // male","title":"Enum"},{"location":"golang/intro-learning-notes/#defer-and-recover","text":"Use defer and recover when as try and catch : func get(index int ) (ret int ) { defer func () { if r := recover (); r != nil { // it will be called after the panic occurs fmt.Println( \"Some error happened!\" , r) ret = -1 } }() arr := [ 3 ] int { 2 , 3 , 4 } return arr[index] } func main() { fmt.Println(get( 5 )) fmt.Println( \"finished\" ) }","title":"Defer and recover"},{"location":"golang/intro-learning-notes/#struct","text":"Use method to call struct instance: type Student struct { name string age int } func (stu * Student) hello(person string ) string { return fmt.Sprintf( \"hello %s, I am %s\" , person, stu.name) } func main() { stu := & Student{ name: \"Tom\" , } // this will also work, now studnet stu := Student{ name: \"Tom\" , } msg := stu.hello( \"Jack\" ) fmt.Println(msg) // hello Jack, I am Tom } In Go, a function can return the reference of a local variable: func myFunction() ( * MyStructType, error ) { var chunk * MyStructType = new (HeaderChunk) ... return chunk, nil } func myFunction() ( * MyStructType, error ) { var chunk MyStructType ... return & chunk, nil // this will work } Quoted from Golang: How do I know whether a variable is allocated on the heap or the stack? From a correctness standpoint, you don't need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language. The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack. In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.","title":"Struct"},{"location":"golang/intro-learning-notes/#package","text":"If function/interface/type/method/statement is capitalized, then these will be accessible from other files in the other package(s). If not capitalized, then it will not be accessible.","title":"Package"},{"location":"golang/intro-learning-notes/#trick","text":"Use empty interface to represent any type: func main() { m := make ( map [ string ] interface {}) m[ \"name\" ] = \"Tom\" m[ \"age\" ] = 18 m[ \"scores\" ] = [ 3 ] int { 98 , 99 , 85 } fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]] }","title":"Trick"},{"location":"golang/struct/","text":"Struct \u00b6 Anonymous Struct \u00b6 monica := struct { firstName, lastName string salary int fullTime bool }{ firstName: \"Monica\" , lastName: \"Geller\" , salary: 1200 , } fmt.Println(monica) Anonymous Field \u00b6 type Data struct { test string int bool } func main() { sample1 := Data{ \"Monday\" , 1200 , true } sample1. bool = false fmt.Println(sample1.test, sample1. int , sample1. bool ) // note that sample1.string will raise error } Tag \u00b6 Tags are formatted as concatenation of key:\"value\" pairs. (Un)marshaling; import ( \"encoding/json\" \"fmt\" ) func main() { type T struct { F1 int `json:\"f_1\"` F2 int `json:\"f_2,omitempty\"` F3 int `json:\"f_3,omitempty\"` F4 int `json:\"-\"` } t := T{ 1 , 0 , 2 , 3 } b, err := json.Marshal(t) if err != nil { panic (err) } fmt.Printf( \"%s\\n\" , b) // {\"f_1\":1,\"f_3\":2} }","title":"Struct"},{"location":"golang/struct/#struct","text":"","title":"Struct"},{"location":"golang/struct/#anonymous-struct","text":"monica := struct { firstName, lastName string salary int fullTime bool }{ firstName: \"Monica\" , lastName: \"Geller\" , salary: 1200 , } fmt.Println(monica)","title":"Anonymous Struct"},{"location":"golang/struct/#anonymous-field","text":"type Data struct { test string int bool } func main() { sample1 := Data{ \"Monday\" , 1200 , true } sample1. bool = false fmt.Println(sample1.test, sample1. int , sample1. bool ) // note that sample1.string will raise error }","title":"Anonymous Field"},{"location":"golang/struct/#tag","text":"Tags are formatted as concatenation of key:\"value\" pairs. (Un)marshaling; import ( \"encoding/json\" \"fmt\" ) func main() { type T struct { F1 int `json:\"f_1\"` F2 int `json:\"f_2,omitempty\"` F3 int `json:\"f_3,omitempty\"` F4 int `json:\"-\"` } t := T{ 1 , 0 , 2 , 3 } b, err := json.Marshal(t) if err != nil { panic (err) } fmt.Printf( \"%s\\n\" , b) // {\"f_1\":1,\"f_3\":2} }","title":"Tag"},{"location":"iOS/exam-ii-review-part-one/","text":"Exam review Part 1 \u00b6 Gesture \u00b6 Tap Double Tap Drag Flick Pinch Spread Press Press and tap Add gesture recognizer in code Single Tap // ViewController.m: Single Tap - ( void ) viewDidLoad { [ super viewDidLoad]; UITapGestureRecognizer * singleTap = [[ UITapGestureRecognizer alloc] initWithTarget : self action : @selector ( singleTapRecognized :)]; /* if double click doubleTap.numberOfTapsRequired = 2; */ [ self .view addGestureRecognizer :singleTap]; } - ( void ) singleTapRecognized: ( UITapGestureRecognizer * ) recognizer { self .msgLabel.text = @\"You single tapped me!\" ; } Single & Double Tap // double tap UITapGestureRecognizer * singleTap = [[ UITapGestureRecognizer alloc] initWithTarget : self action : @selector ( singleTapRecognized :)]; [ self .view addGestureRecognizer : singleTap]; UITapGestureRecognizer * doubleTap = [[ UITapGestureRecognizer alloc] initWithTarget : self action : @selector ( doubleTapRecognized :)]; doubleTap.numberOfTapsRequired = 2 ; [ self .view addGestureRecognizer : doubleTap]; // Only recognize single taps if they're not the first of two [singleTap requireGestureRecognizerToFail : doubleTap]; Swipe: should add left and right separately UISwipeGestureRecognizer * swipeLeft = [[ UISwipeGestureRecognizer alloc] initWithTarget : self action : @selector ( swipeGestureRecognized :)]; swipeLeft.direction = UISwipeGestureRecognizerDirectionLeft; [ self .view addGestureRecognizer :swipeLeft]; UISwipeGestureRecognizer * swipeRight = [[ UISwipeGestureRecognizer alloc] initWithTarget : self action : @selector ( swipeGestureRecognized :)]; swipeRight.direction = UISwipeGestureRecognizerDirectionRight; [ self .view addGestureRecognizer :swipeRight]; Selector * accept a method name * not explicit call Animation: Core Animation \u00b6 View Properties * frame (position and size) * transform * alpha (transparency) * color * background color Block properties 1. can be pass around to methods or functions as if they were values. 2. is OC object, so can be added to collections like NSArray or NSDictionary 3. capture values from enclosing scope 4. used for callback function: code to be exec when finish task Syntax ^ { NSLog( @\"This is a block\" ); } int multiplier = 7 ; int ( ^ myBlock)( int ) = ^ ( int num) { return num * multiplier; } fade-in example - ( void ) fadeInStudent: ( NSString * ) name { // Alpha = 0 means the text is transparent self .nameLabel.alpha = 0 ; self .nameLabel.text = name; [ UIView animateWithDuration : 1.0 animations : ^ { // Fade in the text of the label self .nameLabel.alpha = 1 ; }]; } more examples: // fade in nameLabel - ( void ) animateStudent: ( NSString * ) name { self .nameLabel.text = name; [ UIView animateWithDuration : 1.0 animations : ^ { self .nameLabel.alpha = 1 ; }]; } // fade out then fade in - ( void ) displayStudent: ( NSString * ) name { [ UIView animateWithDuration : 1.0 animations : ^ { // Fade out old text of label self .nameLabel.alpha = 0 ; } completion : ^ ( BOOL finished) { // Upon completion, call animateStudent [ self animateStudent :name]; }]; } Accelerometer Gyroscope \u00b6 Motion Events * move * shake * tilt the device Some Properties* 1. made up of three accelerometers 2. give measurements in g-forces * no movement -- 1g 3. Shake: UIEvent 4. General Orientation: UIDevice 5. Cancel a motion event: An event is canceled if the shake motion is interrupted or if iOS determines that the motion is not valid after all \u2013 for example, if the shaking lasts too long. Use motionCancelled:withEvent:*** Handle Shake Event - ( BOOL ) canBecomeFirstResponder { return YES ; } - ( void ) viewDidAppear: ( BOOL ) animated { [ super viewDidAppear :animated]; [ self becomeFirstResponder]; } - ( void ) motionEnded: (UIEventSubtype) motion withEvent: ( UIEvent * ) event { if (motion == UIEventSubtypeMotionShake){ NSLog( @\"You shook me!\" ); } } Responding Changes in Orientation - ( void ) viewDidLoad { // Request to turn on accelerometer and begin receiving accelerometer events [[ UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[ NSNotificationCenter defaultCenter] addObserver : self selector : @selector ( orientationChanged :) name :UIDeviceOrientationDidChangeNotification object : nil ]; } - ( void ) orientationChanged: ( NSNotification * ) notification { // Respond to changes in device orientation UIDeviceOrientation currentOrientation = [[ UIDevice currentDevice] orientation]; } - ( void ) viewDidDisappear: ( BOOL ) animated { // Request to stop receiving accelerometer events and turn off accelerometer [[ NSNotificationCenter defaultCenter] removeObserver : self ]; [[ UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; } CMMotionManager obtain data * Pull: An app requests that updates start and then periodically samples the most recent measurement of motion data. * Push: An app specifies an update interval and implements a block for handling the data. Then, it requests that updates start, and passes Core Motion an operation queue and the block. Core Motion delivers each update to the block, which executes as a task in the operation queue. Pull is the recommended approach for most apps, especially games. It is generally more efficient and requires less code. Push is appropriate for data-collection apps and similar apps that cannot miss a single sample measurement. startDeviceMotionUpdates \u2013 the pull approach * After you call this method, Core Motion continuously updates the deviceMotion property of CMMotionManager with the latest refined measurements of accelerometer and gyroscope activity, as encapsulated in a CMDeviceMotion object. startDeviceMotionUpdatesToQueue:withHandler: \u2013 the push approach * Before you call this method, assign an update interval to the deviceMotionUpdateInterval property, create an instance of NSOperationQueue , and implement a block of the CMDeviceMotionHandler type that handles the accelerometer updates. * Then, call the startDeviceMotionUpdatesToQueue: withHandler: method on the motion-manager object, passing in the operation queue and the block. Audio \u00b6 File Formats (audio container) and Data Format (audio encoding) * AAC, HE-AAC, AMR, ALAC, iLBC, iMA4...: df * If space is not an issue, just encode everything with linear PCM. * Not only is this the fastest way for your audio to play, but you can play multiple sounds simultaneously without running into any CPU resource issues. * If space is an issue, most likely you\u2019ll want to use AAC encoding for your background music and IMA4 encoding for your sound effects. Bit Rate * When you lower the bytes per second, you lose quality as well. * If your file is mostly speech, you can probably get away with a lower bit rate. Sample Rates * usually 44,100Hz, because it's the same for CD audio. Audio Session * Playback is enabled and recording is disabled. \u2013 When the user moves the Silent switch (or Ring/Silent switch on iPhone) to the \u201csilent\u201d position, your audio is silenced. \u2013 When the user presses the Sleep/Wake button to lock the screen, or when the Auto-Lock period expires, your audio is silenced. \u2013 When your audio starts, other audio on the device \u2013 such as iPod audio that was already playing \u2013 is silenced. System Sound Service * System Sound Services is intended for user-interface sound effects and user alerts \u2013 It is not intended for sound effects in games * Alert sounds work best when kept short \u2013 According to Apple, preferably 2 seconds or less AVAudioPlayer * Play background music * Extremely slow: will be a noticeable delay * If play in bg, check no other sound is playing to prevent two layers of musics going at once * Phone call will interrupt the music Add Audio Framework * Add AudioToolbox.framework in project targets * Import // QuoteViewController.m #import <AudioToolbox/AudioToolbox.h> #import \"QuoteViewController.h\" @interface QuoteViewController () @property ( readonly ) SystemSoundID soundFileID; Examples Setup for Sound // QuoteViewController.m NSString * soundFilePath = [[ NSBundle mainBundle] pathForResource : @\"Tada\" ofType : @\"wav\" ]; NSURL * soundURL = [ NSURL fileURLWithPath :soundFilePath]; AudioServicesCreateSystemSoundID(( __bridge CFURLRef _Nonnull)(soundURL), & _soundFileID); // QuoteViewController.m - ( void ) singleTapRecognized: ( UITapGestureRecognizer * ) recognizer { // Play sound file AudioServicesPlaySystemSound( self .soundFileID); [ self displayQuote :[ self .model randomQuote]]; } Setup for Vibration // QuoteViewController.m - ( void ) doubleTapRecognized: ( UITapGestureRecognizer * ) recognizer { // Vibrate AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); [ self displayQuote :[ self .model randomQuote]]; } Create property using AVFoundation // QuoteViewController.m #import <AVFoundation/AVFoundation.h> // Other imports\u2026 @interface QuoteViewController () @property ( strong , nonatomic ) AVAudioPlayer * audioPlayer; // QuoteViewController.m NSString * path = [ NSString stringWithFormat : @\"%@/tone.mp3\" , [[ NSBundle mainBundle] resourcePath]]; NSURL * soundURL = [ NSURL fileURLWithPath :path]; NSError * error; self .audioPlayer = [[ AVAudioPlayer alloc] initWithContentsOfURL :soundURL error : & error]; [ self .audioPlayer prepareToPlay]; // QuoteViewController.m - ( void ) singleTapRecognized: ( UITapGestureRecognizer * ) recognizer { // Play audio [ self .audioPlayer play]; [ self displayQuote :[ self .model randomQuote]]; } Delegates \u00b6 Protocol * Is a declaration of a list of methods * Two kinds of methods: optional and required Delegation * Allow for one to one communication between two instances: the delegate and delegator * Delegator: Instance that send events to delegate * Delegate: Process events sent from the delegator * The delegator is typically a framework object (i.e. textfield, tableview, etc.), and the delegate is typically a custom controller object. Three Steps Processes 1. In your custom class, adopt the delegate's protocol. 2. Implement the appropriate protocol methods. 3. Connect the delegate outlet of the delegator (i.e. textfield, tableview, etc.) to your custom class. Summary * Allowing some objects to be relatively fixed and others highly customized. * Maximum software reuse and MVC design pattern. Demo: or but not both // ViewController.h @interface ViewController < ProtocolName > @end // ViewController.m @interface ViewController () < ProtocolName > @end @implementation ViewController @end Table Views \u00b6 iOS can have an unlimited # of rows iOS tables can only be one col wide Plain Table View * Row seperated into labeled sections and index appears vertically on right (index list) * Header and footer: row are grouped, doesn't include index * Highlight: * In both styles, a table row becomes highlighted briefly when a user taps a selectable item. * If a row selection results in navigation to a new screen, the selected row becomes highlighted briefly as the new screen slides into place. * When the user navigates back to the previous screen, the originally selected row again becomes highlighted briefly to remind the user of the earlier selection (it doesn\u2019t remain highlighted). * Four Predefined Styles 1. UITableViewCellStyleDefault : The default cell style includes an optional image in the left end of the row, followed by a left-aligned title. 2. UITableViewCellStyleSubtitle : The subtitle style includes an optional image in the left end of the row, followed by a left- aligned title on one line and a left- aligned subtitle on the line below. 3. UITableViewCellStyleValue1 : The value 1 style displays a left-aligned title with, on the same line, a rightaligned subtitle in a lighter font. 4. UITableViewCellStyleValue2`: The value 2 style displays a right-aligned title in a blue font, followed on the same line by a left-aligned subtitle in a black font. Images don\u2019t fit well in this style. Reusing Cell * When you call [tableView dequeuereusablecellwithidentifier:] you either: A. Get a cell that has previously been created and isn't currently being used OR B. Create a new cell of the class you specified Examples // ExampleTableViewController.m // Return the number of sections - (NSInteger) numberOfSectionsInTableView: ( UITableView * ) tableView { return 1 ; } // Return number of rows in the section - (NSInteger) tableView: ( UITableView * ) tableView numberOfRowsInSection: (NSInteger) section { return 100 ; } // Configuring Rows (cell) - ( UITableViewCell * ) tableView: ( UITableView * ) tableView cellForRowAtIndexPath: ( NSIndexPath * ) indexPath { static NSString * cellIdentifier = @\"TableCell\" ; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier :cellIdentifier]; // Configure the cell cell.textLabel.text = [ NSString stringWithFormat : @\"Row %d\" , indexPath.row]; return cell; } Relationships btw View Controllers * If the relationship is a segue , the destination view controller is instantiated when the segue is triggered. * If the relationship represents containment , the child view controller is instantiated when its parent is instantiated. * If the controller is not the destination or child of another controller, it is never instantiated automatically. You must instantiate it from the storyboard programmatically. * Segues: When a segue is triggered, iOS takes the following actions: 1. It instantiates the destination view controller using the attribute values you provided in the storyboard. 2. It gives the source view controller an opportunity to configure the new controller. 3. It performs the transition configured in the segue. * Summary: containment for parent-child connection; segues for two views.","title":"Exam review Part 1"},{"location":"iOS/exam-ii-review-part-one/#exam-review-part-1","text":"","title":"Exam review Part 1"},{"location":"iOS/exam-ii-review-part-one/#gesture","text":"Tap Double Tap Drag Flick Pinch Spread Press Press and tap Add gesture recognizer in code Single Tap // ViewController.m: Single Tap - ( void ) viewDidLoad { [ super viewDidLoad]; UITapGestureRecognizer * singleTap = [[ UITapGestureRecognizer alloc] initWithTarget : self action : @selector ( singleTapRecognized :)]; /* if double click doubleTap.numberOfTapsRequired = 2; */ [ self .view addGestureRecognizer :singleTap]; } - ( void ) singleTapRecognized: ( UITapGestureRecognizer * ) recognizer { self .msgLabel.text = @\"You single tapped me!\" ; } Single & Double Tap // double tap UITapGestureRecognizer * singleTap = [[ UITapGestureRecognizer alloc] initWithTarget : self action : @selector ( singleTapRecognized :)]; [ self .view addGestureRecognizer : singleTap]; UITapGestureRecognizer * doubleTap = [[ UITapGestureRecognizer alloc] initWithTarget : self action : @selector ( doubleTapRecognized :)]; doubleTap.numberOfTapsRequired = 2 ; [ self .view addGestureRecognizer : doubleTap]; // Only recognize single taps if they're not the first of two [singleTap requireGestureRecognizerToFail : doubleTap]; Swipe: should add left and right separately UISwipeGestureRecognizer * swipeLeft = [[ UISwipeGestureRecognizer alloc] initWithTarget : self action : @selector ( swipeGestureRecognized :)]; swipeLeft.direction = UISwipeGestureRecognizerDirectionLeft; [ self .view addGestureRecognizer :swipeLeft]; UISwipeGestureRecognizer * swipeRight = [[ UISwipeGestureRecognizer alloc] initWithTarget : self action : @selector ( swipeGestureRecognized :)]; swipeRight.direction = UISwipeGestureRecognizerDirectionRight; [ self .view addGestureRecognizer :swipeRight]; Selector * accept a method name * not explicit call","title":"Gesture"},{"location":"iOS/exam-ii-review-part-one/#animation-core-animation","text":"View Properties * frame (position and size) * transform * alpha (transparency) * color * background color Block properties 1. can be pass around to methods or functions as if they were values. 2. is OC object, so can be added to collections like NSArray or NSDictionary 3. capture values from enclosing scope 4. used for callback function: code to be exec when finish task Syntax ^ { NSLog( @\"This is a block\" ); } int multiplier = 7 ; int ( ^ myBlock)( int ) = ^ ( int num) { return num * multiplier; } fade-in example - ( void ) fadeInStudent: ( NSString * ) name { // Alpha = 0 means the text is transparent self .nameLabel.alpha = 0 ; self .nameLabel.text = name; [ UIView animateWithDuration : 1.0 animations : ^ { // Fade in the text of the label self .nameLabel.alpha = 1 ; }]; } more examples: // fade in nameLabel - ( void ) animateStudent: ( NSString * ) name { self .nameLabel.text = name; [ UIView animateWithDuration : 1.0 animations : ^ { self .nameLabel.alpha = 1 ; }]; } // fade out then fade in - ( void ) displayStudent: ( NSString * ) name { [ UIView animateWithDuration : 1.0 animations : ^ { // Fade out old text of label self .nameLabel.alpha = 0 ; } completion : ^ ( BOOL finished) { // Upon completion, call animateStudent [ self animateStudent :name]; }]; }","title":"Animation: Core Animation"},{"location":"iOS/exam-ii-review-part-one/#accelerometer-gyroscope","text":"Motion Events * move * shake * tilt the device Some Properties* 1. made up of three accelerometers 2. give measurements in g-forces * no movement -- 1g 3. Shake: UIEvent 4. General Orientation: UIDevice 5. Cancel a motion event: An event is canceled if the shake motion is interrupted or if iOS determines that the motion is not valid after all \u2013 for example, if the shaking lasts too long. Use motionCancelled:withEvent:*** Handle Shake Event - ( BOOL ) canBecomeFirstResponder { return YES ; } - ( void ) viewDidAppear: ( BOOL ) animated { [ super viewDidAppear :animated]; [ self becomeFirstResponder]; } - ( void ) motionEnded: (UIEventSubtype) motion withEvent: ( UIEvent * ) event { if (motion == UIEventSubtypeMotionShake){ NSLog( @\"You shook me!\" ); } } Responding Changes in Orientation - ( void ) viewDidLoad { // Request to turn on accelerometer and begin receiving accelerometer events [[ UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[ NSNotificationCenter defaultCenter] addObserver : self selector : @selector ( orientationChanged :) name :UIDeviceOrientationDidChangeNotification object : nil ]; } - ( void ) orientationChanged: ( NSNotification * ) notification { // Respond to changes in device orientation UIDeviceOrientation currentOrientation = [[ UIDevice currentDevice] orientation]; } - ( void ) viewDidDisappear: ( BOOL ) animated { // Request to stop receiving accelerometer events and turn off accelerometer [[ NSNotificationCenter defaultCenter] removeObserver : self ]; [[ UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; } CMMotionManager obtain data * Pull: An app requests that updates start and then periodically samples the most recent measurement of motion data. * Push: An app specifies an update interval and implements a block for handling the data. Then, it requests that updates start, and passes Core Motion an operation queue and the block. Core Motion delivers each update to the block, which executes as a task in the operation queue. Pull is the recommended approach for most apps, especially games. It is generally more efficient and requires less code. Push is appropriate for data-collection apps and similar apps that cannot miss a single sample measurement. startDeviceMotionUpdates \u2013 the pull approach * After you call this method, Core Motion continuously updates the deviceMotion property of CMMotionManager with the latest refined measurements of accelerometer and gyroscope activity, as encapsulated in a CMDeviceMotion object. startDeviceMotionUpdatesToQueue:withHandler: \u2013 the push approach * Before you call this method, assign an update interval to the deviceMotionUpdateInterval property, create an instance of NSOperationQueue , and implement a block of the CMDeviceMotionHandler type that handles the accelerometer updates. * Then, call the startDeviceMotionUpdatesToQueue: withHandler: method on the motion-manager object, passing in the operation queue and the block.","title":"Accelerometer Gyroscope"},{"location":"iOS/exam-ii-review-part-one/#audio","text":"File Formats (audio container) and Data Format (audio encoding) * AAC, HE-AAC, AMR, ALAC, iLBC, iMA4...: df * If space is not an issue, just encode everything with linear PCM. * Not only is this the fastest way for your audio to play, but you can play multiple sounds simultaneously without running into any CPU resource issues. * If space is an issue, most likely you\u2019ll want to use AAC encoding for your background music and IMA4 encoding for your sound effects. Bit Rate * When you lower the bytes per second, you lose quality as well. * If your file is mostly speech, you can probably get away with a lower bit rate. Sample Rates * usually 44,100Hz, because it's the same for CD audio. Audio Session * Playback is enabled and recording is disabled. \u2013 When the user moves the Silent switch (or Ring/Silent switch on iPhone) to the \u201csilent\u201d position, your audio is silenced. \u2013 When the user presses the Sleep/Wake button to lock the screen, or when the Auto-Lock period expires, your audio is silenced. \u2013 When your audio starts, other audio on the device \u2013 such as iPod audio that was already playing \u2013 is silenced. System Sound Service * System Sound Services is intended for user-interface sound effects and user alerts \u2013 It is not intended for sound effects in games * Alert sounds work best when kept short \u2013 According to Apple, preferably 2 seconds or less AVAudioPlayer * Play background music * Extremely slow: will be a noticeable delay * If play in bg, check no other sound is playing to prevent two layers of musics going at once * Phone call will interrupt the music Add Audio Framework * Add AudioToolbox.framework in project targets * Import // QuoteViewController.m #import <AudioToolbox/AudioToolbox.h> #import \"QuoteViewController.h\" @interface QuoteViewController () @property ( readonly ) SystemSoundID soundFileID; Examples Setup for Sound // QuoteViewController.m NSString * soundFilePath = [[ NSBundle mainBundle] pathForResource : @\"Tada\" ofType : @\"wav\" ]; NSURL * soundURL = [ NSURL fileURLWithPath :soundFilePath]; AudioServicesCreateSystemSoundID(( __bridge CFURLRef _Nonnull)(soundURL), & _soundFileID); // QuoteViewController.m - ( void ) singleTapRecognized: ( UITapGestureRecognizer * ) recognizer { // Play sound file AudioServicesPlaySystemSound( self .soundFileID); [ self displayQuote :[ self .model randomQuote]]; } Setup for Vibration // QuoteViewController.m - ( void ) doubleTapRecognized: ( UITapGestureRecognizer * ) recognizer { // Vibrate AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); [ self displayQuote :[ self .model randomQuote]]; } Create property using AVFoundation // QuoteViewController.m #import <AVFoundation/AVFoundation.h> // Other imports\u2026 @interface QuoteViewController () @property ( strong , nonatomic ) AVAudioPlayer * audioPlayer; // QuoteViewController.m NSString * path = [ NSString stringWithFormat : @\"%@/tone.mp3\" , [[ NSBundle mainBundle] resourcePath]]; NSURL * soundURL = [ NSURL fileURLWithPath :path]; NSError * error; self .audioPlayer = [[ AVAudioPlayer alloc] initWithContentsOfURL :soundURL error : & error]; [ self .audioPlayer prepareToPlay]; // QuoteViewController.m - ( void ) singleTapRecognized: ( UITapGestureRecognizer * ) recognizer { // Play audio [ self .audioPlayer play]; [ self displayQuote :[ self .model randomQuote]]; }","title":"Audio"},{"location":"iOS/exam-ii-review-part-one/#delegates","text":"Protocol * Is a declaration of a list of methods * Two kinds of methods: optional and required Delegation * Allow for one to one communication between two instances: the delegate and delegator * Delegator: Instance that send events to delegate * Delegate: Process events sent from the delegator * The delegator is typically a framework object (i.e. textfield, tableview, etc.), and the delegate is typically a custom controller object. Three Steps Processes 1. In your custom class, adopt the delegate's protocol. 2. Implement the appropriate protocol methods. 3. Connect the delegate outlet of the delegator (i.e. textfield, tableview, etc.) to your custom class. Summary * Allowing some objects to be relatively fixed and others highly customized. * Maximum software reuse and MVC design pattern. Demo: or but not both // ViewController.h @interface ViewController < ProtocolName > @end // ViewController.m @interface ViewController () < ProtocolName > @end @implementation ViewController @end","title":"Delegates"},{"location":"iOS/exam-ii-review-part-one/#table-views","text":"iOS can have an unlimited # of rows iOS tables can only be one col wide Plain Table View * Row seperated into labeled sections and index appears vertically on right (index list) * Header and footer: row are grouped, doesn't include index * Highlight: * In both styles, a table row becomes highlighted briefly when a user taps a selectable item. * If a row selection results in navigation to a new screen, the selected row becomes highlighted briefly as the new screen slides into place. * When the user navigates back to the previous screen, the originally selected row again becomes highlighted briefly to remind the user of the earlier selection (it doesn\u2019t remain highlighted). * Four Predefined Styles 1. UITableViewCellStyleDefault : The default cell style includes an optional image in the left end of the row, followed by a left-aligned title. 2. UITableViewCellStyleSubtitle : The subtitle style includes an optional image in the left end of the row, followed by a left- aligned title on one line and a left- aligned subtitle on the line below. 3. UITableViewCellStyleValue1 : The value 1 style displays a left-aligned title with, on the same line, a rightaligned subtitle in a lighter font. 4. UITableViewCellStyleValue2`: The value 2 style displays a right-aligned title in a blue font, followed on the same line by a left-aligned subtitle in a black font. Images don\u2019t fit well in this style. Reusing Cell * When you call [tableView dequeuereusablecellwithidentifier:] you either: A. Get a cell that has previously been created and isn't currently being used OR B. Create a new cell of the class you specified Examples // ExampleTableViewController.m // Return the number of sections - (NSInteger) numberOfSectionsInTableView: ( UITableView * ) tableView { return 1 ; } // Return number of rows in the section - (NSInteger) tableView: ( UITableView * ) tableView numberOfRowsInSection: (NSInteger) section { return 100 ; } // Configuring Rows (cell) - ( UITableViewCell * ) tableView: ( UITableView * ) tableView cellForRowAtIndexPath: ( NSIndexPath * ) indexPath { static NSString * cellIdentifier = @\"TableCell\" ; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier :cellIdentifier]; // Configure the cell cell.textLabel.text = [ NSString stringWithFormat : @\"Row %d\" , indexPath.row]; return cell; } Relationships btw View Controllers * If the relationship is a segue , the destination view controller is instantiated when the segue is triggered. * If the relationship represents containment , the child view controller is instantiated when its parent is instantiated. * If the controller is not the destination or child of another controller, it is never instantiated automatically. You must instantiate it from the storyboard programmatically. * Segues: When a segue is triggered, iOS takes the following actions: 1. It instantiates the destination view controller using the attribute values you provided in the storyboard. 2. It gives the source view controller an opportunity to configure the new controller. 3. It performs the transition configured in the segue. * Summary: containment for parent-child connection; segues for two views.","title":"Table Views"},{"location":"iOS/exam-ii-review-part-two/","text":"Exam review Part 2 \u00b6 On-class \u00b6 WebKit features (important) Multiple Storyboard prevent merge conflicts no swift to be tested no animation/accelerometer in coding Major Design pattern: delegation MVC Singleton (notification) Objective-C Data Types BOOL ID SELECTOR App States ARC vs. MRR: memory management Understand hw5 very well (code) Pass data/function between controllers: ?? blocks How to save data: ?? Creating a tableView (code) Delete cells Set delegate completion handler using blocks Scene & Segues \u00b6 Use blocks for communication between scenes (save or cancel) typedef returntype(^<#block name#>)(<#arguments#>); block properties should always be copy Two common styles: Show: left-to-right navigation Present Modally: full-screen cover Use prepareForSegue: to connect Set the completion handler: insert new quote into models; have table view reload data; dismiss view controller Data Persistence \u00b6 User Default: NSUserDefaults using key value (like NSDictionary ) Save files to the Document folder using plist Use SQLite Use Core Data Folder to save Documents Your application stores its data in Documents, with the exception of NSUserDefaults-based preference settings Library NSUserDefaults-based preference settings are stored in the Library/Preferences folder tmp Place to store temporary files that will not be backed up by iTunes, but your app has to be responsibility for deleting the files User Defaults No high performance No complex structure Not searchable NSString * const kCurrentIndexKey = @\"CurrentIndex\" ; - ( void ) save { NSUserDefaults * defaults = [ NSUserDefaults standardUserDefaults]; [defaults setObject :[ NSNumber numberWithInt : self .currentIndex] forKey :kCurrentIndexKey]; [defaults synchronize]; } - ( NSNumber ) read { NSNumber * readData = [[ NSUserDefaults standardUserDefaults] objectForKey :kCurrentIndexKey]; return readData; } Use of const 1. Prevent mistype 2. Convenience to auto-complete 3. Declare outside of @interface and @implementation Inside Document Folder Accept types: Property List (xml) Text Files Archiving Objects -- NSCoding protocol NSString * documentsDirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES )[ 0 ]; // Create a file name for your file NSString * filename = @\"flashcards.plist\" ; // Generate the full file path _filePath = [ NSString stringWithFormat : @\"%@/%@\" , documentsDirPath, filename]; NSLog( @\"file path %@\" , _filePath); NSArray * flashcardsFromDocumentsDir = [[ NSArray alloc] initWithContentsOfFile :_filePath]; App life cycle \u00b6 App States * Not Running * Inactive (foreground) * Active (foreground) * Background * Suspended Memory \u00b6 Two Methods of application memory management 1. Manual retain-release: MRR 2. Automatic Reference Counting: ARC * Using reference-count * Invoke dealloc automatically MRR \u00b6 Cocoa's Policy * You own object you created: alloc new copy mutableCopy * Take ownership by using retain * When no longer need, relinquish it using release or autorelease (must relinquish object do not own) * \"Parent\" object maintain strong reference to \"children\", \"children\" have weak reference to \"parents\" Pratical Memory Management * Use accessor methods to set property values * Don't use accessor methods in initalizer and dealloc * Use weak reference to avoid retain cycles * Avoid dealloc object while using * Don't use dealloc to manage scarce resources * Collections own the objects they contain * Ownership policy is implemented using retain counts Retain Count * When create an object, RC (retain count) is 1 * When send a retain message, RC + 1 * When send a release message, RC - 1 * When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block. * If RC == 0 -> object dealloc ARC \u00b6 Insert retains and releases into code when compile Web View \u00b6 WebKit * Follow MVC framework * View: WebView * Object: WebFrameView and WebFrame * App Transport Security force to connect with web service through HTTPS Example: Read a pdf file - ( void ) viewDidLoad { [ super viewDidLoad]; NSString * path = [[ NSBundle mainBundle] pathForResource : @\"HIG\" ofType : @\"pdf\" ]; if (path){ NSData * pdfData = [ NSData dataWithContentsOfFile :path]; [( UIWebView * ) self .view loadData :pdfData MIMEType : @\"application/pdf\" textEncodingName : @\"utf-8\" baseURL : nil ]; } } Read a url NSURL * url = [ NSURL URLWithString : @\"https://www.apple.com\" ]; NSURLRequest * request = [ NSURLRequest requestWithURL :url]; [ self .myWebView loadRequest : request]; Cancel a loading request - ( void ) viewWillDisappear: ( BOOL ) animated { [ super viewWillDisappear :animated]; if ([ self .myWebView isLoading]){ [ self .myWebView stopLoading]; } // Disconnect the delegate as the webview is hidden self .myWebView.delegate = nil ; } Animation loading in WebView - ( void ) webViewDidStartLoad: ( UIWebView * ) webView { [ self .activityIndicator startAnimating]; } - ( void ) webViewDidFinishLoad: ( UIWebView * ) webView { [ self .activityIndicator stopAnimating]; } - ( void ) webView: ( UIWebView * ) webView didFailLoadWithError: ( NSError * ) error { [ self .activityIndicator stopAnimating]; } Notes A web view automatically converts telephone numbers that appear in web content to Phone links. You should not embed UIWebView or UITableView objects in UIScrollView objects. Table View Rewind \u00b6 Modifying Tables \u00b6 Delete table cells * Add navigation control * Enable edit button in viewDidLoad method * Use the public remove method in the model * Implement tableView: commitEditingStyle: forRowAtIndexPath method - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the row from the data source [self.model removeFlashcardAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view } }","title":"Exam review Part 2"},{"location":"iOS/exam-ii-review-part-two/#exam-review-part-2","text":"","title":"Exam review Part 2"},{"location":"iOS/exam-ii-review-part-two/#on-class","text":"WebKit features (important) Multiple Storyboard prevent merge conflicts no swift to be tested no animation/accelerometer in coding Major Design pattern: delegation MVC Singleton (notification) Objective-C Data Types BOOL ID SELECTOR App States ARC vs. MRR: memory management Understand hw5 very well (code) Pass data/function between controllers: ?? blocks How to save data: ?? Creating a tableView (code) Delete cells Set delegate completion handler using blocks","title":"On-class"},{"location":"iOS/exam-ii-review-part-two/#scene-segues","text":"Use blocks for communication between scenes (save or cancel) typedef returntype(^<#block name#>)(<#arguments#>); block properties should always be copy Two common styles: Show: left-to-right navigation Present Modally: full-screen cover Use prepareForSegue: to connect Set the completion handler: insert new quote into models; have table view reload data; dismiss view controller","title":"Scene &amp; Segues"},{"location":"iOS/exam-ii-review-part-two/#data-persistence","text":"User Default: NSUserDefaults using key value (like NSDictionary ) Save files to the Document folder using plist Use SQLite Use Core Data Folder to save Documents Your application stores its data in Documents, with the exception of NSUserDefaults-based preference settings Library NSUserDefaults-based preference settings are stored in the Library/Preferences folder tmp Place to store temporary files that will not be backed up by iTunes, but your app has to be responsibility for deleting the files User Defaults No high performance No complex structure Not searchable NSString * const kCurrentIndexKey = @\"CurrentIndex\" ; - ( void ) save { NSUserDefaults * defaults = [ NSUserDefaults standardUserDefaults]; [defaults setObject :[ NSNumber numberWithInt : self .currentIndex] forKey :kCurrentIndexKey]; [defaults synchronize]; } - ( NSNumber ) read { NSNumber * readData = [[ NSUserDefaults standardUserDefaults] objectForKey :kCurrentIndexKey]; return readData; } Use of const 1. Prevent mistype 2. Convenience to auto-complete 3. Declare outside of @interface and @implementation Inside Document Folder Accept types: Property List (xml) Text Files Archiving Objects -- NSCoding protocol NSString * documentsDirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES )[ 0 ]; // Create a file name for your file NSString * filename = @\"flashcards.plist\" ; // Generate the full file path _filePath = [ NSString stringWithFormat : @\"%@/%@\" , documentsDirPath, filename]; NSLog( @\"file path %@\" , _filePath); NSArray * flashcardsFromDocumentsDir = [[ NSArray alloc] initWithContentsOfFile :_filePath];","title":"Data Persistence"},{"location":"iOS/exam-ii-review-part-two/#app-life-cycle","text":"App States * Not Running * Inactive (foreground) * Active (foreground) * Background * Suspended","title":"App life cycle"},{"location":"iOS/exam-ii-review-part-two/#memory","text":"Two Methods of application memory management 1. Manual retain-release: MRR 2. Automatic Reference Counting: ARC * Using reference-count * Invoke dealloc automatically","title":"Memory"},{"location":"iOS/exam-ii-review-part-two/#mrr","text":"Cocoa's Policy * You own object you created: alloc new copy mutableCopy * Take ownership by using retain * When no longer need, relinquish it using release or autorelease (must relinquish object do not own) * \"Parent\" object maintain strong reference to \"children\", \"children\" have weak reference to \"parents\" Pratical Memory Management * Use accessor methods to set property values * Don't use accessor methods in initalizer and dealloc * Use weak reference to avoid retain cycles * Avoid dealloc object while using * Don't use dealloc to manage scarce resources * Collections own the objects they contain * Ownership policy is implemented using retain counts Retain Count * When create an object, RC (retain count) is 1 * When send a retain message, RC + 1 * When send a release message, RC - 1 * When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block. * If RC == 0 -> object dealloc","title":"MRR"},{"location":"iOS/exam-ii-review-part-two/#arc","text":"Insert retains and releases into code when compile","title":"ARC"},{"location":"iOS/exam-ii-review-part-two/#web-view","text":"WebKit * Follow MVC framework * View: WebView * Object: WebFrameView and WebFrame * App Transport Security force to connect with web service through HTTPS Example: Read a pdf file - ( void ) viewDidLoad { [ super viewDidLoad]; NSString * path = [[ NSBundle mainBundle] pathForResource : @\"HIG\" ofType : @\"pdf\" ]; if (path){ NSData * pdfData = [ NSData dataWithContentsOfFile :path]; [( UIWebView * ) self .view loadData :pdfData MIMEType : @\"application/pdf\" textEncodingName : @\"utf-8\" baseURL : nil ]; } } Read a url NSURL * url = [ NSURL URLWithString : @\"https://www.apple.com\" ]; NSURLRequest * request = [ NSURLRequest requestWithURL :url]; [ self .myWebView loadRequest : request]; Cancel a loading request - ( void ) viewWillDisappear: ( BOOL ) animated { [ super viewWillDisappear :animated]; if ([ self .myWebView isLoading]){ [ self .myWebView stopLoading]; } // Disconnect the delegate as the webview is hidden self .myWebView.delegate = nil ; } Animation loading in WebView - ( void ) webViewDidStartLoad: ( UIWebView * ) webView { [ self .activityIndicator startAnimating]; } - ( void ) webViewDidFinishLoad: ( UIWebView * ) webView { [ self .activityIndicator stopAnimating]; } - ( void ) webView: ( UIWebView * ) webView didFailLoadWithError: ( NSError * ) error { [ self .activityIndicator stopAnimating]; } Notes A web view automatically converts telephone numbers that appear in web content to Phone links. You should not embed UIWebView or UITableView objects in UIScrollView objects.","title":"Web View"},{"location":"iOS/exam-ii-review-part-two/#table-view-rewind","text":"","title":"Table View Rewind"},{"location":"iOS/exam-ii-review-part-two/#modifying-tables","text":"Delete table cells * Add navigation control * Enable edit button in viewDidLoad method * Use the public remove method in the model * Implement tableView: commitEditingStyle: forRowAtIndexPath method - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the row from the data source [self.model removeFlashcardAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view } }","title":"Modifying Tables"},{"location":"iOS/ios-api/","text":"iOS API \u00b6 Taking picture and movie \u00b6 UIImagePickerController AV Foundation JSQMessageController for bubble DialogFlow for smart reply fabric.io submit app Analytics \u00b6 Mixpanel NSLocalization Deployment \u00b6 TestFlight: distribution","title":"iOS API"},{"location":"iOS/ios-api/#ios-api","text":"","title":"iOS API"},{"location":"iOS/ios-api/#taking-picture-and-movie","text":"UIImagePickerController AV Foundation JSQMessageController for bubble DialogFlow for smart reply fabric.io submit app","title":"Taking picture and movie"},{"location":"iOS/ios-api/#analytics","text":"Mixpanel NSLocalization","title":"Analytics"},{"location":"iOS/ios-api/#deployment","text":"TestFlight: distribution","title":"Deployment"},{"location":"iOS/some-tools/","text":"Some tools \u00b6 dev.weev.it use for api dev \u00b6 Dialog Flow use for bot chat \u00b6 Vuforia \u00b6 Bing Speech API use for recognizing speech to string \u00b6","title":"Some tools"},{"location":"iOS/some-tools/#some-tools","text":"","title":"Some tools"},{"location":"iOS/some-tools/#devweevit-use-for-api-dev","text":"","title":"dev.weev.it use for api dev"},{"location":"iOS/some-tools/#dialog-flow-use-for-bot-chat","text":"","title":"Dialog Flow use for bot chat"},{"location":"iOS/some-tools/#vuforia","text":"","title":"Vuforia"},{"location":"iOS/some-tools/#bing-speech-api-use-for-recognizing-speech-to-string","text":"","title":"Bing Speech API use for recognizing speech to string"},{"location":"machine%20learning/coursera-ml-week1/","text":"Coursera Machine Learning \u2014 Week 1 \u00b6 Course by Adrew Ng from Coursera.org Definition of Machine Learing \u00b6 Field of study that gives computers the ability to learn without being explicitly programmed. A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. Suppose your email program watches which emails you do or do not mark as spam, and based on that learns how to better filter spam. What is the task T in this setting? ans: Classifying emails as spam or not spam. Supervised learning: tech to learn (most common) Unsupervised learning: self-learning Others: Reinforcement learning, recommender systems Supervised Learning \u00b6 regression problem Housing price prediction: -> predict price given size classification problem Breast cancer (malignant or benign): given size predict if is malignant or benign, or the possibility of being malignant. Here tumer size called attribute There could be more than one attribute, such as age, etc. Unsupervied Learning \u00b6 The given data doesn't have any labels (there is no labelled data avalible), and find the structure from the data. Google News : look up stories and categorize Organize computing clusters : I had some friends looking at large data centers, that is large computer clusters and trying to figure out which machines tend to work together and if you can put those machines together, you can make your data center work more efficiently. Social network analysis : given a friend circles, identify which cohesive groups of friends all know each other. Market segmentation : sell diffferent products to customers. Cocktail party : filter/separate different languages' voice from a single microphone. Use Octave to implement the algorithm.","title":"Coursera ml week1"},{"location":"machine%20learning/coursera-ml-week1/#coursera-machine-learning-week-1","text":"Course by Adrew Ng from Coursera.org","title":"Coursera Machine Learning \u2014 Week 1"},{"location":"machine%20learning/coursera-ml-week1/#definition-of-machine-learing","text":"Field of study that gives computers the ability to learn without being explicitly programmed. A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. Suppose your email program watches which emails you do or do not mark as spam, and based on that learns how to better filter spam. What is the task T in this setting? ans: Classifying emails as spam or not spam. Supervised learning: tech to learn (most common) Unsupervised learning: self-learning Others: Reinforcement learning, recommender systems","title":"Definition of Machine Learing"},{"location":"machine%20learning/coursera-ml-week1/#supervised-learning","text":"regression problem Housing price prediction: -> predict price given size classification problem Breast cancer (malignant or benign): given size predict if is malignant or benign, or the possibility of being malignant. Here tumer size called attribute There could be more than one attribute, such as age, etc.","title":"Supervised Learning"},{"location":"machine%20learning/coursera-ml-week1/#unsupervied-learning","text":"The given data doesn't have any labels (there is no labelled data avalible), and find the structure from the data. Google News : look up stories and categorize Organize computing clusters : I had some friends looking at large data centers, that is large computer clusters and trying to figure out which machines tend to work together and if you can put those machines together, you can make your data center work more efficiently. Social network analysis : given a friend circles, identify which cohesive groups of friends all know each other. Market segmentation : sell diffferent products to customers. Cocktail party : filter/separate different languages' voice from a single microphone. Use Octave to implement the algorithm.","title":"Unsupervied Learning"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/","text":"Loss Function \u00b6 Multiclass SVM Loss: hinge loss \u00b6 S_{y_j} S_{y_j} is the predict right score (target score) S_j S_j is the predict wrong score (all the other) L_i = \\sum_{j \\neq y_i} max(0, S_j - S_{y_j} + 1) Total Loss is: L = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i L(W) = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i(f(x_i, W), y_i) To calculate the loss for predicting car: max(0, cat score - car score + 1) + max(0, frog score - car score + 1) = max(0, -2.6) + max(0, -1.9) = 0 after using the same method to calculate each of the classes, the averge is the result: (2.9 -> for cat + 0 -> for car + 12.9 -> for frog) / 3 = 5.27 Regularization \u00b6 \\lambda R(W) \\lambda R(W) This term makes sure to choose \"simpler\" W instead of complicated ones that only fit training data, so that the power is lower for each term (high penalty for using high power poly). Softmax Classifier (Multinomial Logistic Regression): cross-entropy loss \u00b6 score is the probabilities for each class, and the sum of all classes equals to one (100%). Loss for each category: L_i = -\\log P(Y = y_i | X = x_i) L_i = -\\log P(Y = y_i | X = x_i) P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} where s s is our model: s = f(x_i;W) s = f(x_i;W) plug in to the first equation: L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) The min loss is 0 and max loss is +inf Finding the lowest score (with respect to W) -- Optimization \u00b6 ramdon (never use) find the slope (using gradient: numberic for debugging and analytic for calculating) Gradient Descent \u00b6 while True : weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter update step_size is also the learning rate, it's the first thing to set Stochastic Gradient Descent (SGD) \u00b6 Use when there are a lot of training set, in each iteraion, take a samples data from the training set (typically 32/64/128/256) called minibatch while True : data_batch = sample_training_data(data, 256 ) weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update","title":"Cs231n lecture 3   loss function"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#loss-function","text":"","title":"Loss Function"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#multiclass-svm-loss-hinge-loss","text":"S_{y_j} S_{y_j} is the predict right score (target score) S_j S_j is the predict wrong score (all the other) L_i = \\sum_{j \\neq y_i} max(0, S_j - S_{y_j} + 1) Total Loss is: L = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i L(W) = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i(f(x_i, W), y_i) To calculate the loss for predicting car: max(0, cat score - car score + 1) + max(0, frog score - car score + 1) = max(0, -2.6) + max(0, -1.9) = 0 after using the same method to calculate each of the classes, the averge is the result: (2.9 -> for cat + 0 -> for car + 12.9 -> for frog) / 3 = 5.27","title":"Multiclass SVM Loss: hinge loss"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#regularization","text":"\\lambda R(W) \\lambda R(W) This term makes sure to choose \"simpler\" W instead of complicated ones that only fit training data, so that the power is lower for each term (high penalty for using high power poly).","title":"Regularization"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#softmax-classifier-multinomial-logistic-regression-cross-entropy-loss","text":"score is the probabilities for each class, and the sum of all classes equals to one (100%). Loss for each category: L_i = -\\log P(Y = y_i | X = x_i) L_i = -\\log P(Y = y_i | X = x_i) P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} where s s is our model: s = f(x_i;W) s = f(x_i;W) plug in to the first equation: L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) The min loss is 0 and max loss is +inf","title":"Softmax Classifier (Multinomial Logistic Regression): cross-entropy loss"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#finding-the-lowest-score-with-respect-to-w-optimization","text":"ramdon (never use) find the slope (using gradient: numberic for debugging and analytic for calculating)","title":"Finding the lowest score (with respect to W) -- Optimization"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#gradient-descent","text":"while True : weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter update step_size is also the learning rate, it's the first thing to set","title":"Gradient Descent"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#stochastic-gradient-descent-sgd","text":"Use when there are a lot of training set, in each iteraion, take a samples data from the training set (typically 32/64/128/256) called minibatch while True : data_batch = sample_training_data(data, 256 ) weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update","title":"Stochastic Gradient Descent (SGD)"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/","text":"Computation Graph \u00b6 Backpropagation: used for finding gradient \u00b6 e.g. f(x,y,z) = (x + y) z where x = -2, y = 5, z = -4 Notations: \u00b6 q = x + y \\frac{\\partial q}{\\partial x} = 1, \\frac{\\partial q}{\\partial y} = 1 f = qz \\frac{\\partial f}{\\partial q} = z, \\frac{\\partial f}{\\partial z} = q goal is to find: \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} In order to get all the targets, we start from the last node where \\frac{\\partial f}{\\partial f} = q = 1 \\frac{\\partial f}{\\partial f} = q = 1 Then find the following in sequences: 1. \\frac{\\partial f}{\\partial z} = q = 1 2. \\frac{\\partial f}{\\partial q} = z = -4 3. \\frac{\\partial f}{\\partial y} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial y} = -4 \\times 1 = -4 -- using chain rule 4. \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial x} = -4 \\times 1 = -4 -- using chain rule Using Chain rule: Use upstreaming compound and multiple with the local compound to derive the desire partial derivative For each node, we just need \"local gradient\" which is the new upstream for the next level node. Another Example \u00b6 Sigmoid Function \u00b6 Because we already know the gradient for sigmoid function, we can just replace the sigmoid gate with the analyic gradient result. Patterns in backward flow \u00b6 add gate: gradient distributor (split to two branches because of two terms) max gate (e.g. max(0,1)=1): gradient router (one gradient is 0 and another is the full value) mul gate: gradient switcher (multiple the other one to derive the current one) Using matrix representation (Vectorization) \u00b6 Jacobian Matrix for derivative for each vector. However, we don't need to calculate Jacobian matrix, because each x in the row only affect the result element in the same row. Thus the matrix is diagonal. L2 norm: f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 Partial in respect to each q_i: \\frac{\\partial f}{\\partial q_i} = 2q_i or \\nabla_q f = 2q Then calculate gradient for W, we can use chain rule: \\frac{\\partial f}{\\partial W_{i,j}} = \\sum_{k} \\frac{\\partial f}{\\partial q_k} \\frac{\\partial q_k}{\\partial W_{i,j}} = 2^k q_i x_j Implement forward and backword for different gates \u00b6 class MultiplyGate ( object ): def forward (x,y): return x * y def backward (dz): dx = self . y * dz # cache y dy = self . x * dz return [dx, dy] where [dx, dy] is: \\frac{\\partial L}{\\partial x}, \\frac{\\partial L}{\\partial y} and dz is: \\frac{\\partial L}{\\partial z}","title":"Cs231n lecture 4   introduction to neural networks"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#computation-graph","text":"","title":"Computation Graph"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#backpropagation-used-for-finding-gradient","text":"e.g. f(x,y,z) = (x + y) z where x = -2, y = 5, z = -4","title":"Backpropagation: used for finding gradient"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#notations","text":"q = x + y \\frac{\\partial q}{\\partial x} = 1, \\frac{\\partial q}{\\partial y} = 1 f = qz \\frac{\\partial f}{\\partial q} = z, \\frac{\\partial f}{\\partial z} = q goal is to find: \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} In order to get all the targets, we start from the last node where \\frac{\\partial f}{\\partial f} = q = 1 \\frac{\\partial f}{\\partial f} = q = 1 Then find the following in sequences: 1. \\frac{\\partial f}{\\partial z} = q = 1 2. \\frac{\\partial f}{\\partial q} = z = -4 3. \\frac{\\partial f}{\\partial y} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial y} = -4 \\times 1 = -4 -- using chain rule 4. \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial x} = -4 \\times 1 = -4 -- using chain rule Using Chain rule: Use upstreaming compound and multiple with the local compound to derive the desire partial derivative For each node, we just need \"local gradient\" which is the new upstream for the next level node.","title":"Notations:"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#another-example","text":"","title":"Another Example"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#sigmoid-function","text":"Because we already know the gradient for sigmoid function, we can just replace the sigmoid gate with the analyic gradient result.","title":"Sigmoid Function"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#patterns-in-backward-flow","text":"add gate: gradient distributor (split to two branches because of two terms) max gate (e.g. max(0,1)=1): gradient router (one gradient is 0 and another is the full value) mul gate: gradient switcher (multiple the other one to derive the current one)","title":"Patterns in backward flow"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#using-matrix-representation-vectorization","text":"Jacobian Matrix for derivative for each vector. However, we don't need to calculate Jacobian matrix, because each x in the row only affect the result element in the same row. Thus the matrix is diagonal. L2 norm: f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 Partial in respect to each q_i: \\frac{\\partial f}{\\partial q_i} = 2q_i or \\nabla_q f = 2q Then calculate gradient for W, we can use chain rule: \\frac{\\partial f}{\\partial W_{i,j}} = \\sum_{k} \\frac{\\partial f}{\\partial q_k} \\frac{\\partial q_k}{\\partial W_{i,j}} = 2^k q_i x_j","title":"Using matrix representation (Vectorization)"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#implement-forward-and-backword-for-different-gates","text":"class MultiplyGate ( object ): def forward (x,y): return x * y def backward (dz): dx = self . y * dz # cache y dy = self . x * dz return [dx, dy] where [dx, dy] is: \\frac{\\partial L}{\\partial x}, \\frac{\\partial L}{\\partial y} and dz is: \\frac{\\partial L}{\\partial z}","title":"Implement forward and backword for different gates"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/","text":"CNN is good for spacial structure Filter \u00b6 stride (3 in this case): number of steps to move for each progress dimentino size: n * n filter size: F Output size = (N - F)/stride+1 => e.g. stride size = 3 won't work 1. To make this case working, adding a border surrounded (padding) will make N divisable (now N is 9 instead of 7) 2. To make the size remain the same dimentionally, we also use padding. Conv Layer \u00b6 Accpets a volume of size W_1\\times H_1 \\times D_1 W_1\\times H_1 \\times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F (or filter dimension), the stride S, the amount of zero padding P. Produces a volume of size W_2 W_2 \\times \\times H_2 H_2 \\times \\times D_2 D_2 W_2 = (W_1 - F + 2P)/S + 1 W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/s + 1 H_2 = (H_1 - F + 2P)/s + 1 (width and height are the same size) D_2 = K D_2 = K With parameter sharing, it produces F \\times F \\times D_1 F \\times F \\times D_1 weights per filter, for a total of (F \\cdot F \\cdot D_1) * K (F \\cdot F \\cdot D_1) * K weights In the output volume, the d-th depth slice (of size W_2 \\times H_2 W_2 \\times H_2 ) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S S , and then offset by d-th bias Pooling Layer \u00b6 input depth would be the same, and width and height would be shrink down by a factor Max-Pooling Layer \u00b6 Choosing the maximum within each filter. Find the region that has fired with higher value from the other region. Summary \u00b6 Accepts a volume of size W1\u00d7H1\u00d7D1 Requires two hyperparameters: their spatial extent F, the stride S, Produces a volume of size W2\u00d7H2\u00d7D2 where: W_2=(W_1\u2212F)/S+1 W_2=(W_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 D_2=D_1 D_2=D_1 Introduces zero parameters since it computes a fixed function of the input For Pooling layers, it is not common to pad the input using zero-padding. It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with F=3,S=2 F=3,S=2 (also called overlapping pooling), and more commonly F=2,S=2 F=2,S=2 . Pooling sizes with larger receptive fields are too destructive. Fully Connected Layer (FC) \u00b6 Stretch out to 1-d array, usually on the last layer.","title":"Cs231n lecture 5   convolutional neural networks"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#filter","text":"stride (3 in this case): number of steps to move for each progress dimentino size: n * n filter size: F Output size = (N - F)/stride+1 => e.g. stride size = 3 won't work 1. To make this case working, adding a border surrounded (padding) will make N divisable (now N is 9 instead of 7) 2. To make the size remain the same dimentionally, we also use padding.","title":"Filter"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#conv-layer","text":"Accpets a volume of size W_1\\times H_1 \\times D_1 W_1\\times H_1 \\times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F (or filter dimension), the stride S, the amount of zero padding P. Produces a volume of size W_2 W_2 \\times \\times H_2 H_2 \\times \\times D_2 D_2 W_2 = (W_1 - F + 2P)/S + 1 W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/s + 1 H_2 = (H_1 - F + 2P)/s + 1 (width and height are the same size) D_2 = K D_2 = K With parameter sharing, it produces F \\times F \\times D_1 F \\times F \\times D_1 weights per filter, for a total of (F \\cdot F \\cdot D_1) * K (F \\cdot F \\cdot D_1) * K weights In the output volume, the d-th depth slice (of size W_2 \\times H_2 W_2 \\times H_2 ) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S S , and then offset by d-th bias","title":"Conv Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#pooling-layer","text":"input depth would be the same, and width and height would be shrink down by a factor","title":"Pooling Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#max-pooling-layer","text":"Choosing the maximum within each filter. Find the region that has fired with higher value from the other region.","title":"Max-Pooling Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#summary","text":"Accepts a volume of size W1\u00d7H1\u00d7D1 Requires two hyperparameters: their spatial extent F, the stride S, Produces a volume of size W2\u00d7H2\u00d7D2 where: W_2=(W_1\u2212F)/S+1 W_2=(W_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 D_2=D_1 D_2=D_1 Introduces zero parameters since it computes a fixed function of the input For Pooling layers, it is not common to pad the input using zero-padding. It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with F=3,S=2 F=3,S=2 (also called overlapping pooling), and more commonly F=2,S=2 F=2,S=2 . Pooling sizes with larger receptive fields are too destructive.","title":"Summary"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#fully-connected-layer-fc","text":"Stretch out to 1-d array, usually on the last layer.","title":"Fully Connected Layer (FC)"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/","text":"Overview \u00b6 One time setup: activation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamics: babysitting the learning process, parameter updates, hyperparameter optimization Evaluation: model ensembles Part 1 \u00b6 Activation functions Data preprocessing Weight initialization, Batch Normalization Babysitting the learning process Hyperparameter Optimization Activation Function \u00b6 Sigmoid \u00b6 \\sigma(x)=\\frac{1}{1+e^{-x}} \\sigma(x)=\\frac{1}{1+e^{-x}} if get high value -> approach to 1, low -> 0 problem 1: if too large, then the value is 1, or too small, then the value is 0 (killed gradient when saturated) problem 2: not zero-centered (gradient on w is always all positive or negative) which makes the parameter update inefficient problem 3: e^{-x} e^{-x} is computation expensive tanh \u00b6 tanh(x) tanh(x) in a range of [-1, 1] it's now zero centered (flip between - and + for same weight) problem 1: still kill gradient when saturated ReLU \u00b6 f(x)=max(0,x) f(x)=max(0,x) doesn't saturated in positive region computation efficient converge faster than sigmoid and tanh biologically plausible than sigmoid problem 1: not zero-centered problem 2: negative still saturated (annoyance, dead relu region) Leaky ReLU and Parametric Rectifier \u00b6 f(x)=max(0.01x, x) and f(x)=max(\\alpha x, x) Does not saturate Computationally efficient Converge much faster than sigmoid/tanh in practice will not \"die\" (no platu) Exponential Linear Unit (ELU) \u00b6 f(x)=x if x > 0 f(x)= alpha (exp(x)-1) if x <= 0 all benefits of ReLU closer to zero mean outputs negative sarturation regime compared with Leaky ReLU adds some robustness to noise problem 1: computation requires exp() Conclusion \u00b6 Use ReLU Try out Leaky ReLU/Maxout/ELU Try tanh but don't expect too much Don't use sigmoid Data Preprocessing \u00b6 for image, stick with zero-mean","title":"Cs231n lecture 6   training neural networks i"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#overview","text":"One time setup: activation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamics: babysitting the learning process, parameter updates, hyperparameter optimization Evaluation: model ensembles","title":"Overview"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#part-1","text":"Activation functions Data preprocessing Weight initialization, Batch Normalization Babysitting the learning process Hyperparameter Optimization","title":"Part 1"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#activation-function","text":"","title":"Activation Function"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#sigmoid","text":"\\sigma(x)=\\frac{1}{1+e^{-x}} \\sigma(x)=\\frac{1}{1+e^{-x}} if get high value -> approach to 1, low -> 0 problem 1: if too large, then the value is 1, or too small, then the value is 0 (killed gradient when saturated) problem 2: not zero-centered (gradient on w is always all positive or negative) which makes the parameter update inefficient problem 3: e^{-x} e^{-x} is computation expensive","title":"Sigmoid"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#tanh","text":"tanh(x) tanh(x) in a range of [-1, 1] it's now zero centered (flip between - and + for same weight) problem 1: still kill gradient when saturated","title":"tanh"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#relu","text":"f(x)=max(0,x) f(x)=max(0,x) doesn't saturated in positive region computation efficient converge faster than sigmoid and tanh biologically plausible than sigmoid problem 1: not zero-centered problem 2: negative still saturated (annoyance, dead relu region)","title":"ReLU"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#leaky-relu-and-parametric-rectifier","text":"f(x)=max(0.01x, x) and f(x)=max(\\alpha x, x) Does not saturate Computationally efficient Converge much faster than sigmoid/tanh in practice will not \"die\" (no platu)","title":"Leaky ReLU and Parametric Rectifier"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#exponential-linear-unit-elu","text":"f(x)=x if x > 0 f(x)= alpha (exp(x)-1) if x <= 0 all benefits of ReLU closer to zero mean outputs negative sarturation regime compared with Leaky ReLU adds some robustness to noise problem 1: computation requires exp()","title":"Exponential Linear Unit (ELU)"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#conclusion","text":"Use ReLU Try out Leaky ReLU/Maxout/ELU Try tanh but don't expect too much Don't use sigmoid","title":"Conclusion"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#data-preprocessing","text":"for image, stick with zero-mean","title":"Data Preprocessing"}]}