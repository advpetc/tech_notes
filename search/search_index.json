{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Haoyang's Tech Notes \u00b6 What's included \u00b6 Leetcode C Java iOS Crypto Python Machine Learning Interview Google Kick Start LibreOJ CLRS Acwing No Longer Update \u00b6 Old gitbook cnblog","title":"Welcome to Haoyang's Tech Notes"},{"location":"#welcome-to-haoyangs-tech-notes","text":"","title":"Welcome to Haoyang's Tech Notes"},{"location":"#whats-included","text":"Leetcode C Java iOS Crypto Python Machine Learning Interview Google Kick Start LibreOJ CLRS Acwing","title":"What's included"},{"location":"#no-longer-update","text":"Old gitbook cnblog","title":"No Longer Update"},{"location":"about/","text":"About \u00b6 Hi, I'm Haoyang Chen (\u9648\u98a2\u9633). I am a student major in Computer Science and Engineering. Ping me AT peterchen.xyz.","title":"About"},{"location":"about/#about","text":"Hi, I'm Haoyang Chen (\u9648\u98a2\u9633). I am a student major in Computer Science and Engineering. Ping me AT peterchen.xyz.","title":"About"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/","text":"Count # of 1 in binary \u00b6 https://www.acwing.com/problem/content/803/ Code \u00b6 #include <iostream> using namespace std; inline int lowbit ( int x) { return x & - x; } int main () { int n; cin >> n; while (n -- ) { int x, res = 0 ; cin >> x; while (x) { x -= lowbit(x); res ++ ; } cout << res << ' ' ; } } a - b \u00b6 https://www.acwing.com/problem/content/794/ Code \u00b6 #include <iostream> #include <vector> using namespace std; bool cmp (vector < int > & A, vector < int > & B) { if (A.size() != B.size()) return A.size() > B.size(); // \u5927\u5c0f\u4e0d\u4e00\u81f4\uff0c\u957f\u7684\u5927 for ( int i = A.size() - 1 ; i >= 0 ; i -- ) if (A[i] != B[i]) // \u5de6\u6570\u7b2c\u4e00\u4e2a\u4e0d\u4e00\u6837\u7684\u5927\u5c0f\u51b3\u5b9a\u6570\u5b57\u5927\u5c0f return A[i] > B[i]; return true; } vector < int > sub(vector < int > & A, vector < int > & B) { vector < int > C; for ( int i = 0 , t = 0 ; i < A.size(); i ++ ) { t = A[i] - t; // \u5f53\u524d\u6570\u51cf\u53bb\u501f\u4f4d\u7684\u6570 if (i < B.size()) t -= B[i]; // \u5982\u679cB\u6570\u7ec4\u6bd4A\u6570\u7ec4\u77ed\uff0c\u90a3\u4e48\u5269\u4f59\u503c\u51cf\u53bbB\u5f53\u524d\u4f4d C.push_back((t + 10 ) % 10 ); // \u5982\u679ct < 0\uff0c\u53d6t + 10\u7684\u503c\uff080-6 = -4\uff09\uff0c\u540c\u65f6\u501f\u4f4d\uff0c\u5982\u679ct >= 0\uff0c\u53d6%10\uff0c\uff085-3=2=2+10%10=2\uff09 if (t < 0 ) t = 1 ; // \u501f\u4f4d else t = 0 ; // \u4e0d\u5fc5\u501f\u4f4d } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a, b; vector < int > A, B; cin >> a >> b; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); for ( int i = b.size() - 1 ; i >= 0 ; i -- ) B.push_back(b[i] - '0' ); vector < int > C; if (cmp(A, B)) C = sub(A, B); else C = sub(B, A), cout << '-' ; for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/activity/content/code/content/39793/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 a * b \u00b6 https://www.acwing.com/activity/content/code/content/39794/ Code \u00b6 #include <iostream> #include <vector> using namespace std; vector < int > mul(vector < int > & A, int b) { vector < int > C; int t = 0 ; for ( int i = 0 ; i < A.size() || t; i ++ ) { if (i < A.size()) t += A[i] * b; C.push_back(t % 10 ); t /= 10 ; } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); // \u53bb\u9664leading zeros return C; } int main() { string a; int b; cin >> a >> b; vector < int > A; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); auto C = mul(A, b); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) printf( \"%d\" , C[i]); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/activity/content/code/content/39794/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 a / b \u00b6 https://www.acwing.com/activity/content/code/content/39795/ Code \u00b6 #include <iostream> #include <vector> #include <algorithm> using namespace std; vector < int > div(vector < int > & A, int b, int & r) { vector < int > C; r = 0 ; // reminder for ( int i = A.size() - 1 ; i >= 0 ; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a; vector < int > A; int B; cin >> a >> B; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); int r; auto C = div(A, B, r); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl << r << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/activity/content/code/content/39795/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"\u7b97\u6cd5\u57fa\u7840\u8bfe"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#count-of-1-in-binary","text":"https://www.acwing.com/problem/content/803/","title":"Count # of 1 in binary"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code","text":"#include <iostream> using namespace std; inline int lowbit ( int x) { return x & - x; } int main () { int n; cin >> n; while (n -- ) { int x, res = 0 ; cin >> x; while (x) { x -= lowbit(x); res ++ ; } cout << res << ' ' ; } }","title":"Code"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#a-b","text":"https://www.acwing.com/problem/content/794/","title":"a - b"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code_1","text":"#include <iostream> #include <vector> using namespace std; bool cmp (vector < int > & A, vector < int > & B) { if (A.size() != B.size()) return A.size() > B.size(); // \u5927\u5c0f\u4e0d\u4e00\u81f4\uff0c\u957f\u7684\u5927 for ( int i = A.size() - 1 ; i >= 0 ; i -- ) if (A[i] != B[i]) // \u5de6\u6570\u7b2c\u4e00\u4e2a\u4e0d\u4e00\u6837\u7684\u5927\u5c0f\u51b3\u5b9a\u6570\u5b57\u5927\u5c0f return A[i] > B[i]; return true; } vector < int > sub(vector < int > & A, vector < int > & B) { vector < int > C; for ( int i = 0 , t = 0 ; i < A.size(); i ++ ) { t = A[i] - t; // \u5f53\u524d\u6570\u51cf\u53bb\u501f\u4f4d\u7684\u6570 if (i < B.size()) t -= B[i]; // \u5982\u679cB\u6570\u7ec4\u6bd4A\u6570\u7ec4\u77ed\uff0c\u90a3\u4e48\u5269\u4f59\u503c\u51cf\u53bbB\u5f53\u524d\u4f4d C.push_back((t + 10 ) % 10 ); // \u5982\u679ct < 0\uff0c\u53d6t + 10\u7684\u503c\uff080-6 = -4\uff09\uff0c\u540c\u65f6\u501f\u4f4d\uff0c\u5982\u679ct >= 0\uff0c\u53d6%10\uff0c\uff085-3=2=2+10%10=2\uff09 if (t < 0 ) t = 1 ; // \u501f\u4f4d else t = 0 ; // \u4e0d\u5fc5\u501f\u4f4d } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a, b; vector < int > A, B; cin >> a >> b; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); for ( int i = b.size() - 1 ; i >= 0 ; i -- ) B.push_back(b[i] - '0' ); vector < int > C; if (cmp(A, B)) C = sub(A, B); else C = sub(B, A), cout << '-' ; for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/activity/content/code/content/39793/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#a-b_1","text":"https://www.acwing.com/activity/content/code/content/39794/","title":"a * b"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code_2","text":"#include <iostream> #include <vector> using namespace std; vector < int > mul(vector < int > & A, int b) { vector < int > C; int t = 0 ; for ( int i = 0 ; i < A.size() || t; i ++ ) { if (i < A.size()) t += A[i] * b; C.push_back(t % 10 ); t /= 10 ; } while (C.size() > 1 && C.back() == 0 ) C.pop_back(); // \u53bb\u9664leading zeros return C; } int main() { string a; int b; cin >> a >> b; vector < int > A; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); auto C = mul(A, b); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) printf( \"%d\" , C[i]); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/activity/content/code/content/39794/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#a-b_2","text":"https://www.acwing.com/activity/content/code/content/39795/","title":"a / b"},{"location":"Acwing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/#code_3","text":"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector < int > div(vector < int > & A, int b, int & r) { vector < int > C; r = 0 ; // reminder for ( int i = A.size() - 1 ; i >= 0 ; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() > 1 && C.back() == 0 ) C.pop_back(); return C; } int main() { string a; vector < int > A; int B; cin >> a >> B; for ( int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0' ); int r; auto C = div(A, B, r); for ( int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i]; cout << endl << r << endl; return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/activity/content/code/content/39795/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Code"},{"location":"CLRS/shortest-path-problem/","text":"Single Source shortest path problem \u00b6 Find the shortest src to a target dest: reversing the direction of the DAG -> find the shortest path starting from dest Find shortest path between u and v. Find shortest path for all pair u and v. Negative Edge \u00b6 If graph has cycle: short path isn't well defined. Dijkstra: has to be positive edge, can deal with cycle Bellman Ford: cannot have a cycle from src but can deal with negative edge (single source shortest path) Shortest path cannot contain a cycle Uniqueness \u00b6 Shortest paths are not necessary unique: Dijkstra \u00b6 More efficient than Bellman Ford but requires the edges are positive weight. The algorithm only traverse each node once, and greedily choose the shortest path to reach the current node (using priority queue). for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; q.push({ 0 ,x}); while ( ! q.empty()) { int a = q.top().second; q.pop(); if (processed[a]) continue ; processed[a] = true; for ( auto u : adj[a]) { int b = u.first, w = u.second; if (distance[a] + w < distance[b]) { distance[b] = distance[a] + w; q.push({ - distance[b],b}); } } } Time: O(n + m log m) O(n + m log m) Bellman Ford \u00b6 Find the shortest path from one src to all the others. If there is a negative cycle, it will be able to detect it. for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { for ( auto e : edges) { int a, b, w; tie(a, b, w) = e; distance[b] = min(distance[b], distance[a] + w); } } for ( auto e : edge) { int a, b, w; tie(a, b, w) = e; if (distance[a] + w < distance[b]) return false; // negative cycle } Time: O(m \\times n) O(m \\times n) n node with m edges Floyd-Warshall (find all shortest path for all pairs) \u00b6 First initialize the distance list with direct connected nodes' distance. for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { if (i == j) distance[i][j] = 0 ; else if (adj[i][j]) distance[i][j] = adj[i][j]; else distance[i][j] = INF; } } Then keep adding the intermediate nodes k, and base on the new graph update the distance list. for ( int k = 1 ; k <= n; k ++ ) { // added node for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]); } } } Time: O(n^3) O(n^3) for the second step","title":"Shortest path problem"},{"location":"CLRS/shortest-path-problem/#single-source-shortest-path-problem","text":"Find the shortest src to a target dest: reversing the direction of the DAG -> find the shortest path starting from dest Find shortest path between u and v. Find shortest path for all pair u and v.","title":"Single Source shortest path problem"},{"location":"CLRS/shortest-path-problem/#negative-edge","text":"If graph has cycle: short path isn't well defined. Dijkstra: has to be positive edge, can deal with cycle Bellman Ford: cannot have a cycle from src but can deal with negative edge (single source shortest path) Shortest path cannot contain a cycle","title":"Negative Edge"},{"location":"CLRS/shortest-path-problem/#uniqueness","text":"Shortest paths are not necessary unique:","title":"Uniqueness"},{"location":"CLRS/shortest-path-problem/#dijkstra","text":"More efficient than Bellman Ford but requires the edges are positive weight. The algorithm only traverse each node once, and greedily choose the shortest path to reach the current node (using priority queue). for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; q.push({ 0 ,x}); while ( ! q.empty()) { int a = q.top().second; q.pop(); if (processed[a]) continue ; processed[a] = true; for ( auto u : adj[a]) { int b = u.first, w = u.second; if (distance[a] + w < distance[b]) { distance[b] = distance[a] + w; q.push({ - distance[b],b}); } } } Time: O(n + m log m) O(n + m log m)","title":"Dijkstra"},{"location":"CLRS/shortest-path-problem/#bellman-ford","text":"Find the shortest path from one src to all the others. If there is a negative cycle, it will be able to detect it. for ( int i = 1 ; i <= n; i ++ ) distance[i] = INF; distance[x] = 0 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { for ( auto e : edges) { int a, b, w; tie(a, b, w) = e; distance[b] = min(distance[b], distance[a] + w); } } for ( auto e : edge) { int a, b, w; tie(a, b, w) = e; if (distance[a] + w < distance[b]) return false; // negative cycle } Time: O(m \\times n) O(m \\times n) n node with m edges","title":"Bellman Ford"},{"location":"CLRS/shortest-path-problem/#floyd-warshall-find-all-shortest-path-for-all-pairs","text":"First initialize the distance list with direct connected nodes' distance. for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { if (i == j) distance[i][j] = 0 ; else if (adj[i][j]) distance[i][j] = adj[i][j]; else distance[i][j] = INF; } } Then keep adding the intermediate nodes k, and base on the new graph update the distance list. for ( int k = 1 ; k <= n; k ++ ) { // added node for ( int i = 1 ; i <= n; i ++ ) { for ( int j = 1 ; j <= n; j ++ ) { distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]); } } } Time: O(n^3) O(n^3) for the second step","title":"Floyd-Warshall (find all shortest path for all pairs)"},{"location":"Crypto/rsa-en%26decryption/","text":"Symbolics \u00b6 p and q are two very large primes n = p * q : Modulus phi = (p-1) * (q-1) : Totient e Public Key: is the prime number chosen in the range [3, phi(n)] d Secret Key Calculate d and Encrypt the message \u00b6 using extended-Euclid's algorithm to find the resulting equation when gcd = 1: it should always look like this: 1 = (a) * phi + (b) * e And d = phi * k - b (k is any integer that could make d > 0) To verify: e * d = 1 mod phi, this could be done easily Encrypt the message using public key e and n: M ^ e mod n the result C is the encrypted message Decrypt C using private key \u00b6 M = c ^ d mod n Sometimes it's being called the signature sign","title":"Rsa en&decryption"},{"location":"Crypto/rsa-en%26decryption/#symbolics","text":"p and q are two very large primes n = p * q : Modulus phi = (p-1) * (q-1) : Totient e Public Key: is the prime number chosen in the range [3, phi(n)] d Secret Key","title":"Symbolics"},{"location":"Crypto/rsa-en%26decryption/#calculate-d-and-encrypt-the-message","text":"using extended-Euclid's algorithm to find the resulting equation when gcd = 1: it should always look like this: 1 = (a) * phi + (b) * e And d = phi * k - b (k is any integer that could make d > 0) To verify: e * d = 1 mod phi, this could be done easily Encrypt the message using public key e and n: M ^ e mod n the result C is the encrypted message","title":"Calculate d and Encrypt the message"},{"location":"Crypto/rsa-en%26decryption/#decrypt-c-using-private-key","text":"M = c ^ d mod n Sometimes it's being called the signature sign","title":"Decrypt C using private key"},{"location":"Google%20Kick%20Start/2020---round-a/","text":"Allocation \u00b6 There are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. Limits Time limit: 15 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 B \u2264 105. 1 \u2264 Ai \u2264 1000, for all i. Test set 1 1 \u2264 N \u2264 100. Test set 2 1 \u2264 N \u2264 105. Sample Input Output 3 4 100 20 90 40 90 4 50 30 30 10 10 3 300 999 999 999 Case #1: 2 Case #2: 3 Case #3: 0 In Sample Case #1, you have a budget of 100 dollars. You can buy the 1 st and 3 rd houses for 20 + 40 = 60 dollars. In Sample Case #2, you have a budget of 50 dollars. You can buy the 1 st , 3 rd and 4 th houses for 30 + 10 + 10 = 50 dollars. In Sample Case #3, you have a budget of 300 dollars. You cannot buy any houses (so the answer is 0). Analysis \u00b6 To buy the maxmimum amount of houses, we can greedy buy the ones with the smallest cost first, and until we reach to the point when there is no money left to buy the next higher cost house, we can stop. Prove by replacement: assume the solution is A = {a1, ..., ak} where ai represents the house cost you choose for the max amount. assume the optimal solution is O = {oi, ..., om} where oi represents the true solution. assume oj is not presented in A we want to prove that A == O pick an ai that is in A, and replace it with oj. oj is not in A, so oj is less than ai. since size of B is the same, the solution is still the most optimal one. keep doing this until there is A == O. Code \u00b6 sort with nlog n \u00b6 /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; vector < int > costs(N, 0 ); for ( int j = 0 ; j < N; ++ j) { cin >> costs[j]; } sort(costs.begin(), costs.end()); // nlog n int cnt = 0 ; for ( int k = 0 ; k < N; ++ k) if (B >= costs[k]) { B -= costs[k]; cnt ++ ; } else break ; cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; } count sort with n \u00b6 because 1 \u2264 Ai \u2264 1000, we can use count sort /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int n = 1010 ; int A[n]; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; memset(A, 0 , sizeof A); int v; for ( int i = 0 ; i < N; ++ i) { cin >> v; A[v] ++ ; } int cnt = 0 ; for ( int i = 1 ; B > 0 && i <= 1000 ; ++ i) { // i is house price int curr = min(B / i, A[i]); // case when there are less than you can buy cnt += curr; B -= curr * i; } cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; } Plates \u00b6 Dr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 K \u2264 30. 1 \u2264 P \u2264 N * K. The beauty values are between 1 and 100, inclusive. Test set 1 1 \u2264 N \u2264 3. Test set 2 1 \u2264 N \u2264 50. Sample Input Output 2 2 4 5 10 10 100 30 80 50 10 50 3 2 3 80 80 15 50 20 10 Case #1: 250 Case #2: 180 In Sample Case #1, Dr. Patel needs to pick P = 5 plates: He can pick the top 3 plates from the first stack (10 + 10 + 100 = 120). He can pick the top 2 plates from the second stack (80 + 50 = 130) . In total, the sum of beauty values is 250. In Sample Case #2, Dr. Patel needs to pick P = 3 plates: He can pick the top 2 plates from the first stack (80 + 80 = 160). He can pick no plates from the second stack. He can pick the top plate from the third stack (20). In total, the sum of beauty values is 180. Analysis \u00b6 dp[N][P]: from first n stacks, with p plates, the maximum beauty values dp[i][j] = max(dp[i][j], val[k] + dp[i - 1][p - k]) for choosing current stack's top k plates, you need to give up the previous stacks k plates, so the previous state is dp[i - 1][p - k] the answer is dp[N][P] Code \u00b6 /* * plates.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T; int N, K, P; // n: # of stacks, k: # of items for each stack, # total to be // borrowed cin >> T; for ( int t = 0 ; t < T; ++ t) { cin >> N >> K >> P; int dp[N + 1 ][P + 1 ]; // from 0-N, the max value for P plates memset(dp, 0 , sizeof dp); for ( int i = 1 ; i <= N; ++ i) { int val[K + 1 ]; memset(val, 0 , sizeof val); for ( int j = 1 ; j <= K; ++ j) { cin >> val[j]; } // calculate preSum for ( int k = 1 ; k <= K; ++ k) { val[k] = val[k - 1 ] + val[k]; } for ( int p = 1 ; p <= P; ++ p) { for ( int k = 0 ; k <= min(p, K); ++ k) { dp[i][p] = max(dp[i][p], val[k] + dp[i - 1 ][p - k]); } } } cout << \"Case #\" << t << \": \" << dp[N][P] << endl; } return 0 ; } Workout \u00b6 Tambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. For at most 10 test cases, 2 \u2264 N \u2264 105. For all other test cases, 2 \u2264 N \u2264 300. 1 \u2264 Mi \u2264 109. Mi < Mi+1 for all i. Test set 1 K = 1. Test set 2 1 \u2264 K \u2264 105. Samples Input 1 Output 1 1 3 1 100 200 230 Case #1: 50 Input 2 Output 2 3 5 2 10 13 15 16 17 5 6 9 10 20 26 30 8 3 1 2 3 4 5 6 7 10 Case #1: 2 Case #2: 3 Case #3: 1 Sample #1 In Case #1: Tambourine can add up to one session. The added sessions are marked in bold: 100 150 200 230. The difficulty is now 50. Sample #2 In Case #1: Tambourine can add up to two sessions. The added sessions are marked in bold: 10 11 13 15 16 17 18. The difficulty is now 2. In Case #2: Tambourine can add up to six sessions. The added sessions are marked in bold: 9 10 12 14 16 18 20 23 26 29 30. The difficulty is now 3. In Case #3: Tambourine can add up to three sessions. The added sessions are marked in bold: 1 2 3 4 5 6 7 8 9 10. The difficulty is now 1. Note that Tambourine only added two sessions. Analysis \u00b6 Priority Queue : Find an array that record the gaps every two sessions. Call it gaps[N-1]. To add one session, the new one should be between the one that has the greatest gap. However, we cannot do that all at once for the first greatest gap. Instead, we should do it \"greedily\". When adding the one, we need to find a way to get the updated max gap from the total gaps. In order to do so, we need to use priority queue. The top of the queue will store the maxmium gap. To keep update the gap, we don't want to manually modify the default gap, but to add a \"cnt\" which will be divied by the gap. When making the comparsion, the real gap value is gap default value / cnt. Binary Search : Our goal is to find the most difficult gap, and try to minimize it as much as possible. It now becomes a search problem. The gap is in between 1 ~ a[n-1]-a[0], and for each gap, we calculate the desire \"cuts\" to satisfy k. To calculate the desire \"cuts\", we should find the gap between each one, and then ceil(gap / most difficult gap) - 1 (check line 21 from solution 2). If the \"cuts\" is less than K, that means we have room to lower our difficulty by using the unused \"cuts\", so our search range is decreased by half from 1 ~ mb, else it will be mb + 1 ~ rb. Code \u00b6 Priority Queue \u00b6 #include <bits/stdc++.h> using namespace std; struct node { int sum, cnt; node() {} node( int sum, int cnt) : sum(sum) , cnt(cnt) { } bool operator < ( const node & b) const { int x = (sum / cnt) + (sum % cnt > 0 ); // sort by averged out by cnt int y = (b.sum / b.cnt) + (b.sum % b.cnt > 0 ); return x < y; } }; int main ( int argc, char * argv[]) { int T; int N, K; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> K; int m[N]; memset(m, 0 , sizeof m); for ( int n = 0 ; n < N; ++ n) { cin >> m[n]; } int gap[N - 1 ]; memset(gap, 0 , sizeof gap); for ( int i = 0 ; i < N - 1 ; ++ i) { gap[i] = m[i + 1 ] - m[i]; } if (K == 1 ) { sort(gap, gap + N - 1 ); if (N == 2 ) printf( \"Case #%d: %d \\n \" , i, (gap[ 0 ] + 1 ) / 2 ); else printf( \"Case #%d: %d \\n \" , i, max((gap[N - 2 ] + 1 ) / 2 , gap[N - 3 ])); } else { priority_queue < node > q; for ( int i = 0 ; i < N - 1 ; ++ i) { q.push(node(gap[i], 1 )); } for ( int i = 0 ; i < K; ++ i) { auto p = q.top(); q.pop(); q.push(node(p.sum, p.cnt + 1 )); // add one to split it } auto p = q.top(); int res = (p.sum / p.cnt) + (p.sum % p.cnt > 0 ); printf( \"Case #%d: %d \\n \" , i, res); } } return 0 ; } Binary search \u00b6 #include <bits/stdc++.h> using namespace std; #define ll long long #define ar array int n, k, a[ 100000 ]; void solve () { cin >> n >> k; // n: size of a, k: # of total insertions for ( int i = 0 ; i < n; ++ i) cin >> a[i]; int lb = 1 , rb = a[n - 1 ] - a[ 0 ]; // total difference while (lb < rb) { int mb = (lb + rb) / 2 ; // guess the most optimal difference is mb int k2 = 0 ; for ( int i = 1 ; i < n; ++ i) { int d = a[i] - a[i - 1 ]; k2 += (d + mb - 1 ) / mb - 1 ; // # of all inserted class if mb is the optimal } if (k2 <= k) // if less than k, we can potentially decrease the difficulity rb = mb; else // or we have to increase the difficulity lb = mb + 1 ; } cout << lb << \" \\n \" ; } int main () { ios :: sync_with_stdio( 0 ); cin.tie( 0 ); int t, i = 1 ; cin >> t; while (t -- ) { cout << \"Case #\" << i << \": \" ; solve(); ++ i; } } Bundling \u00b6 Pip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example: The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is 'RA'). The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is 'FIRE'). The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ''). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip's strings. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 2 \u2264 N \u2264 105. 2 \u2264 K \u2264 N. K divides N. Each of Pip's strings contain at least one character. Each string consists only of letters from A to Z. Test set 1 Each of Pip's strings contain at most 5 characters. Test set 2 The total number of characters in Pip's strings across all test cases is at most 2 \u00d7 106. Samples Input 1 2 2 2 KICK START 8 2 G G GO GO GOO GOO GOOO GOOO Output 1 Case #1: 0 Case #2: 10 Input 2 1 6 3 RAINBOW FIREBALL RANK RANDOM FIREWALL FIREFIGHTER Output 2 Case #1: 6 Sample #1 In Case #1, Pip can achieve a total score of 0 by make the groups: {KICK, START}, with a score of 0. In Case #2, Pip can achieve a total score of 10 by make the groups: {G, G}, with a score of 1. {GO, GO}, with a score of 2. {GOO, GOO}, with a score of 3. {GOOO, GOOO}, with a score of 4. Sample #2 In Case #1, Pip can achieve a total score of 6 by make the groups: {RAINBOW, RANK, RANDOM}, with a score of 2. {FIREBALL, FIREWALL, FIREFIGHTER}, with a score of 4. Analysis \u00b6 Assume each bundle has prefix as P_i P_i , and the CNT_i CNT_i represents the number of strings shares that prefix. Assign k string to the bundle, now we have CNT_i \\% k CNT_i \\% k string left. Do the same thing for preifx P_{i + 1} P_{i + 1} which has a CNT_{i+1} < CNT_i CNT_{i+1} < CNT_i , now we have CNT_{i + 1} \\% k CNT_{i + 1} \\% k left. Keep this procedure until CNT_j \\% k == 0 CNT_j \\% k == 0 which means all the string have assigned to a particular bundle. Now the problem becomes finding the total count. Split into n/k groups, and each group has k strings. Use trie to find the common prefix. Each trie node has 26 children nodes, and one cnt int for counting the number of prefix exist by the current node. Insert: insert into trie and update the cnt for each ending character node. Query: just search from the root of the trie and traverse through the last level of the trie, because all the nodes from root has a count that represent the occurance of word that is ended with node character. Code \u00b6 #include <bits/stdc++.h> using namespace std; #define endl \"\\n\" #define int long long const int N = 1e5 + 5 ; typedef struct data { data * bit[ 26 ]; int cnt = 0 ; }trie; trie * head; void insert (string & s) { trie * cur = head; for ( auto & it:s) { int b = it - 'A' ; if ( ! cur -> bit[b]) cur -> bit[b] = new trie(); // create new node if not exist cur = cur -> bit[b]; // proceed through next character cur -> cnt ++ ; // end with current character } } int n, k; string s[N]; int query (trie * cur) { if ( ! cur) return 0 ; int ans = (cur -> cnt / k); // there are k words each, so there are k times repeat counts for ( int i = 0 ; i <= 25 ; i ++ ) if (cur -> bit[i]) ans += query(cur -> bit[i]); // proceeds to next level and check the count return ans; } int main () { int t; cin >> t; int tc = 0 ; while (t -- ) { head = new trie(); tc ++ ; cin >> n >> k; for ( int i = 1 ; i <= n; i ++ ) { cin >> s[i]; insert(s[i]); } int ans = query(head); cout << \"Case #\" << tc << \": \" << ans << endl; } return 0 ; }","title":"2020   round a"},{"location":"Google%20Kick%20Start/2020---round-a/#allocation","text":"There are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. Limits Time limit: 15 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 B \u2264 105. 1 \u2264 Ai \u2264 1000, for all i. Test set 1 1 \u2264 N \u2264 100. Test set 2 1 \u2264 N \u2264 105. Sample Input Output 3 4 100 20 90 40 90 4 50 30 30 10 10 3 300 999 999 999 Case #1: 2 Case #2: 3 Case #3: 0 In Sample Case #1, you have a budget of 100 dollars. You can buy the 1 st and 3 rd houses for 20 + 40 = 60 dollars. In Sample Case #2, you have a budget of 50 dollars. You can buy the 1 st , 3 rd and 4 th houses for 30 + 10 + 10 = 50 dollars. In Sample Case #3, you have a budget of 300 dollars. You cannot buy any houses (so the answer is 0).","title":"Allocation"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis","text":"To buy the maxmimum amount of houses, we can greedy buy the ones with the smallest cost first, and until we reach to the point when there is no money left to buy the next higher cost house, we can stop. Prove by replacement: assume the solution is A = {a1, ..., ak} where ai represents the house cost you choose for the max amount. assume the optimal solution is O = {oi, ..., om} where oi represents the true solution. assume oj is not presented in A we want to prove that A == O pick an ai that is in A, and replace it with oj. oj is not in A, so oj is less than ai. since size of B is the same, the solution is still the most optimal one. keep doing this until there is A == O.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code","text":"","title":"Code"},{"location":"Google%20Kick%20Start/2020---round-a/#sort-with-nlog-n","text":"/* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; vector < int > costs(N, 0 ); for ( int j = 0 ; j < N; ++ j) { cin >> costs[j]; } sort(costs.begin(), costs.end()); // nlog n int cnt = 0 ; for ( int k = 0 ; k < N; ++ k) if (B >= costs[k]) { B -= costs[k]; cnt ++ ; } else break ; cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; }","title":"sort with nlog n"},{"location":"Google%20Kick%20Start/2020---round-a/#count-sort-with-n","text":"because 1 \u2264 Ai \u2264 1000, we can use count sort /* * allocation.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int n = 1010 ; int A[n]; int main ( int argc, char * argv[]) { int T, N, B; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> B; memset(A, 0 , sizeof A); int v; for ( int i = 0 ; i < N; ++ i) { cin >> v; A[v] ++ ; } int cnt = 0 ; for ( int i = 1 ; B > 0 && i <= 1000 ; ++ i) { // i is house price int curr = min(B / i, A[i]); // case when there are less than you can buy cnt += curr; B -= curr * i; } cout << \"Case #\" << i << \": \" << cnt << endl; } return 0 ; }","title":"count sort with n"},{"location":"Google%20Kick%20Start/2020---round-a/#plates","text":"Dr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 1 \u2264 K \u2264 30. 1 \u2264 P \u2264 N * K. The beauty values are between 1 and 100, inclusive. Test set 1 1 \u2264 N \u2264 3. Test set 2 1 \u2264 N \u2264 50. Sample Input Output 2 2 4 5 10 10 100 30 80 50 10 50 3 2 3 80 80 15 50 20 10 Case #1: 250 Case #2: 180 In Sample Case #1, Dr. Patel needs to pick P = 5 plates: He can pick the top 3 plates from the first stack (10 + 10 + 100 = 120). He can pick the top 2 plates from the second stack (80 + 50 = 130) . In total, the sum of beauty values is 250. In Sample Case #2, Dr. Patel needs to pick P = 3 plates: He can pick the top 2 plates from the first stack (80 + 80 = 160). He can pick no plates from the second stack. He can pick the top plate from the third stack (20). In total, the sum of beauty values is 180.","title":"Plates"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis_1","text":"dp[N][P]: from first n stacks, with p plates, the maximum beauty values dp[i][j] = max(dp[i][j], val[k] + dp[i - 1][p - k]) for choosing current stack's top k plates, you need to give up the previous stacks k plates, so the previous state is dp[i - 1][p - k] the answer is dp[N][P]","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code_1","text":"/* * plates.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; int main ( int argc, char * argv[]) { int T; int N, K, P; // n: # of stacks, k: # of items for each stack, # total to be // borrowed cin >> T; for ( int t = 0 ; t < T; ++ t) { cin >> N >> K >> P; int dp[N + 1 ][P + 1 ]; // from 0-N, the max value for P plates memset(dp, 0 , sizeof dp); for ( int i = 1 ; i <= N; ++ i) { int val[K + 1 ]; memset(val, 0 , sizeof val); for ( int j = 1 ; j <= K; ++ j) { cin >> val[j]; } // calculate preSum for ( int k = 1 ; k <= K; ++ k) { val[k] = val[k - 1 ] + val[k]; } for ( int p = 1 ; p <= P; ++ p) { for ( int k = 0 ; k <= min(p, K); ++ k) { dp[i][p] = max(dp[i][p], val[k] + dp[i - 1 ][p - k]); } } } cout << \"Case #\" << t << \": \" << dp[N][P] << endl; } return 0 ; }","title":"Code"},{"location":"Google%20Kick%20Start/2020---round-a/#workout","text":"Tambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. For at most 10 test cases, 2 \u2264 N \u2264 105. For all other test cases, 2 \u2264 N \u2264 300. 1 \u2264 Mi \u2264 109. Mi < Mi+1 for all i. Test set 1 K = 1. Test set 2 1 \u2264 K \u2264 105. Samples Input 1 Output 1 1 3 1 100 200 230 Case #1: 50 Input 2 Output 2 3 5 2 10 13 15 16 17 5 6 9 10 20 26 30 8 3 1 2 3 4 5 6 7 10 Case #1: 2 Case #2: 3 Case #3: 1 Sample #1 In Case #1: Tambourine can add up to one session. The added sessions are marked in bold: 100 150 200 230. The difficulty is now 50. Sample #2 In Case #1: Tambourine can add up to two sessions. The added sessions are marked in bold: 10 11 13 15 16 17 18. The difficulty is now 2. In Case #2: Tambourine can add up to six sessions. The added sessions are marked in bold: 9 10 12 14 16 18 20 23 26 29 30. The difficulty is now 3. In Case #3: Tambourine can add up to three sessions. The added sessions are marked in bold: 1 2 3 4 5 6 7 8 9 10. The difficulty is now 1. Note that Tambourine only added two sessions.","title":"Workout"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis_2","text":"Priority Queue : Find an array that record the gaps every two sessions. Call it gaps[N-1]. To add one session, the new one should be between the one that has the greatest gap. However, we cannot do that all at once for the first greatest gap. Instead, we should do it \"greedily\". When adding the one, we need to find a way to get the updated max gap from the total gaps. In order to do so, we need to use priority queue. The top of the queue will store the maxmium gap. To keep update the gap, we don't want to manually modify the default gap, but to add a \"cnt\" which will be divied by the gap. When making the comparsion, the real gap value is gap default value / cnt. Binary Search : Our goal is to find the most difficult gap, and try to minimize it as much as possible. It now becomes a search problem. The gap is in between 1 ~ a[n-1]-a[0], and for each gap, we calculate the desire \"cuts\" to satisfy k. To calculate the desire \"cuts\", we should find the gap between each one, and then ceil(gap / most difficult gap) - 1 (check line 21 from solution 2). If the \"cuts\" is less than K, that means we have room to lower our difficulty by using the unused \"cuts\", so our search range is decreased by half from 1 ~ mb, else it will be mb + 1 ~ rb.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code_2","text":"","title":"Code"},{"location":"Google%20Kick%20Start/2020---round-a/#priority-queue","text":"#include <bits/stdc++.h> using namespace std; struct node { int sum, cnt; node() {} node( int sum, int cnt) : sum(sum) , cnt(cnt) { } bool operator < ( const node & b) const { int x = (sum / cnt) + (sum % cnt > 0 ); // sort by averged out by cnt int y = (b.sum / b.cnt) + (b.sum % b.cnt > 0 ); return x < y; } }; int main ( int argc, char * argv[]) { int T; int N, K; cin >> T; for ( int i = 1 ; i <= T; ++ i) { cin >> N >> K; int m[N]; memset(m, 0 , sizeof m); for ( int n = 0 ; n < N; ++ n) { cin >> m[n]; } int gap[N - 1 ]; memset(gap, 0 , sizeof gap); for ( int i = 0 ; i < N - 1 ; ++ i) { gap[i] = m[i + 1 ] - m[i]; } if (K == 1 ) { sort(gap, gap + N - 1 ); if (N == 2 ) printf( \"Case #%d: %d \\n \" , i, (gap[ 0 ] + 1 ) / 2 ); else printf( \"Case #%d: %d \\n \" , i, max((gap[N - 2 ] + 1 ) / 2 , gap[N - 3 ])); } else { priority_queue < node > q; for ( int i = 0 ; i < N - 1 ; ++ i) { q.push(node(gap[i], 1 )); } for ( int i = 0 ; i < K; ++ i) { auto p = q.top(); q.pop(); q.push(node(p.sum, p.cnt + 1 )); // add one to split it } auto p = q.top(); int res = (p.sum / p.cnt) + (p.sum % p.cnt > 0 ); printf( \"Case #%d: %d \\n \" , i, res); } } return 0 ; }","title":"Priority Queue"},{"location":"Google%20Kick%20Start/2020---round-a/#binary-search","text":"#include <bits/stdc++.h> using namespace std; #define ll long long #define ar array int n, k, a[ 100000 ]; void solve () { cin >> n >> k; // n: size of a, k: # of total insertions for ( int i = 0 ; i < n; ++ i) cin >> a[i]; int lb = 1 , rb = a[n - 1 ] - a[ 0 ]; // total difference while (lb < rb) { int mb = (lb + rb) / 2 ; // guess the most optimal difference is mb int k2 = 0 ; for ( int i = 1 ; i < n; ++ i) { int d = a[i] - a[i - 1 ]; k2 += (d + mb - 1 ) / mb - 1 ; // # of all inserted class if mb is the optimal } if (k2 <= k) // if less than k, we can potentially decrease the difficulity rb = mb; else // or we have to increase the difficulity lb = mb + 1 ; } cout << lb << \" \\n \" ; } int main () { ios :: sync_with_stdio( 0 ); cin.tie( 0 ); int t, i = 1 ; cin >> t; while (t -- ) { cout << \"Case #\" << i << \": \" ; solve(); ++ i; } }","title":"Binary search"},{"location":"Google%20Kick%20Start/2020---round-a/#bundling","text":"Pip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example: The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is 'RA'). The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is 'FIRE'). The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ''). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. Input The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip's strings. Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. Limits Time limit: 20 seconds per test set. Memory limit: 1GB. 1 \u2264 T \u2264 100. 2 \u2264 N \u2264 105. 2 \u2264 K \u2264 N. K divides N. Each of Pip's strings contain at least one character. Each string consists only of letters from A to Z. Test set 1 Each of Pip's strings contain at most 5 characters. Test set 2 The total number of characters in Pip's strings across all test cases is at most 2 \u00d7 106. Samples Input 1 2 2 2 KICK START 8 2 G G GO GO GOO GOO GOOO GOOO Output 1 Case #1: 0 Case #2: 10 Input 2 1 6 3 RAINBOW FIREBALL RANK RANDOM FIREWALL FIREFIGHTER Output 2 Case #1: 6 Sample #1 In Case #1, Pip can achieve a total score of 0 by make the groups: {KICK, START}, with a score of 0. In Case #2, Pip can achieve a total score of 10 by make the groups: {G, G}, with a score of 1. {GO, GO}, with a score of 2. {GOO, GOO}, with a score of 3. {GOOO, GOOO}, with a score of 4. Sample #2 In Case #1, Pip can achieve a total score of 6 by make the groups: {RAINBOW, RANK, RANDOM}, with a score of 2. {FIREBALL, FIREWALL, FIREFIGHTER}, with a score of 4.","title":"Bundling"},{"location":"Google%20Kick%20Start/2020---round-a/#analysis_3","text":"Assume each bundle has prefix as P_i P_i , and the CNT_i CNT_i represents the number of strings shares that prefix. Assign k string to the bundle, now we have CNT_i \\% k CNT_i \\% k string left. Do the same thing for preifx P_{i + 1} P_{i + 1} which has a CNT_{i+1} < CNT_i CNT_{i+1} < CNT_i , now we have CNT_{i + 1} \\% k CNT_{i + 1} \\% k left. Keep this procedure until CNT_j \\% k == 0 CNT_j \\% k == 0 which means all the string have assigned to a particular bundle. Now the problem becomes finding the total count. Split into n/k groups, and each group has k strings. Use trie to find the common prefix. Each trie node has 26 children nodes, and one cnt int for counting the number of prefix exist by the current node. Insert: insert into trie and update the cnt for each ending character node. Query: just search from the root of the trie and traverse through the last level of the trie, because all the nodes from root has a count that represent the occurance of word that is ended with node character.","title":"Analysis"},{"location":"Google%20Kick%20Start/2020---round-a/#code_3","text":"#include <bits/stdc++.h> using namespace std; #define endl \"\\n\" #define int long long const int N = 1e5 + 5 ; typedef struct data { data * bit[ 26 ]; int cnt = 0 ; }trie; trie * head; void insert (string & s) { trie * cur = head; for ( auto & it:s) { int b = it - 'A' ; if ( ! cur -> bit[b]) cur -> bit[b] = new trie(); // create new node if not exist cur = cur -> bit[b]; // proceed through next character cur -> cnt ++ ; // end with current character } } int n, k; string s[N]; int query (trie * cur) { if ( ! cur) return 0 ; int ans = (cur -> cnt / k); // there are k words each, so there are k times repeat counts for ( int i = 0 ; i <= 25 ; i ++ ) if (cur -> bit[i]) ans += query(cur -> bit[i]); // proceeds to next level and check the count return ans; } int main () { int t; cin >> t; int tc = 0 ; while (t -- ) { head = new trie(); tc ++ ; cin >> n >> k; for ( int i = 1 ; i <= n; i ++ ) { cin >> s[i]; insert(s[i]); } int ans = query(head); cout << \"Case #\" << tc << \": \" << ans << endl; } return 0 ; }","title":"Code"},{"location":"Interview/balanced-search-trees/","text":"2-3 tree \u00b6 Each node can either have 2 or 3 children (so it's not a binary tree) AND all leaves are at the same level The 2-3 Tree properties must always hold after we are done with the operation, so that the tree remains balanced. Thus, we must ensure that all leaves are at the same level, two-key nodes have three children, one-key nodes have two children, and we can\u2019t have any number other than 1 or 2 keys in one node. Note that each node can have either 1 (with 2 children) value or 2 (with 3 children) values. See illustration: Define a 2-3 tree \u00b6 #ifndef _TRI_NODE #define _TRI_NODE template < class ItemType > class TriNode { private: ItemType smallItem, largeItem; // Data portion TriNode < ItemType >* leftChildPtr; TriNode < ItemType >* midChildPtr; TriNode < ItemType >* rightChildPtr; public: TriNode(); TriNode( const ItemType & anItem); TriNode( const ItemType & anItem, TriNode < ItemType >* leftPtr, TriNode < ItemType >* midPtr, TriNode < ItemType >* rightPtr); bool isLeaf () const ; bool isTwoNode () const ; bool isThreeNode () const ; ItemType getSmallItem () const ; ItemType getLargeItem () const ; void setSamllItem ( const ItemType & anItem); void setLargeItem ( const ItemType & anItem); TriNode < ItemType >* getLeftChildPtr() const ; TriNode < ItemType >* getMidChildPtr() const ; TriNode < ItemType >* getRightChildPtr() const ; void setLeftChildPtr (TriNode < ItemType >* leftPtr); void setMidChildPtr (TriNode < ItemType >* midPtr); void setRightChildPtr (TriNode < ItemType >* rightPtr); }; // end TriNode #include \"TriNode\" #endif Insertion \u00b6 check if the place to be inserted is single node, if yes, make it to two nodes if it is already two nodes, promote the middle node to its parent if parent is full, recursively promote to its parent again if current node after promote (will always create an additional node for current parent) has more than the nodes it could have on the current level, split the root into two parts: left and right, and the mid will be promoted to its parent again. psuedo code Insert 39: Insert 38: Deletion \u00b6 psuedo code Traverse \u00b6 // Traverses a nonempty 2-3 tree in sorted order. inorder( 23 Tree: TwoThreeTree) : void if ( 23 Tree \u2019 s root node r is a leaf) Visit the data item(s) else if (r has two data items) { inorder(left subtree of 23 Tree \u2019 s root) Visit the first data item inorder(middle subtree of 23 Tree \u2019 s root) Visit the second data item inorder(right subtree of 23 Tree \u2019 s root) } else // r has one data item { inorder(left subtree of 23 Tree \u2019 s root) Visit the data item inorder(right subtree of 23 Tree \u2019 s root) }","title":"Balanced search trees"},{"location":"Interview/balanced-search-trees/#2-3-tree","text":"Each node can either have 2 or 3 children (so it's not a binary tree) AND all leaves are at the same level The 2-3 Tree properties must always hold after we are done with the operation, so that the tree remains balanced. Thus, we must ensure that all leaves are at the same level, two-key nodes have three children, one-key nodes have two children, and we can\u2019t have any number other than 1 or 2 keys in one node. Note that each node can have either 1 (with 2 children) value or 2 (with 3 children) values. See illustration:","title":"2-3 tree"},{"location":"Interview/balanced-search-trees/#define-a-2-3-tree","text":"#ifndef _TRI_NODE #define _TRI_NODE template < class ItemType > class TriNode { private: ItemType smallItem, largeItem; // Data portion TriNode < ItemType >* leftChildPtr; TriNode < ItemType >* midChildPtr; TriNode < ItemType >* rightChildPtr; public: TriNode(); TriNode( const ItemType & anItem); TriNode( const ItemType & anItem, TriNode < ItemType >* leftPtr, TriNode < ItemType >* midPtr, TriNode < ItemType >* rightPtr); bool isLeaf () const ; bool isTwoNode () const ; bool isThreeNode () const ; ItemType getSmallItem () const ; ItemType getLargeItem () const ; void setSamllItem ( const ItemType & anItem); void setLargeItem ( const ItemType & anItem); TriNode < ItemType >* getLeftChildPtr() const ; TriNode < ItemType >* getMidChildPtr() const ; TriNode < ItemType >* getRightChildPtr() const ; void setLeftChildPtr (TriNode < ItemType >* leftPtr); void setMidChildPtr (TriNode < ItemType >* midPtr); void setRightChildPtr (TriNode < ItemType >* rightPtr); }; // end TriNode #include \"TriNode\" #endif","title":"Define a 2-3 tree"},{"location":"Interview/balanced-search-trees/#insertion","text":"check if the place to be inserted is single node, if yes, make it to two nodes if it is already two nodes, promote the middle node to its parent if parent is full, recursively promote to its parent again if current node after promote (will always create an additional node for current parent) has more than the nodes it could have on the current level, split the root into two parts: left and right, and the mid will be promoted to its parent again. psuedo code Insert 39: Insert 38:","title":"Insertion"},{"location":"Interview/balanced-search-trees/#deletion","text":"psuedo code","title":"Deletion"},{"location":"Interview/balanced-search-trees/#traverse","text":"// Traverses a nonempty 2-3 tree in sorted order. inorder( 23 Tree: TwoThreeTree) : void if ( 23 Tree \u2019 s root node r is a leaf) Visit the data item(s) else if (r has two data items) { inorder(left subtree of 23 Tree \u2019 s root) Visit the first data item inorder(middle subtree of 23 Tree \u2019 s root) Visit the second data item inorder(right subtree of 23 Tree \u2019 s root) } else // r has one data item { inorder(left subtree of 23 Tree \u2019 s root) Visit the data item inorder(right subtree of 23 Tree \u2019 s root) }","title":"Traverse"},{"location":"Interview/behavior-questions/","text":"Rule of thumb \u00b6 Don't confront your interviewers How to talk when you have nothing to say, say nothing never criticize your previous employers calm and reasonable Say something for a reason Praise someone Criticie someone (how?) CART: clarify, assumption, result, test cases Q1: tell me about yourself \u00b6 Don't just say yourself Name, edu Skills: primary programming language, projects, experiences, past internship. Thank you Other variants: - tell me your weakness (e.g. weakness: cannot do multiple things at the same time. in the future, learn how to prioritize and analyze dependencies.) - 2 nd chance problems - Retrospection - E.g. Biggest failure during your college/work - Key points: how to avoid/address the same problems in the future. Q2: when you have different opinions from your colleagues \u00b6 Scenarios Communication how when where keep in mind: say something for a reason, praise and criticize someone what if? backup solutions how to express yourself? (e.g. how to do prep for meetings, 1 on 1?) e.g. we might have difference knowledge base, so I will try to share our knowledge together. focus on things but not on people Q3: When you have limited time avaliable to finish your project. Quality vs. Speed \u00b6 consider tradeoffs for different tasks, use a quantative way to analyze the data variant 1: provide an e.g. scenario in which you made a quick decision under pressure variant 2: write an email to your manager on how to explain why you missed the deadline Q4: what is your career plan for the next 5 years \u00b6 show self-motivation, start from small/short term goal to big/long term goal. Q5: please tell me one of the most challenging projects you have accomplished \u00b6 technical challenge + human resource (team work, work with mentor, verify tasks, etc.) variant: mistake you have done first tell what you ahfve done wrong Q6: do you have any questions for me \u00b6 tech stack, I may have some similar skills what's your most challenge project Others \u00b6 1, \u5f00\u4f1a\u4e4b\u524d\uff0c\u4e00\u5b9a\u51c6\u5907\u597d 2\uff0c\u4e00\u5b9a\u8981\u7cfb\u7edf\u6027\u7684\u601d\u8003\uff0cconstruction way thinking 3\uff0c\u628a\u505a\u4e8b\u50cf\u7f16\u7a0b\u4e00\u6837\u89c4\u5212 4\uff0c\u5343\u4e07\u4e0d\u8981\u548c\u9762\u8bd5\u5b98\u603c\uff0c\u6709\u53ef\u80fd\u662f\u538b\u529b\u6d4b\u8bd5\uff01\uff01 5\uff0c*** \u5f53\u6ca1\u6709\u4efb\u4f55nice\u7684\u8bdd\u53bb\u8bf4\u7684\u65f6\u5019\uff0c\u9009\u62e9\u4e0d\u8981\u8bf4 6\uff0c\u4ecb\u7ecd\u81ea\u5df1\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u53ea\u8bf4\u81ea\u5df1\uff0c\u6709\u4e0d\u5c11\u5751\uff01\uff01\uff081\uff09\u540d\u5b57\uff0c\u548c\u6559\u80b2\u80cc\u666f 2\uff09\u4ecb\u7ecd\u4e3b\u8981\u7684\u6280\u80fd\u80cc\u666f 3\uff09Thank you\uff09 7\uff0c\u4ecb\u7ecd\u5f31\u70b9\uff1f 8\uff0c \u89c2\u70b9\u4e0d\u540c\uff1f\u5148\u542c\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u540c\uff0c\u7136\u540e\u5bf9\u6bd4\u4e0d\u540c\uff0c\u7136\u540e\u518d\u5206\u6790\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u4e00\u5b9a\u4e0d\u80fd\u4e00\u5f00\u59cb\u5c31\u7ed9\u51fa\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u8fd9\u6837\u592a\u5bf9\u7acb\u4e86\uff01\uff01 9\uff0c\u6279\u8bc4\u4e00\u4ef6\u4e8b\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u6279\u8bc4\u8fd9\u4ef6\u4e8b\uff0c\u8868\u626c\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u8868\u626c\u8fd9\u4e2a\u4eba\uff08\u6279\u8bc4\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u7ed9\u4eba\u7559\u9762\u5b50\uff01\uff0910 \uff0c \u4efb\u4f55\u4e8b\u60c5\u90fd\u6709trade off\uff0c\u8981\u91cf\u5316\u5206\u6790 11\uff0c\u63a5\u4e0b\u67655\u5e74\u7684\u5de5\u4f5c\u8ba1\u5212\uff1f\u4e00\u5b9a\u8981\u4f53\u73b0\u51faself motivated 12\uff0cmost challenging \uff1f 13\uff0c\u5f53\u53d1\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u8bda\u6073\u7684\u544a\u8bc9\u9762\u8bd5\u5b98\uff0c\u54ea\u91cc\u9519\uff0c\u54ea\u91cc\u5bf9\uff01\uff01 14\uff0cmanager\u5347\u4ec0\u4e48\u6837\u7684\u4eba\uff1f\u628a\u6700\u91cd\u8981\u7684\u5de5\u4f5c\u7ed9\u8c01\uff0c\u8c01\u5c31\u4f1a\u5347\u804c 15\uff0c\u597d\u7684reputation\u662f\u4e00\u6b21\u6b21\u6210\u529f\u79ef\u7d2f\u8d77\u6765\u7684\uff01\uff01 16\uff0c\u5f53\u5728stressful situation\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u5411\u7740\u81ea\u5df1\u4ef7\u503c\u89c2\u7684\u65b9\u5411 17\uff0c\u9ad8\u5c14\u592b\u7403\u95ee\u9898\uff1fC\uff1a\u5728\u54ea\u513f\uff0c\u5c3a\u5bf8 A\uff1a\u7cbe\u5ea6\u8981\u6c42 R\uff1a\u5982\u4f55\u89e3\u51b3 T\uff1a\u600e\u4e48\u53bb\u9a8c\u8bc1 18\uff0c\u7528\u529b\uff0c\u7528\u8111\uff0c\u7528\u5fc3 19\uff0c work with smart people\uff0charderrrrrr\uff08\u673a\u4f1a\u4e0d\u80fd\u63a7\u5236\uff0c\u4f46\u662f\u52aa\u529b\u53ef\u4ee5\uff01\uff0920\uff0c\u4e00\u5b9a\u8981\u5bf9\u5f97\u8d77\u522b\u4eba\u7684\u4fe1\u4efb ***** 21\uff0c\u300a\u6052\u5fc3\u300b22\uff0c\u56f0\u96be\u7684\u65f6\u5019\u6709\u591a\u4eba\u613f\u610f\u5e2e\u52a9\u4f60\uff0c\u505a\u4e8b\u7684\u65f6\u5019\uff0c\u6709\u591a\u5c11\u4eba\u8ffd\u968f\u4f60 23\uff0cleadership\u7684\u5206\u91cf\u5f88\u91cd\uff0c\u7528reputation\u53bb\u5efa\u7acb*** 24\uff0c\u62a2\u7740\u4e70\u5355\uff0c\u4e5f\u633a\u597d\u768425\uff0c\u5343\u4e07\u4e0d\u8981\u635f\u574f\u522b\u4eba\u7684\u6838\u5fc3\u5229\u76ca\uff0126\uff0c\u4e00\u5b9a\u8981\u63d0\u4f9b\u5efa\u8bbe\u6027\u610f\u89c1\uff0c\u8fd9\u6837\u80fd\u5e2e\u522b\u4eba\u53d8\u5f97\u66f4\u597d 27\uff0c1day\uff1a\u611f\u8c22\u4fe1 1week\uff1a\u8d8a\u4e00\u4e2a\u4f1a\uff0c\u8ba8\u8bba\u4e00\u4e0b\u81ea\u5df1\u7684\u90e8\u5206 1month\uff1a\u5c3d\u91cf\u62a5\u559c\uff0c\u8bf4\u81ea\u5df1\u7684\u6210\u7ee9\uff0c\u76ee\u6807 1year\uff1a\u4e70\u4e00\u4e2a\u7cbe\u7f8e\u7684thanks card\uff0c\u63d0\u51fa\u5347\u804c\u7684\u8bc9\u6c42 28\uff0c\u4ec0\u4e48\u95ee\u9898\u662f\u597d\u95ee\u9898\uff1f29\uff0c***\u4e00\u5b9a\u8981\u627e\u7684mentor\uff08\u7ed9\u81ea\u5df1\u5efa\u8bbe\u6027\u610f\u89c1\u7684\u4eba\uff0930\uff0c\u53cd\u601d\uff0c\u8ba1\u5212\uff0c\u884c\u52a8 31\uff0cBetter Person","title":"Behavior questions"},{"location":"Interview/behavior-questions/#rule-of-thumb","text":"Don't confront your interviewers How to talk when you have nothing to say, say nothing never criticize your previous employers calm and reasonable Say something for a reason Praise someone Criticie someone (how?) CART: clarify, assumption, result, test cases","title":"Rule of thumb"},{"location":"Interview/behavior-questions/#q1-tell-me-about-yourself","text":"Don't just say yourself Name, edu Skills: primary programming language, projects, experiences, past internship. Thank you Other variants: - tell me your weakness (e.g. weakness: cannot do multiple things at the same time. in the future, learn how to prioritize and analyze dependencies.) - 2 nd chance problems - Retrospection - E.g. Biggest failure during your college/work - Key points: how to avoid/address the same problems in the future.","title":"Q1: tell me about yourself"},{"location":"Interview/behavior-questions/#q2-when-you-have-different-opinions-from-your-colleagues","text":"Scenarios Communication how when where keep in mind: say something for a reason, praise and criticize someone what if? backup solutions how to express yourself? (e.g. how to do prep for meetings, 1 on 1?) e.g. we might have difference knowledge base, so I will try to share our knowledge together. focus on things but not on people","title":"Q2: when you have different opinions from your colleagues"},{"location":"Interview/behavior-questions/#q3-when-you-have-limited-time-avaliable-to-finish-your-project-quality-vs-speed","text":"consider tradeoffs for different tasks, use a quantative way to analyze the data variant 1: provide an e.g. scenario in which you made a quick decision under pressure variant 2: write an email to your manager on how to explain why you missed the deadline","title":"Q3: When you have limited time avaliable to finish your project. Quality vs. Speed"},{"location":"Interview/behavior-questions/#q4-what-is-your-career-plan-for-the-next-5-years","text":"show self-motivation, start from small/short term goal to big/long term goal.","title":"Q4: what is your career plan for the next 5 years"},{"location":"Interview/behavior-questions/#q5-please-tell-me-one-of-the-most-challenging-projects-you-have-accomplished","text":"technical challenge + human resource (team work, work with mentor, verify tasks, etc.) variant: mistake you have done first tell what you ahfve done wrong","title":"Q5: please tell me one of the most challenging projects you have accomplished"},{"location":"Interview/behavior-questions/#q6-do-you-have-any-questions-for-me","text":"tech stack, I may have some similar skills what's your most challenge project","title":"Q6: do you have any questions for me"},{"location":"Interview/behavior-questions/#others","text":"1, \u5f00\u4f1a\u4e4b\u524d\uff0c\u4e00\u5b9a\u51c6\u5907\u597d 2\uff0c\u4e00\u5b9a\u8981\u7cfb\u7edf\u6027\u7684\u601d\u8003\uff0cconstruction way thinking 3\uff0c\u628a\u505a\u4e8b\u50cf\u7f16\u7a0b\u4e00\u6837\u89c4\u5212 4\uff0c\u5343\u4e07\u4e0d\u8981\u548c\u9762\u8bd5\u5b98\u603c\uff0c\u6709\u53ef\u80fd\u662f\u538b\u529b\u6d4b\u8bd5\uff01\uff01 5\uff0c*** \u5f53\u6ca1\u6709\u4efb\u4f55nice\u7684\u8bdd\u53bb\u8bf4\u7684\u65f6\u5019\uff0c\u9009\u62e9\u4e0d\u8981\u8bf4 6\uff0c\u4ecb\u7ecd\u81ea\u5df1\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u53ea\u8bf4\u81ea\u5df1\uff0c\u6709\u4e0d\u5c11\u5751\uff01\uff01\uff081\uff09\u540d\u5b57\uff0c\u548c\u6559\u80b2\u80cc\u666f 2\uff09\u4ecb\u7ecd\u4e3b\u8981\u7684\u6280\u80fd\u80cc\u666f 3\uff09Thank you\uff09 7\uff0c\u4ecb\u7ecd\u5f31\u70b9\uff1f 8\uff0c \u89c2\u70b9\u4e0d\u540c\uff1f\u5148\u542c\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u540c\uff0c\u7136\u540e\u5bf9\u6bd4\u4e0d\u540c\uff0c\u7136\u540e\u518d\u5206\u6790\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u4e00\u5b9a\u4e0d\u80fd\u4e00\u5f00\u59cb\u5c31\u7ed9\u51fa\u81ea\u5df1\u7684\u89c2\u70b9\uff0c\u8fd9\u6837\u592a\u5bf9\u7acb\u4e86\uff01\uff01 9\uff0c\u6279\u8bc4\u4e00\u4ef6\u4e8b\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u6279\u8bc4\u8fd9\u4ef6\u4e8b\uff0c\u8868\u626c\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u8868\u626c\u8fd9\u4e2a\u4eba\uff08\u6279\u8bc4\u4eba\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u7ed9\u4eba\u7559\u9762\u5b50\uff01\uff0910 \uff0c \u4efb\u4f55\u4e8b\u60c5\u90fd\u6709trade off\uff0c\u8981\u91cf\u5316\u5206\u6790 11\uff0c\u63a5\u4e0b\u67655\u5e74\u7684\u5de5\u4f5c\u8ba1\u5212\uff1f\u4e00\u5b9a\u8981\u4f53\u73b0\u51faself motivated 12\uff0cmost challenging \uff1f 13\uff0c\u5f53\u53d1\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u8bda\u6073\u7684\u544a\u8bc9\u9762\u8bd5\u5b98\uff0c\u54ea\u91cc\u9519\uff0c\u54ea\u91cc\u5bf9\uff01\uff01 14\uff0cmanager\u5347\u4ec0\u4e48\u6837\u7684\u4eba\uff1f\u628a\u6700\u91cd\u8981\u7684\u5de5\u4f5c\u7ed9\u8c01\uff0c\u8c01\u5c31\u4f1a\u5347\u804c 15\uff0c\u597d\u7684reputation\u662f\u4e00\u6b21\u6b21\u6210\u529f\u79ef\u7d2f\u8d77\u6765\u7684\uff01\uff01 16\uff0c\u5f53\u5728stressful situation\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u8981\u5411\u7740\u81ea\u5df1\u4ef7\u503c\u89c2\u7684\u65b9\u5411 17\uff0c\u9ad8\u5c14\u592b\u7403\u95ee\u9898\uff1fC\uff1a\u5728\u54ea\u513f\uff0c\u5c3a\u5bf8 A\uff1a\u7cbe\u5ea6\u8981\u6c42 R\uff1a\u5982\u4f55\u89e3\u51b3 T\uff1a\u600e\u4e48\u53bb\u9a8c\u8bc1 18\uff0c\u7528\u529b\uff0c\u7528\u8111\uff0c\u7528\u5fc3 19\uff0c work with smart people\uff0charderrrrrr\uff08\u673a\u4f1a\u4e0d\u80fd\u63a7\u5236\uff0c\u4f46\u662f\u52aa\u529b\u53ef\u4ee5\uff01\uff0920\uff0c\u4e00\u5b9a\u8981\u5bf9\u5f97\u8d77\u522b\u4eba\u7684\u4fe1\u4efb ***** 21\uff0c\u300a\u6052\u5fc3\u300b22\uff0c\u56f0\u96be\u7684\u65f6\u5019\u6709\u591a\u4eba\u613f\u610f\u5e2e\u52a9\u4f60\uff0c\u505a\u4e8b\u7684\u65f6\u5019\uff0c\u6709\u591a\u5c11\u4eba\u8ffd\u968f\u4f60 23\uff0cleadership\u7684\u5206\u91cf\u5f88\u91cd\uff0c\u7528reputation\u53bb\u5efa\u7acb*** 24\uff0c\u62a2\u7740\u4e70\u5355\uff0c\u4e5f\u633a\u597d\u768425\uff0c\u5343\u4e07\u4e0d\u8981\u635f\u574f\u522b\u4eba\u7684\u6838\u5fc3\u5229\u76ca\uff0126\uff0c\u4e00\u5b9a\u8981\u63d0\u4f9b\u5efa\u8bbe\u6027\u610f\u89c1\uff0c\u8fd9\u6837\u80fd\u5e2e\u522b\u4eba\u53d8\u5f97\u66f4\u597d 27\uff0c1day\uff1a\u611f\u8c22\u4fe1 1week\uff1a\u8d8a\u4e00\u4e2a\u4f1a\uff0c\u8ba8\u8bba\u4e00\u4e0b\u81ea\u5df1\u7684\u90e8\u5206 1month\uff1a\u5c3d\u91cf\u62a5\u559c\uff0c\u8bf4\u81ea\u5df1\u7684\u6210\u7ee9\uff0c\u76ee\u6807 1year\uff1a\u4e70\u4e00\u4e2a\u7cbe\u7f8e\u7684thanks card\uff0c\u63d0\u51fa\u5347\u804c\u7684\u8bc9\u6c42 28\uff0c\u4ec0\u4e48\u95ee\u9898\u662f\u597d\u95ee\u9898\uff1f29\uff0c***\u4e00\u5b9a\u8981\u627e\u7684mentor\uff08\u7ed9\u81ea\u5df1\u5efa\u8bbe\u6027\u610f\u89c1\u7684\u4eba\uff0930\uff0c\u53cd\u601d\uff0c\u8ba1\u5212\uff0c\u884c\u52a8 31\uff0cBetter Person","title":"Others"},{"location":"Interview/binary-search/","text":"Binary Search \u00b6 2 Principles: 1. Guarantee that the search space decreases over time (after each iteration). // prevent while \"true\" 2. Guarantee that the target (if exist) cannot be ruled out accidentally, when we change the value of Left or Right. while (l <= r): 1 element can get in while (l < r): 1 element cannot get in l = l + 1: eleminate l for next iteration l = l: check if 1 element will cause inf Classic Binary Search \u00b6 int binarySearch (vector < int >& a, int target) { int left = 0 , right = a.size() - 1 ; while (left <= right) { // <= int mid = left + right >> 1 ; if (a[mid] == target) return mid; else if (a[mid] < target) left = mid + 1 ; else right = mid - 1 ; } return - 1 ; } 2D Space Binary Search \u00b6 1 3 4 6 7 9 10 11 14 17 19 20 target = 11 index = col * row - 1 col = index / size of col row = index % size of col int l = 0 , r = col * row - 1 ; while (l <= r) { int m = (l + r) >> 1 ; int x = m / col, y = m % col; if (a[x][y] == target) return true; else if (a[x][y] < target) l = m + 1 ; else r = m - 1 ; } return false; Closest Element to Target \u00b6 target == 4 [1,2,3,8,9] -> return 3's index which is 2 while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { return m; } else if (a[m] < target) { l = m; } else { r = m; } } if (target - a[l] < a[r] - target) // return the one that is close to target, because there are two elements return l; else return r; First target \u00b6 target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { r = m; // r = m - 1 -> wrong } else if (a[m] < target) { l = m; // l = m + 1 -> right } else { r = m; // r = m - 1 -> right } } if (target == a[l]) // return the left that is equal to target, because it goes from left to right return l; if (target == a[r]) return r; else return - 1 ; Last target (variant for previous one) \u00b6 target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { l = m; // now change to l } else if (a[m] < target) { l = m; } else { r = m; } } if (target == a[r]) // return the right that is equal to target, because it goes from right to left return l; if (target == a[l]) return r; else return - 1 ; Closest k Elements \u00b6 how to return the index of k elements that are closest elements to the target k = 3, target = 5, a = [1,2,3,8,9] return 2,3,8 Solution 1: 1. run binary search to find L and R, where L is the largest value that is smaller than target 2. if l is close to target, l--; else r++ Complexity: O(log(n) + k), what if k \\approx \\approx n? Complexity will be O(n) int largestSmallerEqual (vector < int > arr, int target) { int left = 0 , right = arr.size() - 1 ; while (left < right - 1 ) { int mid = left + right >> 1 ; if (arr[mid] <= target) { left = mid; } else { right = mid; } } if (arr[right] <= target) return right; if (arr[left] <= target) return left; return - 1 ; } vector < int > kClosest(vector < int > arr, int target, int k) { int left = largestSmallerEqual(arr, target); int right = left + 1 ; vector < int > res(k); for ( int i = 0 ; i < k; ++ i) { if (right >= arr.size() || left >= 0 && target - arr[left] <= arr[right] - target) { res[i] = arr[left -- ]; } else { res[i] = arr[right ++ ]; } } return res; } Solution 2: 1. binary search to find L and R 2. using offset to form two more arrays: leftArray = {3 2 1} rightArray = {4 5} then use the method introduced later to find the median. Don't need to preprocess the offset beforehand, but just to update when visited. Solution 3: Moving the sliding window to get the least sum diff. To get the minimal, it has to be the mid point of the sliding window. case 1: x - A[mid] < A[mid + k] - x, need to move window go left -------x----A[mid]-----------------A[mid + k]---------- case 2: x - A[mid] < A[mid + k] - x, need to move window go left again -------A[mid]----x-----------------A[mid + k]---------- case 3: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]------------------x---A[mid + k]---------- case 4: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]---------------------A[mid + k]----x------ vector < int > kClosest(vector < int > a, int x, int k) { int n = a.size(); int l = 0 , r = n - k; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (x - a[m] > a[m + k] - x) l = m + 1 ; else r = m; } auto res = vector < int > (a.begin() + l, a.begin() + l + k ); // this sort is unecessary if there is no requirement for what order to be returned // sort(res.begin(), res.end(), [&](const int l, const int r) { // return abs(l - x) < abs(r - x); // }); return res; } Smallest element that is greater than target \u00b6 sss eee bbb -> same as first target, because we want to find the first b case 1: if input[m] < target: l = m + 1 // l = m also work case 2: if input[m] == target: l = m + 1 // l = m also work case 3: if input[m] > target: r = m // r = m - 1 is wrong, becasue it will wipe out the first b while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] > target) { r = m; } else if (a[m] <= target) { // or just else l = m; } } if (a[l] > target) return l; if (a[r] < target) return r; return - 1 ; Kth smallest in two sorted arrays \u00b6 how to find the median how to find k-th smallest element from them A[] = {2,5,7,10,13} B[] = {1,3,4,13,20,29} k = 5 output = 5 solution 1: two pointer, i++ if a[i] < b[j] else j++, stop until k steps -> O(k) solution 2: binary search Binary Search with Unknown Size \u00b6 dict = {1 3 5 6 .... 1000000}, target = 9999 Assumption: - No dict.size() - if dict.get(index) == null, then we know the size of dict is < index. solution 1: 1. keep jumping out with size = size * 2. until dict.get(index) == null 2. do binary search from 0 to current size Followup: Why not size = size * 10? Which one is better? Don't say an answer (if you don't know yet), but say let's analyze together.","title":"Binary search"},{"location":"Interview/binary-search/#binary-search","text":"2 Principles: 1. Guarantee that the search space decreases over time (after each iteration). // prevent while \"true\" 2. Guarantee that the target (if exist) cannot be ruled out accidentally, when we change the value of Left or Right. while (l <= r): 1 element can get in while (l < r): 1 element cannot get in l = l + 1: eleminate l for next iteration l = l: check if 1 element will cause inf","title":"Binary Search"},{"location":"Interview/binary-search/#classic-binary-search","text":"int binarySearch (vector < int >& a, int target) { int left = 0 , right = a.size() - 1 ; while (left <= right) { // <= int mid = left + right >> 1 ; if (a[mid] == target) return mid; else if (a[mid] < target) left = mid + 1 ; else right = mid - 1 ; } return - 1 ; }","title":"Classic Binary Search"},{"location":"Interview/binary-search/#2d-space-binary-search","text":"1 3 4 6 7 9 10 11 14 17 19 20 target = 11 index = col * row - 1 col = index / size of col row = index % size of col int l = 0 , r = col * row - 1 ; while (l <= r) { int m = (l + r) >> 1 ; int x = m / col, y = m % col; if (a[x][y] == target) return true; else if (a[x][y] < target) l = m + 1 ; else r = m - 1 ; } return false;","title":"2D Space Binary Search"},{"location":"Interview/binary-search/#closest-element-to-target","text":"target == 4 [1,2,3,8,9] -> return 3's index which is 2 while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { return m; } else if (a[m] < target) { l = m; } else { r = m; } } if (target - a[l] < a[r] - target) // return the one that is close to target, because there are two elements return l; else return r;","title":"Closest Element to Target"},{"location":"Interview/binary-search/#first-target","text":"target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { r = m; // r = m - 1 -> wrong } else if (a[m] < target) { l = m; // l = m + 1 -> right } else { r = m; // r = m - 1 -> right } } if (target == a[l]) // return the left that is equal to target, because it goes from left to right return l; if (target == a[r]) return r; else return - 1 ;","title":"First target"},{"location":"Interview/binary-search/#last-target-variant-for-previous-one","text":"target = 5 [4,5,5,5,5,5] -> return 1 (first occurance of 5 index) while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] == target) { l = m; // now change to l } else if (a[m] < target) { l = m; } else { r = m; } } if (target == a[r]) // return the right that is equal to target, because it goes from right to left return l; if (target == a[l]) return r; else return - 1 ;","title":"Last target (variant for previous one)"},{"location":"Interview/binary-search/#closest-k-elements","text":"how to return the index of k elements that are closest elements to the target k = 3, target = 5, a = [1,2,3,8,9] return 2,3,8 Solution 1: 1. run binary search to find L and R, where L is the largest value that is smaller than target 2. if l is close to target, l--; else r++ Complexity: O(log(n) + k), what if k \\approx \\approx n? Complexity will be O(n) int largestSmallerEqual (vector < int > arr, int target) { int left = 0 , right = arr.size() - 1 ; while (left < right - 1 ) { int mid = left + right >> 1 ; if (arr[mid] <= target) { left = mid; } else { right = mid; } } if (arr[right] <= target) return right; if (arr[left] <= target) return left; return - 1 ; } vector < int > kClosest(vector < int > arr, int target, int k) { int left = largestSmallerEqual(arr, target); int right = left + 1 ; vector < int > res(k); for ( int i = 0 ; i < k; ++ i) { if (right >= arr.size() || left >= 0 && target - arr[left] <= arr[right] - target) { res[i] = arr[left -- ]; } else { res[i] = arr[right ++ ]; } } return res; } Solution 2: 1. binary search to find L and R 2. using offset to form two more arrays: leftArray = {3 2 1} rightArray = {4 5} then use the method introduced later to find the median. Don't need to preprocess the offset beforehand, but just to update when visited. Solution 3: Moving the sliding window to get the least sum diff. To get the minimal, it has to be the mid point of the sliding window. case 1: x - A[mid] < A[mid + k] - x, need to move window go left -------x----A[mid]-----------------A[mid + k]---------- case 2: x - A[mid] < A[mid + k] - x, need to move window go left again -------A[mid]----x-----------------A[mid + k]---------- case 3: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]------------------x---A[mid + k]---------- case 4: x - A[mid] > A[mid + k] - x, need to move window go right -------A[mid]---------------------A[mid + k]----x------ vector < int > kClosest(vector < int > a, int x, int k) { int n = a.size(); int l = 0 , r = n - k; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (x - a[m] > a[m + k] - x) l = m + 1 ; else r = m; } auto res = vector < int > (a.begin() + l, a.begin() + l + k ); // this sort is unecessary if there is no requirement for what order to be returned // sort(res.begin(), res.end(), [&](const int l, const int r) { // return abs(l - x) < abs(r - x); // }); return res; }","title":"Closest k Elements"},{"location":"Interview/binary-search/#smallest-element-that-is-greater-than-target","text":"sss eee bbb -> same as first target, because we want to find the first b case 1: if input[m] < target: l = m + 1 // l = m also work case 2: if input[m] == target: l = m + 1 // l = m also work case 3: if input[m] > target: r = m // r = m - 1 is wrong, becasue it will wipe out the first b while (l < r - 1 ) { // only two (or one) element left [l, l+1] or [l] int m = l + (r - l) / 2 ; if (a[m] > target) { r = m; } else if (a[m] <= target) { // or just else l = m; } } if (a[l] > target) return l; if (a[r] < target) return r; return - 1 ;","title":"Smallest element that is greater than target"},{"location":"Interview/binary-search/#kth-smallest-in-two-sorted-arrays","text":"how to find the median how to find k-th smallest element from them A[] = {2,5,7,10,13} B[] = {1,3,4,13,20,29} k = 5 output = 5 solution 1: two pointer, i++ if a[i] < b[j] else j++, stop until k steps -> O(k) solution 2: binary search","title":"Kth smallest in two sorted arrays"},{"location":"Interview/binary-search/#binary-search-with-unknown-size","text":"dict = {1 3 5 6 .... 1000000}, target = 9999 Assumption: - No dict.size() - if dict.get(index) == null, then we know the size of dict is < index. solution 1: 1. keep jumping out with size = size * 2. until dict.get(index) == null 2. do binary search from 0 to current size Followup: Why not size = size * 10? Which one is better? Don't say an answer (if you don't know yet), but say let's analyze together.","title":"Binary Search with Unknown Size"},{"location":"Interview/choose-k-cards-and-find-the-maximum/","text":"There are two players playing alternatively, and there is a deck of cards. Each player can pick 1~3 cards from the top of the deck. Find the maximum card value that player one get. e.g. [8,1,1,1,1] -> p1 pick 1, p2 picks 1,1,1. finally p1 pick 8 which is the highest point it can get. DP[i] = max(sum( 0 , i) - DP[i - 1 ], sum( 0 , i) - DP[i - 2 ], sum( 0 , i) - DP[i - 3 ]) = sum( 0 , i) - min(DP[i - 1 ], DP[i - 2 ], DP[i - 3 ])","title":"Choose k cards and find the maximum"},{"location":"Interview/count-array---count-inversion-of-an-array/","text":"How to make the Time Complexity into O(n * log n) Analysis \u00b6 B[i] represents number of element in A[i-j] that is less than B[i] \u4f7f\u7528\u8c01\u5c0f\u79fb\u8c01: Code \u00b6","title":"Count array   count inversion of an array"},{"location":"Interview/count-array---count-inversion-of-an-array/#analysis","text":"B[i] represents number of element in A[i-j] that is less than B[i] \u4f7f\u7528\u8c01\u5c0f\u79fb\u8c01:","title":"Analysis"},{"location":"Interview/count-array---count-inversion-of-an-array/#code","text":"","title":"Code"},{"location":"Interview/design-heap-priority-queue/","text":"Property for a heap (min heap for example) \u00b6 Complete Tree root = i => left = i * 2 + 1, right = i * 2 + 2 left/right = i => root = (i - 1) / 2 the transferred array (0-based) is unique => the transferred tree is unique Any child is greater than its parent (top one/root node is the smallest one) Left and Right child don't have any relationship (not bst) -> cannot search in O(N \\times log(N)) O(N \\times log(N)) Advantage of using an array: root -> children and child -> root or child -> grandfather easily Operations \u00b6 Trickle Up (offer/push) adding new element to the tail while ((i - 1 ) / 2 >= 0 && arr[i] < arr[(i - 1 ) / 2 ]) { swap(arr[i], arr[(i - 1 ) / 2 ]); i = (i - 1 ) / 2 ; } Trickle Down (poll/pop) remove the root of the tree #define (left) (i * 2 + 1) #define (right) (i * 2 + 2) int i = 0 ; while (left < arr.size() && (arr[i] > arr[left] || arr[i] > arr[right])) { int tmp; if (arr[left] < arr[right]) tmp = left; else tmp = right; swap(arr[i], arr[tmp]); i = tmp; } Heap Sort \u00b6 sort the array by regarding the array as a heap: keep \"polling/pop\" and place the biggest/smallest one to the front heapify (trickle down from n to 0): O(n) O(n) n times poll/pop: O(n \\times log(n)) O(n \\times log(n)) However, it's not a preferrable sorting algorithm runtime overhead poor locality (a lot of swap that addresses are not nearby) hard to parallelize/distribute","title":"Design heap priority queue"},{"location":"Interview/design-heap-priority-queue/#property-for-a-heap-min-heap-for-example","text":"Complete Tree root = i => left = i * 2 + 1, right = i * 2 + 2 left/right = i => root = (i - 1) / 2 the transferred array (0-based) is unique => the transferred tree is unique Any child is greater than its parent (top one/root node is the smallest one) Left and Right child don't have any relationship (not bst) -> cannot search in O(N \\times log(N)) O(N \\times log(N)) Advantage of using an array: root -> children and child -> root or child -> grandfather easily","title":"Property for a heap (min heap for example)"},{"location":"Interview/design-heap-priority-queue/#operations","text":"Trickle Up (offer/push) adding new element to the tail while ((i - 1 ) / 2 >= 0 && arr[i] < arr[(i - 1 ) / 2 ]) { swap(arr[i], arr[(i - 1 ) / 2 ]); i = (i - 1 ) / 2 ; } Trickle Down (poll/pop) remove the root of the tree #define (left) (i * 2 + 1) #define (right) (i * 2 + 2) int i = 0 ; while (left < arr.size() && (arr[i] > arr[left] || arr[i] > arr[right])) { int tmp; if (arr[left] < arr[right]) tmp = left; else tmp = right; swap(arr[i], arr[tmp]); i = tmp; }","title":"Operations"},{"location":"Interview/design-heap-priority-queue/#heap-sort","text":"sort the array by regarding the array as a heap: keep \"polling/pop\" and place the biggest/smallest one to the front heapify (trickle down from n to 0): O(n) O(n) n times poll/pop: O(n \\times log(n)) O(n \\times log(n)) However, it's not a preferrable sorting algorithm runtime overhead poor locality (a lot of swap that addresses are not nearby) hard to parallelize/distribute","title":"Heap Sort"},{"location":"Interview/divide-two-integer/","text":"self intro infrastructure engineer in search ml infrastructure, inside tools for testing and developments service owner for search slogan service team search feature - for users and other engineering teams drive the team of search quality - responsible organize and manage the developments and teams - details impact, complexity for what you have done technically!! millions level users and high qps, autoscaling and analysis tech stacks - details Why do you want to change your company? food truck search problem \u6ca1\u542c\u6e05\u695a \u2192 double check What is the biggest bug/mistake you have committed in your work? broken for the owned service details - main service -> microservice, parameters - coordination of the dependency of push process for different time zone - Why - deep analysis What - 3.1 how do you solve the problem - oncall wake up 2AM - push and rollback in time 3.2 what do you learnt and what to do in the future - use the centralized timezone - how do you enforce? What are the actions? - change the whole process, share calendar, ping on slack and calendar, link on other events, mark and account for the completeness - work and cooperate with diverse working environment - proactively communication Literal point 0 insight point 1 - why your interviewer asked this question? Passion to join company? insight point 2 - think about in depth what he wants to know? What can you bring to our company? \u8f6c\u4e13\u4e1a\u7684\u95ee\u4e3a\u5565\u8f6c\u7801\u5e94\u8be5\u600e\u4e48\u56de\u7b54\u2029?? insight point 1 - passion + motivation \u21d2 100 / 3 100 -3-3-3-3-3 \u2026.. 10^10 / 1 Given two int value a and b, find a/b Notice: you can not use \"/\" operation. 4 / 3 = 1 --- 1 4 / 3 = 1 x * 3 = closet number to 4 but smaller than 4 < 0 sign 1 or both > 0 sign 1, -1 Math.abs(a) Math.abs(b) if (a == 0) { return 0; } min = 1, max = dividend mid = (max - min) / 2 + min mid * divisor = number > dividend max = mid; mid * divisor = number < dividend min = mid + 1 until we make min == max min will be the closest we can and smaller than dividend dividend = 4, divsior = 3 min = 1, max = 4 mid = (4 - 1) >> 1 + min = 2; number = 2 * 3 = 6 > 4 max = mid = 2 min = 1, max = 2 mid = 1 number = 1 * 3 = 3 < 4 min = mid + 1 = 2; min = 2, max = 2 we get result as 2 we check 2, 2 * 3 = 6 we will return 2 - 1 = 1 min = mid max = mid - 1 min =1 , max = 4 mid = 2 max = 2 - 1 min = 1, max = 1 public int divide(int dividend, int divisor) { if (divisior == 0) { throw new Exception(\u201cdivisor cannot be 0\u201d); } if (dividend == 0 || dividend < divisor) { return 0; } int min = 1, max = dividend; while (min < max) { // when min equals max, end it int mid = (max - min) >> 1 + min; // get mid value int number = mid * divisor; // calculate possible value if (number == dividend) { // we find it, so we directly return it return mid; } else if (number > dividend) { // it looks max = mid - 1; } else { min = mid; } } return min; } dividend = 10, divisor = 5 min = 1, max = 10 mid = 5 5 * 5 = 25 > 10 min = 1, max = 4 mid = 2 5 * 2 = 10 = 10 return 2 dividend = 4, divisor = 3 dividend = 0 return 0 divisor = 0 throw out of exception 1 / 2 dividend < divisor 0 dividend = 11 divisor = 3 min: 1 max: 11 mid = 6 * 3 = 18 > 11 min: 1 max: 5 mid = 3 * 3 = 9 < 11 min: 3 max: 5 mid = 4 * 3 = 12 > 11 min: 3 max: 3 mid = 3 * 3 = 9 < 11 mi 1 -- dividend log(dividend) O(1) in the worst case, 1 2 ^ 32 ---> 2^31 ---> 10^10 / 10^9 = 10 1 0 1 0 search range - [1, 2^4] min: 1 to max: 10^10 log(a/b) = loga - logb Clarification & Assumptions: b = 0? Why throw an exception in this case? - this is runtime error NullPointerException ArrayIndexOutOfBoundException IlegalArumentException IlegalStateException ArithmeticException (\"divisor can not be 0\") types of a,b - int, overflow? the result will never overflow? MIN_VALUE = -2^31 MAX_VALUE = 2^31 - 1 MIN_VALUE / -1 = ? What is the result type? int positive/negative for a,b? -7 / 4 = -1 or -2 Result: Binary Search Application \u52a8\u624b\u8fc7\u4f8b\u5b50\uff0c---> 1. \u903b\u8f91\u7684\u5173\u952e\u90e8\u5206 \u6574\u7406\u6e05\u695a \u5404\u79cdcase\uff0c\u7269\u7406\u610f\u4e49\uff0c 2. \u89e3\u91ca\u4f60\u7684high level\uff0cdetail\u7684\u903b\u8f91 4 / 3 1 2 3 4 3 6 9 12 min mid max 2*3 =6 min,max high level - \u4e3a\u4ec0\u4e48\u80fd\u7528binary search \u628aBinary Search\u7684\u8981\u70b9\u8bb2\u6e05\u695a 1. search range \u2192 [min, max] 2. search range reduce size each round \u2192 while loop()\u80fd\u8fdb\u5f97\u53bb\u548c\u8df3\u7684\u51fa\u6765 [1, 2] min max mid case 1 max = mid - 1 case 2 min = mid Test cover all possible code branches 10 / 3 = 3","title":"Divide two integer"},{"location":"Interview/dynamic-programming/","text":"what to do when asking a DP question \u00b6 base case induction rule: DP[i] physical meaning find global min/max \u00b6 recusion: DFS -> permute all possible outcomes -> optimal BFS - heap Greedy - need proof DP Q0: largest sum of a subarray \u00b6 {1, 2, 4, -1, -2, 10, 1} => {1, 2, 4, -1, -2, 10} with max sum of 14 Q1: maximal product: cutting rope \u00b6 Given a rope, cut the rope so that the product of total length is max","title":"Dynamic programming"},{"location":"Interview/dynamic-programming/#what-to-do-when-asking-a-dp-question","text":"base case induction rule: DP[i] physical meaning","title":"what to do when asking a DP question"},{"location":"Interview/dynamic-programming/#find-global-minmax","text":"recusion: DFS -> permute all possible outcomes -> optimal BFS - heap Greedy - need proof DP","title":"find global min/max"},{"location":"Interview/dynamic-programming/#q0-largest-sum-of-a-subarray","text":"{1, 2, 4, -1, -2, 10, 1} => {1, 2, 4, -1, -2, 10} with max sum of 14","title":"Q0: largest sum of a subarray"},{"location":"Interview/dynamic-programming/#q1-maximal-product-cutting-rope","text":"Given a rope, cut the rope so that the product of total length is max","title":"Q1: maximal product: cutting rope"},{"location":"Interview/find-longest-substring-at-most-k-characters/","text":"E.G. s=\"ddfaaaabbbca\", k=2 return 7 Verification/Clarification \u00b6 signacture: int olve(string, int) k > 0 and if k > distinct chars size then return string.size() Analysis \u00b6 Use a sliding window to capture all the substring with distinct chars <= k keep current distinct elements keep two pointers left and right move right+1 and update current keep moving left until curr is greater than k now left - right has k distinct elements, so update global count return global length Code \u00b6 #include <bits/stdc++.h> using namespace std; int main () { string s; int k; cin >> k; cin >> s; int res = 0 , curr = 0 ; int cnt[ 26 ]; memset(cnt, 0 , sizeof cnt); int n = s.size(); for ( int i = 0 , j = 0 ; i < n; ++ i) { // j is left, i is right if (cnt[s[i] - 'a' ] ++ == 0 ) curr ++ ; // keep track of the distinct element in [j:i] while (curr > k) { if ( -- cnt[s[j] - 'a' ] == 0 ) curr -- ; ++ j; } res = max(res, i - j + 1 ); } cout << res; return 0 ; } Followup \u00b6 What if is a stream of data? How to decrease space complexity? Manage duplcates:","title":"Find longest substring at most k characters"},{"location":"Interview/find-longest-substring-at-most-k-characters/#verificationclarification","text":"signacture: int olve(string, int) k > 0 and if k > distinct chars size then return string.size()","title":"Verification/Clarification"},{"location":"Interview/find-longest-substring-at-most-k-characters/#analysis","text":"Use a sliding window to capture all the substring with distinct chars <= k keep current distinct elements keep two pointers left and right move right+1 and update current keep moving left until curr is greater than k now left - right has k distinct elements, so update global count return global length","title":"Analysis"},{"location":"Interview/find-longest-substring-at-most-k-characters/#code","text":"#include <bits/stdc++.h> using namespace std; int main () { string s; int k; cin >> k; cin >> s; int res = 0 , curr = 0 ; int cnt[ 26 ]; memset(cnt, 0 , sizeof cnt); int n = s.size(); for ( int i = 0 , j = 0 ; i < n; ++ i) { // j is left, i is right if (cnt[s[i] - 'a' ] ++ == 0 ) curr ++ ; // keep track of the distinct element in [j:i] while (curr > k) { if ( -- cnt[s[j] - 'a' ] == 0 ) curr -- ; ++ j; } res = max(res, i - j + 1 ); } cout << res; return 0 ; }","title":"Code"},{"location":"Interview/find-longest-substring-at-most-k-characters/#followup","text":"What if is a stream of data? How to decrease space complexity? Manage duplcates:","title":"Followup"},{"location":"Interview/find-minimum-in-rotated-sorted-array/","text":"LaiCode 23 \u00b6 Idea \u00b6 Two Situations: 2 4 5 6 0 1: mid (5) > r (1) -> l-mid is sorted and pivot is on the right -> if [right] < [left] then min is not on the l-mid -> search mid+1 - right (mid cannot be the minimum). 6 0 1 2 4 5: mid (1) < r -> right is sorted -> l-mid is what to be searched (minimum is located) -> mid can be the minimum (e.g. 6 7 | 1 2 4 5) // Assume array != null, array.length >= 2 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ r ] ; } strict -> loose 1. left <= right: 1 element can still jump in to the while loop 2. left < right: >= 2 elements 3. left < right - 1: >= 3 elements Two elements left (l < r - 1) \u00b6 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r - 1 ) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ l ] < array [ r ] ? array [ l ] : array [ r ] ; }","title":"Find minimum in rotated sorted array"},{"location":"Interview/find-minimum-in-rotated-sorted-array/#laicode-23","text":"","title":"LaiCode 23"},{"location":"Interview/find-minimum-in-rotated-sorted-array/#idea","text":"Two Situations: 2 4 5 6 0 1: mid (5) > r (1) -> l-mid is sorted and pivot is on the right -> if [right] < [left] then min is not on the l-mid -> search mid+1 - right (mid cannot be the minimum). 6 0 1 2 4 5: mid (1) < r -> right is sorted -> l-mid is what to be searched (minimum is located) -> mid can be the minimum (e.g. 6 7 | 1 2 4 5) // Assume array != null, array.length >= 2 public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ r ] ; } strict -> loose 1. left <= right: 1 element can still jump in to the while loop 2. left < right: >= 2 elements 3. left < right - 1: >= 3 elements","title":"Idea"},{"location":"Interview/find-minimum-in-rotated-sorted-array/#two-elements-left-l-r-1","text":"public static int shiftedMin ( int [] array) { int l = 0 , r = array. length - 1 ; while (l < r - 1 ) { int mid = (l + r) / 2 ; if (array [ mid ] < array [ r ] ) r = mid; else if (array [ mid ] > array [ r ] ) l = mid + 1 ; else r = mid; } return array [ l ] < array [ r ] ? array [ l ] : array [ r ] ; }","title":"Two elements left (l &lt; r - 1)"},{"location":"Interview/graph/","text":"Tree vs Graph \u00b6 Graph can have cycle while tree cannot Graph can be not connected, which tree cannot Analyze Time Complexiy \u00b6 G = V + E V: vertex, E: edge min edge = 0 (not connected) max edge = V^2 V^2 (each vertex can connect to all the other in directed graph) O(N) = O(V^2) O(N) = O(V^2) DFS vs BFS: space less than BFS \u00b6 1.5 Given an input array with integers, how to split the array into k subarray, such that each subarray shares the same sum. e.g. input[N] = {3,-1,4,6,-8,1,1}, and k = 3 output = {3,-1} {4,6,-8} {1,1} with all sum is equal to two 1.6 Given an input array with integers, how to split the array into k subarrays (subarray may NOT be adjacent to each other), such that each subarray shares the same sum E.g. input[N] = { 3 -1,1 1 1 2 2 2 4, 6, -8, 1, 1 }. and k == 3. Output = {3,-1} {4, 6, - 8} {1, 1} which all have a sum that is equal to two.","title":"Graph"},{"location":"Interview/graph/#tree-vs-graph","text":"Graph can have cycle while tree cannot Graph can be not connected, which tree cannot","title":"Tree vs Graph"},{"location":"Interview/graph/#analyze-time-complexiy","text":"G = V + E V: vertex, E: edge min edge = 0 (not connected) max edge = V^2 V^2 (each vertex can connect to all the other in directed graph) O(N) = O(V^2) O(N) = O(V^2)","title":"Analyze Time Complexiy"},{"location":"Interview/graph/#dfs-vs-bfs-space-less-than-bfs","text":"1.5 Given an input array with integers, how to split the array into k subarray, such that each subarray shares the same sum. e.g. input[N] = {3,-1,4,6,-8,1,1}, and k = 3 output = {3,-1} {4,6,-8} {1,1} with all sum is equal to two 1.6 Given an input array with integers, how to split the array into k subarrays (subarray may NOT be adjacent to each other), such that each subarray shares the same sum E.g. input[N] = { 3 -1,1 1 1 2 2 2 4, 6, -8, 1, 1 }. and k == 3. Output = {3,-1} {4, 6, - 8} {1, 1} which all have a sum that is equal to two.","title":"DFS vs BFS: space less than BFS"},{"location":"Interview/knight-dialer/","text":"e.g. input: 1 output: 10 e.g. input: 2 output: 20 1: 6, 8 2: 7, 9 3: 4, 8 4: 3, 9, 0 5: - 6: 1, 7, 0 7: 2, 6 8: 1, 3 9: 4, 2 0: 4, 6 e.g. input: 3 output: 48 DFS with memo \u00b6 Time Complexity: O(n) -> size of memo, Space Complexity: O(n), But call stack is very large. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 , MAX = 10010 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; int res = 0 , n; int memo[ 10 ][MAX]; int dfs ( int pos, int hops) { if (memo[pos][hops] != 0 ) return memo[pos][hops]; int cnt = 0 ; for ( char i : nxt[pos]) { cnt += dfs(i - '0' , hops - 1 ); } return memo[pos][hops] = cnt; } void solve () { for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int pos = 0 ; pos < 10 ; ++ pos) res += dfs(pos, n - 1 ); } int main () { cin >> n; solve(); cout << res % mod; return 0 ; } DP with 2D matrix \u00b6 memo[pos][hops]: # of solution when ends in \"pos\" in \"hops\" hops. base case: memo[x][0] = 1 #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll memo[ 10 ][n]; for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += memo[nei - '0' ][hops - 1 ]; } memo[pos][hops] = cnt; } } for ( int i = 0 ; i < 10 ; ++ i) { res += memo[i][n - 1 ]; } cout << res % mod; return 0 ; } DP with constant space \u00b6 only need to record last state, so just two array is fine. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll prev[ 10 ], curr[ 10 ]; for ( int i = 0 ; i < 10 ; ++ i) prev[i] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += prev[nei - '0' ]; } curr[pos] = cnt; } for ( int pos = 0 ; pos < 10 ; ++ pos) { prev[pos] = curr[pos]; curr[pos] = 0 ; } } for ( int i = 0 ; i < 10 ; ++ i) { res += prev[i]; } cout << res % mod; return 0 ; }","title":"Knight dialer"},{"location":"Interview/knight-dialer/#dfs-with-memo","text":"Time Complexity: O(n) -> size of memo, Space Complexity: O(n), But call stack is very large. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 , MAX = 10010 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; int res = 0 , n; int memo[ 10 ][MAX]; int dfs ( int pos, int hops) { if (memo[pos][hops] != 0 ) return memo[pos][hops]; int cnt = 0 ; for ( char i : nxt[pos]) { cnt += dfs(i - '0' , hops - 1 ); } return memo[pos][hops] = cnt; } void solve () { for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int pos = 0 ; pos < 10 ; ++ pos) res += dfs(pos, n - 1 ); } int main () { cin >> n; solve(); cout << res % mod; return 0 ; }","title":"DFS with memo"},{"location":"Interview/knight-dialer/#dp-with-2d-matrix","text":"memo[pos][hops]: # of solution when ends in \"pos\" in \"hops\" hops. base case: memo[x][0] = 1 #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll memo[ 10 ][n]; for ( int i = 0 ; i < 10 ; ++ i) memo[i][ 0 ] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += memo[nei - '0' ][hops - 1 ]; } memo[pos][hops] = cnt; } } for ( int i = 0 ; i < 10 ; ++ i) { res += memo[i][n - 1 ]; } cout << res % mod; return 0 ; }","title":"DP with 2D matrix"},{"location":"Interview/knight-dialer/#dp-with-constant-space","text":"only need to record last state, so just two array is fine. #include <bits/stdc++.h> using namespace std; const int mod = 1e9 + 7 ; string nxt[ 10 ] = { \"46\" , \"68\" , \"79\" , \"48\" , \"390\" , \"\" , \"170\" , \"26\" , \"13\" , \"42\" }; #define ll long long int main () { ll res = 0 ; int n; cin >> n; ll prev[ 10 ], curr[ 10 ]; for ( int i = 0 ; i < 10 ; ++ i) prev[i] = 1 ; for ( int hops = 1 ; hops < n; ++ hops) { for ( int pos = 0 ; pos < 10 ; ++ pos) { ll cnt = 0 ; for ( char nei : nxt[pos]) { cnt %= mod; cnt += prev[nei - '0' ]; } curr[pos] = cnt; } for ( int pos = 0 ; pos < 10 ; ++ pos) { prev[pos] = curr[pos]; curr[pos] = 0 ; } } for ( int i = 0 ; i < 10 ; ++ i) { res += prev[i]; } cout << res % mod; return 0 ; }","title":"DP with constant space"},{"location":"Interview/linked-list/","text":"Define \u00b6 Logically consecutive list, but physically not consecutive Principle \u00b6 never lose the control of the head pointer of the linkedlist when want to dereference a ListNode, make sure it is not NULL Q1: reverse Linkedlist \u00b6 Need two pointers: one for previous, one for curr; reverse is simply change the direction Recursion \u00b6 ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL; return res; } Q2: insert into sorted linkedlist \u00b6 ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; } Q3: reorganize linkedlist \u00b6 Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; } Q4: partition list \u00b6 L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Linked list"},{"location":"Interview/linked-list/#define","text":"Logically consecutive list, but physically not consecutive","title":"Define"},{"location":"Interview/linked-list/#principle","text":"never lose the control of the head pointer of the linkedlist when want to dereference a ListNode, make sure it is not NULL","title":"Principle"},{"location":"Interview/linked-list/#q1-reverse-linkedlist","text":"Need two pointers: one for previous, one for curr; reverse is simply change the direction","title":"Q1: reverse Linkedlist"},{"location":"Interview/linked-list/#recursion","text":"ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL; return res; }","title":"Recursion"},{"location":"Interview/linked-list/#q2-insert-into-sorted-linkedlist","text":"ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; }","title":"Q2: insert into sorted linkedlist"},{"location":"Interview/linked-list/#q3-reorganize-linkedlist","text":"Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; }","title":"Q3: reorganize linkedlist"},{"location":"Interview/linked-list/#q4-partition-list","text":"L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Q4: partition list"},{"location":"Interview/linkedlist/","text":"Define \u00b6 Logically consecutive list, but physically not consecutive Q1: reverse Linkedlist \u00b6 Need two pointers: one for previous, one for curr; reverse is simply change the direction Recursion \u00b6 ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL; return res; } Q2: insert into sorted linkedlist \u00b6 ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; } Q3: reorganize linkedlist \u00b6 Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; } Q4: partition list \u00b6 L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Linkedlist"},{"location":"Interview/linkedlist/#define","text":"Logically consecutive list, but physically not consecutive","title":"Define"},{"location":"Interview/linkedlist/#q1-reverse-linkedlist","text":"Need two pointers: one for previous, one for curr; reverse is simply change the direction","title":"Q1: reverse Linkedlist"},{"location":"Interview/linkedlist/#recursion","text":"ListNode * reverse (ListNode * head) { if ( ! head || ! head -> next) return head; ListNode * res = reverse(head -> next); // this will get the last node from the origional linkedlist head -> next -> next = head; head -> next = NULL; return res; }","title":"Recursion"},{"location":"Interview/linkedlist/#q2-insert-into-sorted-linkedlist","text":"ListNode * insert (ListNode * head, int value) { // write your solution here ListNode * node = new ListNode(value); if ( ! head || head -> value >= value) { node -> next = head; head = node; return head; } ListNode * curr = head -> next, * pre = head; while (curr) { if (curr -> value >= value && pre -> value <= value) break ; curr = curr -> next; pre = pre -> next; } pre -> next = node; node -> next = curr; return head; }","title":"Q2: insert into sorted linkedlist"},{"location":"Interview/linkedlist/#q3-reorganize-linkedlist","text":"Reorder the given singly-linked list N1 -> N2 -> N3 -> N4 -> \u2026 -> Nn -> null to be N1- > Nn -> N2 -> Nn-1 -> N3 -> Nn-2 -> \u2026 -> null ListNode * reorder (ListNode * head) { // write your solution here if ( ! head || ! head -> next) return head; ListNode * res = head; ListNode * slow = head, * fast = head; // find mid point while (fast -> next && fast -> next -> next) { slow = slow -> next; fast = fast -> next -> next; } ListNode * mid = slow -> next; slow -> next = NULL; // break the list // reverse the mid - end ListNode * last = mid, * pre = NULL; while (last) { ListNode * next = last -> next; last -> next = pre; pre = last; last = next; } // re-combine together while (head && pre) { ListNode * next = head -> next; head -> next = pre; pre = pre -> next; head -> next -> next = next; head = next; } return res; }","title":"Q3: reorganize linkedlist"},{"location":"Interview/linkedlist/#q4-partition-list","text":"L = 2 -> 4 -> 3 -> 5 -> 1 -> null, T = 3, is partitioned to 2 -> 1 -> 4 -> 3 -> 5 -> null ListNode * partition (ListNode * head, int x) { if (head == nullptr) return head; ListNode lesser, greater; ListNode * p1 = & lesser; ListNode * p2 = & greater; while (head) { if (head -> val < x) { p1 -> next = head; p1 = p1 -> next; } else { p2 -> next = head; p2 = p2 -> next; } head = head -> next; } p1 -> next = greater.next; p2 -> next = nullptr; return lesser.next; }","title":"Q4: partition list"},{"location":"Interview/lowest-common-ancester/","text":"Variant 1: input is a BST \u00b6 https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ To utilize the property of BST, we should keep elimate either the right or the left subtree of the input tree: If p and q are all on the right subtree, that means root -> left is less than the min value of p and q -> so we don't need to search the root -> left subtree If p and q are all on the left subtree, that means root -> right is greater than the max value of p and q -> so we don't need to search the root -> right subtree If p is in root -> left subtree and p is in root -> right subtree (order doesn't matter), then we juet need to find the first root that satisfy this situation -> return current root Time: O(log_2{n}) O(log_2{n}) Code \u00b6 TreeNode * lowestCommonAncestor (TreeNode * root, TreeNode * p, TreeNode * q) { while ( 1 ) { if (root -> val < min(p -> val, q -> val)) root = root -> right; else if (root -> val > max(p -> val, q -> val)) root = root -> left; else break ; } return root; } Variant 2: input is a binary tree \u00b6 If the two nodes are all existed in the binary tree, then if we start from the root of the tree 1. if find one -> two is somewhere deeper than one , so one is the LCA 2. if find two -> one is somewhere deeper than two , so two is the LCA Now the problem reduced to how to find the two nodes from the binay tree. Time: O(n) O(n) Stack Space: O(height) O(height) Code \u00b6 class Solution { public: TreeNode * solve(TreeNode * root, TreeNode * one, TreeNode * two) { if ( ! root || root == one || two == root) return root; TreeNode * left = solve(root -> left, one, two); TreeNode * right = solve(root -> right, one, two); if (left && right) return root; // both exist, so current root is the LCA return left ? left : right; // return the one that is found } };","title":"Lowest common ancester"},{"location":"Interview/lowest-common-ancester/#variant-1-input-is-a-bst","text":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ To utilize the property of BST, we should keep elimate either the right or the left subtree of the input tree: If p and q are all on the right subtree, that means root -> left is less than the min value of p and q -> so we don't need to search the root -> left subtree If p and q are all on the left subtree, that means root -> right is greater than the max value of p and q -> so we don't need to search the root -> right subtree If p is in root -> left subtree and p is in root -> right subtree (order doesn't matter), then we juet need to find the first root that satisfy this situation -> return current root Time: O(log_2{n}) O(log_2{n})","title":"Variant 1: input is a BST"},{"location":"Interview/lowest-common-ancester/#code","text":"TreeNode * lowestCommonAncestor (TreeNode * root, TreeNode * p, TreeNode * q) { while ( 1 ) { if (root -> val < min(p -> val, q -> val)) root = root -> right; else if (root -> val > max(p -> val, q -> val)) root = root -> left; else break ; } return root; }","title":"Code"},{"location":"Interview/lowest-common-ancester/#variant-2-input-is-a-binary-tree","text":"If the two nodes are all existed in the binary tree, then if we start from the root of the tree 1. if find one -> two is somewhere deeper than one , so one is the LCA 2. if find two -> one is somewhere deeper than two , so two is the LCA Now the problem reduced to how to find the two nodes from the binay tree. Time: O(n) O(n) Stack Space: O(height) O(height)","title":"Variant 2: input is a binary tree"},{"location":"Interview/lowest-common-ancester/#code_1","text":"class Solution { public: TreeNode * solve(TreeNode * root, TreeNode * one, TreeNode * two) { if ( ! root || root == one || two == root) return root; TreeNode * left = solve(root -> left, one, two); TreeNode * right = solve(root -> right, one, two); if (left && right) return root; // both exist, so current root is the LCA return left ? left : right; // return the one that is found } };","title":"Code"},{"location":"Interview/maximum-product-subarray/","text":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. How many subarrays in total? \u00b6 There are N^2 N^2 subarrays. You can choose 1 out of N for the start of the subarray, and also 1 out of N for the end of the subarray, so in total it will be N^2 / 2 N^2 / 2 (divide by two because of duplicates). DFS with memo O(n^2) O(n^2) \u00b6 map<int,int> where key is the end and value is the product, create the map every time when start changes. DP O(n) O(n) with space O(n) O(n) \u00b6 max_dp[i]: from 0-i, the maximum product min_dp[i]: from 0-i, the minimum product base case: 1. max_dp[0] = max(0, array[0]) // you can choose itself or nothing 2. min_dp[0] = min(0, array[0]) induction: max_dp[i] = max(min_dp[i] * array[i], max_dp[i-1] * array[i], array[i]) where min_dp[i] * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp[i] * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int n = nums.size(); int max_dp[n], min_dp[n]; memset(max_dp, 0 , sizeof max_dp); memset(min_dp, 0 , sizeof min_dp); int res = INT_MIN; for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) { min_dp[i] = nums[i]; max_dp[i] = nums[i]; } else { max_dp[i] = max(max(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); min_dp[i] = min(min(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); } res = max(res, max_dp[i]); } return res; } }; Optimize DP with O(1) O(1) space \u00b6 max_dp: from 0-i, the maximum product min_dp: from 0-i, the minimum product base case: 1. pre_max_dp = array[0] // you can choose itself or nothing 2. pre_min_dp = array[0] induction: max_dp = max(min_dp * array[i], pre_max_dp * array[i], array[i]) where min_dp * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int size = nums.size(); if (size == 0 ) { return 0 ; } int oldMin = nums[ 0 ]; int oldMax = nums[ 0 ]; int ret = nums[ 0 ]; for ( int i = 1 ; i < size; ++ i) { int newMax = max(nums[i], nums[i] > 0 ? oldMax * nums[i] : oldMin * nums[i]); int newMin = min(nums[i], nums[i] > 0 ? oldMin * nums[i] : oldMax * nums[i]); ret = max(ret, newMax); oldMin = newMin; oldMax = newMax; } return ret; } };","title":"Maximum product subarray"},{"location":"Interview/maximum-product-subarray/#how-many-subarrays-in-total","text":"There are N^2 N^2 subarrays. You can choose 1 out of N for the start of the subarray, and also 1 out of N for the end of the subarray, so in total it will be N^2 / 2 N^2 / 2 (divide by two because of duplicates).","title":"How many subarrays in total?"},{"location":"Interview/maximum-product-subarray/#dfs-with-memo-on2on2","text":"map<int,int> where key is the end and value is the product, create the map every time when start changes.","title":"DFS with memo O(n^2)O(n^2)"},{"location":"Interview/maximum-product-subarray/#dp-onon-with-space-onon","text":"max_dp[i]: from 0-i, the maximum product min_dp[i]: from 0-i, the minimum product base case: 1. max_dp[0] = max(0, array[0]) // you can choose itself or nothing 2. min_dp[0] = min(0, array[0]) induction: max_dp[i] = max(min_dp[i] * array[i], max_dp[i-1] * array[i], array[i]) where min_dp[i] * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp[i] * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int n = nums.size(); int max_dp[n], min_dp[n]; memset(max_dp, 0 , sizeof max_dp); memset(min_dp, 0 , sizeof min_dp); int res = INT_MIN; for ( int i = 0 ; i < n; ++ i) { if (i == 0 ) { min_dp[i] = nums[i]; max_dp[i] = nums[i]; } else { max_dp[i] = max(max(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); min_dp[i] = min(min(min_dp[i - 1 ] * nums[i], max_dp[i - 1 ] * nums[i]), nums[i]); } res = max(res, max_dp[i]); } return res; } };","title":"DP O(n)O(n) with space O(n)O(n)"},{"location":"Interview/maximum-product-subarray/#optimize-dp-with-o1o1-space","text":"max_dp: from 0-i, the maximum product min_dp: from 0-i, the minimum product base case: 1. pre_max_dp = array[0] // you can choose itself or nothing 2. pre_min_dp = array[0] induction: max_dp = max(min_dp * array[i], pre_max_dp * array[i], array[i]) where min_dp * array[i] is for calculating the case when both min_dp and array[i] are neg where max_dp * array[i] is for calculating the case when both max_dp and array[i] are pos class Solution { public: int maxProduct(vector < int >& nums) { int size = nums.size(); if (size == 0 ) { return 0 ; } int oldMin = nums[ 0 ]; int oldMax = nums[ 0 ]; int ret = nums[ 0 ]; for ( int i = 1 ; i < size; ++ i) { int newMax = max(nums[i], nums[i] > 0 ? oldMax * nums[i] : oldMin * nums[i]); int newMin = min(nums[i], nums[i] > 0 ? oldMin * nums[i] : oldMax * nums[i]); ret = max(ret, newMax); oldMin = newMin; oldMax = newMax; } return ret; } };","title":"Optimize DP with O(1)O(1) space"},{"location":"Interview/midterm-java/","text":"P1: N queens \u00b6 Find all valid ways of putting N Queens on an N * N chessboard so that no two Queens can attack each other (two queens can attack each other if they are on the same row/column or same diagonal line). You can define your own way of how to print the solution, e.g. using a size N array/List to record which column the queen occupies on each row Analysis \u00b6 Assumption: Use array curr to represent the solution: one index row, place a queen on curr[index] column to represent the complete configuration. If there are no solutions (e.g. when N <= 3), return an empty array. Approach: 1. High Level: use DFS 2. Details: - Starting from the first row, try placing the queen from the column 0 to column N-1. After the first placement, begin another placement for second row. - In order to check if the current row and column can be placed a queen, we need to have a hashset for storing all the visited queens: column , diagonal and anti-diagonal . - if (x, y) is in the same column of (i, j), then y == j - if (x, y) is in the same diagonal of (i, j), then x + y == i + j - if (x, y) is in the same anti-diagonal of (i, j), then y - x + n - 1 == j - i (+ n - 1 because we want to make sure the sum will fit in our boolean array) - Base case: if we can successfully reach the last row with all the N placement of the queens, then the current configuration is one of the solution. 3. Recursion Tree: Complexity: - Time: O(N^N) O(N^N) - Space: O(N) O(N) Code \u00b6 package test; import java.util.ArrayList; import java.util.List; public class test { /** * convert int[] to List<Integer>: List can track the size of the container * @param array * @return resulting List<Integer> */ private List < Integer > toList ( int [] array) { List < Integer > list = new ArrayList <> (); for ( int num : array) list. add (num); return list; } /** * check if the current placement is valid or not * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals * @return true: is valid, false: invalid */ private boolean valid ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { return ! usedColumns [ column ] && ! usedDiagonals [ column + row ] && ! usedAntiDiagonals [ column - row + n - 1 ] ; } /** * mark the current placement (if is valid) * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void mark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = true ; usedDiagonals [ column + row ] = true ; usedAntiDiagonals [ column - row + n - 1 ] = true ; } /** * unmark the current placement * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void unMark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = false ; usedDiagonals [ column + row ] = false ; usedAntiDiagonals [ column - row + n - 1 ] = false ; } /** * main DFS logic to iterate through all the rows and valid columns * @param n * @param row * @param curr * @param result * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void dfs ( int n, int row, int [] curr, List < List < Integer >> result, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { // base case: reach the last row, so we add the current configuration to the result if (row == n) { result. add (toList(curr)); return ; } for ( int i = 0 ; i < n; ++ i) { // first check if current placement is valid or not if (valid(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals)) { // if is valid, mark it down mark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); curr [ row ] = i; // place to current column dfs(n, row + 1 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); // don't forget to unmark it so that it will go back to the previous stage unMark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); } } } /** * driver method: user input a n, and we should return all the configurations that it should have * @param n * @return List<List<Integer>> result array (configurations) */ public List < List < Integer >> nqueens ( int n) { int [] curr = new int [ n ] ; List < List < Integer >> result = new ArrayList < List < Integer >> (); boolean [] usedColumns = new boolean [ n ] ; boolean [] usedDiagonals = new boolean [ 2 * n - 1 ] ; boolean [] usedAntiDiagonals = new boolean [ 2 * n - 1 ] ; dfs(n, 0 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); return result; } public static void main (String [] args) { test s = new test(); List < List < Integer >> list = s. nqueens ( 4 ); for (List < Integer > l : list) { for (Integer i : l) System. out . println (i); System. out . println (); } } } P2: Maximum leaf sum \u00b6 Given a binary tree in which each node contains an int number. Find the maximum possible sum from any leaf node to another leaf node. The maximum sum path may or may not go through root. Expected time complexity is O(n). Analysis \u00b6 Assumption: If input is null (no node), or without left OR right child, return Integer.MIN_VALUE. Approach: 1. High Level: use Post-order traversal to traverse the binary tree, and calculate the path sum for each path from left leaf - current root - right leaf. 2. Details: - The method signature is int maxPathSum(TreeNode root) where root is the input tree's root node, return is the maximum path sum. - If input is one of the case mentioned in the assumption, return Integer.MIN_VALUE - Define another helper method int postOrder(TreeNode root, int[] result) where result is an array because it will be able to be modified within the recursive method. The return value represents the maximum sum from any leaf to current root. - In the traverse: base case is when current root == null , it should return 0 as it has reach leaf node. Then there are three cases to be considered: 1. left and right children are both null: this path is invalid 2. left or right children have one is null: choose the path that has a leaf 3. left and right children both exist: choose the maximum path between the two paths 3. Recursion Tree: Complexity: - Time: O(N) O(N) - Space: O(height) O(height) or O(N) O(N) Code \u00b6 /** * public class TreeNode { * public int key; * public TreeNode left; * public TreeNode right; * public TreeNode(int key) { * this.key = key; * } * } */ public class Solution { private int postOrder (TreeNode root, int [] result) { if (root == null ) return 0 ; int leftSum = postOrder(root. left , result); int rightSum = postOrder(root. right , result); // case 1: if current root has both left and right child, // then update the result and choose the bigger sum between the left and right children if (root. left != null && root. right != null ) { result [ 0 ] = Math. max (root. key + leftSum + rightSum, result [ 0 ] ); return Math. max (root. key + leftSum, root. key + rightSum); } // case 2: if only one child exist, return the one with leaf if (root. left == null ) return root. key + rightSum; return root. key + leftSum; } public int maxPathSum (TreeNode root) { if (root == null || root. left == null || root. right == null ) return Integer. MIN_VALUE ; int [] result = {Integer. MIN_VALUE }; postOrder(root, result); return result [ 0 ] ; } } P3: minimal cuts to form palindrome \u00b6 Given a string, a partitioning of the string is a palindrome partitioning if every partition is a palindrome. For example, \u201caba |b | bbabb |a| b| aba\u201d is a palindrome partitioning of \u201cababbbabbababa\u201d. Determine the fewest cuts needed for palindrome partitioning of a given string. For example, minimum 3 cuts are needed for \u201cababbbabbababa\u201d. The three cuts are \u201ca | babbbab | b | ababa\u201d. If a string is palindrome, then minimum 0 cuts are needed. Return the minimum cuts. Analysis \u00b6 Assumption: Input string is a valid string: not null Approach: 1. High Level: because this question is asking the minimal cuts but not each configuration/how to cut, we can naturally think to use Dynamic Programming. 2. Details: - cuts[i]: minimal cuts from 0-i in char array - pal[i][j]: s[i-j] is a palindrome or not - base case / how to initialize the cuts array: consider each character in the array is a palindrome itself, so for each string with length n, the maximum cuts requires is n - 1 - induction rule: cuts[i] = min(cuts[i], cuts[j - 1] + 1) if s[j to i] is a palindrome AND s[i] == s[j] - result: cuts[n] 3. Fill \"table\": Complexity: Time: O(N^2) O(N^2) Space: O(N^2) O(N^2) Code \u00b6 package test; public class MinimalCutsPalindrome { public int minCuts (String s) { char [] ch = s. toCharArray (); // convert to char array so that there is no overhead of substring int n = ch. length ; int [] cut = new int [ n ] ; // cut[i]: minimal cuts from 0-i in ch array boolean [][] pal = new boolean [ n ][ n ] ; // pal[i][j]: s[i-j] is a palindrome or not for ( int i = 0 ; i < n; i ++ ) { // grow 1 letter by 1 letter int min = i; for ( int j = 0 ; j <= i; j ++ ) { // j is the start index of the right section if (ch [ j ] == ch [ i ] && (j + 1 > i - 1 || pal [ j + 1 ][ i - 1 ] )) { pal [ j ][ i ] = true ; min = j == 0 ? 0 : Math. min (min, cut [ j - 1 ] + 1 ); } } cut [ i ] = min; System. out . println (); } return cut [ n - 1 ] ; } public static void main (String [] args) { MinimalCutsPalindrome solution = new MinimalCutsPalindrome(); System. out . println (solution. minCuts ( \"abaacda\" )); } } P4: Print all the if { and } \u00b6 Given an integer n, print/output all possible ways of writing n pairs of if blocks with correct indentation. Say n=2 output should be if { } if { } if { if {// here should exist two spaces before each inner block } } Analysis \u00b6 Assumption: input is a valid integer and output is a string that has been formatted in the correct indentation if input is less or equal then 0, print nothing Approach: 1. High Level: use DFS to traverse all the possible combination of if { and } , and then format the raw string into the correct indented string. 2. Details: - To get the correct combination, we need to track the number of if { and } , which have to match with each other. We can use the approach introduced in generated parenthesis to do so. - Format: we need to count the number of space for each level, and I will use int space to track. 3. Recursion Tree: Complexity: Time: O(2^n) O(2^n) Space: O(2 \\times N) O(2 \\times N) Code \u00b6 package test; public class PrintAllBlock { /** * dfs method that keep generate the valid string of { and } * @param leftRemain * @param rightRemain * @param index * @param curr */ private void helper ( int leftRemain, int rightRemain, int index, char [] curr) { // base case if (leftRemain == 0 && rightRemain == 0 ) { printBlock(curr); return ; } if (leftRemain > 0 ) { curr [ index ] = '{' ; helper(leftRemain - 1 , rightRemain, index + 1 , curr); } if (rightRemain > leftRemain) { curr [ index ] = '}' ; helper(leftRemain, rightRemain - 1 , index + 1 , curr); } } /** * print the space for indentation * @param n */ private void printSpace ( int n) { while (n > 0 ) { System. out . print ( \" \" ); n -- ; } } /** * print the corrected format from valid { and } string * @param curr */ private void printBlock ( char [] curr) { int space = 0 ; for ( int i = 0 ; i < curr. length ; ++ i) { if (curr [ i ] == '{' ) { printSpace(space); System. out . println ( \"if {\" ); space += 2 ; } else { space -= 2 ; printSpace(space); System. out . println ( \"}\" ); } } System. out . println (); } /** * driver method: takes in a number represents the number of if { and } that it will have * @param n */ public void printBlocks ( int n) { if (n <= 0 ) return ; char [] curr = new char [ 2 * n ] ; helper(n, n, 0 , curr); } public static void main (String [] argc) { PrintAllBlock s = new PrintAllBlock(); s. printBlocks ( 3 ); } }","title":"Midterm java"},{"location":"Interview/midterm-java/#p1-n-queens","text":"Find all valid ways of putting N Queens on an N * N chessboard so that no two Queens can attack each other (two queens can attack each other if they are on the same row/column or same diagonal line). You can define your own way of how to print the solution, e.g. using a size N array/List to record which column the queen occupies on each row","title":"P1: N queens"},{"location":"Interview/midterm-java/#analysis","text":"Assumption: Use array curr to represent the solution: one index row, place a queen on curr[index] column to represent the complete configuration. If there are no solutions (e.g. when N <= 3), return an empty array. Approach: 1. High Level: use DFS 2. Details: - Starting from the first row, try placing the queen from the column 0 to column N-1. After the first placement, begin another placement for second row. - In order to check if the current row and column can be placed a queen, we need to have a hashset for storing all the visited queens: column , diagonal and anti-diagonal . - if (x, y) is in the same column of (i, j), then y == j - if (x, y) is in the same diagonal of (i, j), then x + y == i + j - if (x, y) is in the same anti-diagonal of (i, j), then y - x + n - 1 == j - i (+ n - 1 because we want to make sure the sum will fit in our boolean array) - Base case: if we can successfully reach the last row with all the N placement of the queens, then the current configuration is one of the solution. 3. Recursion Tree: Complexity: - Time: O(N^N) O(N^N) - Space: O(N) O(N)","title":"Analysis"},{"location":"Interview/midterm-java/#code","text":"package test; import java.util.ArrayList; import java.util.List; public class test { /** * convert int[] to List<Integer>: List can track the size of the container * @param array * @return resulting List<Integer> */ private List < Integer > toList ( int [] array) { List < Integer > list = new ArrayList <> (); for ( int num : array) list. add (num); return list; } /** * check if the current placement is valid or not * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals * @return true: is valid, false: invalid */ private boolean valid ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { return ! usedColumns [ column ] && ! usedDiagonals [ column + row ] && ! usedAntiDiagonals [ column - row + n - 1 ] ; } /** * mark the current placement (if is valid) * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void mark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = true ; usedDiagonals [ column + row ] = true ; usedAntiDiagonals [ column - row + n - 1 ] = true ; } /** * unmark the current placement * @param n * @param row * @param column * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void unMark ( int n, int row, int column, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { usedColumns [ column ] = false ; usedDiagonals [ column + row ] = false ; usedAntiDiagonals [ column - row + n - 1 ] = false ; } /** * main DFS logic to iterate through all the rows and valid columns * @param n * @param row * @param curr * @param result * @param usedColumns * @param usedDiagonals * @param usedAntiDiagonals */ private void dfs ( int n, int row, int [] curr, List < List < Integer >> result, boolean [] usedColumns, boolean [] usedDiagonals, boolean [] usedAntiDiagonals) { // base case: reach the last row, so we add the current configuration to the result if (row == n) { result. add (toList(curr)); return ; } for ( int i = 0 ; i < n; ++ i) { // first check if current placement is valid or not if (valid(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals)) { // if is valid, mark it down mark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); curr [ row ] = i; // place to current column dfs(n, row + 1 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); // don't forget to unmark it so that it will go back to the previous stage unMark(n, row, i, usedColumns, usedDiagonals, usedAntiDiagonals); } } } /** * driver method: user input a n, and we should return all the configurations that it should have * @param n * @return List<List<Integer>> result array (configurations) */ public List < List < Integer >> nqueens ( int n) { int [] curr = new int [ n ] ; List < List < Integer >> result = new ArrayList < List < Integer >> (); boolean [] usedColumns = new boolean [ n ] ; boolean [] usedDiagonals = new boolean [ 2 * n - 1 ] ; boolean [] usedAntiDiagonals = new boolean [ 2 * n - 1 ] ; dfs(n, 0 , curr, result, usedColumns, usedDiagonals, usedAntiDiagonals); return result; } public static void main (String [] args) { test s = new test(); List < List < Integer >> list = s. nqueens ( 4 ); for (List < Integer > l : list) { for (Integer i : l) System. out . println (i); System. out . println (); } } }","title":"Code"},{"location":"Interview/midterm-java/#p2-maximum-leaf-sum","text":"Given a binary tree in which each node contains an int number. Find the maximum possible sum from any leaf node to another leaf node. The maximum sum path may or may not go through root. Expected time complexity is O(n).","title":"P2: Maximum leaf sum"},{"location":"Interview/midterm-java/#analysis_1","text":"Assumption: If input is null (no node), or without left OR right child, return Integer.MIN_VALUE. Approach: 1. High Level: use Post-order traversal to traverse the binary tree, and calculate the path sum for each path from left leaf - current root - right leaf. 2. Details: - The method signature is int maxPathSum(TreeNode root) where root is the input tree's root node, return is the maximum path sum. - If input is one of the case mentioned in the assumption, return Integer.MIN_VALUE - Define another helper method int postOrder(TreeNode root, int[] result) where result is an array because it will be able to be modified within the recursive method. The return value represents the maximum sum from any leaf to current root. - In the traverse: base case is when current root == null , it should return 0 as it has reach leaf node. Then there are three cases to be considered: 1. left and right children are both null: this path is invalid 2. left or right children have one is null: choose the path that has a leaf 3. left and right children both exist: choose the maximum path between the two paths 3. Recursion Tree: Complexity: - Time: O(N) O(N) - Space: O(height) O(height) or O(N) O(N)","title":"Analysis"},{"location":"Interview/midterm-java/#code_1","text":"/** * public class TreeNode { * public int key; * public TreeNode left; * public TreeNode right; * public TreeNode(int key) { * this.key = key; * } * } */ public class Solution { private int postOrder (TreeNode root, int [] result) { if (root == null ) return 0 ; int leftSum = postOrder(root. left , result); int rightSum = postOrder(root. right , result); // case 1: if current root has both left and right child, // then update the result and choose the bigger sum between the left and right children if (root. left != null && root. right != null ) { result [ 0 ] = Math. max (root. key + leftSum + rightSum, result [ 0 ] ); return Math. max (root. key + leftSum, root. key + rightSum); } // case 2: if only one child exist, return the one with leaf if (root. left == null ) return root. key + rightSum; return root. key + leftSum; } public int maxPathSum (TreeNode root) { if (root == null || root. left == null || root. right == null ) return Integer. MIN_VALUE ; int [] result = {Integer. MIN_VALUE }; postOrder(root, result); return result [ 0 ] ; } }","title":"Code"},{"location":"Interview/midterm-java/#p3-minimal-cuts-to-form-palindrome","text":"Given a string, a partitioning of the string is a palindrome partitioning if every partition is a palindrome. For example, \u201caba |b | bbabb |a| b| aba\u201d is a palindrome partitioning of \u201cababbbabbababa\u201d. Determine the fewest cuts needed for palindrome partitioning of a given string. For example, minimum 3 cuts are needed for \u201cababbbabbababa\u201d. The three cuts are \u201ca | babbbab | b | ababa\u201d. If a string is palindrome, then minimum 0 cuts are needed. Return the minimum cuts.","title":"P3: minimal cuts to form palindrome"},{"location":"Interview/midterm-java/#analysis_2","text":"Assumption: Input string is a valid string: not null Approach: 1. High Level: because this question is asking the minimal cuts but not each configuration/how to cut, we can naturally think to use Dynamic Programming. 2. Details: - cuts[i]: minimal cuts from 0-i in char array - pal[i][j]: s[i-j] is a palindrome or not - base case / how to initialize the cuts array: consider each character in the array is a palindrome itself, so for each string with length n, the maximum cuts requires is n - 1 - induction rule: cuts[i] = min(cuts[i], cuts[j - 1] + 1) if s[j to i] is a palindrome AND s[i] == s[j] - result: cuts[n] 3. Fill \"table\": Complexity: Time: O(N^2) O(N^2) Space: O(N^2) O(N^2)","title":"Analysis"},{"location":"Interview/midterm-java/#code_2","text":"package test; public class MinimalCutsPalindrome { public int minCuts (String s) { char [] ch = s. toCharArray (); // convert to char array so that there is no overhead of substring int n = ch. length ; int [] cut = new int [ n ] ; // cut[i]: minimal cuts from 0-i in ch array boolean [][] pal = new boolean [ n ][ n ] ; // pal[i][j]: s[i-j] is a palindrome or not for ( int i = 0 ; i < n; i ++ ) { // grow 1 letter by 1 letter int min = i; for ( int j = 0 ; j <= i; j ++ ) { // j is the start index of the right section if (ch [ j ] == ch [ i ] && (j + 1 > i - 1 || pal [ j + 1 ][ i - 1 ] )) { pal [ j ][ i ] = true ; min = j == 0 ? 0 : Math. min (min, cut [ j - 1 ] + 1 ); } } cut [ i ] = min; System. out . println (); } return cut [ n - 1 ] ; } public static void main (String [] args) { MinimalCutsPalindrome solution = new MinimalCutsPalindrome(); System. out . println (solution. minCuts ( \"abaacda\" )); } }","title":"Code"},{"location":"Interview/midterm-java/#p4-print-all-the-if-and","text":"Given an integer n, print/output all possible ways of writing n pairs of if blocks with correct indentation. Say n=2 output should be if { } if { } if { if {// here should exist two spaces before each inner block } }","title":"P4: Print all the if { and }"},{"location":"Interview/midterm-java/#analysis_3","text":"Assumption: input is a valid integer and output is a string that has been formatted in the correct indentation if input is less or equal then 0, print nothing Approach: 1. High Level: use DFS to traverse all the possible combination of if { and } , and then format the raw string into the correct indented string. 2. Details: - To get the correct combination, we need to track the number of if { and } , which have to match with each other. We can use the approach introduced in generated parenthesis to do so. - Format: we need to count the number of space for each level, and I will use int space to track. 3. Recursion Tree: Complexity: Time: O(2^n) O(2^n) Space: O(2 \\times N) O(2 \\times N)","title":"Analysis"},{"location":"Interview/midterm-java/#code_3","text":"package test; public class PrintAllBlock { /** * dfs method that keep generate the valid string of { and } * @param leftRemain * @param rightRemain * @param index * @param curr */ private void helper ( int leftRemain, int rightRemain, int index, char [] curr) { // base case if (leftRemain == 0 && rightRemain == 0 ) { printBlock(curr); return ; } if (leftRemain > 0 ) { curr [ index ] = '{' ; helper(leftRemain - 1 , rightRemain, index + 1 , curr); } if (rightRemain > leftRemain) { curr [ index ] = '}' ; helper(leftRemain, rightRemain - 1 , index + 1 , curr); } } /** * print the space for indentation * @param n */ private void printSpace ( int n) { while (n > 0 ) { System. out . print ( \" \" ); n -- ; } } /** * print the corrected format from valid { and } string * @param curr */ private void printBlock ( char [] curr) { int space = 0 ; for ( int i = 0 ; i < curr. length ; ++ i) { if (curr [ i ] == '{' ) { printSpace(space); System. out . println ( \"if {\" ); space += 2 ; } else { space -= 2 ; printSpace(space); System. out . println ( \"}\" ); } } System. out . println (); } /** * driver method: takes in a number represents the number of if { and } that it will have * @param n */ public void printBlocks ( int n) { if (n <= 0 ) return ; char [] curr = new char [ 2 * n ] ; helper(n, n, 0 , curr); } public static void main (String [] argc) { PrintAllBlock s = new PrintAllBlock(); s. printBlocks ( 3 ); } }","title":"Code"},{"location":"Interview/ood/","text":"Design Pattern \u00b6 https://github.com/JakubVojvoda/design-patterns-cpp Builder \u00b6 if there are a lot of fields in a class, cannot put them all in as parameters in the constructor. solution 0: define final and optional data fields in the class (no need to initialize in the constructor => bad because it could generate a lot of dfferent types of constructors. solution 1: use setter and getter => bad because if want to create an object, user has to call all the setters and getters (constructor isn't doing what it is supposed to do: dangerous in multi-threading) => encapsulation is destroyed => e.g. setters' member field might not want to be changed OR setters are not changed in the desire way solution 2: encapsulate the related fields into a single function, use an abstract class to manage the top level abstraction and some concrete subclasses to manage the specific constructions. Core: create a builder class for top level abstraction and subclasses for specific constructions. When implementing, don't forget to #include \"builder.hpp\" . /* * C++ Design Patterns: Builder * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * the final object that will be created using Builder */ class Product { public: void makeA( const std :: string & part ) { partA = part; } void makeB( const std :: string & part ) { partB = part; } void makeC( const std :: string & part ) { partC = part; } std :: string get() { return (partA + \" \" + partB + \" \" + partC); } // ... private: std :: string partA; std :: string partB; std :: string partC; // ... }; /* * Builder * abstract interface for creating products */ class Builder { public: virtual ~ Builder() {} Product get() { return product; } virtual void buildPartA() = 0 ; virtual void buildPartB () = 0 ; virtual void buildPartC () = 0 ; // ... protected: Product product; }; /* * Concrete Builder X and Y * create real products and stores them in the composite structure */ class ConcreteBuilderX : public Builder { public: void buildPartA() { product.makeA( \"A-X\" ); } void buildPartB() { product.makeB( \"B-X\" ); } void buildPartC() { product.makeC( \"C-X\" ); } // ... }; class ConcreteBuilderY : public Builder { public: void buildPartA() { product.makeA( \"A-Y\" ); } void buildPartB() { product.makeB( \"B-Y\" ); } void buildPartC() { product.makeC( \"C-Y\" ); } // ... }; /* * Director * responsible for managing the correct sequence of object creation */ class Director { public: Director() : builder() {} ~ Director() { if ( builder ) { delete builder; } } void set( Builder * b ) { if ( builder ) { delete builder; } builder = b; } Product get() { return builder -> get(); } void construct() { builder -> buildPartA(); builder -> buildPartB(); builder -> buildPartC(); // ... } // ... private: Builder * builder; }; int main () { Director director; director.set( new ConcreteBuilderX ); director.construct(); Product product1 = director.get(); std :: cout << \"1st product parts: \" << product1.get() << std :: endl; director.set( new ConcreteBuilderY ); director.construct(); Product product2 = director.get(); std :: cout << \"2nd product parts: \" << product2.get() << std :: endl; return 0 ; } Abstract Factory \u00b6 polymorphism: use an abstract class to include the shared method getName() multiple different classes create the same type of object with the shared method for creations, update and other CRUD operations. it's a easy to extend: if you want to add a new type and add its creation and other CURD , just create a new method in the abstract factory class (implement the details in the subclass). example usage: when designing an application on different platforms, methods themselves don't need to change the logic when running on different platform => create a factory class for initialize different object on different platform /* * C++ Design Patterns: Abstract Factory * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Product A * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class ProductA { public: virtual ~ ProductA() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductAX and ConcreteProductAY * define objects to be created by concrete factory */ class ConcreteProductAX : public ProductA { public: ~ ConcreteProductAX() {} const char * getName() { return \"A-X\" ; } // ... }; class ConcreteProductAY : public ProductA { public: ~ ConcreteProductAY() {} const char * getName() { return \"A-Y\" ; } // ... }; /* * Product B * same as Product A, Product B declares interface for concrete products * where each can produce an entire set of products */ class ProductB { public: virtual ~ ProductB() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductBX and ConcreteProductBY * same as previous concrete product classes */ class ConcreteProductBX : public ProductB { public: ~ ConcreteProductBX() {} const char * getName() { return \"B-X\" ; } // ... }; class ConcreteProductBY : public ProductB { public: ~ ConcreteProductBY() {} const char * getName() { return \"B-Y\" ; } // ... }; /* * Abstract Factory * provides an abstract interface for creating a family of products */ class AbstractFactory { public: virtual ~ AbstractFactory() {} virtual ProductA * createProductA() = 0 ; virtual ProductB * createProductB () = 0 ; }; /* * Concrete Factory X and Y * each concrete factory create a family of products and client uses * one of these factories so it never has to instantiate a product object */ class ConcreteFactoryX : public AbstractFactory { public: ~ ConcreteFactoryX() {} ProductA * createProductA() { return new ConcreteProductAX(); } ProductB * createProductB() { return new ConcreteProductBX(); } // ... }; class ConcreteFactoryY : public AbstractFactory { public: ~ ConcreteFactoryY() {} ProductA * createProductA() { return new ConcreteProductAY(); } ProductB * createProductB() { return new ConcreteProductBY(); } // ... }; int main () { ConcreteFactoryX * factoryX = new ConcreteFactoryX(); ConcreteFactoryY * factoryY = new ConcreteFactoryY(); ProductA * p1 = factoryX -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; ProductA * p2 = factoryY -> createProductA(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; delete p1; delete p2; delete factoryX; delete factoryY; return 0 ; } Factory Method \u00b6 When to use * a class cant anticipate the class of objects it must create * a class wants its subclasses to specify the objects it creates * classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate /* * C++ Design Patterns: Factory Method * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class Product { public: virtual ~ Product() {} virtual std :: string getName() = 0 ; // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductA : public Product { public: ~ ConcreteProductA() {} std :: string getName() { return \"type A\" ; } // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductB : public Product { public: ~ ConcreteProductB() {} std :: string getName() { return \"type B\" ; } // ... }; /* * Creator * contains the implementation for all of the methods * to manipulate products except for the factory method */ class Creator { public: virtual ~ Creator() {} virtual Product * createProductA() = 0 ; virtual Product * createProductB () = 0 ; virtual void removeProduct ( Product * product ) = 0 ; // ... }; /* * Concrete Creator * implements factory method that is responsible for creating * one or more concrete products ie. it is class that has * the knowledge of how to create the products */ class ConcreteCreator : public Creator { public: ~ ConcreteCreator() {} Product * createProductA() { return new ConcreteProductA(); } Product * createProductB() { return new ConcreteProductB(); } void removeProduct( Product * product ) { delete product; } // ... }; int main () { Creator * creator = new ConcreteCreator(); Product * p1 = creator -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; creator -> removeProduct( p1 ); Product * p2 = creator -> createProductB(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; creator -> removeProduct( p2 ); delete creator; return 0 ; } Vending Machine \u00b6 no need to talk about how many user using (distribute system design) Data \u00b6 item vending machine Action \u00b6 buy/purchase: input (item id, money) and output (item, remain money) input and return type: int, Item exceptions (could talk later in details): if there is no more items remaining, or there is not enough money could talk about use case: assumption (money for change is efficient), use the most familiar one for your use case. Class \u00b6 Item (first design the most fundmental class) price: int name/id: int/string type Vending Machine money remaining: int colllection of Item: unordered_map -> unordered_map Item: should represent type of item instead of specific item -> add a field in item for type buy/purchase API more: if there are multiple tracks Elevator Simulator \u00b6 start from use case (discuss with the interviewer): 1. show level button or just up and down then select inside the elevator 2. swipe card to validate or not 3. support for multiple elevator -> design elevator system 4. how to schedule (it could be discussed later): support different types of requests 5. What is elevator's state in each \"iteration\" (per floor) State to determine attribute \u00b6 which floor first floor: up or down (outstanding request to go up or down), open or close door (people load or unload from the elevator) -> next iteration is on second floor (if go up) -> do the same thing for 1 st floor move up or move down weight/headcount and capacity -> if overload what to do when reach a floor what to determine to open or not: depends on the request (from outside or inside people) after open door: get in and get out -> next requests determine whether to change the direction Data \u00b6 maxCapacity maxFloor load location Action \u00b6 open/close door floor going up or down Class \u00b6 System Management (Building) how many elevator going up or down map > Elevator vector : good for encapsulation User (no need -> too detailed) Floor (no need -> too detailed and not relate to action) Request up and down from which floor make the request Scheduling (Final Step) \u00b6 Each elevator makes its own decision check Up/Down requests the 1 st elevator arriving at the floor takes the request with the same direction the elevator loads ppl at the floor and handles their requests Parking Lot \u00b6 Steps: understand/analyze the functionality and its use case use case -> functionality -> APIs one level or multiple levels? parking-spot / vehicle sizes? track the location of each vehicle? Drive in: input is a car, and output could be number of spot, boolean for if possible to be parked, ticket, etc. Why it has some many solutions? Because of use case. Drive out: input is a ticket (money), car object, and output could be a boolean for if car actually exited, or a number for spots left APIs input output specific / important components Design Classes input / output DATA -> physical entities Parking Lot: CORE class -> store the main functionalities Car: physical entity Ticket: physical entity (depends on use case) Parking Spot (optional): track different sized car, visited only, clean energy, etc. level? no need, just a member field in parking lot; need, each level has many different attributes to be considered Class relationships association: a general binary relationship that describes an activity between two classes vehicle -- parking spot: a vehicle can park at a specific parking spot aggregation/composition: has-a inheritance vehicle -- car, truck Member fields and Methods of Class \u00b6 No need to have specific implementation at first Functionality Basic Functionality: for a given vehicle, tell whether there is avaliable spot in the parking lot possible extensions: provide avaliable spot locations, assign spot to the vehicle, ... assume there are multiple levels ENUM hard to be wrong used e.g. : weekday using int -> 8? doesn't exist class ParkingLot { private: vector < Level > levels; // what if no level class? -> 2d array to represent the spot in different level public: bool hasSpot(Vehicle v) { // check each level, for each level, call Level#hasSpot(Vehicle) } } class Level { /* public: bool hasSpot(Vehicle v) { // check current level, if has spot } */ } enum SIZE{suv, truck, eco} class ParkingSpot { private: enum SIZE size; // bool fit(Vehice): check size and avaliability } class Vehicle { public: // data field virtual int getSize() = 0 ; } Implementation \u00b6 no need to complete the entire implementation during the interview, just finish the core functions Exception Handler, Comparator (for enum?)","title":"Ood"},{"location":"Interview/ood/#design-pattern","text":"https://github.com/JakubVojvoda/design-patterns-cpp","title":"Design Pattern"},{"location":"Interview/ood/#builder","text":"if there are a lot of fields in a class, cannot put them all in as parameters in the constructor. solution 0: define final and optional data fields in the class (no need to initialize in the constructor => bad because it could generate a lot of dfferent types of constructors. solution 1: use setter and getter => bad because if want to create an object, user has to call all the setters and getters (constructor isn't doing what it is supposed to do: dangerous in multi-threading) => encapsulation is destroyed => e.g. setters' member field might not want to be changed OR setters are not changed in the desire way solution 2: encapsulate the related fields into a single function, use an abstract class to manage the top level abstraction and some concrete subclasses to manage the specific constructions. Core: create a builder class for top level abstraction and subclasses for specific constructions. When implementing, don't forget to #include \"builder.hpp\" . /* * C++ Design Patterns: Builder * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * the final object that will be created using Builder */ class Product { public: void makeA( const std :: string & part ) { partA = part; } void makeB( const std :: string & part ) { partB = part; } void makeC( const std :: string & part ) { partC = part; } std :: string get() { return (partA + \" \" + partB + \" \" + partC); } // ... private: std :: string partA; std :: string partB; std :: string partC; // ... }; /* * Builder * abstract interface for creating products */ class Builder { public: virtual ~ Builder() {} Product get() { return product; } virtual void buildPartA() = 0 ; virtual void buildPartB () = 0 ; virtual void buildPartC () = 0 ; // ... protected: Product product; }; /* * Concrete Builder X and Y * create real products and stores them in the composite structure */ class ConcreteBuilderX : public Builder { public: void buildPartA() { product.makeA( \"A-X\" ); } void buildPartB() { product.makeB( \"B-X\" ); } void buildPartC() { product.makeC( \"C-X\" ); } // ... }; class ConcreteBuilderY : public Builder { public: void buildPartA() { product.makeA( \"A-Y\" ); } void buildPartB() { product.makeB( \"B-Y\" ); } void buildPartC() { product.makeC( \"C-Y\" ); } // ... }; /* * Director * responsible for managing the correct sequence of object creation */ class Director { public: Director() : builder() {} ~ Director() { if ( builder ) { delete builder; } } void set( Builder * b ) { if ( builder ) { delete builder; } builder = b; } Product get() { return builder -> get(); } void construct() { builder -> buildPartA(); builder -> buildPartB(); builder -> buildPartC(); // ... } // ... private: Builder * builder; }; int main () { Director director; director.set( new ConcreteBuilderX ); director.construct(); Product product1 = director.get(); std :: cout << \"1st product parts: \" << product1.get() << std :: endl; director.set( new ConcreteBuilderY ); director.construct(); Product product2 = director.get(); std :: cout << \"2nd product parts: \" << product2.get() << std :: endl; return 0 ; }","title":"Builder"},{"location":"Interview/ood/#abstract-factory","text":"polymorphism: use an abstract class to include the shared method getName() multiple different classes create the same type of object with the shared method for creations, update and other CRUD operations. it's a easy to extend: if you want to add a new type and add its creation and other CURD , just create a new method in the abstract factory class (implement the details in the subclass). example usage: when designing an application on different platforms, methods themselves don't need to change the logic when running on different platform => create a factory class for initialize different object on different platform /* * C++ Design Patterns: Abstract Factory * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Product A * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class ProductA { public: virtual ~ ProductA() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductAX and ConcreteProductAY * define objects to be created by concrete factory */ class ConcreteProductAX : public ProductA { public: ~ ConcreteProductAX() {} const char * getName() { return \"A-X\" ; } // ... }; class ConcreteProductAY : public ProductA { public: ~ ConcreteProductAY() {} const char * getName() { return \"A-Y\" ; } // ... }; /* * Product B * same as Product A, Product B declares interface for concrete products * where each can produce an entire set of products */ class ProductB { public: virtual ~ ProductB() {} virtual const char * getName() = 0 ; // ... }; /* * ConcreteProductBX and ConcreteProductBY * same as previous concrete product classes */ class ConcreteProductBX : public ProductB { public: ~ ConcreteProductBX() {} const char * getName() { return \"B-X\" ; } // ... }; class ConcreteProductBY : public ProductB { public: ~ ConcreteProductBY() {} const char * getName() { return \"B-Y\" ; } // ... }; /* * Abstract Factory * provides an abstract interface for creating a family of products */ class AbstractFactory { public: virtual ~ AbstractFactory() {} virtual ProductA * createProductA() = 0 ; virtual ProductB * createProductB () = 0 ; }; /* * Concrete Factory X and Y * each concrete factory create a family of products and client uses * one of these factories so it never has to instantiate a product object */ class ConcreteFactoryX : public AbstractFactory { public: ~ ConcreteFactoryX() {} ProductA * createProductA() { return new ConcreteProductAX(); } ProductB * createProductB() { return new ConcreteProductBX(); } // ... }; class ConcreteFactoryY : public AbstractFactory { public: ~ ConcreteFactoryY() {} ProductA * createProductA() { return new ConcreteProductAY(); } ProductB * createProductB() { return new ConcreteProductBY(); } // ... }; int main () { ConcreteFactoryX * factoryX = new ConcreteFactoryX(); ConcreteFactoryY * factoryY = new ConcreteFactoryY(); ProductA * p1 = factoryX -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; ProductA * p2 = factoryY -> createProductA(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; delete p1; delete p2; delete factoryX; delete factoryY; return 0 ; }","title":"Abstract Factory"},{"location":"Interview/ood/#factory-method","text":"When to use * a class cant anticipate the class of objects it must create * a class wants its subclasses to specify the objects it creates * classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegate /* * C++ Design Patterns: Factory Method * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> #include <string> /* * Product * products implement the same interface so that the classes can refer * to the interface not the concrete product */ class Product { public: virtual ~ Product() {} virtual std :: string getName() = 0 ; // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductA : public Product { public: ~ ConcreteProductA() {} std :: string getName() { return \"type A\" ; } // ... }; /* * Concrete Product * define product to be created */ class ConcreteProductB : public Product { public: ~ ConcreteProductB() {} std :: string getName() { return \"type B\" ; } // ... }; /* * Creator * contains the implementation for all of the methods * to manipulate products except for the factory method */ class Creator { public: virtual ~ Creator() {} virtual Product * createProductA() = 0 ; virtual Product * createProductB () = 0 ; virtual void removeProduct ( Product * product ) = 0 ; // ... }; /* * Concrete Creator * implements factory method that is responsible for creating * one or more concrete products ie. it is class that has * the knowledge of how to create the products */ class ConcreteCreator : public Creator { public: ~ ConcreteCreator() {} Product * createProductA() { return new ConcreteProductA(); } Product * createProductB() { return new ConcreteProductB(); } void removeProduct( Product * product ) { delete product; } // ... }; int main () { Creator * creator = new ConcreteCreator(); Product * p1 = creator -> createProductA(); std :: cout << \"Product: \" << p1 -> getName() << std :: endl; creator -> removeProduct( p1 ); Product * p2 = creator -> createProductB(); std :: cout << \"Product: \" << p2 -> getName() << std :: endl; creator -> removeProduct( p2 ); delete creator; return 0 ; }","title":"Factory Method"},{"location":"Interview/ood/#vending-machine","text":"no need to talk about how many user using (distribute system design)","title":"Vending Machine"},{"location":"Interview/ood/#data","text":"item vending machine","title":"Data"},{"location":"Interview/ood/#action","text":"buy/purchase: input (item id, money) and output (item, remain money) input and return type: int, Item exceptions (could talk later in details): if there is no more items remaining, or there is not enough money could talk about use case: assumption (money for change is efficient), use the most familiar one for your use case.","title":"Action"},{"location":"Interview/ood/#class","text":"Item (first design the most fundmental class) price: int name/id: int/string type Vending Machine money remaining: int colllection of Item: unordered_map -> unordered_map Item: should represent type of item instead of specific item -> add a field in item for type buy/purchase API more: if there are multiple tracks","title":"Class"},{"location":"Interview/ood/#elevator-simulator","text":"start from use case (discuss with the interviewer): 1. show level button or just up and down then select inside the elevator 2. swipe card to validate or not 3. support for multiple elevator -> design elevator system 4. how to schedule (it could be discussed later): support different types of requests 5. What is elevator's state in each \"iteration\" (per floor)","title":"Elevator Simulator"},{"location":"Interview/ood/#state-to-determine-attribute","text":"which floor first floor: up or down (outstanding request to go up or down), open or close door (people load or unload from the elevator) -> next iteration is on second floor (if go up) -> do the same thing for 1 st floor move up or move down weight/headcount and capacity -> if overload what to do when reach a floor what to determine to open or not: depends on the request (from outside or inside people) after open door: get in and get out -> next requests determine whether to change the direction","title":"State to determine attribute"},{"location":"Interview/ood/#data_1","text":"maxCapacity maxFloor load location","title":"Data"},{"location":"Interview/ood/#action_1","text":"open/close door floor going up or down","title":"Action"},{"location":"Interview/ood/#class_1","text":"System Management (Building) how many elevator going up or down map > Elevator vector : good for encapsulation User (no need -> too detailed) Floor (no need -> too detailed and not relate to action) Request up and down from which floor make the request","title":"Class"},{"location":"Interview/ood/#scheduling-final-step","text":"Each elevator makes its own decision check Up/Down requests the 1 st elevator arriving at the floor takes the request with the same direction the elevator loads ppl at the floor and handles their requests","title":"Scheduling (Final Step)"},{"location":"Interview/ood/#parking-lot","text":"Steps: understand/analyze the functionality and its use case use case -> functionality -> APIs one level or multiple levels? parking-spot / vehicle sizes? track the location of each vehicle? Drive in: input is a car, and output could be number of spot, boolean for if possible to be parked, ticket, etc. Why it has some many solutions? Because of use case. Drive out: input is a ticket (money), car object, and output could be a boolean for if car actually exited, or a number for spots left APIs input output specific / important components Design Classes input / output DATA -> physical entities Parking Lot: CORE class -> store the main functionalities Car: physical entity Ticket: physical entity (depends on use case) Parking Spot (optional): track different sized car, visited only, clean energy, etc. level? no need, just a member field in parking lot; need, each level has many different attributes to be considered Class relationships association: a general binary relationship that describes an activity between two classes vehicle -- parking spot: a vehicle can park at a specific parking spot aggregation/composition: has-a inheritance vehicle -- car, truck","title":"Parking Lot"},{"location":"Interview/ood/#member-fields-and-methods-of-class","text":"No need to have specific implementation at first Functionality Basic Functionality: for a given vehicle, tell whether there is avaliable spot in the parking lot possible extensions: provide avaliable spot locations, assign spot to the vehicle, ... assume there are multiple levels ENUM hard to be wrong used e.g. : weekday using int -> 8? doesn't exist class ParkingLot { private: vector < Level > levels; // what if no level class? -> 2d array to represent the spot in different level public: bool hasSpot(Vehicle v) { // check each level, for each level, call Level#hasSpot(Vehicle) } } class Level { /* public: bool hasSpot(Vehicle v) { // check current level, if has spot } */ } enum SIZE{suv, truck, eco} class ParkingSpot { private: enum SIZE size; // bool fit(Vehice): check size and avaliability } class Vehicle { public: // data field virtual int getSize() = 0 ; }","title":"Member fields and Methods of Class"},{"location":"Interview/ood/#implementation","text":"no need to complete the entire implementation during the interview, just finish the core functions Exception Handler, Comparator (for enum?)","title":"Implementation"},{"location":"Interview/rectangle--2d-dp/","text":"Longest Cross Of 1s \u00b6 Given a matrix that contains only 1s and 0s, find the largest cross which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest cross. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest cross of 1s has arm length 2. Analysis \u00b6 Use the same prefix sum technique to solve this problem: 1. prefix sum from left to i, j 2. prefix sum from right to i, j 3. prefix sum from top to i, j 4. prefix sum from bottom to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public: struct Node { int left, right, down, up; int minVal () { return min({left, right, down, up}); } void setRD ( int val) { right = val; down = val; } void setLU ( int val) { left = val; up = val; } }; int largest (vector < vector < int >> matrix) { // write your solution here int m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); int res = 0 ; for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int one = matrix[i][j]; dp[i][j].setRD(one); if (i != 0 && one) dp[i][j].right = dp[i - 1 ][j].right + 1 ; if (j != 0 && one) dp[i][j].down = dp[i][j - 1 ].down + 1 ; } } // Note: direction is reversed, or there is no precalculation for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int one = matrix[i][j]; dp[i][j].setLU(one); if (i != m - 1 && one) dp[i][j].left = dp[i + 1 ][j].left + 1 ; if (j != n - 1 && one) dp[i][j].up = dp[i][j + 1 ].up + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } }; Largest X Of 1s \u00b6 Given a matrix that contains only 1s and 0s, find the largest X shape which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest X shape. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest X of 1s has arm length 2. Analysis \u00b6 Same as the largest Cross of 1s, it calcualte the the presum for diagonal axis: 1. prefix sum from top left to i, j 2. prefix sum from top right to i, j 3. prefix sum from bottom left to i, j 4. prefix sum from bottom left to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public: struct Node { int nw, ne, sw, se; void setN ( int val) { nw = ne = val; } void setS ( int val) { sw = se = val; } int minVal () { return min({nw, ne, sw, se}); } }; int largest (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].setN(val); if (val == 0 ) continue ; if (i != 0 && j != 0 ) dp[i][j].nw = dp[i - 1 ][j - 1 ].nw + 1 ; if (i != 0 && j != n - 1 ) dp[i][j].ne = dp[i - 1 ][j + 1 ].ne + 1 ; } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].setS(val); if (val == 0 ) continue ; if (i != m - 1 && j != 0 ) dp[i][j].sw = dp[i + 1 ][j - 1 ].sw + 1 ; if (i != m - 1 && j != n - 1 ) dp[i][j].se = dp[i + 1 ][j + 1 ].se + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } }; Largest Square Surrounded By One \u00b6 Determine the largest square surrounded by 1s in a binary matrix (a binary matrix only contains 0 and 1), return the length of the largest square. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{1, 0, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 0, 1, 0}, {1, 1, 1, 1, 1}, {1, 1, 1, 0, 0}} The largest square surrounded by 1s has length of 3. Analysis \u00b6 Cannot just count the largest square that is all zero, because below case is also valid: 1111 \\ 1011 \\ 1111 \\ 1111 and the answer is 4. In order to find the largest submatrix, we need to determine the smallest \"stretching length\" for its width and height. To find the \"stretching\" width and height, we can use prefix sum to do so. After we maintained the two \"stretching length\", we should find the minimal and find the longest size of the submatrix. Time: O(m \\times n \\times max(m, n)) O(m \\times n \\times max(m, n)) Space: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public: struct Node { int hor, ver; int minVal () { return min(hor, ver); } void set ( int val) { hor = ver = val; } }; int largestSquareSurroundedByOne (vector < vector < int >> matrix) { if (matrix.empty() || matrix[ 0 ].empty()) return 0 ; int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].set(val); if (val == 1 ) { if (i != 0 ) dp[i][j].ver = dp[i - 1 ][j].ver + 1 ; if (j != 0 ) dp[i][j].hor = dp[i][j - 1 ].hor + 1 ; } } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int small = dp[i][j].minVal(); while (small > res) { // horizonal grow requires vertial has the same stretching size, vice versa for vertial grow if (dp[i][j - small + 1 ].ver >= small && dp[i - small + 1 ][j].hor >= small) res = small; small -- ; } } } return res; } }; Largest Square Of Matches \u00b6 Determine the largest square surrounded by a bunch of matches (each match is either horizontal or vertical), return the length of the largest square. The input is a matrix of points. Each point has one of the following values: 0 - there is no match to its right or bottom. 1 - there is a match to its right. 2 - there is a match to its bottom. 3 - there is a match to its right, and a match to its bottom. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{3, 1, 1, 3, 0, 1, 1, 0}, {2, 0, 0, 2, 0, 0, 0, 0}, {3, 1, 3, 0, 0, 0, 0, 0}, {2, 0, 2, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0}} This matrix represents the following bunch of matches: The largest square has length of 2. Analysis \u00b6 Use the same presum technique by defining two direction: left and top 1. if matrix[i][j] == 1 || matrix[i][j] == 3: dp[i][j].left = dp[i][j + 1].left + 1; 2. if matrix[i][j] == 2 || matrix[i][j] == 3: dp[i][j].top = dp[i + 1][j].top + 1; Note that it's [i][j + 1] and [i + 1][j] , which means we need to make sure the two locations have already populated, so we should going from bottom to top and right to left. Also note that the way to find largest submatrix is different from largest square surround by ones, because the direction of the presum is flipped. And the element stored is offset by 1, because the number represent the number of matches on its right or top, so we need to check one more. Time: O(m \\times n \\times max(n, m)) O(m \\times n \\times max(n, m)) Space: O(m \\times n) O(m \\times n) Code \u00b6 class Solution { public: struct Node { int left, top; int minVal () { return min(left, top); } void set ( int val) { left = top = val; } }; int largestSquareOfMatches (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].set( 0 ); if ((val == 1 || val == 3 ) && j != n - 1 ) dp[i][j].left = dp[i][j + 1 ].left + 1 ; if ((val == 2 || val == 3 ) && i != m - 1 ) dp[i][j].top = dp[i + 1 ][j].top + 1 ; } } for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int small = dp[i][j].minVal(); while (small > res) { // j + small but not j + small - 1 if (dp[i][j + small].top >= small && dp[i + small][j].left >= small) res = small; small -- ; } } } return res; } }; Largest SubMatrix Sum \u00b6 Given a matrix that contains integers, find the submatrix with the largest sum. Return the sum of the submatrix. Assumptions The given matrix is not null and has size of M * N, where M >= 1 and N >= 1 Examples { {1, -2, -1, 4}, {1, -1, 1, 1}, {0, -1, -1, 1}, {0, 0, 1, 1} } the largest submatrix sum is (-1) + 4 + 1 + 1 + (-1) + 1 + 1 + 1 = 7. Analysis \u00b6 Imagine there are two horizon lines split the matrix into three parts: xxxx yyyy yyyy xxxx Your job is to find the maximum area sum generated by the two line (max y's sum). If we can compress the area between the two horizon lines, we can use the technique for finding the largest subarray sum to solve this problem. Time: O(n \\times n \\times m) O(n \\times n \\times m) or O(min(m, n)^2 \\times max(m, n)) O(min(m, n)^2 \\times max(m, n)) Space: because we just need one 1-d presum array: O(min(m, n)) O(min(m, n)) Code \u00b6 class Solution { public: int largest(vector < vector < int >> matrix) { int res = matrix[ 0 ][ 0 ], m = matrix.size(), n = matrix[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { vector < int > preSum(n); // keep adding from i - j rows' sum for ( int j = i; j < m; ++ j) { for ( int k = 0 ; k < n; ++ k) preSum[k] += matrix[j][k]; int currMax = preSum[ 0 ]; for ( int k = 1 ; k < n; ++ k) { // find largest subarray currMax = max(currMax + preSum[k], preSum[k]); res = max(res, currMax); } } } return res; } };","title":"Rectangle  2d dp"},{"location":"Interview/rectangle--2d-dp/#longest-cross-of-1s","text":"Given a matrix that contains only 1s and 0s, find the largest cross which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest cross. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest cross of 1s has arm length 2.","title":"Longest Cross Of 1s"},{"location":"Interview/rectangle--2d-dp/#analysis","text":"Use the same prefix sum technique to solve this problem: 1. prefix sum from left to i, j 2. prefix sum from right to i, j 3. prefix sum from top to i, j 4. prefix sum from bottom to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle--2d-dp/#code","text":"class Solution { public: struct Node { int left, right, down, up; int minVal () { return min({left, right, down, up}); } void setRD ( int val) { right = val; down = val; } void setLU ( int val) { left = val; up = val; } }; int largest (vector < vector < int >> matrix) { // write your solution here int m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); int res = 0 ; for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int one = matrix[i][j]; dp[i][j].setRD(one); if (i != 0 && one) dp[i][j].right = dp[i - 1 ][j].right + 1 ; if (j != 0 && one) dp[i][j].down = dp[i][j - 1 ].down + 1 ; } } // Note: direction is reversed, or there is no precalculation for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int one = matrix[i][j]; dp[i][j].setLU(one); if (i != m - 1 && one) dp[i][j].left = dp[i + 1 ][j].left + 1 ; if (j != n - 1 && one) dp[i][j].up = dp[i][j + 1 ].up + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } };","title":"Code"},{"location":"Interview/rectangle--2d-dp/#largest-x-of-1s","text":"Given a matrix that contains only 1s and 0s, find the largest X shape which contains only 1s, with the same arm lengths and the four arms joining at the central point. Return the arm length of the largest X shape. Assumptions The given matrix is not null, has size of N * M, N >= 0 and M >= 0. Examples { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}, {1, 0, 1, 1} } the largest X of 1s has arm length 2.","title":"Largest X Of 1s"},{"location":"Interview/rectangle--2d-dp/#analysis_1","text":"Same as the largest Cross of 1s, it calcualte the the presum for diagonal axis: 1. prefix sum from top left to i, j 2. prefix sum from top right to i, j 3. prefix sum from bottom left to i, j 4. prefix sum from bottom left to i, j After finishing the calcualtion, we find the min of each prefix sum on curr i, j, update the answer with the larger min prefix sum. Time: O(m \\times n) O(m \\times n) Time: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle--2d-dp/#code_1","text":"class Solution { public: struct Node { int nw, ne, sw, se; void setN ( int val) { nw = ne = val; } void setS ( int val) { sw = se = val; } int minVal () { return min({nw, ne, sw, se}); } }; int largest (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].setN(val); if (val == 0 ) continue ; if (i != 0 && j != 0 ) dp[i][j].nw = dp[i - 1 ][j - 1 ].nw + 1 ; if (i != 0 && j != n - 1 ) dp[i][j].ne = dp[i - 1 ][j + 1 ].ne + 1 ; } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].setS(val); if (val == 0 ) continue ; if (i != m - 1 && j != 0 ) dp[i][j].sw = dp[i + 1 ][j - 1 ].sw + 1 ; if (i != m - 1 && j != n - 1 ) dp[i][j].se = dp[i + 1 ][j + 1 ].se + 1 ; } } for ( int i = 0 ; i < m; ++ i) for ( int j = 0 ; j < n; ++ j) res = max(res, dp[i][j].minVal()); return res; } };","title":"Code"},{"location":"Interview/rectangle--2d-dp/#largest-square-surrounded-by-one","text":"Determine the largest square surrounded by 1s in a binary matrix (a binary matrix only contains 0 and 1), return the length of the largest square. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{1, 0, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 0, 1, 0}, {1, 1, 1, 1, 1}, {1, 1, 1, 0, 0}} The largest square surrounded by 1s has length of 3.","title":"Largest Square Surrounded By One"},{"location":"Interview/rectangle--2d-dp/#analysis_2","text":"Cannot just count the largest square that is all zero, because below case is also valid: 1111 \\ 1011 \\ 1111 \\ 1111 and the answer is 4. In order to find the largest submatrix, we need to determine the smallest \"stretching length\" for its width and height. To find the \"stretching\" width and height, we can use prefix sum to do so. After we maintained the two \"stretching length\", we should find the minimal and find the longest size of the submatrix. Time: O(m \\times n \\times max(m, n)) O(m \\times n \\times max(m, n)) Space: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle--2d-dp/#code_2","text":"class Solution { public: struct Node { int hor, ver; int minVal () { return min(hor, ver); } void set ( int val) { hor = ver = val; } }; int largestSquareSurroundedByOne (vector < vector < int >> matrix) { if (matrix.empty() || matrix[ 0 ].empty()) return 0 ; int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int val = matrix[i][j]; dp[i][j].set(val); if (val == 1 ) { if (i != 0 ) dp[i][j].ver = dp[i - 1 ][j].ver + 1 ; if (j != 0 ) dp[i][j].hor = dp[i][j - 1 ].hor + 1 ; } } } for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int small = dp[i][j].minVal(); while (small > res) { // horizonal grow requires vertial has the same stretching size, vice versa for vertial grow if (dp[i][j - small + 1 ].ver >= small && dp[i - small + 1 ][j].hor >= small) res = small; small -- ; } } } return res; } };","title":"Code"},{"location":"Interview/rectangle--2d-dp/#largest-square-of-matches","text":"Determine the largest square surrounded by a bunch of matches (each match is either horizontal or vertical), return the length of the largest square. The input is a matrix of points. Each point has one of the following values: 0 - there is no match to its right or bottom. 1 - there is a match to its right. 2 - there is a match to its bottom. 3 - there is a match to its right, and a match to its bottom. Assumptions The given matrix is guaranteed to be of size M * N, where M, N >= 0 Examples {{3, 1, 1, 3, 0, 1, 1, 0}, {2, 0, 0, 2, 0, 0, 0, 0}, {3, 1, 3, 0, 0, 0, 0, 0}, {2, 0, 2, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0}} This matrix represents the following bunch of matches: The largest square has length of 2.","title":"Largest Square Of Matches"},{"location":"Interview/rectangle--2d-dp/#analysis_3","text":"Use the same presum technique by defining two direction: left and top 1. if matrix[i][j] == 1 || matrix[i][j] == 3: dp[i][j].left = dp[i][j + 1].left + 1; 2. if matrix[i][j] == 2 || matrix[i][j] == 3: dp[i][j].top = dp[i + 1][j].top + 1; Note that it's [i][j + 1] and [i + 1][j] , which means we need to make sure the two locations have already populated, so we should going from bottom to top and right to left. Also note that the way to find largest submatrix is different from largest square surround by ones, because the direction of the presum is flipped. And the element stored is offset by 1, because the number represent the number of matches on its right or top, so we need to check one more. Time: O(m \\times n \\times max(n, m)) O(m \\times n \\times max(n, m)) Space: O(m \\times n) O(m \\times n)","title":"Analysis"},{"location":"Interview/rectangle--2d-dp/#code_3","text":"class Solution { public: struct Node { int left, top; int minVal () { return min(left, top); } void set ( int val) { left = top = val; } }; int largestSquareOfMatches (vector < vector < int >> matrix) { int res = 0 , m = matrix.size(), n = matrix[ 0 ].size(); Node dp[m][n]; memset(dp, 0 , sizeof dp); for ( int i = m - 1 ; i >= 0 ; -- i) { for ( int j = n - 1 ; j >= 0 ; -- j) { int val = matrix[i][j]; dp[i][j].set( 0 ); if ((val == 1 || val == 3 ) && j != n - 1 ) dp[i][j].left = dp[i][j + 1 ].left + 1 ; if ((val == 2 || val == 3 ) && i != m - 1 ) dp[i][j].top = dp[i + 1 ][j].top + 1 ; } } for ( int i = 0 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { int small = dp[i][j].minVal(); while (small > res) { // j + small but not j + small - 1 if (dp[i][j + small].top >= small && dp[i + small][j].left >= small) res = small; small -- ; } } } return res; } };","title":"Code"},{"location":"Interview/rectangle--2d-dp/#largest-submatrix-sum","text":"Given a matrix that contains integers, find the submatrix with the largest sum. Return the sum of the submatrix. Assumptions The given matrix is not null and has size of M * N, where M >= 1 and N >= 1 Examples { {1, -2, -1, 4}, {1, -1, 1, 1}, {0, -1, -1, 1}, {0, 0, 1, 1} } the largest submatrix sum is (-1) + 4 + 1 + 1 + (-1) + 1 + 1 + 1 = 7.","title":"Largest SubMatrix Sum"},{"location":"Interview/rectangle--2d-dp/#analysis_4","text":"Imagine there are two horizon lines split the matrix into three parts: xxxx yyyy yyyy xxxx Your job is to find the maximum area sum generated by the two line (max y's sum). If we can compress the area between the two horizon lines, we can use the technique for finding the largest subarray sum to solve this problem. Time: O(n \\times n \\times m) O(n \\times n \\times m) or O(min(m, n)^2 \\times max(m, n)) O(min(m, n)^2 \\times max(m, n)) Space: because we just need one 1-d presum array: O(min(m, n)) O(min(m, n))","title":"Analysis"},{"location":"Interview/rectangle--2d-dp/#code_4","text":"class Solution { public: int largest(vector < vector < int >> matrix) { int res = matrix[ 0 ][ 0 ], m = matrix.size(), n = matrix[ 0 ].size(); for ( int i = 0 ; i < m; ++ i) { vector < int > preSum(n); // keep adding from i - j rows' sum for ( int j = i; j < m; ++ j) { for ( int k = 0 ; k < n; ++ k) preSum[k] += matrix[j][k]; int currMax = preSum[ 0 ]; for ( int k = 1 ; k < n; ++ k) { // find largest subarray currMax = max(currMax + preSum[k], preSum[k]); res = max(res, currMax); } } } return res; } };","title":"Code"},{"location":"Interview/rectangle/","text":"Find max area in binary matrix (0, 1) where the inside the square are 0s and the perimeter is 1s \u00b6 https://docs.google.com/document/d/1FVkdwM83-g49zJdbrxQocgDM_hMvhTUsWyKB8NXc-ew/edit","title":"Rectangle"},{"location":"Interview/rectangle/#find-max-area-in-binary-matrix-0-1-where-the-inside-the-square-are-0s-and-the-perimeter-is-1s","text":"https://docs.google.com/document/d/1FVkdwM83-g49zJdbrxQocgDM_hMvhTUsWyKB8NXc-ew/edit","title":"Find max area in binary matrix (0, 1) where the inside the square are 0s and the perimeter is 1s"},{"location":"Interview/recursion-tree/","text":"Is tree symmetric \u00b6 Recurison Tree \u00b6 Solution \u00b6 bool isSymmetric(left, right) if left == null and right == null return true else if left == null || right == null return false else if left.val != right.val return false else return isSymmetric(left.left, right.right) and isSymmetric(left.right, right.left) Time = O(n/2)=O(n) Calculate Time Complexity \u00b6 Branch Factor: b Height: h Total Complexity: b^h b^h","title":"Recursion tree"},{"location":"Interview/recursion-tree/#is-tree-symmetric","text":"","title":"Is tree symmetric"},{"location":"Interview/recursion-tree/#recurison-tree","text":"","title":"Recurison Tree"},{"location":"Interview/recursion-tree/#solution","text":"bool isSymmetric(left, right) if left == null and right == null return true else if left == null || right == null return false else if left.val != right.val return false else return isSymmetric(left.left, right.right) and isSymmetric(left.right, right.left) Time = O(n/2)=O(n)","title":"Solution"},{"location":"Interview/recursion-tree/#calculate-time-complexity","text":"Branch Factor: b Height: h Total Complexity: b^h b^h","title":"Calculate Time Complexity"},{"location":"Interview/recursion/","text":"Fibonacci Sequence \u00b6 Clarification Assumption Result Test Time Complexity: total nodes of the recursion tree Space Complexity: call stack (typically equals to the height of the recursion tree) Naive Approach \u00b6 int fib ( int n) { if (n == 0 || n == 1 ) return n; return fib(n - 1 ) + fib(n - 2 ); } Time: 2^0+2^1+2^2...+2^n \\approx 2^n 2^0+2^1+2^2...+2^n \\approx 2^n Space: n pow(a, b) \u00b6 don't care the case for a == 0 or b < 0 for now Naive Approach \u00b6 int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b - 1 ) * a; } analysis \u00b6 recursion tree: 2^999 | 2^998 | 2^997 | 2^996 ... there are b nodes and the longest path is b Time: O(b) Space: O(b) Optimize Space \u00b6 int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b / 2 ) * pow(a, b - b / 2 ); // why not using b/2? because 3/2 = 1.5 = 1 } 2^999 | | 2^500 2^499 | | | | 250 250 250 249 ... there are 1 + 2 + 4 + ... 2^log(b) = b => time: O(b) Space: O(log(b))","title":"Recursion"},{"location":"Interview/recursion/#fibonacci-sequence","text":"Clarification Assumption Result Test Time Complexity: total nodes of the recursion tree Space Complexity: call stack (typically equals to the height of the recursion tree)","title":"Fibonacci Sequence"},{"location":"Interview/recursion/#naive-approach","text":"int fib ( int n) { if (n == 0 || n == 1 ) return n; return fib(n - 1 ) + fib(n - 2 ); } Time: 2^0+2^1+2^2...+2^n \\approx 2^n 2^0+2^1+2^2...+2^n \\approx 2^n Space: n","title":"Naive Approach"},{"location":"Interview/recursion/#powa-b","text":"don't care the case for a == 0 or b < 0 for now","title":"pow(a, b)"},{"location":"Interview/recursion/#naive-approach_1","text":"int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b - 1 ) * a; }","title":"Naive Approach"},{"location":"Interview/recursion/#analysis","text":"recursion tree: 2^999 | 2^998 | 2^997 | 2^996 ... there are b nodes and the longest path is b Time: O(b) Space: O(b)","title":"analysis"},{"location":"Interview/recursion/#optimize-space","text":"int pow ( int a, int b) { if (b == 0 ) return 1 ; return pow(a, b / 2 ) * pow(a, b - b / 2 ); // why not using b/2? because 3/2 = 1.5 = 1 } 2^999 | | 2^500 2^499 | | | | 250 250 250 249 ... there are 1 + 2 + 4 + ... 2^log(b) = b => time: O(b) Space: O(log(b))","title":"Optimize Space"},{"location":"Interview/reviews/","text":"6/5 \u00b6","title":"Reviews"},{"location":"Interview/reviews/#65","text":"","title":"6/5"},{"location":"Interview/russian-roll/","text":"Input: Method 1: DFS \u00b6 Try each envelope as starting point and stack all the other avaliable envelopes. Level 1: n Level 2: n * (n - 1) Level 3: n * (n - 1) * (n - 2) ... Level n: O(n!) O(n!) Space: O(n) O(n) Method 2: Sort + DFS \u00b6 Sort by width and run DFS once: skip all the nodes if already included in previous iteration Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result) Method 3: Sort + DP (longest increasing subsequence) \u00b6 sort by width height after sorted (1,1,3,2,2,4) -- assume using stable sort check LIS from the hight array find the first height to the left of the current height that is less than the current height this will take O(n) O(n) to find such element Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result) Solution \u00b6 Optimize DP (Space and Time) \u00b6 delete the previous one (M[i]) if array[i] > array[i+1] and M[i] <= M[i+1] But if already sorted from low to high -> space stays the same create an array for storing the lowest ending at current index Then use binary search with O(log_2{n}) O(log_2{n}) Time: O(n \\times log_2{n}) O(n \\times log_2{n}) Space: O(n) O(n) will be less than n since LIS might not be continuous Pitfall \u00b6 When sort: if width is the same, higher height sort first (same width cannot stack together) So we need to rewrite the comparator such that when two width are the same, choose the one with higher height Solution Code \u00b6 #include <bits/stdc++.h> using namespace std; int main () { int n; cin >> n; pair < int , int > env[n]; for ( int i = 0 ; i < n; ++ i) { cin >> env[i].first; cin >> env[i].second; } sort(env, env + n, []( const pair < int , int >& l, const pair < int , int >& r) { return l.first < r.first || (l.first == r.first && l.second > r.second); }); vector < int > dp; for ( auto p : env) { int longest = lower_bound(dp.begin(), dp.end(), p.second) - dp.begin(); if (longest >= dp.size()) dp.push_back(p.second); else dp[longest] = p.second; } cout << dp.size(); return 0 ; }","title":"Russian roll"},{"location":"Interview/russian-roll/#method-1-dfs","text":"Try each envelope as starting point and stack all the other avaliable envelopes. Level 1: n Level 2: n * (n - 1) Level 3: n * (n - 1) * (n - 2) ... Level n: O(n!) O(n!) Space: O(n) O(n)","title":"Method 1: DFS"},{"location":"Interview/russian-roll/#method-2-sort-dfs","text":"Sort by width and run DFS once: skip all the nodes if already included in previous iteration Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result)","title":"Method 2: Sort + DFS"},{"location":"Interview/russian-roll/#method-3-sort-dp-longest-increasing-subsequence","text":"sort by width height after sorted (1,1,3,2,2,4) -- assume using stable sort check LIS from the hight array find the first height to the left of the current height that is less than the current height this will take O(n) O(n) to find such element Time: O(n^2) O(n^2) Space: O(n) O(n) (need to store the previous result)","title":"Method 3: Sort + DP (longest increasing subsequence)"},{"location":"Interview/russian-roll/#solution","text":"","title":"Solution"},{"location":"Interview/russian-roll/#optimize-dp-space-and-time","text":"delete the previous one (M[i]) if array[i] > array[i+1] and M[i] <= M[i+1] But if already sorted from low to high -> space stays the same create an array for storing the lowest ending at current index Then use binary search with O(log_2{n}) O(log_2{n}) Time: O(n \\times log_2{n}) O(n \\times log_2{n}) Space: O(n) O(n) will be less than n since LIS might not be continuous","title":"Optimize DP (Space and Time)"},{"location":"Interview/russian-roll/#pitfall","text":"When sort: if width is the same, higher height sort first (same width cannot stack together) So we need to rewrite the comparator such that when two width are the same, choose the one with higher height","title":"Pitfall"},{"location":"Interview/russian-roll/#solution-code","text":"#include <bits/stdc++.h> using namespace std; int main () { int n; cin >> n; pair < int , int > env[n]; for ( int i = 0 ; i < n; ++ i) { cin >> env[i].first; cin >> env[i].second; } sort(env, env + n, []( const pair < int , int >& l, const pair < int , int >& r) { return l.first < r.first || (l.first == r.first && l.second > r.second); }); vector < int > dp; for ( auto p : env) { int longest = lower_bound(dp.begin(), dp.end(), p.second) - dp.begin(); if (longest >= dp.size()) dp.push_back(p.second); else dp[longest] = p.second; } cout << dp.size(); return 0 ; }","title":"Solution Code"},{"location":"Interview/search-in-bitonic-array/","text":"Search for a target number in a bitonic array, return the index of the target number if found in the array, or return -1. A bitonic array is a combination of two sequence: the first sequence is a monotonically increasing one and the second sequence is a monotonically decreasing one. Assumptions: The array is not null. Examples: array = {1, 4, 7, 11, 6, 2, -3, -8}, target = 2, return 5. Analysis \u00b6 Use arr[m] and arr[m - 1] to find the order of the array for l ~ m or m ~ r if m > m - 1: l ~ m is in increasing order if target is greater than m, then search the (m, r] else: search in l ~ m in increasing order if m <= m - 1: m ~ r is in decreasing order if target is greater than m, then search the [l, m) else: search in m ~ r in decreasing order Depending on the order, change according for the binary search function Code \u00b6 class Solution { public: int bsearch(vector < int > a, int target, int l, int r) { bool dir = a[l] <= a[r]; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (target == a[m]) return m; else if (target < a[m]) dir ? r = m : l = m + 1 ; else dir ? l = m + 1 : r = m; } return - 1 ; } int search(vector < int > a, int target) { // write your solution here int n = a.size(); int l = 0 , r = n - 1 ; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (target == a[m]) return m; if (a[m] > a[m - 1 ]) { // increasing from l to m if (target > a[m]) // m-1 < m < target l = m + 1 ; else { int res; if ((res = bsearch(a, target, l, m)) != - 1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != - 1 ) // m + 1 <= target <= r return res; else return - 1 ; } } else { // decreasing from m - 1 to r if (target > a[m]) // target > m > m - 1 r = m; else { int res; if ((res = bsearch(a, target, l, m)) != - 1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != - 1 ) // m + 1 >= target >= r return res; else return - 1 ; } } } return - 1 ; } };","title":"Search in bitonic array"},{"location":"Interview/search-in-bitonic-array/#analysis","text":"Use arr[m] and arr[m - 1] to find the order of the array for l ~ m or m ~ r if m > m - 1: l ~ m is in increasing order if target is greater than m, then search the (m, r] else: search in l ~ m in increasing order if m <= m - 1: m ~ r is in decreasing order if target is greater than m, then search the [l, m) else: search in m ~ r in decreasing order Depending on the order, change according for the binary search function","title":"Analysis"},{"location":"Interview/search-in-bitonic-array/#code","text":"class Solution { public: int bsearch(vector < int > a, int target, int l, int r) { bool dir = a[l] <= a[r]; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (target == a[m]) return m; else if (target < a[m]) dir ? r = m : l = m + 1 ; else dir ? l = m + 1 : r = m; } return - 1 ; } int search(vector < int > a, int target) { // write your solution here int n = a.size(); int l = 0 , r = n - 1 ; while (l < r) { int m = (l + 0ll + r) >> 1 ; if (target == a[m]) return m; if (a[m] > a[m - 1 ]) { // increasing from l to m if (target > a[m]) // m-1 < m < target l = m + 1 ; else { int res; if ((res = bsearch(a, target, l, m)) != - 1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != - 1 ) // m + 1 <= target <= r return res; else return - 1 ; } } else { // decreasing from m - 1 to r if (target > a[m]) // target > m > m - 1 r = m; else { int res; if ((res = bsearch(a, target, l, m)) != - 1 ) // l <= target <= m return res; else if ((res = bsearch(a, target, m + 1 , r)) != - 1 ) // m + 1 >= target >= r return res; else return - 1 ; } } } return - 1 ; } };","title":"Code"},{"location":"Interview/singleton/","text":"Definition \u00b6 in the entire life cycles, there is only one object being created and used. so that a class should not provide an explict contructor for user AND the instance itself is private static there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code Lazy vs Eager initialization: create upon call or avaliable all the time. Below example is lazy initialization. Depending on use case. /* * C++ Design Patterns: Singleton * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Singleton * has private static variable to hold one instance of the class * and method which gives us a way to instantiate the class */ class Singleton { public: // The copy constructor and assignment operator // are defined as deleted, which means that you // can't make a copy of singleton. // // Note: you can achieve the same effect by declaring // the constructor and the operator as private Singleton( Singleton const & ) = delete; Singleton & operator = ( Singleton const & ) = delete; static Singleton * get () { if ( ! instance ) { instance = new Singleton(); } return instance; } static void restart () { if ( instance ) { delete instance; } } void tell () { std :: cout << \"This is Singleton.\" << std :: endl; // ... } // ... private: Singleton() {} static Singleton * instance; // ... }; Singleton * Singleton :: instance = nullptr; int main () { Singleton :: get() -> tell(); Singleton :: restart(); return 0 ; }","title":"Singleton"},{"location":"Interview/singleton/#definition","text":"in the entire life cycles, there is only one object being created and used. so that a class should not provide an explict contructor for user AND the instance itself is private static there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code Lazy vs Eager initialization: create upon call or avaliable all the time. Below example is lazy initialization. Depending on use case. /* * C++ Design Patterns: Singleton * Author: Jakub Vojvoda [github.com/JakubVojvoda] * 2016 * * Source code is licensed under MIT License * (for more details see LICENSE) * */ #include <iostream> /* * Singleton * has private static variable to hold one instance of the class * and method which gives us a way to instantiate the class */ class Singleton { public: // The copy constructor and assignment operator // are defined as deleted, which means that you // can't make a copy of singleton. // // Note: you can achieve the same effect by declaring // the constructor and the operator as private Singleton( Singleton const & ) = delete; Singleton & operator = ( Singleton const & ) = delete; static Singleton * get () { if ( ! instance ) { instance = new Singleton(); } return instance; } static void restart () { if ( instance ) { delete instance; } } void tell () { std :: cout << \"This is Singleton.\" << std :: endl; // ... } // ... private: Singleton() {} static Singleton * instance; // ... }; Singleton * Singleton :: instance = nullptr; int main () { Singleton :: get() -> tell(); Singleton :: restart(); return 0 ; }","title":"Definition"},{"location":"Interview/sorting-algorithms/","text":"Overview \u00b6 Selection Sort \u00b6 arr[] = 64 25 12 22 11 // Find the minimum element in arr[0...4] // and place it at beginning 11 25 12 22 64 // Find the minimum element in arr[1...4] // and place it at beginning of arr[1...4] 11 12 25 22 64 // Find the minimum element in arr[2...4] // and place it at beginning of arr[2...4] 11 12 22 25 64 // Find the minimum element in arr[3...4] // and place it at beginning of arr[3...4] 11 12 22 25 64 /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length /* advance the position through the entire array */ /* (could do i < aLength-1 because single element is also min element) */ for (i = 0 ; i < aLength - 1 ; i ++ ) { /* find the min element in the unsorted a[i .. aLength-1] */ /* assume the min is the first element */ int jMin = i; /* test against elements after i to find the smallest */ for (j = i + 1 ; j < aLength; j ++ ) { /* if this element is less, then it is the new minimum */ if (a[j] < a[jMin]) { /* found new minimum; remember its index */ jMin = j; } } if (jMin != i) { swap(a[i], a[jMin]); } } Complexity \u00b6 O(\\frac{(n-1)+1}{2} \\times (n-1)) O(\\frac{(n-1)+1}{2} \\times (n-1)) = O(n^2) O(n^2) -- no matter if is pre-sorted or not Q1: sort with stacks \u00b6 sort with two stacks: #include<bits/stdc++.h> using namespace std; int main () { int n; cin >> n; int num[n]; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; stack < int > s1, s2; // s1: buffer; s2: sorted array in ascending order for ( int i : num) s1.push(i); while ( ! s1.empty()) { int curr = s1.top(); s1.pop(); int cnt = 0 ; /* s1: C s2: LLL */ // remove everything that is less than curr in the buffer while ( ! s2.empty() && s2.top() < curr) { s1.push(s2.top()); s2.pop(); ++ cnt; } s2.push(curr); /* s1: LLL s2: C */ // move back for ( int i = 0 ; i < cnt; ++ i) { s2.push(s1.top()); s1.pop(); } /* s1: s2: CLLL */ } while ( ! s2.empty()) { cout << s2.top() << \" \" ; s2.pop(); } return 0 ; } counter: count number of element that is less than current top. 1. compare sorted.top() with item, pop all the elements back to the input stack that are greater than item 2. push the item to the sorted top 3. using the counter to determine when to stop when pushing the pop the input stack Here input stack's top (from top to top + counter) works as the buffer Insertion Sort \u00b6 for ( int i = 0 ; i < A.size(); ++ i) { for ( int j = i; j > 0 && A[j - 1 ] > A[j]; -- j) { // can terminate early if unsatisfy swap(A[j], A[j - 1 ]); } } 1, 4, 7, 11, 6, 2, -3, -8 1... 1, 4... 1, 4, 7... 1, 4, 7, 11... 1, 4, 6, 7, 11... 1, 2, 4, 6, 7, 11... -3, 1, 2, 4, 6, 11... -8, -3, 1, 2, 4, 6, 11 if the origional array is pre-sorted, then the complexity is O(n) O(n) , if not, it will be O(n^2) O(n^2) Counting Sort \u00b6 A[] original array to be sorted B[] sorted array from less to greater C[] is pre-sum for counting the frequency of each element (element is the index) on line 11, it keep \"filling\" the element from right to the left (greater to less) to B[]. initial \u00b6 after pre-sum \u00b6 Complexity \u00b6 Time: O(n) O(n) , Space: O(|max - min|) O(|max - min|) Merge Sort: stable \u00b6 int tmp[ 1010 ]; void merge_sort (vector < int >& q, int l, int r) { if (l >= r) return ; int mid = (l + r) >> 1 ; merge_sort(q, l, mid); merge_sort(q, mid + 1 , r); int k = 0 , i = l, j = mid + 1 ; while (i <= mid && j <= r) { // two pointers if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; } while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0 ; i <= r; i ++ , j ++ ) q[i] = tmp[j]; } vector < int > mergeSort(vector < int > array) { // write your solution here vector < int > res = array; merge_sort(res, 0 , array.size() - 1 ); return res; } Use merge sort to find Inversion Count \u00b6 Inversion Count: a_i > a_j a_i > a_j and i < j i < j , to do so, just uncomment line 12. Complexity \u00b6 space: - call stack: O(log(n)) O(log(n)) - heap: O(n) O(n) Q1: \u00b6 Quick Sort: not stable \u00b6 class Solution { public: void quick_sort(vector < int >& q, int l, int r) { if (l >= r) return ; // pivot at mid int i = l - 1 , j = r + 1 , x = q[(l + r) >> 1 ]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1 , r); } vector < int > quickSort(vector < int > array) { // write your solution here quick_sort(array, 0 , array.size() - 1 ); return array; } }; Quick select: select kth element \u00b6 Differ from Merge Sort, Quick sort first split array into two half where the values on the left of x are less than x and values on the right of x are equal or greater than x. Code \u00b6 #include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N]; int quick_select ( int l, int r, int k) { if (l == r) return num[l]; int i = l - 1 , j = r + 1 , x = num[(l + r) >> 1 ]; while (i < j) { while (num[ ++ i] < x) ; while (num[ -- j] > x) ; if (i < j) swap(num[i], num[j]); } int offset = j - l + 1 ; if (k <= offset) return quick_select(l, j, k); return quick_select(j + 1 , r, k - offset); } int main () { int n, k; cin >> n >> k; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; cout << quick_select( 0 , n - 1 , k); return 0 ; } Auxiliary Space : Mergesort uses extra space , quicksort requires little space and exhibits good cache locality. Quick sort is an in-place sorting algorithm. In-place sorting means no additional storage space is needed to perform sorting. Merge sort requires a temporary array to merge the sorted arrays and hence it is not in-place giving Quick sort the advantage of space. Worst Cases : The worst case of quicksort O(n^2) O(n^2) can be avoided by using randomized quicksort . It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort. Locality of reference : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment. Merge sort is better for large data structures : Mergesort is a stable sort , unlike quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Best time complexity: O(n \\log n) O(n \\log n) , Worst: O(n^2) O(n^2) . It works great in small size array, and for large size array it's better to use merge sort. Q1: moving zeros \u00b6 Move 0s to the right end of the array, no need to keep the relative order of the elements in the origional array vector < int > moveZeros(vector < int > arr) { if (arr.size() <= 1 ) return arr; int l = 0 , r = arr.size() - 1 ; while (l <= r) { if (arr[l] != 0 ) l ++ ; else if (arr[r] == 0 ) r -- ; else swap (arr[l ++ ], arr[r -- ]); } return arr; } Q2: rainbow sort \u00b6 sort the array by three color (a,b,c represent three colors). e.g. given [a,b,a,a,a,c,b,a] -> [a,a,a,a,a,b,b,c] i): all elements to the left of arr[i] are a [i-j): all elements between arr[i] ~ arr[j] are b [j-k]: all elements between arr[j] ~ arr[k] are unexplored range [k: all elements to the right of arr[k] are c if arr[j] == a: swap(arr[i++], arr[j++]) // i++ because i~j are b, and after sway, arr[i] is a if arr[j] == b: j++ if arr[j] == c: swap(arr[j], arr[k--]) // don't need to j++ becasue arr[j] is unknown void rainbowSort (vector < char >& arr) { if (arr.size() <= 1 ) return ; int i = 0 , j = 0 , k = arr.size() - 1 ; while (j <= k) { if (arr[j] == 'a' ) swap(arr[i ++ ], arr[j ++ ]); else if (arr[j] == 'b' ) j ++ ; else swap(arr[j], arr[k -- ]); } } Q3: sort four color \u00b6 [aaa i0) [bbb i1) [ccc i2) [dddd i3) XXXX a=0,b=1,c=2,d=3 i0): all elements to the left of arr[i0] are a [i0-i1): all elements between arr[i0] ~ arr[i1] are b [i1-i2): all elements between arr[i1] ~ arr[i2] are c [i2-i3): all elements between arr[i2] ~ arr[i3] are d [i3: all elements to the right of arr[i3] are unexplored range if arr[i3] == d: i3++ if arr[i3] == c: swap(arr[i3++], arr[i2++]) if arr[i3] == b: swap(arr[i3++], arr[i2++]), swap(arr[i1++, i2]) if arr[i3] == a: swap(arr[i3++], arr[i2++]), swap(arr[i1++], arr[i2]) , swap(arr[i0++], arr[i1]) public int [] rainbowSortII ( int [] array) { // Write your solution here int i0 = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; while (i3 < array. length ) { if (array [ i3 ] == 3 ) { i3 ++ ; } else if (array [ i3 ] == 2 ) { swap(array, i2, i3); i2 ++ ; i3 ++ ; } else if (array [ i3 ] == 1 ) { swap(array, i2, i3); swap(array, i1, i2); i1 ++ ; i2 ++ ; i3 ++ ; } else { swap(array, i2, i3); swap(array, i1, i2); swap(array, i0, i1); i0 ++ ; i1 ++ ; i2 ++ ; i3 ++ ; } } return array; } Q4: What about k color? \u00b6 use counting sort, sort in linear time! class Solution { public : vector < int > rainbowSortIII (vector < int > a, int k) { vector < int > cnt (k + 1 ); // accumulate cnt of each element (from 0 - k) int n = a. size (); for ( int i = 0 ; i < n; ++ i) cnt [ a [ i ]]++ ; for ( int i = 1 ; i <= k; ++ i) cnt [ i ] = cnt [ i ] + cnt [ i - 1 ] ; vector < int > res (n); for ( int i = n - 1 ; i >= 0 ; -- i) { res [ cnt [ a [ i ]] - 1 ] = a [ i ] ; cnt [ a [ i ]]-- ; } return res; } }; \u590d\u6742\u5ea6\u5206\u6790 \u00b6 \u65f6\u95f4\uff1a O(n) O(n) \u7a7a\u95f4\uff1a O(n) O(n) <- this is not a in-place algorithm \u5206\u6790 \u00b6 \u5982\u679c\u6709k\u4e2acolor\uff0c\u90a3\u4e48\u5982\u679c\u60f3\u8981\u77e5\u9053\u6bcf\u4e2acolor\u5e94\u8be5\u653e\u5728\u54ea\u91cc\u9700\u8981\u77e5\u9053\u4ee5\u4e0b\u4fe1\u606f\uff1a 1. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e 2. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u4e2a\u6570 \u8fd9\u4e24\u4e2a\u4fe1\u606f\u867d\u7136\u770b\u4f3c\u6ca1\u6709\u5173\u8054\u5b9e\u9645\u4e0a\u662f\uff1a\u5f53\u77e5\u9053\u6240\u6709\u5728\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272 \u6bcf\u4e2a\u4e2a\u6570\u4e4b\u540e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\u3002\u90a3\u4e48\u5c31\u662f\u8981\u5904\u7406\u5982\u4f55\u77e5\u9053\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u6240\u6709\u989c\u8272 \u4e2a\u6570\u3002 \u8fd9\u91cc\u5c31\u53ef\u4ee5\u60f3\u5230accumulate list\u6216\u8005pre sum list\u6765\u5904\u7406\u3002 for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; \u8fd9\u4e24\u884c\u505a\u7684\u4e8b\u60c5\u5206\u522b\u662f\u627e\u5230\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u91cf\uff0c\u7136\u540e\u8ba1\u7b97presum\uff0c\u8fd9\u91cc\u7684presum\u4fbf\u662f\u4e0a\u9762\u8bf4\u7684 \u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272*\u6bcf\u4e2a\u4e2a\u6570 \u3002\u5f53\u77e5\u9053\u4e86\u8fd9\u4e24\u4e2a\u4fe1\u606f\u4e4b\u540e\u4fbf\u53ef\u4ee5\u628a\u4ed6\u4eec\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230sort\u597d\u7684res\u6570\u7ec4\u4e86\u3002 for ( int i = n - 1 ; i >= 0 ; -- i) { res[cnt[a[i]] - 1 ] = a[i]; cnt[a[i]] -- ; } \u6ce8\u610f\uff1a\u6bcf\u6b21\u904d\u5386\u7684\u65f6\u5019\u9700\u8981\u66f4\u65b0cnt(cnt --)\uff0c\u540c\u65f6\u56e0\u4e3a\u6570\u7ec4\u662f0 base\uff0c\u4f46\u662f\u989c\u8272\u662f\u4ece[1\uff5ek]\uff0c\u6240\u4ee5\u6bcf\u6b21res\u7684index\u8981-1. \u5982\u4f55\u89e3\u51b3\u975e\u6570\u5b57\u95ee\u9898 \u00b6 \u5047\u5982\u989c\u8272\u4e0d\u662f1\uff5ek\u7684\u6570\u5b57\uff0c\u90a3\u4e48\u4e3a\u4e86\u8ba1\u7b97presum\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u67d0\u79cd\u65b9\u6cd5\u6765\u77e5\u9053\u6bcf\u4e24\u4e2a\u5143\u7d20\u7684\u76f8\u5bf9\u4f4d\u7f6e\uff1a \u5047\u8bbeobjA < objB\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a unordered_map<Obj, int> mapping \u6765\u4e3a\u6bcf\u4e2a\u5143\u7d20\u8d4b\u503c\u3002\u5373\uff1a for ( int i = 0 ; i < n; ++ i) cnt[mapping[a[i]]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; In-place sort: space O(k), time O(n) \u00b6 vector < int > rainbowSortIII(vector < int > a, int k) { vector < int > cnt(k + 1 ); // cnt of each element (from 0 - k) int n = a.size(); for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 , idx = 0 ; i <= k; ++ i) { while (cnt[i] != 0 ) { a[idx ++ ] = i; cnt[i] -- ; } } return a; } Q5: reorder the array \u00b6 An array contains both pos and neg numbers in random order. Order the array elements so that pos and neg are placed alternatively. If there are more pos they appear at the end of the array. If there are more neg, they also appear at the end of the array. e.g. input: [1,2,3,4,5,-1,-1,-1], output: [1,-1,2,-1,3,-1,4,5] (the ordering of pos/neg number doesn't matter) Analysis \u00b6 Use quick sort's partition to split the array into two half, then put them back to the new array alternatively Code \u00b6 #include <bits/stdc++.h> using namespace std; #define N 1010 int nums[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; int x = 0 , l = 0 , r = n - 1 ; while (l < r) { while (nums[ ++ l] > x); while (nums[ -- r] < x); if (l < r) swap(nums[l], nums[r]); } cout << nums[l] << \" \" << nums[r] << endl; int res[n]; memset(res, - 1 , sizeof res); int idx = 0 ; for ( int i = 0 ; idx <= r; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i = 1 ; idx < n; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Sorting algorithms"},{"location":"Interview/sorting-algorithms/#overview","text":"","title":"Overview"},{"location":"Interview/sorting-algorithms/#selection-sort","text":"arr[] = 64 25 12 22 11 // Find the minimum element in arr[0...4] // and place it at beginning 11 25 12 22 64 // Find the minimum element in arr[1...4] // and place it at beginning of arr[1...4] 11 12 25 22 64 // Find the minimum element in arr[2...4] // and place it at beginning of arr[2...4] 11 12 22 25 64 // Find the minimum element in arr[3...4] // and place it at beginning of arr[3...4] 11 12 22 25 64 /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length /* advance the position through the entire array */ /* (could do i < aLength-1 because single element is also min element) */ for (i = 0 ; i < aLength - 1 ; i ++ ) { /* find the min element in the unsorted a[i .. aLength-1] */ /* assume the min is the first element */ int jMin = i; /* test against elements after i to find the smallest */ for (j = i + 1 ; j < aLength; j ++ ) { /* if this element is less, then it is the new minimum */ if (a[j] < a[jMin]) { /* found new minimum; remember its index */ jMin = j; } } if (jMin != i) { swap(a[i], a[jMin]); } }","title":"Selection Sort"},{"location":"Interview/sorting-algorithms/#complexity","text":"O(\\frac{(n-1)+1}{2} \\times (n-1)) O(\\frac{(n-1)+1}{2} \\times (n-1)) = O(n^2) O(n^2) -- no matter if is pre-sorted or not","title":"Complexity"},{"location":"Interview/sorting-algorithms/#q1-sort-with-stacks","text":"sort with two stacks: #include<bits/stdc++.h> using namespace std; int main () { int n; cin >> n; int num[n]; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; stack < int > s1, s2; // s1: buffer; s2: sorted array in ascending order for ( int i : num) s1.push(i); while ( ! s1.empty()) { int curr = s1.top(); s1.pop(); int cnt = 0 ; /* s1: C s2: LLL */ // remove everything that is less than curr in the buffer while ( ! s2.empty() && s2.top() < curr) { s1.push(s2.top()); s2.pop(); ++ cnt; } s2.push(curr); /* s1: LLL s2: C */ // move back for ( int i = 0 ; i < cnt; ++ i) { s2.push(s1.top()); s1.pop(); } /* s1: s2: CLLL */ } while ( ! s2.empty()) { cout << s2.top() << \" \" ; s2.pop(); } return 0 ; } counter: count number of element that is less than current top. 1. compare sorted.top() with item, pop all the elements back to the input stack that are greater than item 2. push the item to the sorted top 3. using the counter to determine when to stop when pushing the pop the input stack Here input stack's top (from top to top + counter) works as the buffer","title":"Q1: sort with stacks"},{"location":"Interview/sorting-algorithms/#insertion-sort","text":"for ( int i = 0 ; i < A.size(); ++ i) { for ( int j = i; j > 0 && A[j - 1 ] > A[j]; -- j) { // can terminate early if unsatisfy swap(A[j], A[j - 1 ]); } } 1, 4, 7, 11, 6, 2, -3, -8 1... 1, 4... 1, 4, 7... 1, 4, 7, 11... 1, 4, 6, 7, 11... 1, 2, 4, 6, 7, 11... -3, 1, 2, 4, 6, 11... -8, -3, 1, 2, 4, 6, 11 if the origional array is pre-sorted, then the complexity is O(n) O(n) , if not, it will be O(n^2) O(n^2)","title":"Insertion Sort"},{"location":"Interview/sorting-algorithms/#counting-sort","text":"A[] original array to be sorted B[] sorted array from less to greater C[] is pre-sum for counting the frequency of each element (element is the index) on line 11, it keep \"filling\" the element from right to the left (greater to less) to B[].","title":"Counting Sort"},{"location":"Interview/sorting-algorithms/#initial","text":"","title":"initial"},{"location":"Interview/sorting-algorithms/#after-pre-sum","text":"","title":"after pre-sum"},{"location":"Interview/sorting-algorithms/#complexity_1","text":"Time: O(n) O(n) , Space: O(|max - min|) O(|max - min|)","title":"Complexity"},{"location":"Interview/sorting-algorithms/#merge-sort-stable","text":"int tmp[ 1010 ]; void merge_sort (vector < int >& q, int l, int r) { if (l >= r) return ; int mid = (l + r) >> 1 ; merge_sort(q, l, mid); merge_sort(q, mid + 1 , r); int k = 0 , i = l, j = mid + 1 ; while (i <= mid && j <= r) { // two pointers if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; } while (i <= mid) tmp[k ++ ] = q[i ++ ]; while (j <= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0 ; i <= r; i ++ , j ++ ) q[i] = tmp[j]; } vector < int > mergeSort(vector < int > array) { // write your solution here vector < int > res = array; merge_sort(res, 0 , array.size() - 1 ); return res; }","title":"Merge Sort: stable"},{"location":"Interview/sorting-algorithms/#use-merge-sort-to-find-inversion-count","text":"Inversion Count: a_i > a_j a_i > a_j and i < j i < j , to do so, just uncomment line 12.","title":"Use merge sort to find Inversion Count"},{"location":"Interview/sorting-algorithms/#complexity_2","text":"space: - call stack: O(log(n)) O(log(n)) - heap: O(n) O(n)","title":"Complexity"},{"location":"Interview/sorting-algorithms/#q1","text":"","title":"Q1:"},{"location":"Interview/sorting-algorithms/#quick-sort-not-stable","text":"class Solution { public: void quick_sort(vector < int >& q, int l, int r) { if (l >= r) return ; // pivot at mid int i = l - 1 , j = r + 1 , x = q[(l + r) >> 1 ]; while (i < j) { do i ++ ; while (q[i] < x); do j -- ; while (q[j] > x); if (i < j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1 , r); } vector < int > quickSort(vector < int > array) { // write your solution here quick_sort(array, 0 , array.size() - 1 ); return array; } };","title":"Quick Sort: not stable"},{"location":"Interview/sorting-algorithms/#quick-select-select-kth-element","text":"Differ from Merge Sort, Quick sort first split array into two half where the values on the left of x are less than x and values on the right of x are equal or greater than x.","title":"Quick select: select kth element"},{"location":"Interview/sorting-algorithms/#code","text":"#include <bits/stdc++.h> using namespace std; const int N = 1010 ; int num[N]; int quick_select ( int l, int r, int k) { if (l == r) return num[l]; int i = l - 1 , j = r + 1 , x = num[(l + r) >> 1 ]; while (i < j) { while (num[ ++ i] < x) ; while (num[ -- j] > x) ; if (i < j) swap(num[i], num[j]); } int offset = j - l + 1 ; if (k <= offset) return quick_select(l, j, k); return quick_select(j + 1 , r, k - offset); } int main () { int n, k; cin >> n >> k; for ( int i = 0 ; i < n; ++ i) cin >> num[i]; cout << quick_select( 0 , n - 1 , k); return 0 ; } Auxiliary Space : Mergesort uses extra space , quicksort requires little space and exhibits good cache locality. Quick sort is an in-place sorting algorithm. In-place sorting means no additional storage space is needed to perform sorting. Merge sort requires a temporary array to merge the sorted arrays and hence it is not in-place giving Quick sort the advantage of space. Worst Cases : The worst case of quicksort O(n^2) O(n^2) can be avoided by using randomized quicksort . It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort. Locality of reference : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment. Merge sort is better for large data structures : Mergesort is a stable sort , unlike quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Best time complexity: O(n \\log n) O(n \\log n) , Worst: O(n^2) O(n^2) . It works great in small size array, and for large size array it's better to use merge sort.","title":"Code"},{"location":"Interview/sorting-algorithms/#q1-moving-zeros","text":"Move 0s to the right end of the array, no need to keep the relative order of the elements in the origional array vector < int > moveZeros(vector < int > arr) { if (arr.size() <= 1 ) return arr; int l = 0 , r = arr.size() - 1 ; while (l <= r) { if (arr[l] != 0 ) l ++ ; else if (arr[r] == 0 ) r -- ; else swap (arr[l ++ ], arr[r -- ]); } return arr; }","title":"Q1: moving zeros"},{"location":"Interview/sorting-algorithms/#q2-rainbow-sort","text":"sort the array by three color (a,b,c represent three colors). e.g. given [a,b,a,a,a,c,b,a] -> [a,a,a,a,a,b,b,c] i): all elements to the left of arr[i] are a [i-j): all elements between arr[i] ~ arr[j] are b [j-k]: all elements between arr[j] ~ arr[k] are unexplored range [k: all elements to the right of arr[k] are c if arr[j] == a: swap(arr[i++], arr[j++]) // i++ because i~j are b, and after sway, arr[i] is a if arr[j] == b: j++ if arr[j] == c: swap(arr[j], arr[k--]) // don't need to j++ becasue arr[j] is unknown void rainbowSort (vector < char >& arr) { if (arr.size() <= 1 ) return ; int i = 0 , j = 0 , k = arr.size() - 1 ; while (j <= k) { if (arr[j] == 'a' ) swap(arr[i ++ ], arr[j ++ ]); else if (arr[j] == 'b' ) j ++ ; else swap(arr[j], arr[k -- ]); } }","title":"Q2: rainbow sort"},{"location":"Interview/sorting-algorithms/#q3-sort-four-color","text":"[aaa i0) [bbb i1) [ccc i2) [dddd i3) XXXX a=0,b=1,c=2,d=3 i0): all elements to the left of arr[i0] are a [i0-i1): all elements between arr[i0] ~ arr[i1] are b [i1-i2): all elements between arr[i1] ~ arr[i2] are c [i2-i3): all elements between arr[i2] ~ arr[i3] are d [i3: all elements to the right of arr[i3] are unexplored range if arr[i3] == d: i3++ if arr[i3] == c: swap(arr[i3++], arr[i2++]) if arr[i3] == b: swap(arr[i3++], arr[i2++]), swap(arr[i1++, i2]) if arr[i3] == a: swap(arr[i3++], arr[i2++]), swap(arr[i1++], arr[i2]) , swap(arr[i0++], arr[i1]) public int [] rainbowSortII ( int [] array) { // Write your solution here int i0 = 0 ; int i1 = 0 ; int i2 = 0 ; int i3 = 0 ; while (i3 < array. length ) { if (array [ i3 ] == 3 ) { i3 ++ ; } else if (array [ i3 ] == 2 ) { swap(array, i2, i3); i2 ++ ; i3 ++ ; } else if (array [ i3 ] == 1 ) { swap(array, i2, i3); swap(array, i1, i2); i1 ++ ; i2 ++ ; i3 ++ ; } else { swap(array, i2, i3); swap(array, i1, i2); swap(array, i0, i1); i0 ++ ; i1 ++ ; i2 ++ ; i3 ++ ; } } return array; }","title":"Q3: sort four color"},{"location":"Interview/sorting-algorithms/#q4-what-about-k-color","text":"use counting sort, sort in linear time! class Solution { public : vector < int > rainbowSortIII (vector < int > a, int k) { vector < int > cnt (k + 1 ); // accumulate cnt of each element (from 0 - k) int n = a. size (); for ( int i = 0 ; i < n; ++ i) cnt [ a [ i ]]++ ; for ( int i = 1 ; i <= k; ++ i) cnt [ i ] = cnt [ i ] + cnt [ i - 1 ] ; vector < int > res (n); for ( int i = n - 1 ; i >= 0 ; -- i) { res [ cnt [ a [ i ]] - 1 ] = a [ i ] ; cnt [ a [ i ]]-- ; } return res; } };","title":"Q4: What about k color?"},{"location":"Interview/sorting-algorithms/#_1","text":"\u65f6\u95f4\uff1a O(n) O(n) \u7a7a\u95f4\uff1a O(n) O(n) <- this is not a in-place algorithm","title":"\u590d\u6742\u5ea6\u5206\u6790"},{"location":"Interview/sorting-algorithms/#_2","text":"\u5982\u679c\u6709k\u4e2acolor\uff0c\u90a3\u4e48\u5982\u679c\u60f3\u8981\u77e5\u9053\u6bcf\u4e2acolor\u5e94\u8be5\u653e\u5728\u54ea\u91cc\u9700\u8981\u77e5\u9053\u4ee5\u4e0b\u4fe1\u606f\uff1a 1. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e 2. \u5f53\u524d\u989c\u8272\u5728array\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u4e2a\u6570 \u8fd9\u4e24\u4e2a\u4fe1\u606f\u867d\u7136\u770b\u4f3c\u6ca1\u6709\u5173\u8054\u5b9e\u9645\u4e0a\u662f\uff1a\u5f53\u77e5\u9053\u6240\u6709\u5728\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272 \u6bcf\u4e2a\u4e2a\u6570\u4e4b\u540e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u989c\u8272\u5728array\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\u3002\u90a3\u4e48\u5c31\u662f\u8981\u5904\u7406\u5982\u4f55\u77e5\u9053\u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u6240\u6709\u989c\u8272 \u4e2a\u6570\u3002 \u8fd9\u91cc\u5c31\u53ef\u4ee5\u60f3\u5230accumulate list\u6216\u8005pre sum list\u6765\u5904\u7406\u3002 for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ]; \u8fd9\u4e24\u884c\u505a\u7684\u4e8b\u60c5\u5206\u522b\u662f\u627e\u5230\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u91cf\uff0c\u7136\u540e\u8ba1\u7b97presum\uff0c\u8fd9\u91cc\u7684presum\u4fbf\u662f\u4e0a\u9762\u8bf4\u7684 \u5f53\u524d\u989c\u8272\u4e4b\u524d\u7684\u989c\u8272*\u6bcf\u4e2a\u4e2a\u6570 \u3002\u5f53\u77e5\u9053\u4e86\u8fd9\u4e24\u4e2a\u4fe1\u606f\u4e4b\u540e\u4fbf\u53ef\u4ee5\u628a\u4ed6\u4eec\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230sort\u597d\u7684res\u6570\u7ec4\u4e86\u3002 for ( int i = n - 1 ; i >= 0 ; -- i) { res[cnt[a[i]] - 1 ] = a[i]; cnt[a[i]] -- ; } \u6ce8\u610f\uff1a\u6bcf\u6b21\u904d\u5386\u7684\u65f6\u5019\u9700\u8981\u66f4\u65b0cnt(cnt --)\uff0c\u540c\u65f6\u56e0\u4e3a\u6570\u7ec4\u662f0 base\uff0c\u4f46\u662f\u989c\u8272\u662f\u4ece[1\uff5ek]\uff0c\u6240\u4ee5\u6bcf\u6b21res\u7684index\u8981-1.","title":"\u5206\u6790"},{"location":"Interview/sorting-algorithms/#_3","text":"\u5047\u5982\u989c\u8272\u4e0d\u662f1\uff5ek\u7684\u6570\u5b57\uff0c\u90a3\u4e48\u4e3a\u4e86\u8ba1\u7b97presum\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u67d0\u79cd\u65b9\u6cd5\u6765\u77e5\u9053\u6bcf\u4e24\u4e2a\u5143\u7d20\u7684\u76f8\u5bf9\u4f4d\u7f6e\uff1a \u5047\u8bbeobjA < objB\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a unordered_map<Obj, int> mapping \u6765\u4e3a\u6bcf\u4e2a\u5143\u7d20\u8d4b\u503c\u3002\u5373\uff1a for ( int i = 0 ; i < n; ++ i) cnt[mapping[a[i]]] ++ ; for ( int i = 1 ; i <= k; ++ i) cnt[i] = cnt[i] + cnt[i - 1 ];","title":"\u5982\u4f55\u89e3\u51b3\u975e\u6570\u5b57\u95ee\u9898"},{"location":"Interview/sorting-algorithms/#in-place-sort-space-ok-time-on","text":"vector < int > rainbowSortIII(vector < int > a, int k) { vector < int > cnt(k + 1 ); // cnt of each element (from 0 - k) int n = a.size(); for ( int i = 0 ; i < n; ++ i) cnt[a[i]] ++ ; for ( int i = 1 , idx = 0 ; i <= k; ++ i) { while (cnt[i] != 0 ) { a[idx ++ ] = i; cnt[i] -- ; } } return a; }","title":"In-place sort: space O(k), time O(n)"},{"location":"Interview/sorting-algorithms/#q5-reorder-the-array","text":"An array contains both pos and neg numbers in random order. Order the array elements so that pos and neg are placed alternatively. If there are more pos they appear at the end of the array. If there are more neg, they also appear at the end of the array. e.g. input: [1,2,3,4,5,-1,-1,-1], output: [1,-1,2,-1,3,-1,4,5] (the ordering of pos/neg number doesn't matter)","title":"Q5: reorder the array"},{"location":"Interview/sorting-algorithms/#analysis","text":"Use quick sort's partition to split the array into two half, then put them back to the new array alternatively","title":"Analysis"},{"location":"Interview/sorting-algorithms/#code_1","text":"#include <bits/stdc++.h> using namespace std; #define N 1010 int nums[N]; int main () { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) cin >> nums[i]; int x = 0 , l = 0 , r = n - 1 ; while (l < r) { while (nums[ ++ l] > x); while (nums[ -- r] < x); if (l < r) swap(nums[l], nums[r]); } cout << nums[l] << \" \" << nums[r] << endl; int res[n]; memset(res, - 1 , sizeof res); int idx = 0 ; for ( int i = 0 ; idx <= r; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i = 1 ; idx < n; i += 2 ) { res[i] = nums[idx ++ ]; } for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Code"},{"location":"Interview/stack-and-queue/","text":"","title":"Stack and queue"},{"location":"Interview/string-match/","text":"Problem \u00b6 Determine if a small string is a substring of another large string. Return the index of the first occurrence of the small string in the large string. Return -1 if the small string is not a substring of the large string. Consider the case: mississippi issip -> return 4 KMP \u00b6 next array physcial meaning \u00b6 next[i] = j means p[1, j] = p[i - j + 1, i] (blue part is same with grean part) What it does is keep checking the longest suffix (ending at j) with prefix (starting at 0) Or: longest ending index j that makes 0 ~ j == i - j + 1 ~ i e.g. P = \"ababababab\" psuedocode \u00b6 Part 1: form the next array \u00b6 check if small[i] == small[j + 1] if not, meaning 0 ~ i - 1 matches 0 ~ j but i doesn't match j + 1 to find last match (0 ~ i matches i - j + 1 ~ j + 1) if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j set next[i] = j // last match Part 2: find in the original string \u00b6 check if large[i] == small[j + 1] if not, meaning large[0 ~ i] matches small[0 ~ j] but i doesn't match j + 1 (same as part 1) try last match if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j check if reach the end Code \u00b6 class Solution { public: int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); vector < int > next(n, - 1 ); for ( int i = 1 , j = - 1 ; i < n; ++ i) { // either not start matching yet // or find previous one that stops at current i while (j >= 0 && small[j + 1 ] != small[i]) j = next[j]; // check if current one is matched if (small[j + 1 ] == small[i]) j ++ ; // now next[i] = j; } for ( int i = 0 , j = - 1 ; i < m; ++ i) { while (j != - 1 && large[i] != small[j + 1 ]) j = next[j]; if (large[i] == small[j + 1 ]) j ++ ; if (j == n - 1 ) return i - j; } return - 1 ; } }; String Hashing or RabinKarp Algorithm \u00b6 First calculate the hash value for subtring from 0 ~ i in large Second calculate the hash value for substring from i ~ j given hash values of 0 ~ i and 0 ~ j To Prevent collision, use a large prime for P. Why use unsigned long long ? Because unsigned long long 's max is 2^{64} 2^{64} , if add one more, it will become 0 0 , which makes sure all the values are in the range of 0 ~ 2^{64} 2^{64} -- works like a module operation. Why h[i - 1] * p[n] ? Because to find out the hash value for substring of i + n - 1 (right) to i - 1 (left), we need to find p[i + n - 1 (right) - i + 1 (left)], which yields p[n]. Code \u00b6 before Optimization class Solution { public: int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > p(m + 1 , 1 ), h(m + 1 , 1 ); for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; p[i] = p[i - 1 ] * P; } ULL check = 1 ; for ( int i = 1 ; i <= n; ++ i) { check = check * P + small[i - 1 ]; } check = check - p[n]; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { ULL hash = h[i + n - 1 ] - h[i - 1 ] * p[n]; if (h[i + n - 1 ] - h[i - 1 ] * p[n] == check) return i - 1 ; } return - 1 ; } }; after optimization class Solution { public: int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > h(m + 1 , 1 ); ULL p = 1 , check = 1 ; for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; if (i <= n) { p *= P; check = check * P + small[i - 1 ]; } } check = check - p; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { if (h[i + n - 1 ] - h[i - 1 ] * p == check) return i - 1 ; } return - 1 ; } };","title":"String match"},{"location":"Interview/string-match/#problem","text":"Determine if a small string is a substring of another large string. Return the index of the first occurrence of the small string in the large string. Return -1 if the small string is not a substring of the large string. Consider the case: mississippi issip -> return 4","title":"Problem"},{"location":"Interview/string-match/#kmp","text":"","title":"KMP"},{"location":"Interview/string-match/#next-array-physcial-meaning","text":"next[i] = j means p[1, j] = p[i - j + 1, i] (blue part is same with grean part) What it does is keep checking the longest suffix (ending at j) with prefix (starting at 0) Or: longest ending index j that makes 0 ~ j == i - j + 1 ~ i e.g. P = \"ababababab\"","title":"next array physcial meaning"},{"location":"Interview/string-match/#psuedocode","text":"","title":"psuedocode"},{"location":"Interview/string-match/#part-1-form-the-next-array","text":"check if small[i] == small[j + 1] if not, meaning 0 ~ i - 1 matches 0 ~ j but i doesn't match j + 1 to find last match (0 ~ i matches i - j + 1 ~ j + 1) if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j set next[i] = j // last match","title":"Part 1: form the next array"},{"location":"Interview/string-match/#part-2-find-in-the-original-string","text":"check if large[i] == small[j + 1] if not, meaning large[0 ~ i] matches small[0 ~ j] but i doesn't match j + 1 (same as part 1) try last match if yes, meaning 0 ~ i matches 0 ~ j + 1, so keep matching and update j check if reach the end","title":"Part 2: find in the original string"},{"location":"Interview/string-match/#code","text":"class Solution { public: int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); vector < int > next(n, - 1 ); for ( int i = 1 , j = - 1 ; i < n; ++ i) { // either not start matching yet // or find previous one that stops at current i while (j >= 0 && small[j + 1 ] != small[i]) j = next[j]; // check if current one is matched if (small[j + 1 ] == small[i]) j ++ ; // now next[i] = j; } for ( int i = 0 , j = - 1 ; i < m; ++ i) { while (j != - 1 && large[i] != small[j + 1 ]) j = next[j]; if (large[i] == small[j + 1 ]) j ++ ; if (j == n - 1 ) return i - j; } return - 1 ; } };","title":"Code"},{"location":"Interview/string-match/#string-hashing-or-rabinkarp-algorithm","text":"First calculate the hash value for subtring from 0 ~ i in large Second calculate the hash value for substring from i ~ j given hash values of 0 ~ i and 0 ~ j To Prevent collision, use a large prime for P. Why use unsigned long long ? Because unsigned long long 's max is 2^{64} 2^{64} , if add one more, it will become 0 0 , which makes sure all the values are in the range of 0 ~ 2^{64} 2^{64} -- works like a module operation. Why h[i - 1] * p[n] ? Because to find out the hash value for substring of i + n - 1 (right) to i - 1 (left), we need to find p[i + n - 1 (right) - i + 1 (left)], which yields p[n].","title":"String Hashing or RabinKarp Algorithm"},{"location":"Interview/string-match/#code_1","text":"before Optimization class Solution { public: int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > p(m + 1 , 1 ), h(m + 1 , 1 ); for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; p[i] = p[i - 1 ] * P; } ULL check = 1 ; for ( int i = 1 ; i <= n; ++ i) { check = check * P + small[i - 1 ]; } check = check - p[n]; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { ULL hash = h[i + n - 1 ] - h[i - 1 ] * p[n]; if (h[i + n - 1 ] - h[i - 1 ] * p[n] == check) return i - 1 ; } return - 1 ; } }; after optimization class Solution { public: int strstr(string large, string small) { if (small == \"\" ) return 0 ; int m = large.size(), n = small.size(); typedef unsigned long long ULL; int P = 131 ; vector < ULL > h(m + 1 , 1 ); ULL p = 1 , check = 1 ; for ( int i = 1 ; i <= m; ++ i) { h[i] = h[i - 1 ] * P + large[i - 1 ]; if (i <= n) { p *= P; check = check * P + small[i - 1 ]; } } check = check - p; for ( int i = 1 ; i <= m - n + 1 ; ++ i) { if (h[i + n - 1 ] - h[i - 1 ] * p == check) return i - 1 ; } return - 1 ; } };","title":"Code"},{"location":"Interview/string/","text":"Reverse \u00b6 Reverse \"I love yahoo\" to \"yahoo love I\" reverse entire string: \"oohay evol I\" reverse each word: \"yahoo love I\" Trick \u00b6 Right shift a given string by n characters. Assumptions The given string is not null. n >= 0. Examples \"abc\", 4 -> \"cab\" class Solution { public: string rightShift(string s, int n) { // write your solution here if ( ! n || s == \"\" ) return s; reverse(s.begin(), s.end()); int shift = n % s.size(); reverse(s.begin() + shift, s.end()); reverse(s.begin(), s.begin() + shift); return s; } }; Replacement \u00b6 Replace \"student\" to \"stuXXt\" -> replace all \"den\" to \"XX\" Note that replacement may have different size Use two pointers method + If p.size() > replaced part: 1. add space to the end of the original string (buffer zone) 2. start from right to left to replace (replace in reversed order) + If p.size() < replaced part 1. start from left to right. replace if met and continue on https://app.laicode.io/app/problem/649 // TODO for ( int i = 0 , j = 0 ; i < n; ++ i) { if (s[i] == p[j]) { j ++ ; s[i] = p[j]; } }","title":"String"},{"location":"Interview/string/#reverse","text":"Reverse \"I love yahoo\" to \"yahoo love I\" reverse entire string: \"oohay evol I\" reverse each word: \"yahoo love I\"","title":"Reverse"},{"location":"Interview/string/#trick","text":"Right shift a given string by n characters. Assumptions The given string is not null. n >= 0. Examples \"abc\", 4 -> \"cab\" class Solution { public: string rightShift(string s, int n) { // write your solution here if ( ! n || s == \"\" ) return s; reverse(s.begin(), s.end()); int shift = n % s.size(); reverse(s.begin() + shift, s.end()); reverse(s.begin(), s.begin() + shift); return s; } };","title":"Trick"},{"location":"Interview/string/#replacement","text":"Replace \"student\" to \"stuXXt\" -> replace all \"den\" to \"XX\" Note that replacement may have different size Use two pointers method + If p.size() > replaced part: 1. add space to the end of the original string (buffer zone) 2. start from right to left to replace (replace in reversed order) + If p.size() < replaced part 1. start from left to right. replace if met and continue on https://app.laicode.io/app/problem/649 // TODO for ( int i = 0 , j = 0 ; i < n; ++ i) { if (s[i] == p[j]) { j ++ ; s[i] = p[j]; } }","title":"Replacement"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/","text":"Generate all subset duplicate character can exist in the single set of a sequence \u00b6 All elements are distinct \u00b6 Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Analysis \u00b6 Since each element can either be included or not included, we have 2^N 2^N subsets. branch factor = 1 to n, height = 1 to n branch factor = 2 (choose or not choose), height = n Code 1: using bitwise manipulation \u00b6 class Solution { public: // use binary increment for listing all the combination of bits // converting the binary representation to subset representation vector < vector < int >> subsets(vector < int >& nums) { vector < vector < int >> res; for ( int i = 0 ; i < 1 << nums.size(); ++ i) { vector < int > temp; for ( int j = 0 ; j < nums.size(); ++ j) { // check if current bit is 1, if so, add the value to list if ((i >> j) & 1 ) temp.push_back(nums[j]); } res.push_back(temp); } return res; } }; Code 2: using backtracking/dfs with varied branch factor \u00b6 class Solution { public: vector < vector < int >> ret; vector < vector < int >> subsets(vector < int >& nums) { vector < int > v; helper(v, nums, 0 ); return ret; } void helper(vector < int > curr, vector < int >& nums, int i) { ret.push_back(curr); for (; i < nums.size(); ++ i) { curr.push_back(nums[i]); helper(curr, nums, i + 1 ); curr.pop_back(); } } }; Code 3: using backtracking/dfs with choose or not \u00b6 class Solution { public: vector < vector < int >> res; void dfs (vector < int >& nums, int i, vector < int >& curr) { if (i == nums.size()) { res.push_back(curr); return ; } // choose current element from nums[i] curr.push_back(nums[i]); dfs(nums, i + 1 , curr); curr.pop_back(); // not choose dfs(nums, i + 1 , curr); } vector < vector < int >> subsets(vector < int >& nums) { vector < int > curr; dfs(nums, 0 , curr); return res; } }; There are duplicates in the given nums \u00b6 Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Anaylsis \u00b6 Different from the distinct element subset problem, now we need to decide how to deal with duplicate: 1,2 and 1,2,2 are two different subsets, so we need to decide when to stop the recursion. In the previous problem, using \"choose or not choose\" we stop as we have reach to the end of the elements to be chosen. See the recursion tree for this particular problem: Code 1: using backtracking/dfs with varied branch factor \u00b6 class Solution { public: vector < vector < int >> subsetsWithDup(vector < int > & S) { if (S.empty()) return {}; vector < vector < int >> res; vector < int > out; sort(S.begin(), S.end()); getSubsets(S, 0 , out, res); return res; } void getSubsets(vector < int > & S, int pos, vector < int > & out, vector < vector < int >> & res) { res.push_back(out); for ( int i = pos; i < S.size(); ++ i) { out.push_back(S[i]); getSubsets(S, i + 1 , out, res); out.pop_back(); while (i + 1 < S.size() && S[i] == S[i + 1 ]) ++ i; } } }; Code 2: using backtracking/dfs with choose or not \u00b6 class Solution { public: vector < vector < int >> res; void dfs ( int i, vector < int >& s, vector < int >& curr) { if (i == s.size()) { res.push_back(curr); return ; } // choose current s[i] curr.push_back(s[i]); dfs(i + 1 , s, curr); curr.pop_back(); // not choose current s[i] and skip all the rest that are duplicated with s[i] int idx = i; while (i < s.size() && s[idx] == s[i]) i ++ ; dfs(i, s, curr); } vector < vector < int >> subsetsWithDup(vector < int >& nums) { sort(nums.begin(), nums.end()); vector < int > curr; dfs( 0 , nums, curr); return res; } }; Combination \u00b6","title":"Subset, combination, permutation problems"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#generate-all-subset-duplicate-character-can-exist-in-the-single-set-of-a-sequence","text":"","title":"Generate all subset duplicate character can exist in the single set of a sequence"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#all-elements-are-distinct","text":"Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]","title":"All elements are distinct"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#analysis","text":"Since each element can either be included or not included, we have 2^N 2^N subsets. branch factor = 1 to n, height = 1 to n branch factor = 2 (choose or not choose), height = n","title":"Analysis"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-1-using-bitwise-manipulation","text":"class Solution { public: // use binary increment for listing all the combination of bits // converting the binary representation to subset representation vector < vector < int >> subsets(vector < int >& nums) { vector < vector < int >> res; for ( int i = 0 ; i < 1 << nums.size(); ++ i) { vector < int > temp; for ( int j = 0 ; j < nums.size(); ++ j) { // check if current bit is 1, if so, add the value to list if ((i >> j) & 1 ) temp.push_back(nums[j]); } res.push_back(temp); } return res; } };","title":"Code 1: using bitwise manipulation"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-2-using-backtrackingdfs-with-varied-branch-factor","text":"class Solution { public: vector < vector < int >> ret; vector < vector < int >> subsets(vector < int >& nums) { vector < int > v; helper(v, nums, 0 ); return ret; } void helper(vector < int > curr, vector < int >& nums, int i) { ret.push_back(curr); for (; i < nums.size(); ++ i) { curr.push_back(nums[i]); helper(curr, nums, i + 1 ); curr.pop_back(); } } };","title":"Code 2: using backtracking/dfs with varied branch factor"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-3-using-backtrackingdfs-with-choose-or-not","text":"class Solution { public: vector < vector < int >> res; void dfs (vector < int >& nums, int i, vector < int >& curr) { if (i == nums.size()) { res.push_back(curr); return ; } // choose current element from nums[i] curr.push_back(nums[i]); dfs(nums, i + 1 , curr); curr.pop_back(); // not choose dfs(nums, i + 1 , curr); } vector < vector < int >> subsets(vector < int >& nums) { vector < int > curr; dfs(nums, 0 , curr); return res; } };","title":"Code 3: using backtracking/dfs with choose or not"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#there-are-duplicates-in-the-given-nums","text":"Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]","title":"There are duplicates in the given nums"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#anaylsis","text":"Different from the distinct element subset problem, now we need to decide how to deal with duplicate: 1,2 and 1,2,2 are two different subsets, so we need to decide when to stop the recursion. In the previous problem, using \"choose or not choose\" we stop as we have reach to the end of the elements to be chosen. See the recursion tree for this particular problem:","title":"Anaylsis"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-1-using-backtrackingdfs-with-varied-branch-factor","text":"class Solution { public: vector < vector < int >> subsetsWithDup(vector < int > & S) { if (S.empty()) return {}; vector < vector < int >> res; vector < int > out; sort(S.begin(), S.end()); getSubsets(S, 0 , out, res); return res; } void getSubsets(vector < int > & S, int pos, vector < int > & out, vector < vector < int >> & res) { res.push_back(out); for ( int i = pos; i < S.size(); ++ i) { out.push_back(S[i]); getSubsets(S, i + 1 , out, res); out.pop_back(); while (i + 1 < S.size() && S[i] == S[i + 1 ]) ++ i; } } };","title":"Code 1: using backtracking/dfs with varied branch factor"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#code-2-using-backtrackingdfs-with-choose-or-not","text":"class Solution { public: vector < vector < int >> res; void dfs ( int i, vector < int >& s, vector < int >& curr) { if (i == s.size()) { res.push_back(curr); return ; } // choose current s[i] curr.push_back(s[i]); dfs(i + 1 , s, curr); curr.pop_back(); // not choose current s[i] and skip all the rest that are duplicated with s[i] int idx = i; while (i < s.size() && s[idx] == s[i]) i ++ ; dfs(i, s, curr); } vector < vector < int >> subsetsWithDup(vector < int >& nums) { sort(nums.begin(), nums.end()); vector < int > curr; dfs( 0 , nums, curr); return res; } };","title":"Code 2: using backtracking/dfs with choose or not"},{"location":"Interview/subset%2C-combination%2C-permutation-problems/#combination","text":"","title":"Combination"},{"location":"Interview/tree/","text":"Balanced Tree \u00b6 Def: height of the left and right subtrees of every node differ by 1 or less. Method 1: check is balanced \u00b6 int height (TreeNode * root) { if ( ! root) return 0 ; return max(height(root -> left), height(root -> right)) + 1 ; } bool isBalanced (TreeNode * root) { if ( ! root) return true; if (abs(height(root -> left) - height(root -> right)) > 1 ) return false; return isBalanced(root -> left) && isBalanced(root -> right); } Analysis \u00b6 Time: worst case happens when tree is balanced, so there are log(n) levels. first level requires n ops to get height, second = n/2, ....1. So total complexity is n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} Space: \\log{n} \\log{n} Method 2: check is balanced \u00b6 int checkDepth (TreeNode * root) { if ( ! root) return 0 ; int left = checkDepth(root -> left); if (left == - 1 ) return - 1 ; int right = checkDepth(root -> right); if (right == - 1 ) return - 1 ; if (abs(right - left) > 1 ) return - 1 ; else return 1 + max(left, right); } bool isBalanced (TreeNode * root) { if (checkDepth(root) == - 1 ) return false; else return true; } Analysis \u00b6 For each node, early terminate if left or right subtree is invalid. Each node only requries to visit once, so the time compleixty is O(n) O(n) Space Compleixty: the worst case would be like a linkedlist and the height is n, so O(n) O(n) Symmetric Tree \u00b6 Assume if we tweak the lchild with rchild of an arbitrary node in a binary tree, then the \"structure\" of the tree are not changed. Then how can we determinte whether two binary trees' structures are identical. bool isTweakedIdentical (TreeNode * l, TreeNode * r) { // write your solution here if ( ! l && ! r) return true; if ( ! l || ! r) return false; if (l -> value != r -> value) return false; return (isTweakedIdentical(l -> left, r -> right) && isTweakedIdentical(l -> right, r -> left)) || (isTweakedIdentical(l -> right, r -> right) && isTweakedIdentical(l -> left, r -> left)) || (isTweakedIdentical(l -> left, r -> left) && isTweakedIdentical(l -> right, r -> right)) || (isTweakedIdentical(l -> right, r -> left) && isTweakedIdentical(l -> left, r -> right)); } Analysis \u00b6 Each level has four nodes, and total cost is N. There are \\log_2{N} \\log_2{N} because the wrost case is when the tree is balanced (there are not a lot early terminations). Total number of nodes in the quadral tree is 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) Space: wrost case is linkedlist so O(n) O(n) Traverse Tree \u00b6 pre-order: root -> left -> right in-order: left -> root -> right post-order: left -> right -> root Pre-order \u00b6 recursion: vector < int > res; vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; res.push_back(root -> val); preorderTraversal(root -> left); preorderTraversal(root -> right); /* traverse a graph for (int i = 0; i < n; ++i) preorder(root -> neighbour[i]); */ return res; } iterative: vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st{{root}}; while ( ! st.empty()) { TreeNode * t = st.top(); st.pop(); res.push_back(t -> val); /* traverse a graph for (int i = n - 1; i >= 0; --i) preorder(root -> neighbour[i]); */ if (t -> right) st.push(t -> right); // push right first, so it will be popped last if (t -> left) st.push(t -> left); } return res; } In-order \u00b6 recursion: vector < int > res; vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; /* traverse a graph: all from 0 to current root for (int i = 0; i < m; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> left); res.push_back(root -> val); /* traverse a graph: all from current root to the end for (int i = m; i < n; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> right); return res; } iterative: vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st; while (root || ! st.empty()) { while (root) { // first push all the left children to the stack st.push(root); root = root -> left; } root = st.top(); st.pop(); res.push_back(root -> val); root = root -> right; } return res; } Post-order \u00b6 recursion: vector < int > res; vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; postorderTraversal(root -> left); postorderTraversal(root -> right); res.push_back(root -> val); return res; } iterative: vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> s; while (root || ! s.empty()) { if (root) { s.push(root); res.insert(res.begin(), root -> val); root = root -> right; } else { TreeNode * pleft = s.top(); s.pop(); root = pleft -> left; } } return res; } Binary Searh Tree \u00b6 Query \u00b6 find min/max: while x.left / x.right != null: x = x.left / x.right return x // if using x.left -> min, x.right -> max Insertion \u00b6 class Solution { public: TreeNode * insertIntoBST(TreeNode * root, int val) { if ( ! root) return new TreeNode(val); TreeNode * cur = root; while (true) { if (cur -> val > val) { if ( ! cur -> left) { cur -> left = new TreeNode(val); break ; } cur = cur -> left; } else { if ( ! cur -> right) { cur -> right = new TreeNode(val); break ; } cur = cur -> right; } } return root; } }; Form the Minimal Tree \u00b6 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a bnary search tree with minimal height. Analysis \u00b6 In order to have the shortest height, we need to make left subtree and right subtree as close size as possible. To do so, we can recursively find the middle value of the sorted array and then appoints that as the root node (left subtree and right subtree). Code \u00b6 TreeNode * h (vector < int >& arr, int l, int r) { if (l == r) return NULL; int mid = (l + r) >> 1 ; TreeNode * n = new TreeNode(arr[mid]); n -> left = h(arr, l, mid - 1 ); // [l, mid) are less than arr[mid] n -> right = h(arr, mid + 1 , r); // (mid, r] are greater than arr[mid] return n; } TreeNode * createMinimalBST (vector < int >& arr) { return h(arr, 0 , arr.size() - 1 ); }","title":"Tree"},{"location":"Interview/tree/#balanced-tree","text":"Def: height of the left and right subtrees of every node differ by 1 or less.","title":"Balanced Tree"},{"location":"Interview/tree/#method-1-check-is-balanced","text":"int height (TreeNode * root) { if ( ! root) return 0 ; return max(height(root -> left), height(root -> right)) + 1 ; } bool isBalanced (TreeNode * root) { if ( ! root) return true; if (abs(height(root -> left) - height(root -> right)) > 1 ) return false; return isBalanced(root -> left) && isBalanced(root -> right); }","title":"Method 1: check is balanced"},{"location":"Interview/tree/#analysis","text":"Time: worst case happens when tree is balanced, so there are log(n) levels. first level requires n ops to get height, second = n/2, ....1. So total complexity is n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} n + n / 2 + n / 4 + .... + n \\times 2^{\\log{n}} = n \\log{n} Space: \\log{n} \\log{n}","title":"Analysis"},{"location":"Interview/tree/#method-2-check-is-balanced","text":"int checkDepth (TreeNode * root) { if ( ! root) return 0 ; int left = checkDepth(root -> left); if (left == - 1 ) return - 1 ; int right = checkDepth(root -> right); if (right == - 1 ) return - 1 ; if (abs(right - left) > 1 ) return - 1 ; else return 1 + max(left, right); } bool isBalanced (TreeNode * root) { if (checkDepth(root) == - 1 ) return false; else return true; }","title":"Method 2: check is balanced"},{"location":"Interview/tree/#analysis_1","text":"For each node, early terminate if left or right subtree is invalid. Each node only requries to visit once, so the time compleixty is O(n) O(n) Space Compleixty: the worst case would be like a linkedlist and the height is n, so O(n) O(n)","title":"Analysis"},{"location":"Interview/tree/#symmetric-tree","text":"Assume if we tweak the lchild with rchild of an arbitrary node in a binary tree, then the \"structure\" of the tree are not changed. Then how can we determinte whether two binary trees' structures are identical. bool isTweakedIdentical (TreeNode * l, TreeNode * r) { // write your solution here if ( ! l && ! r) return true; if ( ! l || ! r) return false; if (l -> value != r -> value) return false; return (isTweakedIdentical(l -> left, r -> right) && isTweakedIdentical(l -> right, r -> left)) || (isTweakedIdentical(l -> right, r -> right) && isTweakedIdentical(l -> left, r -> left)) || (isTweakedIdentical(l -> left, r -> left) && isTweakedIdentical(l -> right, r -> right)) || (isTweakedIdentical(l -> right, r -> left) && isTweakedIdentical(l -> left, r -> right)); }","title":"Symmetric Tree"},{"location":"Interview/tree/#analysis_2","text":"Each level has four nodes, and total cost is N. There are \\log_2{N} \\log_2{N} because the wrost case is when the tree is balanced (there are not a lot early terminations). Total number of nodes in the quadral tree is 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) 1 + 4 + 16 .... + 4^{\\log_2{n}} \\approx 4^{\\log_2{n}} = 2^{2\\log_2{n}} = 2^{\\log_2{n^2}} = O(n^2) Space: wrost case is linkedlist so O(n) O(n)","title":"Analysis"},{"location":"Interview/tree/#traverse-tree","text":"pre-order: root -> left -> right in-order: left -> root -> right post-order: left -> right -> root","title":"Traverse Tree"},{"location":"Interview/tree/#pre-order","text":"recursion: vector < int > res; vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; res.push_back(root -> val); preorderTraversal(root -> left); preorderTraversal(root -> right); /* traverse a graph for (int i = 0; i < n; ++i) preorder(root -> neighbour[i]); */ return res; } iterative: vector < int > preorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st{{root}}; while ( ! st.empty()) { TreeNode * t = st.top(); st.pop(); res.push_back(t -> val); /* traverse a graph for (int i = n - 1; i >= 0; --i) preorder(root -> neighbour[i]); */ if (t -> right) st.push(t -> right); // push right first, so it will be popped last if (t -> left) st.push(t -> left); } return res; }","title":"Pre-order"},{"location":"Interview/tree/#in-order","text":"recursion: vector < int > res; vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; /* traverse a graph: all from 0 to current root for (int i = 0; i < m; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> left); res.push_back(root -> val); /* traverse a graph: all from current root to the end for (int i = m; i < n; ++i) inorder(root -> neighbour[i]); */ inorderTraversal(root -> right); return res; } iterative: vector < int > inorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> st; while (root || ! st.empty()) { while (root) { // first push all the left children to the stack st.push(root); root = root -> left; } root = st.top(); st.pop(); res.push_back(root -> val); root = root -> right; } return res; }","title":"In-order"},{"location":"Interview/tree/#post-order","text":"recursion: vector < int > res; vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; postorderTraversal(root -> left); postorderTraversal(root -> right); res.push_back(root -> val); return res; } iterative: vector < int > postorderTraversal(TreeNode * root) { if ( ! root) return {}; vector < int > res; stack < TreeNode *> s; while (root || ! s.empty()) { if (root) { s.push(root); res.insert(res.begin(), root -> val); root = root -> right; } else { TreeNode * pleft = s.top(); s.pop(); root = pleft -> left; } } return res; }","title":"Post-order"},{"location":"Interview/tree/#binary-searh-tree","text":"","title":"Binary Searh Tree"},{"location":"Interview/tree/#query","text":"find min/max: while x.left / x.right != null: x = x.left / x.right return x // if using x.left -> min, x.right -> max","title":"Query"},{"location":"Interview/tree/#insertion","text":"class Solution { public: TreeNode * insertIntoBST(TreeNode * root, int val) { if ( ! root) return new TreeNode(val); TreeNode * cur = root; while (true) { if (cur -> val > val) { if ( ! cur -> left) { cur -> left = new TreeNode(val); break ; } cur = cur -> left; } else { if ( ! cur -> right) { cur -> right = new TreeNode(val); break ; } cur = cur -> right; } } return root; } };","title":"Insertion"},{"location":"Interview/tree/#form-the-minimal-tree","text":"Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a bnary search tree with minimal height.","title":"Form the Minimal Tree"},{"location":"Interview/tree/#analysis_3","text":"In order to have the shortest height, we need to make left subtree and right subtree as close size as possible. To do so, we can recursively find the middle value of the sorted array and then appoints that as the root node (left subtree and right subtree).","title":"Analysis"},{"location":"Interview/tree/#code","text":"TreeNode * h (vector < int >& arr, int l, int r) { if (l == r) return NULL; int mid = (l + r) >> 1 ; TreeNode * n = new TreeNode(arr[mid]); n -> left = h(arr, l, mid - 1 ); // [l, mid) are less than arr[mid] n -> right = h(arr, mid + 1 , r); // (mid, r] are greater than arr[mid] return n; } TreeNode * createMinimalBST (vector < int >& arr) { return h(arr, 0 , arr.size() - 1 ); }","title":"Code"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/","text":"5.26 Consider a hash table of size seven, with starting index zero, and a hash function (7x+3) mod 4. Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing ? Here \u201c__\u201d denotes an empty location in the table. _ 1 _ _ 3 _ 1 _ _ 3 _ 1 8 _ _ 3 10 1 8 _ _ _ 5.25 To implement Dijkstra\u2019s shortest path algorithm on unweighted graphs so that it runs in linear time, the data structure to be used is\uff1f Priority Queue 5.24 When do we consider using dynamic programming? For problem that can be solved by dividing problems to sub problems, where results of sub problems can be reused. It can be solved by recursion method but recursion here is sometimes not ideal in time complexity (too many overlapping a). Since the results can be reused. DP provides a way to record and reuse the results from previous solved sub problems, which greatly reduce the time complexity. 5.23 Analysis Complexity 5.22 Check output 5.21 Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix. 5.20 What does final mean in Java? What does finally mean in Java? final is a keyword that once a field/method/class has been designed, it\u2019s unchangeable and un override-able. Finally is a block that always executed when the try block exits. 5.19 What is dependency injection\uff1f https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/ 5.18 What are the differences between overload and override? 1). The real object type in the run-time, not the reference variable's type, determines which overridden method is used at runtime. In contrast, reference type determines which overloaded method will be used at compile time. 2). Polymorphism applies to overriding, not to overloading. 3). Overriding is a run-time concept while overloading is a compile-time concept. 5.17 Which class does all the Enums directly extend? All enums extend java.lang.Enum. Enum cannot extend any other class. 5.16 Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than that of array. Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity? \u6536\u5230\u5927\u5bb6\u7684\u6253\u5361\u5566~\u6628\u5929\u57fa\u7840\u9898\u7684\u7b54\u6848\u662f Heap Sort\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(nLogk) create a Min heap \uff0c\u6700\u5c0f\u5143\u7d20\u5728\u7b2ck+1\u4f4d\u7f6e\uff0c\u6392\u5e8f\u6574\u4e2aarray\uff0co(k)\u5efa\u7acb\u4e00\u4e2amin heap,O(n-k)logk\u5bf9\u4e8e\u5269\u4f59\u5143\u7d20\uff0cO1\u4ecemin heap\u4e2d\u53d6\u51fa\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6nlogk 5.15 What is OOPS? Could you name some important OOPS features in Java? Object Oriented Programing ,like java, is different from Process Oriented programing, like C. More focus on the object itself rather running process. we can bind the data and the function methods together in the object. Program become more flexible. Important features like inheritance, abstraction, polymorphism, Encapsulation and so on. 5.14 In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child? \u55ef\u55ef\uff0c\u6bcf\u4e2anode\u7684child\u90fd\u662f2\u4e2a\uff0c\u90a3node\u7684descendent\u5c31\u4f1a\u662f0\uff0c2\uff0c4\uff0c6 and so on \u5982\u679c\u8981\u8bc1\u660e\u7684\u8bdd\uff0c\u53ef\u4ee5\u7528\u53cd\u6b63\u6cd5\uff1a\u82e5\u5b58\u5728\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u5b69\u5b50\u7684\u7ed3\u70b9X\uff0c\u5047\u8bbeX->right=NULL\uff0c\u90a3\u4e48\u7531\u4e8eX\u548cX->left\u7684descendent\u6570\u76ee\u5747\u8981\u4e3a\u5947\u6570\uff0c\u4f46\u8fd9\u4e24\u4e2a\u503c\u53ea\u5dee1\uff0c\u56e0\u6b64\u77db\u76fe 5.13 What are the differences between traversing a graph and traversing a tree? tree \u7684\u904d\u5386\u53ef\u4ee5\u7528 pre-order, in-order, post-order, level-order, \u524d\u4e09\u79cd\u90fd\u53ef\u4ee5\u7528 dfs \u6765\u5b9e\u73b0\uff0c\u6700\u540e\u4e00\u79cd\u7528 bfs\u3002graph \u7684\u904d\u5386\u4e5f\u53ef\u4ee5\u7528 dfs \u6216\u8005 bfs\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f graph \u4e2d\u53ef\u80fd\u6709\u975e\u8fde\u901a\u533a\u57df\uff0c\u9700\u8981\u4ee5\u6bcf\u4e2a\u8282\u70b9\u4e3a\u8d77\u59cb\u6765\u505a\u4e00\u904d bfs/dfs\uff0c\u5f53\u7136\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b deduplicate \u673a\u5236\u6765\u907f\u514d\u91cd\u590d 5.12 An unordered list contains n distinct elements. What is number of comparisons to find an element in this list that is neither maximum nor minimum? worst case\u662f3\u6b21 \u590d\u6742\u5ea6\u662f\u0398(1) \u9700\u8981\u8ba8\u8bban!=length\u7684case 5.26 Alien Dictionary https://app.laicode.io/app/problem/501 5.25 Merge Stones https://app.laicode.io/app/problem/96 5.24 Edit Distance https://app.laicode.io/app/problem/100 5.23 Largest Rectangle Of 1s https://app.laicode.io/app/problem/102 5.22 Depth Of Forest https://app.laicode.io/app/problem/323 5.21 Walls and gates https://app.laicode.io/app/problem/503 5.20 All Permutations II https://app.laicode.io/app/problem/65 5.19 Restore IP Addresses https://app.laicode.io/app/problem/147 5.18 Longest Substring With K Typed Characters https://app.laicode.io/app/problem/285 5.17 Compress String https://app.laicode.io/app/problem/173 StringBuilder in Java 5.16 Distance Of Two Nodes In Binary Tree https://app.laicode.io/app/problem/299 LCA 5.15 Longest Ascending Path Binary Tree https://app.laicode.io/app/problem/388 tree height 5.14 Merge Sort Linked List https://app.laicode.io/app/problem/29 5.13 Search In Bitonic Array https://app.laicode.io/app/problem/401 bst 5.12 Largest Container https://app.laicode.io/app/problem/201 Longest Substring With K Typed Characters \u00b6 Given a string, return the longest contiguous substring that contains exactly k type of characters. Return null if there does not exist such substring. Assumptions: The given string is not null and guaranteed to have at least k different characters. k > 0. Examples: input = \"aabcc\", k = 3, output = \"aabcc\". input = \"aabcccc\", k = 2, output = \"bcccc\". Analysis \u00b6 Using sliding window to search and update the current longest string: dabaaebac: l = 0, r = 0, cnt = 0, len = 9 l = 0, r = 7: dabaaeba Code \u00b6 class Solution { public: string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt <= k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt <= k && len < r - l) { // cnt is valid len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // cnt is invalid len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } };","title":"\u6bcf\u65e5\u6253\u5361"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#longest-substring-with-k-typed-characters","text":"Given a string, return the longest contiguous substring that contains exactly k type of characters. Return null if there does not exist such substring. Assumptions: The given string is not null and guaranteed to have at least k different characters. k > 0. Examples: input = \"aabcc\", k = 3, output = \"aabcc\". input = \"aabcccc\", k = 2, output = \"bcccc\".","title":"Longest Substring With K Typed Characters"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#analysis","text":"Using sliding window to search and update the current longest string: dabaaebac: l = 0, r = 0, cnt = 0, len = 9 l = 0, r = 7: dabaaeba","title":"Analysis"},{"location":"Interview/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/#code","text":"class Solution { public: string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt <= k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt <= k && len < r - l) { // cnt is valid len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // cnt is invalid len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } };","title":"Code"},{"location":"Java/array%2C-class-and-objects/","text":"1D/2D Array constructor initialization read/write length/dimension traversal Main Function public static void main(String[] args) signacture OOD or OOP class, object, reference, dereference Student tom = new Student(\"Tom\", 5, 4.0); Declaration Instantiation Initialization Assignment Array \u00b6 1-D array \u00b6 create: int[] array = new int[10]; once create, size cannot be modified int [] numbers = new int [] { 1 , 2 , 3 , 4 }; int num = numbers [ 2 ] ; number [ 4 ] = 15 ; int size = numbers. length ; for ( int index = 0 ; index < number. length ; ++ index) {} for ( int num : numbers) {} Max value \u00b6 Integer. MAX_VALUE Integer. MIN_VALUE Insert \u00b6 public int [] reverse ( int [] arr) { int [] new_arr = new int [ arr. length - 1 ] ; for ( int i = 0 ; i < position; ++ i) { new_arr [ i ] = arr [ i ] ; } new_arr [ position ] = element; for ( int i = position; i < arr. length ; ++ i) { new_arr [ i + 1 ] = arr [ i ] ; } return new_arr; } Reverse Array \u00b6 swap public int [] reverse ( int [] arr) { int i = 0 , j = arr. length - 1 ; while (i < j) { int tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp; i ++ , j -- ; } return arr; } 2-D Array \u00b6 create \u00b6 int [][] matrix = new int [][] {{ 2 , 1 },{ 4 , 7 },{ 5 , 9 }}; int [] firstRow = matrix [ 0 ] ; int firstElementOfSecondRow = matrix [ 1 ][ 0 ] ; int rows = matrix. length ; // (row = 3 because the array has 3 elements) int cols = matrix [ 0 ] . length ; calculate \"g\": the diagonal -- has to be square matrix \u00b6 public int [] reverse ( int [][] matrix) { int g = 0 ; for ( int i = 0 ; i < matrix. length ; ++ i) { g += matrix [ i ][ i ] ; } return g; } calculate sum of two matrix -- has to be same dimension \u00b6 public int [][] reverse ( int [][] matrix1, int [][] matrix2) { int row = matrix1. length ; int col = matrix1 [ 0 ] . length ; int [][] result = new int [][] ; for ( int i = 0 ; i < row; ++ i) { for ( int j = 0 ; j < col; ++ j) { result [ i ][ j ] = matrix1 [ i ][ j ] + matrix2 [ i ][ j ] ; } } return result; } Main Function \u00b6 public static void main (String [] args) { System. out . println ( \"hello world.\" ); } OOD or OOP \u00b6 Memory Layout \u00b6 Stack: local variable (in function or scope) Heap: all the object","title":"Array, class and objects"},{"location":"Java/array%2C-class-and-objects/#array","text":"","title":"Array"},{"location":"Java/array%2C-class-and-objects/#1-d-array","text":"create: int[] array = new int[10]; once create, size cannot be modified int [] numbers = new int [] { 1 , 2 , 3 , 4 }; int num = numbers [ 2 ] ; number [ 4 ] = 15 ; int size = numbers. length ; for ( int index = 0 ; index < number. length ; ++ index) {} for ( int num : numbers) {}","title":"1-D array"},{"location":"Java/array%2C-class-and-objects/#max-value","text":"Integer. MAX_VALUE Integer. MIN_VALUE","title":"Max value"},{"location":"Java/array%2C-class-and-objects/#insert","text":"public int [] reverse ( int [] arr) { int [] new_arr = new int [ arr. length - 1 ] ; for ( int i = 0 ; i < position; ++ i) { new_arr [ i ] = arr [ i ] ; } new_arr [ position ] = element; for ( int i = position; i < arr. length ; ++ i) { new_arr [ i + 1 ] = arr [ i ] ; } return new_arr; }","title":"Insert"},{"location":"Java/array%2C-class-and-objects/#reverse-array","text":"swap public int [] reverse ( int [] arr) { int i = 0 , j = arr. length - 1 ; while (i < j) { int tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp; i ++ , j -- ; } return arr; }","title":"Reverse Array"},{"location":"Java/array%2C-class-and-objects/#2-d-array","text":"","title":"2-D Array"},{"location":"Java/array%2C-class-and-objects/#create","text":"int [][] matrix = new int [][] {{ 2 , 1 },{ 4 , 7 },{ 5 , 9 }}; int [] firstRow = matrix [ 0 ] ; int firstElementOfSecondRow = matrix [ 1 ][ 0 ] ; int rows = matrix. length ; // (row = 3 because the array has 3 elements) int cols = matrix [ 0 ] . length ;","title":"create"},{"location":"Java/array%2C-class-and-objects/#calculate-g-the-diagonal-has-to-be-square-matrix","text":"public int [] reverse ( int [][] matrix) { int g = 0 ; for ( int i = 0 ; i < matrix. length ; ++ i) { g += matrix [ i ][ i ] ; } return g; }","title":"calculate \"g\": the diagonal -- has to be square matrix"},{"location":"Java/array%2C-class-and-objects/#calculate-sum-of-two-matrix-has-to-be-same-dimension","text":"public int [][] reverse ( int [][] matrix1, int [][] matrix2) { int row = matrix1. length ; int col = matrix1 [ 0 ] . length ; int [][] result = new int [][] ; for ( int i = 0 ; i < row; ++ i) { for ( int j = 0 ; j < col; ++ j) { result [ i ][ j ] = matrix1 [ i ][ j ] + matrix2 [ i ][ j ] ; } } return result; }","title":"calculate sum of two matrix -- has to be same dimension"},{"location":"Java/array%2C-class-and-objects/#main-function","text":"public static void main (String [] args) { System. out . println ( \"hello world.\" ); }","title":"Main Function"},{"location":"Java/array%2C-class-and-objects/#ood-or-oop","text":"","title":"OOD or OOP"},{"location":"Java/array%2C-class-and-objects/#memory-layout","text":"Stack: local variable (in function or scope) Heap: all the object","title":"Memory Layout"},{"location":"Java/common-problem/","text":"Java pass-by-value \u00b6 reassignment int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b = new int [] { 2 }; // if print a, it will output 1 int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b [ 0 ] = 2 ; // if print a, it will output 2 pass in as parameter // anything \"new\" in function will stay local and will not modify the outter scope variable public void reassign ( int [] array) { array = new int [] { 2 }; } public void modify ( int [] array) { array [ 0 ] = 2 ; } public int [] returnArray ( int [] array) { array = new int [] { 2 }; return array; } public void foo ( int [] array) { array [ 0 ] = 2 ; // output this value 2 array = new int [] { 3 }; array [ 0 ] = 4 ; } public void foo2 ( int [] array) { array [ 0 ] = 2 ; array [ 0 ] = 4 ; // output 4 array = new int [] { 3 }; } public static void main (String [] args) { int [] array = new int [] { 1 }; reassign(array); //what\u2019s the result? 1 modify(array); //what\u2019s the result? 2 (ignore previous statement) array = returnArray(array); //what\u2019s the result? 2 (ignore previous statement) } debug \u00b6 public class Solution { public void reverse ( int [] array) { int [] array1 = new int [ array. length ] ; for ( int i = 0 ; i < array. length ; i = i + 1 ) { array1 [ i ]= array [ array. length - 1 - i ] ; } array = array1; // Write your solution here } Problem: Give an array list of integer, calculate the sum of squares of all its elements. Note: return 0 if the list is null or empty. Example: list = {1,2,3} \u2192 returns 14 (14=1 1+2 2+3*3) public class Solution { public int sumOfSquare (List < Integer > list) { if (list == null || list. isEmpty ()) { return 0 ; } int sum = 0 ; for ( int i = 0 ; i < list. size (); i ++ ) { sum += list. get (i) * list. get (i); } return sum; } Misc \u00b6 String s = 4 + \"aa\"; // will print 4aa, because 4.toString() + \"aa\", however it won't work in c++ low -> high precision: will cast implicitly (no need to add (long) for example). high -> low precision: need explict cast","title":"Common problem"},{"location":"Java/common-problem/#java-pass-by-value","text":"reassignment int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b = new int [] { 2 }; // if print a, it will output 1 int [] a = new int [] { 1 }; // a is on stack int [] b = a; // b still store on stack b [ 0 ] = 2 ; // if print a, it will output 2 pass in as parameter // anything \"new\" in function will stay local and will not modify the outter scope variable public void reassign ( int [] array) { array = new int [] { 2 }; } public void modify ( int [] array) { array [ 0 ] = 2 ; } public int [] returnArray ( int [] array) { array = new int [] { 2 }; return array; } public void foo ( int [] array) { array [ 0 ] = 2 ; // output this value 2 array = new int [] { 3 }; array [ 0 ] = 4 ; } public void foo2 ( int [] array) { array [ 0 ] = 2 ; array [ 0 ] = 4 ; // output 4 array = new int [] { 3 }; } public static void main (String [] args) { int [] array = new int [] { 1 }; reassign(array); //what\u2019s the result? 1 modify(array); //what\u2019s the result? 2 (ignore previous statement) array = returnArray(array); //what\u2019s the result? 2 (ignore previous statement) }","title":"Java pass-by-value"},{"location":"Java/common-problem/#debug","text":"public class Solution { public void reverse ( int [] array) { int [] array1 = new int [ array. length ] ; for ( int i = 0 ; i < array. length ; i = i + 1 ) { array1 [ i ]= array [ array. length - 1 - i ] ; } array = array1; // Write your solution here } Problem: Give an array list of integer, calculate the sum of squares of all its elements. Note: return 0 if the list is null or empty. Example: list = {1,2,3} \u2192 returns 14 (14=1 1+2 2+3*3) public class Solution { public int sumOfSquare (List < Integer > list) { if (list == null || list. isEmpty ()) { return 0 ; } int sum = 0 ; for ( int i = 0 ; i < list. size (); i ++ ) { sum += list. get (i) * list. get (i); } return sum; }","title":"debug"},{"location":"Java/common-problem/#misc","text":"String s = 4 + \"aa\"; // will print 4aa, because 4.toString() + \"aa\", however it won't work in c++ low -> high precision: will cast implicitly (no need to add (long) for example). high -> low precision: need explict cast","title":"Misc"},{"location":"Java/control-flow-and-methods/","text":"Method overloading \u00b6 method name is the same, but parameter type list is different 1. different types 2. different num of parameters 3. different order Notes \u00b6 return type cannot be used to identify which function to use \u00b6 public class test { public static int add ( double a, double b) { return ( int ) (a + b); } public static double add ( double a, double b) { return (a + b); } public static void main (String [] args) { double a = 1.3 , b = 2.4 ; // int c = add(a, b); System. out . println (add(a, b)); } }","title":"Control flow and methods"},{"location":"Java/control-flow-and-methods/#method-overloading","text":"method name is the same, but parameter type list is different 1. different types 2. different num of parameters 3. different order","title":"Method overloading"},{"location":"Java/control-flow-and-methods/#notes","text":"","title":"Notes"},{"location":"Java/control-flow-and-methods/#return-type-cannot-be-used-to-identify-which-function-to-use","text":"public class test { public static int add ( double a, double b) { return ( int ) (a + b); } public static double add ( double a, double b) { return (a + b); } public static void main (String [] args) { double a = 1.3 , b = 2.4 ; // int c = add(a, b); System. out . println (add(a, b)); } }","title":"return type cannot be used to identify which function to use"},{"location":"Java/css/","text":"@ CHARSET \"UTF-8\" ; html { height : 100 % ; } hr { margin-right : 10 px ; margin-left : 10 px ; height : 2 px ; background : url( http://ibrahimjabbari.com/english/images/hr-11.png ) repeat-x 0 0 ; border-top : 1 px dashed #866760 ; } table { border-radius : 10 px ; border-collapse : collapse ; } th { background-color : #7c7dca ; color : white ; border-bottom : 2 px dashed white ; } input[type=text] : focus { background-color : #d9e6e5 ; } input[type=text] : hover { width : 170 px ; } input[type=text] { width : 200 px ; box-sizing : border-box ; border : 2 px solid #ccc ; border-radius : 4 px ; font-size : 16 px ; padding : 5 px 5 px 5 px 10 px ; -webkit-transition : width 0.4 s ease-in-out ; transition : width 0.4 s ease-in-out ; } body { background-image : linear-gradient( to bottom , rgba( 33 , 97 , 140 , 0.3 ) 0 % ,rgba( 213 , 219 , 219 , 0.3 ) 100 % ); width : 100 % ; background-repeat : no-repeat ; background-size : cover ; background-attachment : fixed ; } th { font-family : 'Macondo' , Cursive; } a : hover { background-color : rgba( 230 , 230 , 230 , 0.6 ); } a { text-decoration : none ; color : #5f609a ; } #leftTd{ position : fixed ; } input { animation :showInput 3 s ease 1 forwards ; } #centerTd{ animation :showTable 1 s ease 1 forwards ; margin-bottom : 100 px ; } #uscImage{ -webkit-animation :spin 8 s linear infinite ; -moz-animation :spin 8 s linear infinite ; animation :spin 8 s linear infinite ; } @ keyframes spin { 100% { -webkit-transform : rotate( 360 deg ); transform :rotate( 360 deg ); } } @ -moz-keyframes spin { 100% { -moz-transform : rotate( 360 deg ); } } @ -webkit-keyframes spin { 100% { -webkit-transform : rotate( 360 deg ); } } @ -webkit-keyframes showInput { 0% { opacity : 0 ; width : 100 px ; } 50% { opacity : 0.5 ; width : 90 px ; } 100% { opacity : 1 ; width : 100 px ; } } @ -webkit-keyframes showTable { 0% { opacity : 0 ; } 50% { opacity : 0.5 ; } 100% { opacity : 1 ; } }","title":"Css"},{"location":"Java/primitive-types-and-basic-operations/","text":"Primitive Types \u00b6 char 2 bytes 2's complement \u00b6 flip all digit and +1 Default Value \u00b6 Instance field: 0 false null Local variable: not allow -> will throw compile exception","title":"Primitive types and basic operations"},{"location":"Java/primitive-types-and-basic-operations/#primitive-types","text":"char 2 bytes","title":"Primitive Types"},{"location":"Java/primitive-types-and-basic-operations/#2s-complement","text":"flip all digit and +1","title":"2's complement"},{"location":"Java/primitive-types-and-basic-operations/#default-value","text":"Instance field: 0 false null Local variable: not allow -> will throw compile exception","title":"Default Value"},{"location":"Java/serialization/","text":"Compare two Files containing two integer Complete the method below to read two integers from the input file, compare them, and write true or false into the output file based on whether the values are the same or not. // inputFile: path to input file; outputFile: path to output file public void compareValues (String inputFile, String outputFile) { Scanner scan = null ; PrintWriter pw = null ; try { scan = new Scanner( new FileReader(inputFile)); int num1 = scan. nextInt (); int num2 = scan. nextInt (); pw = new PrintWriter( new FileWriter(outputFile)); if (num1 == num2) { pw. println ( \"true\" ); } else { pw. println ( \"false\" ); } } catch (FileNotFoundException fnfe) { System. out . println ( \"fnfe: \" + fnfe. getMessage ()); } catch (IOException ioe) { System. out . println ( \"ioe: \" + ioe. getMessage ()); } finally { if (pw != null ) { pw. close (); } if (scan != null ) { scan. close (); } } } Scanner takes in a FileReader instannce FileReader takes in a path string ChatRoom Practice -- Serialization in network \u00b6 main thread for connection, and each thread with each client PrintWriter for printing string","title":"Serialization"},{"location":"Java/serialization/#chatroom-practice-serialization-in-network","text":"main thread for connection, and each thread with each client PrintWriter for printing string","title":"ChatRoom Practice -- Serialization in network"},{"location":"Java/tips/","text":"Min and Max value \u00b6 int: Integer.MAX_VALUE ( 2^{31} - 1 2^{31} - 1 ), Integer.MIN_VALUE ( -2^{31} -2^{31} )","title":"Tips"},{"location":"Java/tips/#min-and-max-value","text":"int: Integer.MAX_VALUE ( 2^{31} - 1 2^{31} - 1 ), Integer.MIN_VALUE ( -2^{31} -2^{31} )","title":"Min and Max value"},{"location":"Leetcode/10.-regular-expression-matching/","text":"class Solution { public: bool isMatch(string s, string p) { int n = s.length(), m = p.length(); vector < vector < bool >> f(n + 1 , vector < bool > (m + 1 , false)); s = \" \" + s; p = \" \" + p; f[ 0 ][ 0 ] = true; for ( int i = 0 ; i <= n; i ++ ) for ( int j = 1 ; j <= m; j ++ ) { if (i > 0 && (s[i] == p[j] || p[j] == '.' )) f[i][j] = f[i - 1 ][j - 1 ]; if (p[j] == '*' ) { if (j >= 2 ) f[i][j] = f[i][j - 2 ]; if (i > 0 && (s[i] == p[j - 1 ] || p[j - 1 ] == '.' )) f[i][j] = f[i][j] | f[i - 1 ][j]; // if anything happened to set f[i][j] = true, here will ignore if f[i-1][j] ?= true } } return f[n][m]; } }; dp[i][j]: s[0:i] matches p[0:j] if p[i] == . then matches everything from s, so dp[i][j] = true if p[i] == * then if dp[i][j-2] (skip the last one and check if previous one matches) or s[i] == p[j-1] or p[j-1] (match anything) set dp[i][j] = true","title":"10. regular expression matching"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/","text":"Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them. We repeatedly make duplicate removals on S until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique. Example 1: Input: \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". Note: 1 <= S.length <= 20000 S consists only of English lowercase letters. Analysis \u00b6 Because it requires to continuously merge and delete char that are the same, we should think about using stack to solve this problem. Solution 1 \u00b6 Using a stack to maintain resulting string, if there is a duplicate with the ongoing char, we just keep popping the stack (the top) in O(1) O(1) and put ongoing char back to the stack. Code \u00b6 class Solution { public: string removeDuplicates(string s) { int n = s.length(); string res; for ( int i = 0 ; i < n; ++ i) { if ( ! res.empty() && res.back() == s[i]) res.pop_back(); else res += s[i]; } return res; } }; Solution 2 \u00b6 The first solution requires to allocate a new string to be return (as a stack), which will create space overhead for the new string (if the string is all distinct, then the return string will have the same size of the input string). To solve this, we can use two pointer to mimic the stack operations, and then use substr from C++ to split the string (although substr also make copy, but if it's a linkedlist, we can just delete the remaining part in place). i: everything from 0:i are distinct (our returned string). j: probing pointer that will exam if our new string need to be \"shrink\" or not. assign s[i] = s[j] exam if s[i] == s[i - 1], if so, that means the jth char is invalid, we just need to step back by 2 (previous one is also going to be deleted). e.g. s = \"abbaca\" Code \u00b6 class Solution { public: string removeDuplicates(string s) { int i = 0 , n = s.length(); for ( int j = 0 ; j < n; ++ j, ++ i) { s[i] = s[j]; if (i > 0 && s[i - 1 ] == s[i]) i -= 2 ; // not only remove itself but also the remaining one in previous iteration } return s.substr( 0 , i); } };","title":"1047. remove all adjacent duplicates in string"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#analysis","text":"Because it requires to continuously merge and delete char that are the same, we should think about using stack to solve this problem.","title":"Analysis"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#solution-1","text":"Using a stack to maintain resulting string, if there is a duplicate with the ongoing char, we just keep popping the stack (the top) in O(1) O(1) and put ongoing char back to the stack.","title":"Solution 1"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#code","text":"class Solution { public: string removeDuplicates(string s) { int n = s.length(); string res; for ( int i = 0 ; i < n; ++ i) { if ( ! res.empty() && res.back() == s[i]) res.pop_back(); else res += s[i]; } return res; } };","title":"Code"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#solution-2","text":"The first solution requires to allocate a new string to be return (as a stack), which will create space overhead for the new string (if the string is all distinct, then the return string will have the same size of the input string). To solve this, we can use two pointer to mimic the stack operations, and then use substr from C++ to split the string (although substr also make copy, but if it's a linkedlist, we can just delete the remaining part in place). i: everything from 0:i are distinct (our returned string). j: probing pointer that will exam if our new string need to be \"shrink\" or not. assign s[i] = s[j] exam if s[i] == s[i - 1], if so, that means the jth char is invalid, we just need to step back by 2 (previous one is also going to be deleted). e.g. s = \"abbaca\"","title":"Solution 2"},{"location":"Leetcode/1047.-remove-all-adjacent-duplicates-in-string/#code_1","text":"class Solution { public: string removeDuplicates(string s) { int i = 0 , n = s.length(); for ( int j = 0 ; j < n; ++ j, ++ i) { s[i] = s[j]; if (i > 0 && s[i - 1 ] == s[i]) i -= 2 ; // not only remove itself but also the remaining one in previous iteration } return s.substr( 0 , i); } };","title":"Code"},{"location":"Leetcode/1057.-campus-bikes/","text":"On a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid. Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers. The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|. Return a vector ansof length N, where ans[i]is the index (0-indexed) of the bike that the i-th worker is assigned to. Example 1: Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]] Output: [1,0] Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0]. Example 2: Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]] Output: [0,2,1] Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1]. Note: 0 <= workers[i][j], bikes[i][j] < 1000 All worker and bike locations are distinct. 1 <= workers.length <= bikes.length <= 1000 Analysis \u00b6 Sort based on 1. Manahattan distance between bike and worker 2. Worker index 3. Bike index Using Priority Queue if the input is unbounded. Code \u00b6 /* * tmp.cpp * Copyright (C) 2020 Haoyang <me@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; typedef tuple < int , int , int > TII; int inline manhattan (vector < int >& p1, vector < int >& p2) { return abs(p1[ 0 ] - p2[ 0 ]) + abs(p1[ 1 ] - p2[ 1 ]); } vector < int > assignBikes(vector < vector < int >>& workers, vector < vector < int >>& bikes) { /* *auto cmp = [](const TII& l, const TII& r) { * int ld = get<0>(l), rd = get<0>(r), wl = get<1>(l), wr = get<1>(r), * bl = get<2>(l), br = get<2>(r); * if (ld != rd) * return ld > rd; * else if (wl != wr) * return wl > wr; * else * return bl > br; *}; */ //priority_queue<TII, vector<TII>, decltype(cmp)> pq(cmp); priority_queue < TII, vector < TII > , greater < TII >> pq; for ( int i = 0 ; i < workers.size(); ++ i) { for ( int j = 0 ; j < bikes.size(); ++ j) { pq.push({manhattan(workers[i], bikes[j]), i, j}); } } vector < int > wo(workers.size(), - 1 ), bi(bikes.size(), - 1 ); int assigned = 0 ; while ( ! pq.empty() && assigned < workers.size()) { TII t = pq.top(); printf( \"after: %d, %d, %d \\n \" , get < 0 > (t), get < 1 > (t), get < 2 > (t)); pq.pop(); if (wo[get < 1 > (t)] == - 1 && bi[get < 2 > (t)] == - 1 ) { // both unassigned wo[get < 1 > (t)] = get < 2 > (t); bi[get < 2 > (t)] = get < 1 > (t); assigned ++ ; } } return wo; } int main() { int w, b; cin >> w; vector < vector < int >> workers, bikes; for ( int i = 0 ; i < w; ++ i) { int x, y; cin >> x >> y; workers.push_back({x, y}); } cin >> b; for ( int i = 0 ; i < b; ++ i) { int x, y; cin >> x >> y; bikes.push_back({x, y}); } vector < int > res = assignBikes(workers, bikes); for ( int i : res) cout << i << \" \" ; return 0 ; } Variant 1: match as much as possible \u00b6 Find the assignment such that the most workers can be matched (there are obstacle that some bikes ain't reachabe by certain cars ). Using Hungarian algorithm \u00b6 match the workers in the order of manhattan distance (it actually doesn't matter, the order can be random) to the bike, keep matching until there is a tie. find the one with tie's other matches (same distance but different bike). Find the max # of matches for this bipartite graph Start from node 1, matches with 6 (because 6 < 8), then node 2 matches with 5 (5 < 7): mark matches with red lines When it comes to node 3, it can only matches with 6, but node 6 is already matched with 1. However, since node 1 can also matches with 8, node 1 will concede 6 and gives 6 to node 3. Final match: 4 pairs Complete Bipartite graph \u00b6 Since all workers can freely assigned with all the bikes, and bikes can \"choose\" any of the workers. It's a complete bipartitie graph. We should assume # of bikes != # of workes, or the ans is simply # of bikes or # of workers. #include<iostream> #include<cstring> using namespace std; const int N = 510 , M = 100010 ; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add ( int a , int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void init () { memset(h, - 1 , sizeof h); } int find ( int x) { //\u904d\u5386\u81ea\u5df1\u559c\u6b22\u7684\u5973\u5b69 for ( int i = h[x] ; i != - 1 ;i = ne[i]) { int j = e[i]; if ( ! st[j]) //\u5982\u679c\u5728\u8fd9\u4e00\u8f6e\u6a21\u62df\u5339\u914d\u4e2d,\u8fd9\u4e2a\u5973\u5b69\u5c1a\u672a\u88ab\u9884\u5b9a { st[j] = true; //\u90a3x\u5c31\u9884\u5b9a\u8fd9\u4e2a\u5973\u5b69\u4e86 //\u5982\u679c\u5973\u5b69j\u6ca1\u6709\u7537\u670b\u53cb\uff0c\u6216\u8005\u5979\u539f\u6765\u7684\u7537\u670b\u53cb\u80fd\u591f\u9884\u5b9a\u5176\u5b83\u559c\u6b22\u7684\u5973\u5b69\u3002\u914d\u5bf9\u6210\u529f if ( ! match[j] || find(match[j])) { match[j] = x; return true; } } } //\u81ea\u5df1\u4e2d\u610f\u7684\u5168\u90e8\u90fd\u88ab\u9884\u5b9a\u4e86\u3002\u914d\u5bf9\u5931\u8d25\u3002 return false; } int main () { init(); cin >> n1 >> n2 >> m; while (m -- ) { int a,b; cin >> a >> b; add(a,b); } int res = 0 ; for ( int i = 1 ; i <= n1 ;i ++ ) { //\u56e0\u4e3a\u6bcf\u6b21\u6a21\u62df\u5339\u914d\u7684\u9884\u5b9a\u60c5\u51b5\u90fd\u662f\u4e0d\u4e00\u6837\u7684\u6240\u4ee5\u6bcf\u8f6e\u6a21\u62df\u90fd\u8981\u521d\u59cb\u5316 memset(st,false, sizeof st); if (find(i)) res ++ ; } cout << res << endl; } \u4f5c\u8005\uff1a\u5728\u7ebf\u767d\u7ed9 \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/5334/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Variant 2: find the minimal total matches' manhattan distance \u00b6 Variant 3: find the max manhattan to be the smallest \u00b6 https://www.acwing.com/problem/content/259/ Property of the max distance: - dis > max: can assign all the bikes and workers whose manhattan distance are greater than max distance into other pairs (already assigned, so even if they have higher manhattan distance, they can still get the bike) - dis < max: there is a at least one bike and worker cannot be assigned whose distance is greater than max distance Use binary search for finding the biggest distance where the graph is still bipartite Use dfs to check if all the other can have the coloring Now we have a different problem: find the if the graph is bipartitie if max = ?, and we find the smallest max #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 20010 , M = 200010 ; int n, m; int h[N], e[M], w[M], ne[M], idx; int color[N]; void add ( int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs ( int u, int c, int limit) { color[u] = c; // color current node to c for ( int i = h[u]; ~ i; i = ne[i]) { if (w[i] <= limit) continue ; // weight is less than current found max wight int j = e[i]; if (color[j]) { if (color[j] == c) return false; // in the same group } else if ( ! dfs(j, 3 - c, limit)) return false; // check alternative coloring => place j to another group } return true; } bool check ( int limit) { memset(color, 0 , sizeof color); for ( int i = 1 ; i <= n; i ++ ) if (color[i] == 0 ) if ( ! dfs(i, 1 , limit)) // start with coloring current node with 1, any that couldn't make it work will return false return false; return true; } int main () { scanf( \"%d%d\" , & n, & m); memset(h, - 1 , sizeof h); while (m -- ) { int a, b, c; scanf( \"%d%d%d\" , & a, & b, & c); // a: bike id, b: worker id, c: weight add(a, b, c); add(b, a, c); } int l = 0 , r = 1e9 ; while (l < r) { int mid = l + r >> 1 ; if (check(mid)) r = mid; else l = mid + 1 ; } printf( \"%d \\n \" , l); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/3042/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"1057. campus bikes"},{"location":"Leetcode/1057.-campus-bikes/#analysis","text":"Sort based on 1. Manahattan distance between bike and worker 2. Worker index 3. Bike index Using Priority Queue if the input is unbounded.","title":"Analysis"},{"location":"Leetcode/1057.-campus-bikes/#code","text":"/* * tmp.cpp * Copyright (C) 2020 Haoyang <me@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; typedef tuple < int , int , int > TII; int inline manhattan (vector < int >& p1, vector < int >& p2) { return abs(p1[ 0 ] - p2[ 0 ]) + abs(p1[ 1 ] - p2[ 1 ]); } vector < int > assignBikes(vector < vector < int >>& workers, vector < vector < int >>& bikes) { /* *auto cmp = [](const TII& l, const TII& r) { * int ld = get<0>(l), rd = get<0>(r), wl = get<1>(l), wr = get<1>(r), * bl = get<2>(l), br = get<2>(r); * if (ld != rd) * return ld > rd; * else if (wl != wr) * return wl > wr; * else * return bl > br; *}; */ //priority_queue<TII, vector<TII>, decltype(cmp)> pq(cmp); priority_queue < TII, vector < TII > , greater < TII >> pq; for ( int i = 0 ; i < workers.size(); ++ i) { for ( int j = 0 ; j < bikes.size(); ++ j) { pq.push({manhattan(workers[i], bikes[j]), i, j}); } } vector < int > wo(workers.size(), - 1 ), bi(bikes.size(), - 1 ); int assigned = 0 ; while ( ! pq.empty() && assigned < workers.size()) { TII t = pq.top(); printf( \"after: %d, %d, %d \\n \" , get < 0 > (t), get < 1 > (t), get < 2 > (t)); pq.pop(); if (wo[get < 1 > (t)] == - 1 && bi[get < 2 > (t)] == - 1 ) { // both unassigned wo[get < 1 > (t)] = get < 2 > (t); bi[get < 2 > (t)] = get < 1 > (t); assigned ++ ; } } return wo; } int main() { int w, b; cin >> w; vector < vector < int >> workers, bikes; for ( int i = 0 ; i < w; ++ i) { int x, y; cin >> x >> y; workers.push_back({x, y}); } cin >> b; for ( int i = 0 ; i < b; ++ i) { int x, y; cin >> x >> y; bikes.push_back({x, y}); } vector < int > res = assignBikes(workers, bikes); for ( int i : res) cout << i << \" \" ; return 0 ; }","title":"Code"},{"location":"Leetcode/1057.-campus-bikes/#variant-1-match-as-much-as-possible","text":"Find the assignment such that the most workers can be matched (there are obstacle that some bikes ain't reachabe by certain cars ).","title":"Variant 1: match as much as possible"},{"location":"Leetcode/1057.-campus-bikes/#using-hungarian-algorithm","text":"match the workers in the order of manhattan distance (it actually doesn't matter, the order can be random) to the bike, keep matching until there is a tie. find the one with tie's other matches (same distance but different bike). Find the max # of matches for this bipartite graph Start from node 1, matches with 6 (because 6 < 8), then node 2 matches with 5 (5 < 7): mark matches with red lines When it comes to node 3, it can only matches with 6, but node 6 is already matched with 1. However, since node 1 can also matches with 8, node 1 will concede 6 and gives 6 to node 3. Final match: 4 pairs","title":"Using Hungarian algorithm"},{"location":"Leetcode/1057.-campus-bikes/#complete-bipartite-graph","text":"Since all workers can freely assigned with all the bikes, and bikes can \"choose\" any of the workers. It's a complete bipartitie graph. We should assume # of bikes != # of workes, or the ans is simply # of bikes or # of workers. #include<iostream> #include<cstring> using namespace std; const int N = 510 , M = 100010 ; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add ( int a , int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void init () { memset(h, - 1 , sizeof h); } int find ( int x) { //\u904d\u5386\u81ea\u5df1\u559c\u6b22\u7684\u5973\u5b69 for ( int i = h[x] ; i != - 1 ;i = ne[i]) { int j = e[i]; if ( ! st[j]) //\u5982\u679c\u5728\u8fd9\u4e00\u8f6e\u6a21\u62df\u5339\u914d\u4e2d,\u8fd9\u4e2a\u5973\u5b69\u5c1a\u672a\u88ab\u9884\u5b9a { st[j] = true; //\u90a3x\u5c31\u9884\u5b9a\u8fd9\u4e2a\u5973\u5b69\u4e86 //\u5982\u679c\u5973\u5b69j\u6ca1\u6709\u7537\u670b\u53cb\uff0c\u6216\u8005\u5979\u539f\u6765\u7684\u7537\u670b\u53cb\u80fd\u591f\u9884\u5b9a\u5176\u5b83\u559c\u6b22\u7684\u5973\u5b69\u3002\u914d\u5bf9\u6210\u529f if ( ! match[j] || find(match[j])) { match[j] = x; return true; } } } //\u81ea\u5df1\u4e2d\u610f\u7684\u5168\u90e8\u90fd\u88ab\u9884\u5b9a\u4e86\u3002\u914d\u5bf9\u5931\u8d25\u3002 return false; } int main () { init(); cin >> n1 >> n2 >> m; while (m -- ) { int a,b; cin >> a >> b; add(a,b); } int res = 0 ; for ( int i = 1 ; i <= n1 ;i ++ ) { //\u56e0\u4e3a\u6bcf\u6b21\u6a21\u62df\u5339\u914d\u7684\u9884\u5b9a\u60c5\u51b5\u90fd\u662f\u4e0d\u4e00\u6837\u7684\u6240\u4ee5\u6bcf\u8f6e\u6a21\u62df\u90fd\u8981\u521d\u59cb\u5316 memset(st,false, sizeof st); if (find(i)) res ++ ; } cout << res << endl; } \u4f5c\u8005\uff1a\u5728\u7ebf\u767d\u7ed9 \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/5334/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Complete Bipartite graph"},{"location":"Leetcode/1057.-campus-bikes/#variant-2-find-the-minimal-total-matches-manhattan-distance","text":"","title":"Variant 2: find the minimal total matches' manhattan distance"},{"location":"Leetcode/1057.-campus-bikes/#variant-3-find-the-max-manhattan-to-be-the-smallest","text":"https://www.acwing.com/problem/content/259/ Property of the max distance: - dis > max: can assign all the bikes and workers whose manhattan distance are greater than max distance into other pairs (already assigned, so even if they have higher manhattan distance, they can still get the bike) - dis < max: there is a at least one bike and worker cannot be assigned whose distance is greater than max distance Use binary search for finding the biggest distance where the graph is still bipartite Use dfs to check if all the other can have the coloring Now we have a different problem: find the if the graph is bipartitie if max = ?, and we find the smallest max #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std; const int N = 20010 , M = 200010 ; int n, m; int h[N], e[M], w[M], ne[M], idx; int color[N]; void add ( int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs ( int u, int c, int limit) { color[u] = c; // color current node to c for ( int i = h[u]; ~ i; i = ne[i]) { if (w[i] <= limit) continue ; // weight is less than current found max wight int j = e[i]; if (color[j]) { if (color[j] == c) return false; // in the same group } else if ( ! dfs(j, 3 - c, limit)) return false; // check alternative coloring => place j to another group } return true; } bool check ( int limit) { memset(color, 0 , sizeof color); for ( int i = 1 ; i <= n; i ++ ) if (color[i] == 0 ) if ( ! dfs(i, 1 , limit)) // start with coloring current node with 1, any that couldn't make it work will return false return false; return true; } int main () { scanf( \"%d%d\" , & n, & m); memset(h, - 1 , sizeof h); while (m -- ) { int a, b, c; scanf( \"%d%d%d\" , & a, & b, & c); // a: bike id, b: worker id, c: weight add(a, b, c); add(b, a, c); } int l = 0 , r = 1e9 ; while (l < r) { int mid = l + r >> 1 ; if (check(mid)) r = mid; else l = mid + 1 ; } printf( \"%d \\n \" , l); return 0 ; } \u4f5c\u8005\uff1a yxc \u94fe\u63a5\uff1a https: //www.acwing.com/solution/content/3042/ \u6765\u6e90\uff1a AcWing \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002","title":"Variant 3: find the max manhattan to be the smallest"},{"location":"Leetcode/109.-convert-sorted-list-to-binary-search-tree/","text":"Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Analysis \u00b6 To build a bst from a sorted array , we can do so by recursively finding the middle of the array to generate the tree. However, we need extra time to find the middle of a linkedlist (use fast slow pointer requires O(n) O(n) ) We can definitely use fast slow pointer to find the mid in each iteration and the psuedo code would like sort(node): set mid = find_min_for_head set root->value = mid->value","title":"109. convert sorted list to binary search tree"},{"location":"Leetcode/109.-convert-sorted-list-to-binary-search-tree/#analysis","text":"To build a bst from a sorted array , we can do so by recursively finding the middle of the array to generate the tree. However, we need extra time to find the middle of a linkedlist (use fast slow pointer requires O(n) O(n) ) We can definitely use fast slow pointer to find the mid in each iteration and the psuedo code would like sort(node): set mid = find_min_for_head set root->value = mid->value","title":"Analysis"},{"location":"Leetcode/11.-container-with-most-water/","text":"Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Using two pointers \u00b6 if a_i a_i > a_j a_j : then j -- else then i ++ until two pointers have met Proof : Assume the answer is i^{'} i^{'} and j^{'} j^{'} where (i^{'} < j^{'}) (i^{'} < j^{'}) , use S^{'} S^{'} to represent the total water. Also assume a_i > a_j a_i > a_j , so i to j - 1 should have the answer. We need to prove it is correct by showing optimal isn't in i + 1 to j Assume there is another S S that is greater than S^{'} S^{'} , then S = min(a_i, a_j) * (j - i) S = min(a_i, a_j) * (j - i) and j > j^{'} j > j^{'} $ = a_i \\times (j - i)$ $ > a_i \\times (j^{'} - i)$ $ \\geqslant min(a_i, a_{j^{'}}) \\times (j^{'} - i) = S^{'}$ Code \u00b6 class Solution { public: int maxArea(vector < int >& height) { int res = 0 ; for ( int i = 0 , j = height.size() - 1 ; i < j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] > height[j]) j -- ; else i ++ ; } return res; } };","title":"11. container with most water"},{"location":"Leetcode/11.-container-with-most-water/#using-two-pointers","text":"if a_i a_i > a_j a_j : then j -- else then i ++ until two pointers have met Proof : Assume the answer is i^{'} i^{'} and j^{'} j^{'} where (i^{'} < j^{'}) (i^{'} < j^{'}) , use S^{'} S^{'} to represent the total water. Also assume a_i > a_j a_i > a_j , so i to j - 1 should have the answer. We need to prove it is correct by showing optimal isn't in i + 1 to j Assume there is another S S that is greater than S^{'} S^{'} , then S = min(a_i, a_j) * (j - i) S = min(a_i, a_j) * (j - i) and j > j^{'} j > j^{'} $ = a_i \\times (j - i)$ $ > a_i \\times (j^{'} - i)$ $ \\geqslant min(a_i, a_{j^{'}}) \\times (j^{'} - i) = S^{'}$","title":"Using two pointers"},{"location":"Leetcode/11.-container-with-most-water/#code","text":"class Solution { public: int maxArea(vector < int >& height) { int res = 0 ; for ( int i = 0 , j = height.size() - 1 ; i < j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] > height[j]) j -- ; else i ++ ; } return res; } };","title":"Code"},{"location":"Leetcode/115.-distinct-subsequences/","text":"class Solution { public: int numDistinct(string s, string t) { int m = t.length(), n = s.length(); int64_t dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int j = 0 ; j <= n; j ++ ) dp[ 0 ][j] = 1 ; for ( int i = 1 ; i <= m; i ++ ) for ( int j = i; j <= n; j ++ ) dp[i][j] = dp[i][j - 1 ] + (t[i - 1 ] == s[j - 1 ] ? dp[i - 1 ][j - 1 ] : 0 ); return dp[m][n]; } }; S = \"rabbbit\", T = \"rabbit\" rabbbit ^ ^ ^^ rabbbit ^^ ^ ^ rabbbit ^ ^ note: can only delete dp[i][j]: ways to transform S[0:i] to T[0:j] if t is \"\", then only one way to form t from s (delete all) if t[i] == s[j]: dp[i][j] = dp[i-1][j-1]+dp[i][j-1] -> t can choose either delete the current one or not, both are valid if t[i] != s[j]: dp[i][j] = dp[i][j-1] -> the extra one cannot be counted and should only use the previous stage result (delete current one)","title":"115. distinct subsequences"},{"location":"Leetcode/12.-integer-to-roman/","text":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Analysis \u00b6 This question is finding the relationship of Roma Integer to decimal integer. for 1 to 9 (one digit: 1: I, 2: II, 3: III, 4: IV, 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL, 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD, 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM It can generate any number from the map: e.g. 1234 1: M 2: CC 3: XXX 4: IV -> 1234 = MCCXXXIV Code \u00b6 class Solution { public: string intToRoman( int num) { int val[] = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }; string repr[] = { \"M\" , \"CM\" , \"D\" , \"CD\" , \"C\" , \"XC\" , \"L\" , \"XL\" , \"X\" , \"IX\" , \"V\" , \"IV\" , \"I\" }; string res; for ( int i = 0 ; i < 13 ; ++ i) { while (num >= val[i]) { num -= val[i]; res += repr[i]; } } return res; } };","title":"12. integer to roman"},{"location":"Leetcode/12.-integer-to-roman/#analysis","text":"This question is finding the relationship of Roma Integer to decimal integer. for 1 to 9 (one digit: 1: I, 2: II, 3: III, 4: IV, 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL, 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD, 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM It can generate any number from the map: e.g. 1234 1: M 2: CC 3: XXX 4: IV -> 1234 = MCCXXXIV","title":"Analysis"},{"location":"Leetcode/12.-integer-to-roman/#code","text":"class Solution { public: string intToRoman( int num) { int val[] = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }; string repr[] = { \"M\" , \"CM\" , \"D\" , \"CD\" , \"C\" , \"XC\" , \"L\" , \"XL\" , \"X\" , \"IX\" , \"V\" , \"IV\" , \"I\" }; string res; for ( int i = 0 ; i < 13 ; ++ i) { while (num >= val[i]) { num -= val[i]; res += repr[i]; } } return res; } };","title":"Code"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/","text":"solution all referenced from: \u4f5c\u8005\uff1alabuladong \u94fe\u63a5\uff1a https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09 \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. presumptions \u00b6 there is only one stock to be bought no consective buy or sell happens (buy on day one and buy one day two, instead, can only choose rest or sell) state machine \u00b6 representation dp[i][j][k] 1. i: current day from day zero 2. j: transections left 3. k: {1,0} own (rest) or sold (sell) dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 sell ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6ca1\u6709\u6301\u6709\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u662f\u6211\u6628\u5929\u5c31\u6ca1\u6709\u6301\u6709\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u662f\u6ca1\u6709\u6301\u6709\uff1b \u8981\u4e48\u662f\u6211\u6628\u5929\u6301\u6709\u80a1\u7968\uff0c\u4f46\u662f\u4eca\u5929\u6211 sell \u4e86\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u6ca1\u6709\u6301\u6709\u80a1\u7968\u4e86\u3002 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 buy ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6301\u6709\u7740\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u6211\u6628\u5929\u5c31\u6301\u6709\u7740\u80a1\u7968\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u6301\u6709\u7740\u80a1\u7968\uff1b \u8981\u4e48\u6211\u6628\u5929\u672c\u6ca1\u6709\u6301\u6709\uff0c\u4f46\u4eca\u5929\u6211\u9009\u62e9 buy\uff0c\u6240\u4ee5\u4eca\u5929\u6211\u5c31\u6301\u6709\u80a1\u7968\u4e86\u3002 inital : dp[-1][k][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a i \u662f\u4ece 0 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 i = -1 \u610f\u5473\u7740\u8fd8\u6ca1\u6709\u5f00\u59cb\uff0c\u8fd9\u65f6\u5019\u7684\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[-1][k][1] = -infinity \u89e3\u91ca\uff1a\u8fd8\u6ca1\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 dp[i][0][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a k \u662f\u4ece 1 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 k = 0 \u610f\u5473\u7740\u6839\u672c\u4e0d\u5141\u8bb8\u4ea4\u6613\uff0c\u8fd9\u65f6\u5019\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[i][0][1] = -infinity \u89e3\u91ca\uff1a\u4e0d\u5141\u8bb8\u4ea4\u6613\u7684\u60c5\u51b5\u4e0b\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 part 1: one transection \u00b6 dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) \u89e3\u91ca\uff1ak = 0 \u7684 base case\uff0c\u6240\u4ee5 dp[i-1][0][0] = 0\u3002 \u73b0\u5728\u53d1\u73b0 k \u90fd\u662f 1\uff0c\u4e0d\u4f1a\u6539\u53d8\uff0c\u5373 k \u5bf9\u72b6\u6001\u8f6c\u79fb\u5df2\u7ecf\u6ca1\u6709\u5f71\u54cd\u4e86\u3002 \u53ef\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u5316\u7b80\u53bb\u6389\u6240\u6709 k\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) for ( int i = 0 ; i < n; i ++ ) { if (i - 1 == - 1 ) { // i==0 dp[i][ 0 ] = 0 ; // \u89e3\u91ca\uff1a // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][ 1 ] = - prices[i]; //\u89e3\u91ca\uff1a // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue ; } dp[i][ 0 ] = max(dp[i - 1 ][ 0 ], dp[i - 1 ][ 1 ] + prices[i]); dp[i][ 1 ] = max(dp[i - 1 ][ 1 ], - prices[i]); // now is sell, if last is sold now has to hold // if last is buy, now is rest } return dp[n - 1 ][ 0 ]; part 2: k transections \u00b6 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) \u6211\u4eec\u53d1\u73b0\u6570\u7ec4\u4e2d\u7684 k \u5df2\u7ecf\u4e0d\u4f1a\u6539\u53d8\u4e86\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u9700\u8981\u8bb0\u5f55 k \u8fd9\u4e2a\u72b6\u6001\u4e86\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) int maxProfit_k_inf (vector < int > prices) { int n = prices.size(); int dp_i_0 = 0 , dp_i_1 = INT_MIN; for ( int i = 0 ; i < n; i ++ ) { int temp = dp_i_0; // last state is dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, temp - prices[i]); } return dp_i_0; }","title":"121,123,132,188,309,714 best time to buy and sell stock"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#presumptions","text":"there is only one stock to be bought no consective buy or sell happens (buy on day one and buy one day two, instead, can only choose rest or sell)","title":"presumptions"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#state-machine","text":"representation dp[i][j][k] 1. i: current day from day zero 2. j: transections left 3. k: {1,0} own (rest) or sold (sell) dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 sell ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6ca1\u6709\u6301\u6709\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u662f\u6211\u6628\u5929\u5c31\u6ca1\u6709\u6301\u6709\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u662f\u6ca1\u6709\u6301\u6709\uff1b \u8981\u4e48\u662f\u6211\u6628\u5929\u6301\u6709\u80a1\u7968\uff0c\u4f46\u662f\u4eca\u5929\u6211 sell \u4e86\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u6ca1\u6709\u6301\u6709\u80a1\u7968\u4e86\u3002 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( \u9009\u62e9 rest , \u9009\u62e9 buy ) \u89e3\u91ca\uff1a\u4eca\u5929\u6211\u6301\u6709\u7740\u80a1\u7968\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a \u8981\u4e48\u6211\u6628\u5929\u5c31\u6301\u6709\u7740\u80a1\u7968\uff0c\u7136\u540e\u4eca\u5929\u9009\u62e9 rest\uff0c\u6240\u4ee5\u6211\u4eca\u5929\u8fd8\u6301\u6709\u7740\u80a1\u7968\uff1b \u8981\u4e48\u6211\u6628\u5929\u672c\u6ca1\u6709\u6301\u6709\uff0c\u4f46\u4eca\u5929\u6211\u9009\u62e9 buy\uff0c\u6240\u4ee5\u4eca\u5929\u6211\u5c31\u6301\u6709\u80a1\u7968\u4e86\u3002 inital : dp[-1][k][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a i \u662f\u4ece 0 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 i = -1 \u610f\u5473\u7740\u8fd8\u6ca1\u6709\u5f00\u59cb\uff0c\u8fd9\u65f6\u5019\u7684\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[-1][k][1] = -infinity \u89e3\u91ca\uff1a\u8fd8\u6ca1\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002 dp[i][0][0] = 0 \u89e3\u91ca\uff1a\u56e0\u4e3a k \u662f\u4ece 1 \u5f00\u59cb\u7684\uff0c\u6240\u4ee5 k = 0 \u610f\u5473\u7740\u6839\u672c\u4e0d\u5141\u8bb8\u4ea4\u6613\uff0c\u8fd9\u65f6\u5019\u5229\u6da6\u5f53\u7136\u662f 0 \u3002 dp[i][0][1] = -infinity \u89e3\u91ca\uff1a\u4e0d\u5141\u8bb8\u4ea4\u6613\u7684\u60c5\u51b5\u4e0b\uff0c\u662f\u4e0d\u53ef\u80fd\u6301\u6709\u80a1\u7968\u7684\uff0c\u7528\u8d1f\u65e0\u7a77\u8868\u793a\u8fd9\u79cd\u4e0d\u53ef\u80fd\u3002","title":"state machine"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#part-1-one-transection","text":"dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) \u89e3\u91ca\uff1ak = 0 \u7684 base case\uff0c\u6240\u4ee5 dp[i-1][0][0] = 0\u3002 \u73b0\u5728\u53d1\u73b0 k \u90fd\u662f 1\uff0c\u4e0d\u4f1a\u6539\u53d8\uff0c\u5373 k \u5bf9\u72b6\u6001\u8f6c\u79fb\u5df2\u7ecf\u6ca1\u6709\u5f71\u54cd\u4e86\u3002 \u53ef\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u5316\u7b80\u53bb\u6389\u6240\u6709 k\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) for ( int i = 0 ; i < n; i ++ ) { if (i - 1 == - 1 ) { // i==0 dp[i][ 0 ] = 0 ; // \u89e3\u91ca\uff1a // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][ 1 ] = - prices[i]; //\u89e3\u91ca\uff1a // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue ; } dp[i][ 0 ] = max(dp[i - 1 ][ 0 ], dp[i - 1 ][ 1 ] + prices[i]); dp[i][ 1 ] = max(dp[i - 1 ][ 1 ], - prices[i]); // now is sell, if last is sold now has to hold // if last is buy, now is rest } return dp[n - 1 ][ 0 ];","title":"part 1: one transection"},{"location":"Leetcode/121%2C123%2C132%2C188%2C309%2C714-best-time-to-buy-and-sell-stock/#part-2-k-transections","text":"dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) \u6211\u4eec\u53d1\u73b0\u6570\u7ec4\u4e2d\u7684 k \u5df2\u7ecf\u4e0d\u4f1a\u6539\u53d8\u4e86\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u9700\u8981\u8bb0\u5f55 k \u8fd9\u4e2a\u72b6\u6001\u4e86\uff1a dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) int maxProfit_k_inf (vector < int > prices) { int n = prices.size(); int dp_i_0 = 0 , dp_i_1 = INT_MIN; for ( int i = 0 ; i < n; i ++ ) { int temp = dp_i_0; // last state is dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = max(dp_i_1, temp - prices[i]); } return dp_i_0; }","title":"part 2: k transections"},{"location":"Leetcode/13.-roman-to-integer/","text":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Analysis \u00b6 for 1 to 9 (one digit): 1: I, 2: II, 3: III, 4: IV , 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL , 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD , 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM Notice that only 4, 40 and 400 are having the roman character reversed (smaller mapping is in the front the larger mapping), so we only need to handle the special case for that. Code \u00b6 class Solution { public: int romanToInt(string s) { unordered_map < char , int > hash; hash[ 'I' ] = 1 , hash[ 'V' ] = 5 ; hash[ 'X' ] = 10 , hash[ 'L' ] = 50 ; hash[ 'C' ] = 100 , hash[ 'D' ] = 500 ; hash[ 'M' ] = 1000 ; int res = 0 ; for ( int i = 0 ; i < s.size(); i ++ ) { if (i + 1 < s.size() && hash[s[i]] < hash[s[i + 1 ]]) // compare neighour character res -= hash[s[i]]; // if less then - else res += hash[s[i]]; // normal case then + } return res; } };","title":"13. roman to integer"},{"location":"Leetcode/13.-roman-to-integer/#analysis","text":"for 1 to 9 (one digit): 1: I, 2: II, 3: III, 4: IV , 5: V, 6: VI, 7: VII, 8: VIII, 9: IX. for 10 to 99 (two digits): 10: X, 20: XX, 30: XXX, 40: XL , 50: L, 60: LX, 70: LXX, 80: LXXX, 90: XC. for 100 to 999 (three digits): 100: C, 200: CC, 300: CCC, 400: CD , 500: D, 600: DC, 700: DCC, 800: DCCC, 900: CM. for 1000 to 3999 (four digits): 1000: M, 2000: MM, 3000: MMM Notice that only 4, 40 and 400 are having the roman character reversed (smaller mapping is in the front the larger mapping), so we only need to handle the special case for that.","title":"Analysis"},{"location":"Leetcode/13.-roman-to-integer/#code","text":"class Solution { public: int romanToInt(string s) { unordered_map < char , int > hash; hash[ 'I' ] = 1 , hash[ 'V' ] = 5 ; hash[ 'X' ] = 10 , hash[ 'L' ] = 50 ; hash[ 'C' ] = 100 , hash[ 'D' ] = 500 ; hash[ 'M' ] = 1000 ; int res = 0 ; for ( int i = 0 ; i < s.size(); i ++ ) { if (i + 1 < s.size() && hash[s[i]] < hash[s[i + 1 ]]) // compare neighour character res -= hash[s[i]]; // if less then - else res += hash[s[i]]; // normal case then + } return res; } };","title":"Code"},{"location":"Leetcode/139.-word-break/","text":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false cpp: dfs with memo \u00b6 class Solution { public: unordered_map < string, bool > memo; bool wordBreak (string s, vector < string >& wordDict) { unordered_set < string > dict(wordDict.begin(), wordDict.end()); return dfs(s, dict); } bool dfs (string s, unordered_set < string >& dict) { if (memo.count(s)) return memo[s]; if (dict.count(s)) return memo[s] = true; for ( int i = 1 ; i < s.size(); ++ i) { if (dict.count(s.substr( 0 , i)) == 0 ) // cannot split from here continue ; if (dfs(s.substr(i), dict)) // 0-i do exist, now check the rest return memo[s] = true; } return memo[s] = false; // has tried all options } }; java: dp \u00b6 public class Solution { public boolean wordBreak (String s, Set < String > dict) { boolean [] f = new boolean [ s. length () + 1 ] ; f [ 0 ] = true ; /* First DP for(int i = 1; i <= s.length(); i++){ for(String str: dict){ // check each element in dp if(str.length() <= i){ if(f[i - str.length()]){ // complement exist if(s.substring(i-str.length(), i).equals(str)){ f[i] = true; break; } } } } }*/ //Second DP for ( int i = 1 ; i <= s. length (); i ++ ){ for ( int j = 0 ; j < i; j ++ ){ // split current s into s[0:j] and s[j:i] if (f [ j ] && dict. contains (s. substring (j, i))){ f [ i ] = true ; break ; } } } return f [ s. length () ] ; } } f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes. The default value for boolean array is false. Therefore we need to set f[0] to be true. cpp w/ optimization \u00b6 class Solution { public: bool wordBreak(string s, vector < string >& word) { int n = s.size(); vector < bool > dp(n + 1 ); dp[ 0 ] = true; for ( int i = 0 ; i < n; i ++ ) if (dp[i]) { // only consider if s[0:i] already exists for ( auto & str: word) { int l = str.size(); if (s.substr(i, l) == str) dp[i + l] = true; // s[0:i] and s[i+str.size()] all valid } } return dp.back(); } }; instead of comparing with the rest from s, compare with the word dict.","title":"139. word break"},{"location":"Leetcode/139.-word-break/#cpp-dfs-with-memo","text":"class Solution { public: unordered_map < string, bool > memo; bool wordBreak (string s, vector < string >& wordDict) { unordered_set < string > dict(wordDict.begin(), wordDict.end()); return dfs(s, dict); } bool dfs (string s, unordered_set < string >& dict) { if (memo.count(s)) return memo[s]; if (dict.count(s)) return memo[s] = true; for ( int i = 1 ; i < s.size(); ++ i) { if (dict.count(s.substr( 0 , i)) == 0 ) // cannot split from here continue ; if (dfs(s.substr(i), dict)) // 0-i do exist, now check the rest return memo[s] = true; } return memo[s] = false; // has tried all options } };","title":"cpp: dfs with memo"},{"location":"Leetcode/139.-word-break/#java-dp","text":"public class Solution { public boolean wordBreak (String s, Set < String > dict) { boolean [] f = new boolean [ s. length () + 1 ] ; f [ 0 ] = true ; /* First DP for(int i = 1; i <= s.length(); i++){ for(String str: dict){ // check each element in dp if(str.length() <= i){ if(f[i - str.length()]){ // complement exist if(s.substring(i-str.length(), i).equals(str)){ f[i] = true; break; } } } } }*/ //Second DP for ( int i = 1 ; i <= s. length (); i ++ ){ for ( int j = 0 ; j < i; j ++ ){ // split current s into s[0:j] and s[j:i] if (f [ j ] && dict. contains (s. substring (j, i))){ f [ i ] = true ; break ; } } } return f [ s. length () ] ; } } f[i] stands for whether subarray(0, i) can be segmented into words from the dictionary. So f[0] means whether subarray(0, 0) (which is an empty string) can be segmented, and of course the answer is yes. The default value for boolean array is false. Therefore we need to set f[0] to be true.","title":"java: dp"},{"location":"Leetcode/139.-word-break/#cpp-w-optimization","text":"class Solution { public: bool wordBreak(string s, vector < string >& word) { int n = s.size(); vector < bool > dp(n + 1 ); dp[ 0 ] = true; for ( int i = 0 ; i < n; i ++ ) if (dp[i]) { // only consider if s[0:i] already exists for ( auto & str: word) { int l = str.size(); if (s.substr(i, l) == str) dp[i + l] = true; // s[0:i] and s[i+str.size()] all valid } } return dp.back(); } }; instead of comparing with the rest from s, compare with the word dict.","title":"cpp w/ optimization"},{"location":"Leetcode/140.-word-break-ii/","text":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"catsanddog\" wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output: [ \"cats and dog\", \"cat sand dog\" ] Example 2: Input: s = \"pineapplepenapple\" wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] Output: [ \"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\" ] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\" wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: [] dfs w/ memo \u00b6 class Solution { unordered_map < string, vector < string >> m; vector < string > combine (string word, vector < string > prev){ for ( int i = 0 ;i < prev. size (); ++ i){ prev [ i ]+= \" \" + word; } return prev; } public: vector < string > wordBreak (string s, unordered_set < string >& dict) { if (m. count (s)) return m [ s ] ; //take from memory vector < string > result; if (dict. count (s)){ //a whole string is a word result. push_back (s); } for ( int i = 1 ;i < s. size (); ++ i){ string word = s. substr (i); if (dict. count (word)){ //s[0:i] and s[i:], s[i:] is checked, now check s[0:i] string rem = s. substr ( 0 ,i); vector < string > prev = combine(word,wordBreak(rem,dict)); result. insert (result. end (),prev. begin (), prev. end ()); } } m [ s ]= result; //memorize return result; } }; dfs always takes in from s[0:i], and check s[i:] for current branch cache is the map of current s[0:i] to all the combination for this substring, so for s[0:i+1], to check s[0:i], just uses the cached one and combine with s[:i]","title":"140. word break ii"},{"location":"Leetcode/140.-word-break-ii/#dfs-w-memo","text":"class Solution { unordered_map < string, vector < string >> m; vector < string > combine (string word, vector < string > prev){ for ( int i = 0 ;i < prev. size (); ++ i){ prev [ i ]+= \" \" + word; } return prev; } public: vector < string > wordBreak (string s, unordered_set < string >& dict) { if (m. count (s)) return m [ s ] ; //take from memory vector < string > result; if (dict. count (s)){ //a whole string is a word result. push_back (s); } for ( int i = 1 ;i < s. size (); ++ i){ string word = s. substr (i); if (dict. count (word)){ //s[0:i] and s[i:], s[i:] is checked, now check s[0:i] string rem = s. substr ( 0 ,i); vector < string > prev = combine(word,wordBreak(rem,dict)); result. insert (result. end (),prev. begin (), prev. end ()); } } m [ s ]= result; //memorize return result; } }; dfs always takes in from s[0:i], and check s[i:] for current branch cache is the map of current s[0:i] to all the combination for this substring, so for s[0:i+1], to check s[0:i], just uses the cached one and combine with s[:i]","title":"dfs w/ memo"},{"location":"Leetcode/146.-lru-cache/","text":"Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 / capacity / ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 double linked list with map (java) \u00b6 import java.util.Hashtable; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } /** * Always add the new node right after head; */ /* before: node.pre - node - node.post head - head.post (tail) after: head - node - head.post (tail) */ private void addNode (DLinkedNode node) { node. pre = head; node. post = head. post ; head. post . pre = node; head. post = node; } /** * Remove an existing node from the linked list. */ // pre - node - post -> pre - post private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } /** * Move certain node in between to the head. */ private void moveToHead (DLinkedNode node){ this . removeNode (node); this . addNode (node); // head->post now point to node } // pop the current tail. private DLinkedNode popTail (){ DLinkedNode res = tail. pre ; this . removeNode (res); // return res; } private Hashtable < Integer, DLinkedNode > cache = new Hashtable < Integer, DLinkedNode > (); private int count; private int capacity; private DLinkedNode head, tail; // head.pre (null) - head - head.post (tail) // tail.pre (head) - tail - tail.post (null) // -> head.pre (null) - head - tail - tail.post (null) public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } public int get ( int key) { DLinkedNode node = cache. get (key); if (node == null ){ return - 1 ; // should raise exception here. } // move the accessed node to the head; this . moveToHead (node); return node. value ; } public void put ( int key, int value) { DLinkedNode node = cache. get (key); if (node == null ){ // need to insert new key-value pair into the list DLinkedNode newNode = new DLinkedNode(); newNode. key = key; newNode. value = value; this . cache . put (key, newNode); this . addNode (newNode); ++ count; // same as the size of cache.size() if (count > capacity){ // pop the tail DLinkedNode tail = this . popTail (); this . cache . remove (tail. key ); -- count; } } else { // just swap to the head and update value node. value = value; this . moveToHead (node); } } } why bother doubly linked list \u00b6 Fast removal. Doubly linked lists let us remove and insert in constant time if we have access to a node directly. The hashtable gives us access to a node directly. If we use a singly linked list we will need to spend O(n) time to remove a node even if we have direct reference to the node that needs to get removed. (This is because to remove in a singly linked list we need to point nodeToDelete's previous node to nodeToDelete's next node. Finding nodeToDelete's previous is expensive if nodeToDelete is the last node in the list.) why cannot converted to singly linked list in Java \u00b6 People who are wondering why we have double-linked list here instead of single-linked linked list : Yes, the purpose can be achieved with a single-linked LL with some hacks but NOT in java. Let's say I've to remove node n and it's previous node is p. If n is the last node in the list, I've to modify the next field of p to point to null. This can't be done if I don't have access to p.next since in java, method parameters are actually references of the objects and they are passed by value. So, let's say right now, n and p.next point to the same object (i.e. n of course). If I do n=null, that doesn't makes the object null. The object is still there and p.next points to that object. The only diff is that now n doesn't point to that object. In fact, it doesn't point to anything. n=null doesn't remove n, but just send what it points-to to null public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } if tail.pre is always pointing to head, and head.post always points to tail private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } cpp \u00b6 class LRUCache { struct Node { int key, val; Node * next, * pre; Node( int key, int val) : key(key) , val(val) { } }; private: unordered_map < int , Node *> map; int cap; Node * head, * tail; public: LRUCache( int capacity) { cap = capacity; head = NULL, tail = NULL; } int get( int key) { if ( ! map.count(key)) return - 1 ; Node * node = map[key]; if (node != tail) { if (node == head) { head = head -> next; // leave space for head to move node to the back } else { // pre <-> node <-> next => pre <-> next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; // now tail points to the latest node node -> pre = tail; node -> next = NULL; tail = node; } return node -> val; } void put( int key, int value) { // exist if (map.count(key)) { Node * node = map[key]; node -> val = value; // update value if (node != tail) { // here are the same logic as in get() if (node == head) { // head now points to the second recent used node head = head -> next; } else { // split out node, now node.pre - node.next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL; tail = node; } } else { // not exit Node * newNode = new Node(key, value); if (cap == 0 ) { // cap == capacity - map.size() Node * temp = head; head = head -> next; // always remove the least recent used node map.erase(temp -> key); cap ++ ; } // what could happen after removal? if (head == NULL && tail == NULL) { head = newNode; } else { // let tail point to the newly inserted node tail -> next = newNode; newNode -> pre = tail; newNode -> next = NULL; } tail = newNode; map[key] = newNode; cap -- ; } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ head: least recent used node tail: most recent used node","title":"146. lru cache"},{"location":"Leetcode/146.-lru-cache/#double-linked-list-with-map-java","text":"import java.util.Hashtable; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } /** * Always add the new node right after head; */ /* before: node.pre - node - node.post head - head.post (tail) after: head - node - head.post (tail) */ private void addNode (DLinkedNode node) { node. pre = head; node. post = head. post ; head. post . pre = node; head. post = node; } /** * Remove an existing node from the linked list. */ // pre - node - post -> pre - post private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; } /** * Move certain node in between to the head. */ private void moveToHead (DLinkedNode node){ this . removeNode (node); this . addNode (node); // head->post now point to node } // pop the current tail. private DLinkedNode popTail (){ DLinkedNode res = tail. pre ; this . removeNode (res); // return res; } private Hashtable < Integer, DLinkedNode > cache = new Hashtable < Integer, DLinkedNode > (); private int count; private int capacity; private DLinkedNode head, tail; // head.pre (null) - head - head.post (tail) // tail.pre (head) - tail - tail.post (null) // -> head.pre (null) - head - tail - tail.post (null) public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } public int get ( int key) { DLinkedNode node = cache. get (key); if (node == null ){ return - 1 ; // should raise exception here. } // move the accessed node to the head; this . moveToHead (node); return node. value ; } public void put ( int key, int value) { DLinkedNode node = cache. get (key); if (node == null ){ // need to insert new key-value pair into the list DLinkedNode newNode = new DLinkedNode(); newNode. key = key; newNode. value = value; this . cache . put (key, newNode); this . addNode (newNode); ++ count; // same as the size of cache.size() if (count > capacity){ // pop the tail DLinkedNode tail = this . popTail (); this . cache . remove (tail. key ); -- count; } } else { // just swap to the head and update value node. value = value; this . moveToHead (node); } } }","title":"double linked list with map (java)"},{"location":"Leetcode/146.-lru-cache/#why-bother-doubly-linked-list","text":"Fast removal. Doubly linked lists let us remove and insert in constant time if we have access to a node directly. The hashtable gives us access to a node directly. If we use a singly linked list we will need to spend O(n) time to remove a node even if we have direct reference to the node that needs to get removed. (This is because to remove in a singly linked list we need to point nodeToDelete's previous node to nodeToDelete's next node. Finding nodeToDelete's previous is expensive if nodeToDelete is the last node in the list.)","title":"why bother doubly linked list"},{"location":"Leetcode/146.-lru-cache/#why-cannot-converted-to-singly-linked-list-in-java","text":"People who are wondering why we have double-linked list here instead of single-linked linked list : Yes, the purpose can be achieved with a single-linked LL with some hacks but NOT in java. Let's say I've to remove node n and it's previous node is p. If n is the last node in the list, I've to modify the next field of p to point to null. This can't be done if I don't have access to p.next since in java, method parameters are actually references of the objects and they are passed by value. So, let's say right now, n and p.next point to the same object (i.e. n of course). If I do n=null, that doesn't makes the object null. The object is still there and p.next points to that object. The only diff is that now n doesn't point to that object. In fact, it doesn't point to anything. n=null doesn't remove n, but just send what it points-to to null public LRUCache ( int capacity) { this . count = 0 ; this . capacity = capacity; head = new DLinkedNode(); head. pre = null ; tail = new DLinkedNode(); tail. post = null ; head. post = tail; tail. pre = head; } if tail.pre is always pointing to head, and head.post always points to tail private void removeNode (DLinkedNode node){ DLinkedNode pre = node. pre ; DLinkedNode post = node. post ; pre. post = post; post. pre = pre; }","title":"why cannot converted to singly linked list in Java"},{"location":"Leetcode/146.-lru-cache/#cpp","text":"class LRUCache { struct Node { int key, val; Node * next, * pre; Node( int key, int val) : key(key) , val(val) { } }; private: unordered_map < int , Node *> map; int cap; Node * head, * tail; public: LRUCache( int capacity) { cap = capacity; head = NULL, tail = NULL; } int get( int key) { if ( ! map.count(key)) return - 1 ; Node * node = map[key]; if (node != tail) { if (node == head) { head = head -> next; // leave space for head to move node to the back } else { // pre <-> node <-> next => pre <-> next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; // now tail points to the latest node node -> pre = tail; node -> next = NULL; tail = node; } return node -> val; } void put( int key, int value) { // exist if (map.count(key)) { Node * node = map[key]; node -> val = value; // update value if (node != tail) { // here are the same logic as in get() if (node == head) { // head now points to the second recent used node head = head -> next; } else { // split out node, now node.pre - node.next node -> pre -> next = node -> next; node -> next -> pre = node -> pre; } tail -> next = node; node -> pre = tail; node -> next = NULL; tail = node; } } else { // not exit Node * newNode = new Node(key, value); if (cap == 0 ) { // cap == capacity - map.size() Node * temp = head; head = head -> next; // always remove the least recent used node map.erase(temp -> key); cap ++ ; } // what could happen after removal? if (head == NULL && tail == NULL) { head = newNode; } else { // let tail point to the newly inserted node tail -> next = newNode; newNode -> pre = tail; newNode -> next = NULL; } tail = newNode; map[key] = newNode; cap -- ; } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ head: least recent used node tail: most recent used node","title":"cpp"},{"location":"Leetcode/148.-sort-list/","text":"Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4 Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5 Analysis \u00b6 To sort a linkedlist with constant space, we can use merge sort (for array it will be O(N) O(N) space). Let's recap what to do if we are sorting an array: define base case: there is only one element find mid and split array into left - mid and mid+1 - right recurse left part and right part use a temporary array to store the sorted array in range of current left - right reassign back to the original array from the temporary array Convert to linkedlist: define base case: only one node (listnode) use slow-fast pointers to find mid set mid -> next = NULL so it will split left - mid -> NULL and mid + 1 - right recurse left and right create a dummy list node and use two pointers to append append the one with smaller value first since we didn't create a new list, we can just return now Time: O(n \\times log_2{n}) O(n \\times log_2{n}) for each break: O(n) O(n) + for merge: O(n) O(n) + for height O(log_2{n}) O(log_2{n}) Code \u00b6 class Solution { public: ListNode * h(ListNode * head) { if ( ! head || ! head -> next) return head; // find mid ListNode * pre = head, * slow = head -> next, * fast = head -> next; while (fast && fast -> next) { pre = pre -> next; slow = slow -> next; fast = fast -> next -> next; } // break pre -> next = NULL; ListNode * left = h(head), * right = h(slow); // merge ListNode res ( - 1 ); ListNode * curr = & res; while (left && right) { if (left -> val < right -> val) { curr -> next = left; left = left -> next; } else { curr -> next = right; right = right -> next; } curr = curr -> next; } // append the rest if (left) curr -> next = left; if (right) curr -> next = right; return ( & res) -> next; } ListNode * sortList(ListNode * head) { return h(head); } };","title":"148. sort list"},{"location":"Leetcode/148.-sort-list/#analysis","text":"To sort a linkedlist with constant space, we can use merge sort (for array it will be O(N) O(N) space). Let's recap what to do if we are sorting an array: define base case: there is only one element find mid and split array into left - mid and mid+1 - right recurse left part and right part use a temporary array to store the sorted array in range of current left - right reassign back to the original array from the temporary array Convert to linkedlist: define base case: only one node (listnode) use slow-fast pointers to find mid set mid -> next = NULL so it will split left - mid -> NULL and mid + 1 - right recurse left and right create a dummy list node and use two pointers to append append the one with smaller value first since we didn't create a new list, we can just return now Time: O(n \\times log_2{n}) O(n \\times log_2{n}) for each break: O(n) O(n) + for merge: O(n) O(n) + for height O(log_2{n}) O(log_2{n})","title":"Analysis"},{"location":"Leetcode/148.-sort-list/#code","text":"class Solution { public: ListNode * h(ListNode * head) { if ( ! head || ! head -> next) return head; // find mid ListNode * pre = head, * slow = head -> next, * fast = head -> next; while (fast && fast -> next) { pre = pre -> next; slow = slow -> next; fast = fast -> next -> next; } // break pre -> next = NULL; ListNode * left = h(head), * right = h(slow); // merge ListNode res ( - 1 ); ListNode * curr = & res; while (left && right) { if (left -> val < right -> val) { curr -> next = left; left = left -> next; } else { curr -> next = right; right = right -> next; } curr = curr -> next; } // append the rest if (left) curr -> next = left; if (right) curr -> next = right; return ( & res) -> next; } ListNode * sortList(ListNode * head) { return h(head); } };","title":"Code"},{"location":"Leetcode/152.-maximum-product-subarray/","text":"refer to /tech_notes/Lai/Maximum Product Subarray","title":"152. maximum product subarray"},{"location":"Leetcode/2.-add-two-numbers/","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. Analysis \u00b6 Two input linkedlists have already revsered, so we can just use two pointer to make the addition. To deal with carry bit, we need a integer to show the current sum. If the current sum is equal/greater than 10, then carry = 1 and sum %= 10 Time: O(min(size of l1, size of l2)) Code \u00b6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode * addTwoNumbers(ListNode * l1, ListNode * l2) { ListNode * dummy = new ListNode( - 1 ), * curr = dummy; int carry = 0 ; while (l1 || l2) { // either one is terminated int val1 = l1 ? l1 -> val : 0 ; int val2 = l2 ? l2 -> val : 0 ; int sum = val1 + val2 + carry; carry = sum / 10 ; // if greater than 10 -> carry > 0 curr -> next = new ListNode(sum % 10 ); curr = curr -> next; if (l1) l1 = l1 -> next; if (l2) l2 = l2 -> next; } if (carry) // final check curr -> next = new ListNode( 1 ); return dummy -> next; } };","title":"2. add two numbers"},{"location":"Leetcode/2.-add-two-numbers/#analysis","text":"Two input linkedlists have already revsered, so we can just use two pointer to make the addition. To deal with carry bit, we need a integer to show the current sum. If the current sum is equal/greater than 10, then carry = 1 and sum %= 10 Time: O(min(size of l1, size of l2))","title":"Analysis"},{"location":"Leetcode/2.-add-two-numbers/#code","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode * addTwoNumbers(ListNode * l1, ListNode * l2) { ListNode * dummy = new ListNode( - 1 ), * curr = dummy; int carry = 0 ; while (l1 || l2) { // either one is terminated int val1 = l1 ? l1 -> val : 0 ; int val2 = l2 ? l2 -> val : 0 ; int sum = val1 + val2 + carry; carry = sum / 10 ; // if greater than 10 -> carry > 0 curr -> next = new ListNode(sum % 10 ); curr = curr -> next; if (l1) l1 = l1 -> next; if (l2) l2 = l2 -> next; } if (carry) // final check curr -> next = new ListNode( 1 ); return dummy -> next; } };","title":"Code"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/","text":"Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Property for Trie Tree \u00b6 each node does not store complete word each path has a character, the word to current node is the path with all the characters each leaf node marks as end for telling it's a complete word each leaf can store the frequency (7, 3, 4, 15, 12, 11, 5, 9) in this case in the same level, all the silbilings are not the same if just typing in the prefix, trie can print out all the suggesting silbilings each node can has 26 (all lower case) children - pretty bad space complexity cpp: dynamically generate 26 nodes all the time \u00b6 struct TrieNode { TrieNode * next[ 26 ]; bool is_word; TrieNode( bool b = false) : is_word(b) { memset(next, 0 , sizeof (next)); // next store address instead of the value itself } }; class Trie { private: TrieNode * root; TrieNode * find (string key) { TrieNode * p = root; for ( int i = 0 ; i < key.size() && p != NULL; ++ i) { p = p -> next[key[i] - 'a' ]; } return p; } public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode * p = root; for ( int i = 0 ; i < word.size(); ++ i) { if (p -> next[word[i] - 'a' ] == NULL) // not assign any value yet p -> next[word[i] - 'a' ] = new TrieNode(); // only new when p = p -> next[word[i] - 'a' ]; } p -> is_word = true; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode * p = find(word); return p != NULL && p -> is_word; } /** Returns if there is any word in the trie that starts with the given * prefix. */ bool startsWith(string prefix) { return find(prefix) != NULL; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_3 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"208. implement trie (prefix tree)"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#property-for-trie-tree","text":"each node does not store complete word each path has a character, the word to current node is the path with all the characters each leaf node marks as end for telling it's a complete word each leaf can store the frequency (7, 3, 4, 15, 12, 11, 5, 9) in this case in the same level, all the silbilings are not the same if just typing in the prefix, trie can print out all the suggesting silbilings each node can has 26 (all lower case) children - pretty bad space complexity","title":"Property for Trie Tree"},{"location":"Leetcode/208.-implement-trie-%28prefix-tree%29/#cpp-dynamically-generate-26-nodes-all-the-time","text":"struct TrieNode { TrieNode * next[ 26 ]; bool is_word; TrieNode( bool b = false) : is_word(b) { memset(next, 0 , sizeof (next)); // next store address instead of the value itself } }; class Trie { private: TrieNode * root; TrieNode * find (string key) { TrieNode * p = root; for ( int i = 0 ; i < key.size() && p != NULL; ++ i) { p = p -> next[key[i] - 'a' ]; } return p; } public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode * p = root; for ( int i = 0 ; i < word.size(); ++ i) { if (p -> next[word[i] - 'a' ] == NULL) // not assign any value yet p -> next[word[i] - 'a' ] = new TrieNode(); // only new when p = p -> next[word[i] - 'a' ]; } p -> is_word = true; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode * p = find(word); return p != NULL && p -> is_word; } /** Returns if there is any word in the trie that starts with the given * prefix. */ bool startsWith(string prefix) { return find(prefix) != NULL; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_3 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"cpp: dynamically generate 26 nodes all the time"},{"location":"Leetcode/295.-find-median-from-data-stream/","text":"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Analysis \u00b6 To find the median, we need to split data into two halfs, and then use (first half's last element + second half's first element) / 2 (even) or first half's last (odd) to find the median. First half's last should be the value that is greater or equal to all the values from the first half of the data, and the second half's first is less than all the elements following. To find such two elements, we can use priority queue. Use one queue for finding the large median (max heap), and use the other queue to find the smaller median (min heap). To make two queues with the size difference at most 1, we need to find a way to balance the two queues. Complexity: Time: add takes O(\\log{n}) O(\\log{n}) + find takes O(1) O(1) Space: two queues take O(n) O(n) Solution 1 [Recommend]: use global odd or even to determine median \u00b6 xxxx m yyyy q1: xxxx q2: yyyy xxxxm yyyy z // push from odd 1. xxxxzm yyyy -> xxxxxx yyyy -> xxxxx yyyyx -> xxxxx yyyyy -> m = (x + y) / 2 2. xxxxm zyyyy -> xxxxm yyyyy -> xxxxx yyyyy -> m = (x + y) / 2 xxxm yyyy z // push from even 1. xxxzm yyyy -> xxxx yyyyx -> xxxxm yyyy 2. xxxm yyyyz -> xxxx yyyyy -> xxxxm yyyy if there are even num of nodes then push to large then push the top of large to small // now it's odd else then push to small then push the top of small to large // now it's even Code \u00b6 class MedianFinder { private: priority_queue < double > small, large; bool even; public: /** initialize your data structure here. */ MedianFinder() { even = true; // 0 is even } void addNum( int num) { if (even) { // small.size() == large.size() large.push( - num); small.push( - large.top()); large.pop(); } else { // small.size() - large.size() == 1 small.push(num); large.push( - small.top()); small.pop(); } even = ! even; } double findMedian() { return ! even ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Solution 2: without even boolean \u00b6 Use two priority queues to store the streaming element. 2 small: 2 -> empty -> 2 large: -2 -> empty median: 2 2, 3 small: 2 -> 3,2 -> 2 large: empty -> -3 median: \\frac{2 - (-3)}{2} = 2.5 \\frac{2 - (-3)}{2} = 2.5 2, 3, 4 small: 2 -> 4, 2 -> 2 -> 3, 2 large: -3 -> -3, -4 -> -4 median: 3 Code \u00b6 class MedianFinder { private: priority_queue < long > small, large; public: /** initialize your data structure here. */ MedianFinder() {} void addNum( int num) { // blindly push in two pq small.push(num); large.push( - small.top()); // small is always greater than large in size, at most greater by one, equal is fine small.pop(); // leave the new element in large if (small.size() < large.size()) { small.push( - large.top()); large.pop(); // large has one more, so move it to small } } double findMedian() { return small.size() != large.size() ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Followups \u00b6 With all fall in between 0-100? Code O(100) O(100) \u00b6 class MedianFinder { private: int A[ 101 ], n; public: MedianFinder() { n = 0 ; memset(A, 0 , sizeof A); } void addNum( int num) { A[num] ++ ; n ++ ; } double findMedian() { int count = 0 , i = 0 ; while (count < n / 2 ) count += A[i ++ ]; int j = i; while (count < n / 2 + 1 ) count += A[j ++ ]; return (n % 2 == 1 ) ? j - 1 : (i + j - 2 ) / 2.0 ; } }; Further Thoughts: https://leetcode.com/articles/find-median-from-data-stream/ There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across: Buckets ! If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. @mitbbs8080 has an interesting implementation here . Reservoir Sampling . Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or reservoir) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a \" good \" size for your reservoir? Now, that's a whole other challenge. A good explanation for this can be found in this StackOverflow answer . Segment Trees are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations fast and in roughly the same amount of time , always . The only problem is that they are far from trivial to implement. Take a look at my introductory article on Segment Trees if you are interested. Order Statistic Trees are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the k^{th} k^{th} order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. GNU libstdc++ users are in luck! Take a look at this StackOverflow answer . \u21a9","title":"295. find median from data stream"},{"location":"Leetcode/295.-find-median-from-data-stream/#analysis","text":"To find the median, we need to split data into two halfs, and then use (first half's last element + second half's first element) / 2 (even) or first half's last (odd) to find the median. First half's last should be the value that is greater or equal to all the values from the first half of the data, and the second half's first is less than all the elements following. To find such two elements, we can use priority queue. Use one queue for finding the large median (max heap), and use the other queue to find the smaller median (min heap). To make two queues with the size difference at most 1, we need to find a way to balance the two queues. Complexity: Time: add takes O(\\log{n}) O(\\log{n}) + find takes O(1) O(1) Space: two queues take O(n) O(n)","title":"Analysis"},{"location":"Leetcode/295.-find-median-from-data-stream/#solution-1-recommend-use-global-odd-or-even-to-determine-median","text":"xxxx m yyyy q1: xxxx q2: yyyy xxxxm yyyy z // push from odd 1. xxxxzm yyyy -> xxxxxx yyyy -> xxxxx yyyyx -> xxxxx yyyyy -> m = (x + y) / 2 2. xxxxm zyyyy -> xxxxm yyyyy -> xxxxx yyyyy -> m = (x + y) / 2 xxxm yyyy z // push from even 1. xxxzm yyyy -> xxxx yyyyx -> xxxxm yyyy 2. xxxm yyyyz -> xxxx yyyyy -> xxxxm yyyy if there are even num of nodes then push to large then push the top of large to small // now it's odd else then push to small then push the top of small to large // now it's even","title":"Solution 1 [Recommend]: use global odd or even to determine median"},{"location":"Leetcode/295.-find-median-from-data-stream/#code","text":"class MedianFinder { private: priority_queue < double > small, large; bool even; public: /** initialize your data structure here. */ MedianFinder() { even = true; // 0 is even } void addNum( int num) { if (even) { // small.size() == large.size() large.push( - num); small.push( - large.top()); large.pop(); } else { // small.size() - large.size() == 1 small.push(num); large.push( - small.top()); small.pop(); } even = ! even; } double findMedian() { return ! even ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */","title":"Code"},{"location":"Leetcode/295.-find-median-from-data-stream/#solution-2-without-even-boolean","text":"Use two priority queues to store the streaming element. 2 small: 2 -> empty -> 2 large: -2 -> empty median: 2 2, 3 small: 2 -> 3,2 -> 2 large: empty -> -3 median: \\frac{2 - (-3)}{2} = 2.5 \\frac{2 - (-3)}{2} = 2.5 2, 3, 4 small: 2 -> 4, 2 -> 2 -> 3, 2 large: -3 -> -3, -4 -> -4 median: 3","title":"Solution 2: without even boolean"},{"location":"Leetcode/295.-find-median-from-data-stream/#code_1","text":"class MedianFinder { private: priority_queue < long > small, large; public: /** initialize your data structure here. */ MedianFinder() {} void addNum( int num) { // blindly push in two pq small.push(num); large.push( - small.top()); // small is always greater than large in size, at most greater by one, equal is fine small.pop(); // leave the new element in large if (small.size() < large.size()) { small.push( - large.top()); large.pop(); // large has one more, so move it to small } } double findMedian() { return small.size() != large.size() ? small.top() : 0.5 * (small.top() - large.top()); } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */","title":"Code"},{"location":"Leetcode/295.-find-median-from-data-stream/#followups","text":"With all fall in between 0-100?","title":"Followups"},{"location":"Leetcode/295.-find-median-from-data-stream/#code-o100o100","text":"class MedianFinder { private: int A[ 101 ], n; public: MedianFinder() { n = 0 ; memset(A, 0 , sizeof A); } void addNum( int num) { A[num] ++ ; n ++ ; } double findMedian() { int count = 0 , i = 0 ; while (count < n / 2 ) count += A[i ++ ]; int j = i; while (count < n / 2 + 1 ) count += A[j ++ ]; return (n % 2 == 1 ) ? j - 1 : (i + j - 2 ) / 2.0 ; } }; Further Thoughts: https://leetcode.com/articles/find-median-from-data-stream/ There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across: Buckets ! If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. @mitbbs8080 has an interesting implementation here . Reservoir Sampling . Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or reservoir) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a \" good \" size for your reservoir? Now, that's a whole other challenge. A good explanation for this can be found in this StackOverflow answer . Segment Trees are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations fast and in roughly the same amount of time , always . The only problem is that they are far from trivial to implement. Take a look at my introductory article on Segment Trees if you are interested. Order Statistic Trees are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the k^{th} k^{th} order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. GNU libstdc++ users are in luck! Take a look at this StackOverflow answer . \u21a9","title":"Code O(100)O(100)"},{"location":"Leetcode/32.-longest-valid-parentheses/","text":"int longestValidParentheses (string s) { if (s.length() <= 1 ) return 0 ; int curMax = 0 ; vector < int > longest(s.size(), 0 ); for ( int i = 1 ; i < s.length(); i ++ ){ if (s[i] == ')' ){ /* this block could be ignored because the else block has already calculated it if(s[i-1] == '('){ // valid parethese with previous one longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); } */ else { // if s[i-1] == ')', combine the previous length. int prevStart = i - longest[i - 1 ] - 1 ; // the one before the last start valid if (prevStart >= 0 && s[prevStart] == '(' ){ longest[i] = longest[i - 1 ] + 2 + ((prevStart - 1 >= 0 ) ? longest[prevStart - 1 ] : 0 ); curMax = max(longest[i],curMax); } } } //else if s[i] == '(', skip it, because longest[i] must be 0 } return curMax; } dp[i]: longest valid parentheses length ending with current [i] i - dp[i] + 1: start index of the previous valid one (dp[i-1]) why +2 : because the dp[prevStart-1] + ( + dp[i-1] + ), there are two elements","title":"32. longest valid parentheses"},{"location":"Leetcode/437.-path-sum-iii/","text":"You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. \u6837\u4f8b \u00b6 Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 5 -> 3 5 -> 2 -> 1 -3 -> 11 \u7b97\u6cd51 \u00b6 O(2^n) O(2^n) \u00b6 \u5982\u679c\u53ef\u4ee5\u4ece\u4efb\u610f\u70b9\u5f00\u59cb\uff0c\u90a3\u4e48\u8bf4\u660e\u6bcf\u4e2a\u4f4d\u7f6e\u7684node\u90fd\u6709\u53ef\u80fd\u662fstart\uff0c\u90a3\u4e48\u53ea\u8981\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u8fc7\u4e00\u904d\u5c31\u53ef\u4ee5\u4e86\u3002 \u5728\u9012\u5f52\u7684\u65f6\u5019\u7528\u4e00\u4e2a\u53d8\u91cf as_start \u4ee3\u8868\u662f\u5426\u4ece\u5f53\u524d\u8282\u70b9\u5f00\u59cb\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1abrute force\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c1d\u8bd5\u4e00\u904d\uff0c\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e24\u4e2aoperation\uff0c\u5982\u679c\u6709 n\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u4e00\u5171\u67092^n\u79cd\u9009\u6cd5\u3002 C++ \u00b6 class Solution { public: int res; int pathSum (TreeNode * root, int sum) { traverse(root, sum, 0 , true); return res; } // there are two choice: 1 start from current node 2. keep going from current node void traverse (TreeNode * root, int sum, int curr_sum, bool as_start) { if ( ! root) return ; curr_sum += root -> val; if (curr_sum == sum) res ++ ; traverse(root -> left, sum, curr_sum, false); traverse(root -> right, sum, curr_sum, false); if (as_start) { traverse(root -> left, sum, 0 , true); // start from next node, so sum is 0 traverse(root -> right, sum, 0 , true); } } }; \u7b97\u6cd52 \u00b6 O(n) O(n) space O(n) O(n) \u00b6 \u7b2c\u4e00\u79cd\u590d\u6742\u5ea6\u9ad8\u7684\u539f\u56e0\u662f\u6bcf\u4e2a\u8282\u70b9\u90fd\u8981\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u4f5c\u4e3a\u5934\u8282\u70b9\uff0c\u8fd9\u6837\u6bcf\u4e2a\u8282\u70b9\u76f8\u5f53\u4e8e\u90fd\u8981\u518d\u8dd1n\u6b21\u3002 \u4f46\u662f\u5176\u5b9e\u6ca1\u6709\u5fc5\u8981\u6bcf\u6b21\u90fd\u67e5\uff0c\u8fd9\u9053\u9898\u53ef\u4ee5\u60f3\u50cf\u6210two sum\u3002 \u6211\u4eec\u6bcf\u6b21\u5b58\u5f53\u524d\u5230root\u7684sum\uff0c\u8fd9\u6837\u6bcf\u6b21\u5230\u67d0\u4e2a\u8282\u70b9\u6211\u4eec\u5c31\u53ea\u8981\u770b\u8d85\u8fc7target\u7684\u90e8\u5206\u662f\u4e0d\u662f\u5df2\u7ecf\u5728\u4e4b\u524d \u5b58\u5728\u8fc7\u4e86\uff08\u56e0\u4e3a\u662froot\u5230\u5f53\u524d\u8282\u70b9\u7684sum\uff0c\u6240\u4ee5\u5fc5\u5b9a\u662f\u8fde\u7eed\u7684\uff09\u3002 \u8fd9\u4e2amap\u6211\u7528m\u6765\u8868\u793a\uff0ckey\u662fsum\u7684\u503c\uff0cvalue\u662f\u4e2a\u6570\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\uff08\u5047\u5982\u6709\u8d1f\u6570\u5b58\u5728\uff09\u3002 two sum\u90a3\u9053\u9898\u5176\u5b9e\u4e5f\u662f\u7c7b\u4f3c\u7684\u601d\u60f3\uff0c\u53ea\u4e0d\u8fc7\u662f\u6709\u4e24\u4e2a\uff0c\u6240\u4ee5\u4e0d\u7528map\u6765\u5b58\u4e2a\u6570\uff0c\u76f4\u63a5\u7528set\u6765\u770b\u5b58\u4e0d\u5b58\u5728 \u5c31\u53ef\u4ee5\u4e86\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1a\u6bcf\u4e2a\u8282\u70b9\u53ea\u8981\u8d70\u4e00\u6b21\uff0c\u4f46\u662f\u8981\u727a\u7272space\u6765\u5b58\u4e4b\u524d\u7684sum\uff0c\u6240\u4ee5space\u662fn\uff0ctime\u662fn\u3002 C++ \u00b6 class Solution { public: int res; unordered_map < int , int > m; int pathSum (TreeNode * root, int sum) { if ( ! root) return 0 ; m[ 0 ] = 1 ; // the node before root: value is 0 and it has 1 way to get that sum traverse(root, sum, root -> val); return res; } void traverse (TreeNode * root, int sum, int curr_sum) { if ( ! root) return ; // check the complements if (m.count(curr_sum - sum)) res += m[curr_sum - sum]; m[curr_sum] ++ ; if (root -> left) traverse(root -> left, sum, curr_sum + root -> left -> val); if (root -> right) traverse(root -> right, sum, curr_sum + root -> right -> val); m[curr_sum] -- ; // don't forget to set it back } };","title":"437. path sum iii"},{"location":"Leetcode/437.-path-sum-iii/#_1","text":"Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 5 -> 3 5 -> 2 -> 1 -3 -> 11","title":"\u6837\u4f8b"},{"location":"Leetcode/437.-path-sum-iii/#1","text":"","title":"\u7b97\u6cd51"},{"location":"Leetcode/437.-path-sum-iii/#o2no2n","text":"\u5982\u679c\u53ef\u4ee5\u4ece\u4efb\u610f\u70b9\u5f00\u59cb\uff0c\u90a3\u4e48\u8bf4\u660e\u6bcf\u4e2a\u4f4d\u7f6e\u7684node\u90fd\u6709\u53ef\u80fd\u662fstart\uff0c\u90a3\u4e48\u53ea\u8981\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u8fc7\u4e00\u904d\u5c31\u53ef\u4ee5\u4e86\u3002 \u5728\u9012\u5f52\u7684\u65f6\u5019\u7528\u4e00\u4e2a\u53d8\u91cf as_start \u4ee3\u8868\u662f\u5426\u4ece\u5f53\u524d\u8282\u70b9\u5f00\u59cb\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1abrute force\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c1d\u8bd5\u4e00\u904d\uff0c\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e24\u4e2aoperation\uff0c\u5982\u679c\u6709 n\u4e2a\u8282\u70b9\uff0c\u90a3\u4e48\u4e00\u5171\u67092^n\u79cd\u9009\u6cd5\u3002","title":"O(2^n)O(2^n)"},{"location":"Leetcode/437.-path-sum-iii/#c","text":"class Solution { public: int res; int pathSum (TreeNode * root, int sum) { traverse(root, sum, 0 , true); return res; } // there are two choice: 1 start from current node 2. keep going from current node void traverse (TreeNode * root, int sum, int curr_sum, bool as_start) { if ( ! root) return ; curr_sum += root -> val; if (curr_sum == sum) res ++ ; traverse(root -> left, sum, curr_sum, false); traverse(root -> right, sum, curr_sum, false); if (as_start) { traverse(root -> left, sum, 0 , true); // start from next node, so sum is 0 traverse(root -> right, sum, 0 , true); } } };","title":"C++"},{"location":"Leetcode/437.-path-sum-iii/#2","text":"","title":"\u7b97\u6cd52"},{"location":"Leetcode/437.-path-sum-iii/#onon-space-onon","text":"\u7b2c\u4e00\u79cd\u590d\u6742\u5ea6\u9ad8\u7684\u539f\u56e0\u662f\u6bcf\u4e2a\u8282\u70b9\u90fd\u8981\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u4f5c\u4e3a\u5934\u8282\u70b9\uff0c\u8fd9\u6837\u6bcf\u4e2a\u8282\u70b9\u76f8\u5f53\u4e8e\u90fd\u8981\u518d\u8dd1n\u6b21\u3002 \u4f46\u662f\u5176\u5b9e\u6ca1\u6709\u5fc5\u8981\u6bcf\u6b21\u90fd\u67e5\uff0c\u8fd9\u9053\u9898\u53ef\u4ee5\u60f3\u50cf\u6210two sum\u3002 \u6211\u4eec\u6bcf\u6b21\u5b58\u5f53\u524d\u5230root\u7684sum\uff0c\u8fd9\u6837\u6bcf\u6b21\u5230\u67d0\u4e2a\u8282\u70b9\u6211\u4eec\u5c31\u53ea\u8981\u770b\u8d85\u8fc7target\u7684\u90e8\u5206\u662f\u4e0d\u662f\u5df2\u7ecf\u5728\u4e4b\u524d \u5b58\u5728\u8fc7\u4e86\uff08\u56e0\u4e3a\u662froot\u5230\u5f53\u524d\u8282\u70b9\u7684sum\uff0c\u6240\u4ee5\u5fc5\u5b9a\u662f\u8fde\u7eed\u7684\uff09\u3002 \u8fd9\u4e2amap\u6211\u7528m\u6765\u8868\u793a\uff0ckey\u662fsum\u7684\u503c\uff0cvalue\u662f\u4e2a\u6570\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\uff08\u5047\u5982\u6709\u8d1f\u6570\u5b58\u5728\uff09\u3002 two sum\u90a3\u9053\u9898\u5176\u5b9e\u4e5f\u662f\u7c7b\u4f3c\u7684\u601d\u60f3\uff0c\u53ea\u4e0d\u8fc7\u662f\u6709\u4e24\u4e2a\uff0c\u6240\u4ee5\u4e0d\u7528map\u6765\u5b58\u4e2a\u6570\uff0c\u76f4\u63a5\u7528set\u6765\u770b\u5b58\u4e0d\u5b58\u5728 \u5c31\u53ef\u4ee5\u4e86\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1a\u6bcf\u4e2a\u8282\u70b9\u53ea\u8981\u8d70\u4e00\u6b21\uff0c\u4f46\u662f\u8981\u727a\u7272space\u6765\u5b58\u4e4b\u524d\u7684sum\uff0c\u6240\u4ee5space\u662fn\uff0ctime\u662fn\u3002","title":"O(n)O(n) space O(n)O(n)"},{"location":"Leetcode/437.-path-sum-iii/#c_1","text":"class Solution { public: int res; unordered_map < int , int > m; int pathSum (TreeNode * root, int sum) { if ( ! root) return 0 ; m[ 0 ] = 1 ; // the node before root: value is 0 and it has 1 way to get that sum traverse(root, sum, root -> val); return res; } void traverse (TreeNode * root, int sum, int curr_sum) { if ( ! root) return ; // check the complements if (m.count(curr_sum - sum)) res += m[curr_sum - sum]; m[curr_sum] ++ ; if (root -> left) traverse(root -> left, sum, curr_sum + root -> left -> val); if (root -> right) traverse(root -> right, sum, curr_sum + root -> right -> val); m[curr_sum] -- ; // don't forget to set it back } };","title":"C++"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/","text":"https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem public class Solution { public List < Integer > slidingWindowTemplateByHarryChaoyangHe(String s, String t) { //init a collection or int value to save the result according the question. List < Integer > result = new LinkedList <> (); if (t.length() > s.length()) return result; //create a hashmap to save the Characters of the target substring. //(K, V) = (Character, Frequence of the Characters) Map < Character, Integer > map = new HashMap <> (); for ( char c : t.toCharArray()){ map.put(c, map.getOrDefault(c, 0 ) + 1 ); } //maintain a counter to check whether match the target string. int counter = map.size(); //must be the map size, NOT the string size because the char may be duplicate. //Two Pointers: begin - left pointer of the window; end - right pointer of the window int begin = 0 , end = 0 ; //the length of the substring which match the target string. int len = Integer.MAX_VALUE; //loop at the begining of the source string while (end < s.length()){ char c = s.charAt(end); //get a character if ( map.containsKey(c) ){ map.put(c, map.get(c) - 1 ); // plus or minus one if (map.get(c) == 0 ) counter -- ; //modify the counter according the requirement(different condition). } end ++ ; //increase begin pointer to make it invalid/valid again while (counter == 0 /* counter condition. different question may have different condition */ ){ char tempc = s.charAt(begin); //***be careful here: choose the char at begin pointer, NOT the end pointer if (map.containsKey(tempc)){ map.put(tempc, map.get(tempc) + 1 ); //plus or minus one if (map.get(tempc) > 0 ) counter ++ ; //modify the counter according the requirement(different condition). } /* save / update(min/max) the result if find a target*/ // result collections or result int value begin ++ ; } } return result; } } 438. Find All Anagrams in a String \u00b6 Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". class Solution { public: vector < int > findAnagrams(string s, string p) { if (s.empty()) return {}; vector < int > res, m( 256 , 0 ); int left = 0 , right = 0 , cnt = p.size(), n = s.size(); for ( char c : p) ++ m[c]; while (right < n) { if (m[s[right ++ ]] -- >= 1 ) -- cnt; if (cnt == 0 ) res.push_back(left); if (right - left == p.size() && m[s[left ++ ]] ++ >= 0 ) ++ cnt; } } }; 76. Minimum Window Substring \u00b6 Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. class Solution { public: string minWindow(string s, string t) { unordered_map < char , int > m; for ( char c : t) { m[c] ++ ; } int sz = m.size(); string res; for ( int i = 0 , j = 0 , cnt = 0 ; i < s.size(); ++ i) { if (m[s[i]] == 1 ) cnt ++ ; m[s[i]] -- ; while (m[s[j]] < 0 ) { m[s[j ++ ]] ++ ; } if (cnt == sz) { if (res.empty() || res.size() > i - j + 1 ) res = s.substr(j, i - j + 1 ); } } return res; } }; 3. Longest Substring Without Repeating Characters \u00b6 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. class Solution { public: int lengthOfLongestSubstring(string s) { int start = 0 , end = 0 ; vector < int > v( 128 , 0 ); int res = 0 ; for ( int i = 0 , j = 0 ; i < s.size(); ++ i) { v[s[i]] ++ ; while (v[s[i]] > 1 ) { v[s[j ++ ]] -- ; } res = max(res, i - j + 1 ); } return res; } }; 30. Substring with Concatenation of All Words \u00b6 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } }; 30. Substring with Concatenation of All Words \u00b6 You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } }; 159. Longest Substring with At Most Two Distinct Characters \u00b6 Given a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: tis \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: tis \"aabbb\" which its length is 5. Analysis \u00b6 Use left only Use map<char, int> to record the frequency of character in the range of left - i (inclusive). Once the keys is greater than 2, try moves left by 1 unit and update the map if the frequency is 0. Time: O(n), Space: O(1) because size if always 2 entry of key-value pair. class Solution { public: int lengthOfLongestSubstringTwoDistinct(string s) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { m[s[i]] ++ ; while (m.size() > 2 ) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } }; Use left and right Space is optimized, but a little unintuitive. Use two pointers to represent the window. If s[i] == s[i-1], there is no update to the count of distinct elements. If right is not equal to the current one, that means there is a update (+1) to the total count, so we stop and update our res with the current i - left (window is now left - i). Because it only allows two characters, we should skip the ith character and start from right + 1 as left. #include <bits/stdc++.h> using namespace std; int main () { cin >> s; int left = 0 , right = - 1 , res = 0 , sz = s.size(); for ( int i = 1 ; i < sz; ++ i) { if (s[i] == s[i - 1 ]) continue ; if (right >= 0 && s[right] != s[i]) { res = max(res, i - left); left = right + 1 ; } right = i - 1 ; } cout << max(res, sz - left); return 0 ; } Variation: with K different words \u00b6 if the character is in range of 'a' to 'z', then maintain a int array with size of 26. class Solution { public: string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt < k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt == k && len < r - l) { // case 1: cnt still in the range so, r doesn't overcount len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // case 2: cnt is greater than k by 1, r overcount by 1 len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } }; class Solution { public: int lengthOfLongestSubstringKDistinct(string s, int k) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { ++ m[s[i]]; while (m.size() > k) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } };","title":"438, 76, 3, 30, sliding window"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#438-find-all-anagrams-in-a-string","text":"Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". class Solution { public: vector < int > findAnagrams(string s, string p) { if (s.empty()) return {}; vector < int > res, m( 256 , 0 ); int left = 0 , right = 0 , cnt = p.size(), n = s.size(); for ( char c : p) ++ m[c]; while (right < n) { if (m[s[right ++ ]] -- >= 1 ) -- cnt; if (cnt == 0 ) res.push_back(left); if (right - left == p.size() && m[s[left ++ ]] ++ >= 0 ) ++ cnt; } } };","title":"438. Find All Anagrams in a String"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#76-minimum-window-substring","text":"Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. class Solution { public: string minWindow(string s, string t) { unordered_map < char , int > m; for ( char c : t) { m[c] ++ ; } int sz = m.size(); string res; for ( int i = 0 , j = 0 , cnt = 0 ; i < s.size(); ++ i) { if (m[s[i]] == 1 ) cnt ++ ; m[s[i]] -- ; while (m[s[j]] < 0 ) { m[s[j ++ ]] ++ ; } if (cnt == sz) { if (res.empty() || res.size() > i - j + 1 ) res = s.substr(j, i - j + 1 ); } } return res; } };","title":"76. Minimum Window Substring"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#3-longest-substring-without-repeating-characters","text":"Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. class Solution { public: int lengthOfLongestSubstring(string s) { int start = 0 , end = 0 ; vector < int > v( 128 , 0 ); int res = 0 ; for ( int i = 0 , j = 0 ; i < s.size(); ++ i) { v[s[i]] ++ ; while (v[s[i]] > 1 ) { v[s[j ++ ]] -- ; } res = max(res, i - j + 1 ); } return res; } };","title":"3. Longest Substring Without Repeating Characters"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#30-substring-with-concatenation-of-all-words","text":"You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } };","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#30-substring-with-concatenation-of-all-words_1","text":"You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public: vector < int > findSubstring(string s, vector < string >& words) { if (s.empty() || words.empty()) return {}; int n = s.size(), len = words[ 0 ].size(), total = words.size(), cnt = total; vector < int > res; unordered_map < string, int > counts; for (string s : words) counts[s] ++ ; for ( int i = 0 ; i < len; i ++ ) { unordered_map < string, int > wordcnt = counts; cnt = total; for ( int j = i; j + len <= n; j += len) { string cur = s.substr(j, len); if (wordcnt[cur] -- > 0 ) cnt -- ; if (j - total * len >= 0 ) { string out = s.substr(j - total * len, len); // the word out side of current sliding window if ( ++ wordcnt[out] > 0 ) cnt ++ ; } if (cnt == 0 ) res.push_back(j - (total - 1 ) * len); } } return res; } };","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#159-longest-substring-with-at-most-two-distinct-characters","text":"Given a string s , find the length of the longest substring t that contains at most 2 distinct characters. Example 1: Input: \"eceba\" Output: 3 Explanation: tis \"ece\" which its length is 3. Example 2: Input: \"ccaabbb\" Output: 5 Explanation: tis \"aabbb\" which its length is 5.","title":"159. Longest Substring with At Most Two Distinct Characters"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#analysis","text":"Use left only Use map<char, int> to record the frequency of character in the range of left - i (inclusive). Once the keys is greater than 2, try moves left by 1 unit and update the map if the frequency is 0. Time: O(n), Space: O(1) because size if always 2 entry of key-value pair. class Solution { public: int lengthOfLongestSubstringTwoDistinct(string s) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { m[s[i]] ++ ; while (m.size() > 2 ) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } }; Use left and right Space is optimized, but a little unintuitive. Use two pointers to represent the window. If s[i] == s[i-1], there is no update to the count of distinct elements. If right is not equal to the current one, that means there is a update (+1) to the total count, so we stop and update our res with the current i - left (window is now left - i). Because it only allows two characters, we should skip the ith character and start from right + 1 as left. #include <bits/stdc++.h> using namespace std; int main () { cin >> s; int left = 0 , right = - 1 , res = 0 , sz = s.size(); for ( int i = 1 ; i < sz; ++ i) { if (s[i] == s[i - 1 ]) continue ; if (right >= 0 && s[right] != s[i]) { res = max(res, i - left); left = right + 1 ; } right = i - 1 ; } cout << max(res, sz - left); return 0 ; }","title":"Analysis"},{"location":"Leetcode/438%2C-76%2C-3%2C-30%2C-sliding-window/#variation-with-k-different-words","text":"if the character is in range of 'a' to 'z', then maintain a int array with size of 26. class Solution { public: string longest(string input, int k) { int n = input.size(); int l = 0 , r = 0 , cnt = 0 , len = 0 ; string res = \"\" ; int v[ 26 ]; memset(v, 0 , sizeof v); while (l < n - 1 ) { while (cnt < k && r < n) { if (v[input[r] - 'a' ] ++ == 0 ) cnt ++ ; r ++ ; } if (cnt == k && len < r - l) { // case 1: cnt still in the range so, r doesn't overcount len = r - l; res = input.substr(l, len); } else if (len < r - l - 1 ) { // case 2: cnt is greater than k by 1, r overcount by 1 len = r - l - 1 ; res = input.substr(l, len); } if ( -- v[input[l] - 'a' ] == 0 ) cnt -- ; l ++ ; } return res; } }; class Solution { public: int lengthOfLongestSubstringKDistinct(string s, int k) { int res = 0 , left = 0 ; unordered_map < char , int > m; for ( int i = 0 ; i < s.size(); ++ i) { ++ m[s[i]]; while (m.size() > k) { if ( -- m[s[left]] == 0 ) m.erase(s[left]); ++ left; } res = max(res, i - left + 1 ); } return res; } };","title":"Variation: with K different words"},{"location":"Leetcode/54.-spiral-matrix/","text":"Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Analysis \u00b6 Split the matrix into four parts: 1. right: column can move in the range of [l, r], after finish, ++u 2. down: row can move in the range of [u, d], after finish, --r 3. left: column can move in the range of [l, r], after finish, ++d 4. up: row can move in the range of [u, d], after finish, ++l Code \u00b6 class Solution { public: vector < int > spiral(vector < vector < int >> matrix) { // write your solution here if (matrix.empty() || matrix[ 0 ].empty()) return {}; int m = matrix.size(), n = matrix[ 0 ].size(); vector < int > res(m * n); int u = 0 , d = m - 1 , l = 0 , r = n - 1 , k = 0 ; while ( 1 ) { // right: l <= col <= r for ( int col = l; col <= r; ++ col) res[k ++ ] = matrix[u][col]; if ( ++ u > d) break ; // down: u <= row <= d for ( int row = u; row <= d; ++ row) res[k ++ ] = matrix[row][r]; if ( -- r < l) break ; // left: l <= col <= r for ( int col = r; col >= l; -- col) res[k ++ ] = matrix[d][col]; if ( -- d < u) break ; // up: u <= row <= d for ( int row = d; row >= u; -- row) res[k ++ ] = matrix[row][l]; if ( ++ l > r) break ; } return res; } };","title":"54. spiral matrix"},{"location":"Leetcode/54.-spiral-matrix/#analysis","text":"Split the matrix into four parts: 1. right: column can move in the range of [l, r], after finish, ++u 2. down: row can move in the range of [u, d], after finish, --r 3. left: column can move in the range of [l, r], after finish, ++d 4. up: row can move in the range of [u, d], after finish, ++l","title":"Analysis"},{"location":"Leetcode/54.-spiral-matrix/#code","text":"class Solution { public: vector < int > spiral(vector < vector < int >> matrix) { // write your solution here if (matrix.empty() || matrix[ 0 ].empty()) return {}; int m = matrix.size(), n = matrix[ 0 ].size(); vector < int > res(m * n); int u = 0 , d = m - 1 , l = 0 , r = n - 1 , k = 0 ; while ( 1 ) { // right: l <= col <= r for ( int col = l; col <= r; ++ col) res[k ++ ] = matrix[u][col]; if ( ++ u > d) break ; // down: u <= row <= d for ( int row = u; row <= d; ++ row) res[k ++ ] = matrix[row][r]; if ( -- r < l) break ; // left: l <= col <= r for ( int col = r; col >= l; -- col) res[k ++ ] = matrix[d][col]; if ( -- d < u) break ; // up: u <= row <= d for ( int row = d; row >= u; -- row) res[k ++ ] = matrix[row][l]; if ( ++ l > r) break ; } return res; } };","title":"Code"},{"location":"Leetcode/72.-edit-distance/","text":"int dp_sol (string word1, string word2){ int m = word1.size(), n = word2.size(); vector < vector < int >> dp(m + 1 , vector < int > (n + 1 )); for ( int i = 0 ; i <= m; ++ i) { dp[i][ 0 ] = i; // can only remove all from word2[0:i] to form an empty word1 } for ( int i = 0 ; i <= n; ++ i) { dp[ 0 ][i] = i; // same as above } for ( int i = 1 ; i <= m; ++ i) { for ( int j = 1 ; j <= n; ++ j) { if (word1[i - 1 ] == word2[j - 1 ]) { // nothing needs to be changed, because they are the same dp[i][j] = dp[i - 1 ][j - 1 ]; } else { // now you can either remove previous one from word1, add is equal to remove one from word2, or replace current one (no change) dp[i][j] = min(dp[i - 1 ][j - 1 ], min(dp[i - 1 ][j], dp[i][j - 1 ])) + 1 ; // +1 for the current op } } } return dp[m][n]; } dp[i][j]: # of ops to transfer word1[0:i] to word2[0:j]","title":"72. edit distance"},{"location":"Leetcode/85.-maximal-rectangle/","text":"class Solution {public: int maximalRectangle(vector < vector < char > > & matrix) { if (matrix.empty()) return 0 ; const int m = matrix.size(); const int n = matrix[ 0 ].size(); int left[n], right[n], height[n]; fill_n(left,n, 0 ); fill_n(right,n,n); fill_n(height,n, 0 ); int maxA = 0 ; for ( int i = 0 ; i < m; i ++ ) { int cur_left = 0 , cur_right = n; for ( int j = 0 ; j < n; j ++ ) { // compute height (can do this from either side) if (matrix[i][j] == '1' ) height[j] ++ ; else height[j] = 0 ; } for ( int j = 0 ; j < n; j ++ ) { // compute left (from left to right) if (matrix[i][j] == '1' ) left[j] = max(left[j],cur_left); else {left[j] = 0 ; cur_left = j + 1 ;} } // compute right (from right to left) for ( int j = n - 1 ; j >= 0 ; j -- ) { if (matrix[i][j] == '1' ) right[j] = min(right[j],cur_right); else {right[j] = n; cur_right = j;} } // compute the area of rectangle (can do this from either side) for ( int j = 0 ; j < n; j ++ ) maxA = max(maxA,(right[j] - left[j]) * height[j]); } return maxA; } height[i] record the current number of countinous '1' in column i; left[i] record the left most index j which satisfies that for any index k from j to i, height[k] >= height[i]; right[i] record the right most index j which satifies that for any index k from i to j, height[k] >= height[i]; if j doesn't exist, then use size of matrix to represent j for right, use 0 to represent j for left matrix 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 height 0 0 0 1 0 0 0 0 0 1 2 1 0 0 0 1 2 3 2 1 0 left 0 0 0 3 0 0 0 0 0 2 3 2 0 0 0 1 2 3 2 1 0 right 7 7 7 4 7 7 7 // at index i from right to left, if height[i] >= height[i+1], set right[i]=i or keep going 7 7 5 4 5 7 7 7 6 5 4 5 4 7 result 0 0 0 1 0 0 0 0 0 3 2 3 0 0 0 5 6 3 6 5 0","title":"85. maximal rectangle"},{"location":"Leetcode/87.-scramble-string/","text":"Using cache + recursion \u00b6 class Solution { bool DP_helper(unordered_map < string, bool > & isScramblePair, string s1, string s2) { int i,len = s1.size(); bool res = false; if ( 0 == len) return true; else if ( 1 == len) return s1 == s2; else { if (isScramblePair.count(s1 + s2)) return isScramblePair[s1 + s2]; // checked before, return intermediate result directly if (s1 == s2) res = true; else { for (i = 1 ; i < len && ! res; ++ i) { //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr( 0 ,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr(i,len - i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr(len - i,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr( 0 ,len - i))); } } return isScramblePair[s1 + s2] = res; //save the intermediate results } } public: bool isScramble(string s1, string s2) { unordered_map < string, bool > isScramblePair; return DP_helper (isScramblePair, s1, s2); } }; A string can be rotated anyway. There are four things to compare between two strings: s1: 111i222len s2: 333i444len 111 && 333 222 && 444 or 111 && 444 222 && 333 DP bottom-up \u00b6 class Solution { public: bool isScramble(string s1, string s2) { int sSize = s1.size(), len, i, j, k; if ( 0 == sSize) return true; if ( 1 == sSize) return s1 == s2; bool isS[sSize + 1 ][sSize][sSize]; for (i = 0 ; i < sSize; ++ i) for (j = 0 ; j < sSize; ++ j) isS[ 1 ][i][j] = s1[i] == s2[j]; for (len = 2 ; len <= sSize; ++ len) for (i = 0 ; i <= sSize - len; ++ i) for (j = 0 ; j <= sSize - len; ++ j) { isS[len][i][j] = false; for (k = 1 ; k < len && ! isS[len][i][j]; ++ k) { isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len - k][i + k][j + k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i + len - k][j] && isS[len - k][i][j + k]); } } return isS[sSize][ 0 ][ 0 ]; } }; dp[len][i][j]: s1[i..i+len-1] is a scramble of s2[j..j+len-1] 1. init: all single char can match if they are the same (line 11) 2. dp[len][i][j] = (dp[k][i][j] && dp[len-k][i+k][j+k]) || (dp[k][i+len-k][j] && dp[len-k][i][j+k]) Time Complexity \u00b6 n^4 for all cases","title":"87. scramble string"},{"location":"Leetcode/87.-scramble-string/#using-cache-recursion","text":"class Solution { bool DP_helper(unordered_map < string, bool > & isScramblePair, string s1, string s2) { int i,len = s1.size(); bool res = false; if ( 0 == len) return true; else if ( 1 == len) return s1 == s2; else { if (isScramblePair.count(s1 + s2)) return isScramblePair[s1 + s2]; // checked before, return intermediate result directly if (s1 == s2) res = true; else { for (i = 1 ; i < len && ! res; ++ i) { //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr( 0 ,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr(i,len - i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr( 0 ,i), s2.substr(len - i,i)) && DP_helper(isScramblePair, s1.substr(i,len - i), s2.substr( 0 ,len - i))); } } return isScramblePair[s1 + s2] = res; //save the intermediate results } } public: bool isScramble(string s1, string s2) { unordered_map < string, bool > isScramblePair; return DP_helper (isScramblePair, s1, s2); } }; A string can be rotated anyway. There are four things to compare between two strings: s1: 111i222len s2: 333i444len 111 && 333 222 && 444 or 111 && 444 222 && 333","title":"Using cache + recursion"},{"location":"Leetcode/87.-scramble-string/#dp-bottom-up","text":"class Solution { public: bool isScramble(string s1, string s2) { int sSize = s1.size(), len, i, j, k; if ( 0 == sSize) return true; if ( 1 == sSize) return s1 == s2; bool isS[sSize + 1 ][sSize][sSize]; for (i = 0 ; i < sSize; ++ i) for (j = 0 ; j < sSize; ++ j) isS[ 1 ][i][j] = s1[i] == s2[j]; for (len = 2 ; len <= sSize; ++ len) for (i = 0 ; i <= sSize - len; ++ i) for (j = 0 ; j <= sSize - len; ++ j) { isS[len][i][j] = false; for (k = 1 ; k < len && ! isS[len][i][j]; ++ k) { isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len - k][i + k][j + k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i + len - k][j] && isS[len - k][i][j + k]); } } return isS[sSize][ 0 ][ 0 ]; } }; dp[len][i][j]: s1[i..i+len-1] is a scramble of s2[j..j+len-1] 1. init: all single char can match if they are the same (line 11) 2. dp[len][i][j] = (dp[k][i][j] && dp[len-k][i+k][j+k]) || (dp[k][i+len-k][j] && dp[len-k][i][j+k])","title":"DP bottom-up"},{"location":"Leetcode/87.-scramble-string/#time-complexity","text":"n^4 for all cases","title":"Time Complexity"},{"location":"Leetcode/91.-decode-ways/","text":"Use array DP \u00b6 java \u00b6 public class Solution { public int numDecodings(String s) { if (s == null || s.length() == 0 ) { return 0 ; } int n = s.length(); int [] dp = new int [n + 1 ]; dp[ 0 ] = 1 ; // # of ways to decode for empty s dp[ 1 ] = s.charAt( 0 ) != '0' ? 1 : 0 ; // 0 cannot be leading element for a number for ( int i = 2 ; i <= n; i ++ ) { int first = Integer.valueOf(s.substring(i - 1 , i)); // s[i-1:i] int second = Integer.valueOf(s.substring(i - 2 , i)); // s[i-2:i] if (first >= 1 && first <= 9 ) { dp[i] += dp[i - 1 ]; } if (second >= 10 && second <= 26 ) { dp[i] += dp[i - 2 ]; } } return dp[n]; } } dp[i]: number of ways to decode 1. dp[i] += dp[i-1] if s[i-1:i] is valid (single digit: range from 0-9) 2. dp[i] += dp[i-2] if s[i-2:i] is valid (two digits: range from 10-26) cpp \u00b6 int numDecodings (string s) { int n = s.size(); vector < int > dp(n + 1 ); dp[n] = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) dp[i] = 0 ; else { dp[i] = dp[i + 1 ]; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) dp[i] += dp[i + 2 ]; } } return s.empty() ? 0 : dp[ 0 ]; } dp[i] += dp[i+2] if 1. s[i] == 1, so that any s[i+2] is valid, s[i:i+1] is in range 10-19 2. s[i] == 2 and s[i+1] < 7, so that s[i:i+1] is in range 20-26 if s[i] == 0, then dp[i] = 0, because 0 cannot be leading optimize with constant space \u00b6 class Solution { public: int numDecodings(string s) { int n = s.size(); int pre = 1 , prepre = 1 , curr = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) curr = 0 ; else { curr = pre; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) curr += prepre; } prepre = pre; pre = curr; curr = 1 ; } return s.empty() ? 0 : pre; } }; only needs two more states from current state, so 1. pre: s[i:i+1] 2. prepre: s[i:i+2]","title":"Use array DP"},{"location":"Leetcode/91.-decode-ways/#use-array-dp","text":"","title":"Use array DP"},{"location":"Leetcode/91.-decode-ways/#java","text":"public class Solution { public int numDecodings(String s) { if (s == null || s.length() == 0 ) { return 0 ; } int n = s.length(); int [] dp = new int [n + 1 ]; dp[ 0 ] = 1 ; // # of ways to decode for empty s dp[ 1 ] = s.charAt( 0 ) != '0' ? 1 : 0 ; // 0 cannot be leading element for a number for ( int i = 2 ; i <= n; i ++ ) { int first = Integer.valueOf(s.substring(i - 1 , i)); // s[i-1:i] int second = Integer.valueOf(s.substring(i - 2 , i)); // s[i-2:i] if (first >= 1 && first <= 9 ) { dp[i] += dp[i - 1 ]; } if (second >= 10 && second <= 26 ) { dp[i] += dp[i - 2 ]; } } return dp[n]; } } dp[i]: number of ways to decode 1. dp[i] += dp[i-1] if s[i-1:i] is valid (single digit: range from 0-9) 2. dp[i] += dp[i-2] if s[i-2:i] is valid (two digits: range from 10-26)","title":"java"},{"location":"Leetcode/91.-decode-ways/#cpp","text":"int numDecodings (string s) { int n = s.size(); vector < int > dp(n + 1 ); dp[n] = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) dp[i] = 0 ; else { dp[i] = dp[i + 1 ]; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) dp[i] += dp[i + 2 ]; } } return s.empty() ? 0 : dp[ 0 ]; } dp[i] += dp[i+2] if 1. s[i] == 1, so that any s[i+2] is valid, s[i:i+1] is in range 10-19 2. s[i] == 2 and s[i+1] < 7, so that s[i:i+1] is in range 20-26 if s[i] == 0, then dp[i] = 0, because 0 cannot be leading","title":"cpp"},{"location":"Leetcode/91.-decode-ways/#optimize-with-constant-space","text":"class Solution { public: int numDecodings(string s) { int n = s.size(); int pre = 1 , prepre = 1 , curr = 1 ; for ( int i = n - 1 ;i >= 0 ;i -- ) { // from back to front if (s[i] == '0' ) curr = 0 ; else { curr = pre; if (i < n - 1 && (s[i] == '1' || s[i] == '2' && s[i + 1 ] < '7' )) curr += prepre; } prepre = pre; pre = curr; curr = 1 ; } return s.empty() ? 0 : pre; } }; only needs two more states from current state, so 1. pre: s[i:i+1] 2. prepre: s[i:i+2]","title":"optimize with constant space"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/","text":"Analysis \u00b6 start.... i .....end for all left from start to i - 1: for all right from i + 1 to end: root -> left = choose one from all left root -> right = choose one from all right Time Compleixty: O(n!) O(n!) since each node could be the root node, and for each root there could have n - 1 configuration of left (so does right subtree), and doing the process recursively will yield n \\times (n - 1) ... \\times 1 = n! n \\times (n - 1) ... \\times 1 = n! c++ \u00b6 class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; return helper ( 1 , n); } vector < TreeNode *> helper( int start, int end) { if (start > end) return {nullptr}; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 ), right = helper(i + 1 , end); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return res; } }; with MEMO + DP class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; vector < vector < vector < TreeNode *>>> memo(n, vector < vector < TreeNode *>> (n)); return helper ( 1 , n, memo); } vector < TreeNode *> helper( int start, int end, vector < vector < vector < TreeNode *>>>& memo) { if (start > end) return {nullptr}; if ( ! memo[start - 1 ][end - 1 ].empty()) return memo[start - 1 ][end - 1 ]; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 , memo), right = helper(i + 1 , end, memo); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return memo[start - 1 ][end - 1 ] = res; } }; memo[i][j][k]: save current tree (root) with left starts from i - 1, right starts from j - 1","title":"95. unique binary search trees ii"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#analysis","text":"start.... i .....end for all left from start to i - 1: for all right from i + 1 to end: root -> left = choose one from all left root -> right = choose one from all right Time Compleixty: O(n!) O(n!) since each node could be the root node, and for each root there could have n - 1 configuration of left (so does right subtree), and doing the process recursively will yield n \\times (n - 1) ... \\times 1 = n! n \\times (n - 1) ... \\times 1 = n!","title":"Analysis"},{"location":"Leetcode/95.-unique-binary-search-trees-ii/#c","text":"class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; return helper ( 1 , n); } vector < TreeNode *> helper( int start, int end) { if (start > end) return {nullptr}; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 ), right = helper(i + 1 , end); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return res; } }; with MEMO + DP class Solution { public: vector < TreeNode *> generateTrees( int n) { if (n == 0 ) return {}; vector < vector < vector < TreeNode *>>> memo(n, vector < vector < TreeNode *>> (n)); return helper ( 1 , n, memo); } vector < TreeNode *> helper( int start, int end, vector < vector < vector < TreeNode *>>>& memo) { if (start > end) return {nullptr}; if ( ! memo[start - 1 ][end - 1 ].empty()) return memo[start - 1 ][end - 1 ]; vector < TreeNode *> res; for ( int i = start; i <= end; ++ i) { auto left = helper(start, i - 1 , memo), right = helper(i + 1 , end, memo); for ( auto a : left) { for ( auto b : right) { TreeNode * node = new TreeNode(i); node -> left = a; node -> right = b; res.push_back(node); } } } return memo[start - 1 ][end - 1 ] = res; } }; memo[i][j][k]: save current tree (root) with left starts from i - 1, right starts from j - 1","title":"c++"},{"location":"Leetcode/96.-unique-binary-search-trees-%282%29/","text":"Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Analysis \u00b6 We don't need to find the detail configuration for the trees, so we can use DP. DP[i]: from 0~i, total number of subtrees DP[i + 1] = left subtree * right subtree = dp[left to root] * dp[root to right] Time Complexity: O(n^2) O(n^2) Space Complexity: O(n) O(n) Code \u00b6 class Solution { public: int numTrees( int n) { int dp[n + 1 ]; memset(dp, 0 , sizeof dp); dp[ 1 ] = 1 ; dp[ 0 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) // j is root dp[i] += dp[j - 1 ] * dp[i - j]; // left subtree * right subtree } return dp[n]; } };","title":"96. unique binary search trees (2)"},{"location":"Leetcode/96.-unique-binary-search-trees-%282%29/#analysis","text":"We don't need to find the detail configuration for the trees, so we can use DP. DP[i]: from 0~i, total number of subtrees DP[i + 1] = left subtree * right subtree = dp[left to root] * dp[root to right] Time Complexity: O(n^2) O(n^2) Space Complexity: O(n) O(n)","title":"Analysis"},{"location":"Leetcode/96.-unique-binary-search-trees-%282%29/#code","text":"class Solution { public: int numTrees( int n) { int dp[n + 1 ]; memset(dp, 0 , sizeof dp); dp[ 1 ] = 1 ; dp[ 0 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) // j is root dp[i] += dp[j - 1 ] * dp[i - j]; // left subtree * right subtree } return dp[n]; } };","title":"Code"},{"location":"Leetcode/96.-unique-binary-search-trees/","text":"The problem can be solved in a dynamic programming way. I\u2019ll explain the intuition and formulas in the following. Given a sequence 1\u2026n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1\u2026(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)\u2026n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique , since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 \\<= i \\<= n: the number of unique BST , where the number i is the root of BST , and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root. i.e. G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree). i.e. G(0)=1, G(1)=1. Given a sequence 1\u2026n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. F(i, n) = G(i-1) * G(n-i) 1 \\<= i \\<= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \u2026 + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) \u2026 G(n-1). With the above explanation and formulas, here is the implementation in Java. public int numTrees ( int n) { int [] G = new int [n + 1 ]; G[ 0 ] = G[ 1 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) { G[i] += G[j - 1 ] * G[i - j]; } } return G[n]; } in cpp \u00b6 public int numTrees ( int n) { int G[n + 1 ]; fill_n(G, n + 1 , 0 ); G[ 0 ] = G[ 1 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) { G[i] += G[j - 1 ] * G[i - j]; } } return G[n]; }","title":"96. unique binary search trees"},{"location":"Leetcode/96.-unique-binary-search-trees/#in-cpp","text":"public int numTrees ( int n) { int G[n + 1 ]; fill_n(G, n + 1 , 0 ); G[ 0 ] = G[ 1 ] = 1 ; for ( int i = 2 ; i <= n; ++ i) { for ( int j = 1 ; j <= i; ++ j) { G[i] += G[j - 1 ] * G[i - j]; } } return G[n]; }","title":"in cpp"},{"location":"Leetcode/97.-interleaving-string/","text":"class Solution { public: bool isInterleave(string s1, string s2, string s3) { int m = s1.size(), n = s2.size(), k = s3.size(); if (m + n != k) return false; bool dp[m + 1 ][n + 1 ]; memset(dp, false, sizeof dp); for ( int i = 0 ; i <= m; ++ i) { for ( int j = 0 ; j <= n; ++ j) { if (i == 0 && j == 0 ) dp[i][j] = true; else if (i == 0 ) dp[i][j] = dp[i][j - 1 ] && s2[j - 1 ] == s3[i + j - 1 ]; else if (j == 0 ) dp[i][j] = dp[i - 1 ][j] && s1[i - 1 ] == s3[i + j - 1 ]; else dp[i][j] = (dp[i - 1 ][j] && s1[i - 1 ] == s3[i + j - 1 ]) || (dp[i][j - 1 ] && s2[j - 1 ] == s3[i + j - 1 ]); } } return dp[m][n]; } }; dp[i][j]: from s1[0:i] and s2[0:j] can be combined to s3[0:i+j-1]","title":"97. interleaving string"},{"location":"Leetcode/99.-recover-binary-search-tree/","text":"Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Analysis \u00b6 Use in-order tree traverse, we can find that all the left < root > right. If there is any invalid nodes, we should find left(prev) > root. We keep track of last level's root as prev where current root is it's left child. There are two situations: 1. first isn't populated, so the first two node should be swapped are pre and root. 2. first is populated, then we traverse all the way down to find the last pre that is greater than root. Time Complexity: O(n) O(n) as it's an in-order traversal Space Complexity: O(n) O(n) worst case the tree is a linkedlist Code \u00b6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), * right(right) {} * }; */ class Solution { public: TreeNode * first = NULL; TreeNode * second = NULL; TreeNode * prev = new TreeNode(INT_MIN); void recoverTree (TreeNode * root) { help(root); swap(first -> val, second -> val); } void help (TreeNode * root) { if (root == NULL) return ; help(root -> left); if (first == NULL && prev -> val > root -> val) first = prev; if (first != NULL && prev -> val > root -> val) second = root; prev = root; help(root -> right); }","title":"99. recover binary search tree"},{"location":"Leetcode/99.-recover-binary-search-tree/#analysis","text":"Use in-order tree traverse, we can find that all the left < root > right. If there is any invalid nodes, we should find left(prev) > root. We keep track of last level's root as prev where current root is it's left child. There are two situations: 1. first isn't populated, so the first two node should be swapped are pre and root. 2. first is populated, then we traverse all the way down to find the last pre that is greater than root. Time Complexity: O(n) O(n) as it's an in-order traversal Space Complexity: O(n) O(n) worst case the tree is a linkedlist","title":"Analysis"},{"location":"Leetcode/99.-recover-binary-search-tree/#code","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), * right(right) {} * }; */ class Solution { public: TreeNode * first = NULL; TreeNode * second = NULL; TreeNode * prev = new TreeNode(INT_MIN); void recoverTree (TreeNode * root) { help(root); swap(first -> val, second -> val); } void help (TreeNode * root) { if (root == NULL) return ; help(root -> left); if (first == NULL && prev -> val > root -> val) first = prev; if (first != NULL && prev -> val > root -> val) second = root; prev = root; help(root -> right); }","title":"Code"},{"location":"Leetcode/dp-pattern/","text":"https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns Minimum (Maximum) Path to Reach a Target \u00b6 Given a target find minimum (maximum) cost / path / sum to reach the target. 746. Min Cost Climbing Stairs \u00b6 On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. dp[i] min cost to reach ith stair. for ( int i = 2 ; i <= n; ++ i) { dp[i] = min(dp[i - 1 ], dp[i - 2 ]) + (i == n ? 0 : cost[i]); // on last step, there is no need to proceed further. } return dp[n] with optimization int p1 = 0 , p2 = 0 ; for ( int i = 2 ; i <= cost.size(); ++ i) { int p = min(p1 + cost[i - 1 ], p2 + cost[i - 2 ]); p2 = p1; p1 = p; } return p1; 64. Minimum Path Sum \u00b6 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum. dp[i][j]: min sum to reach x=i,y=j, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] for ( int i = 1 ; i < n; ++ i) { for ( int j = 1 ; j < m; ++ j) { grid[i][j] = min(grid[i - 1 ][j], grid[i][j - 1 ]) + grid[i][j]; } } return grid[n - 1 ][m - 1 ] 322. Coin Change \u00b6 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin. dp[j]: min # of coins to be used for j amount for ( int j = 1 ; j <= amount; ++ j) { for ( int i = 0 ; i < coins.size(); ++ i) { // try all coins if (coins[i] <= j) { // only try the one that is less than total required dp[j] = min(dp[j], dp[j - coins[i]] + 1 ); } } } return dp[amount]; Why this cannot be solved by greedy algorithm? \u00b6 Exception: But for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set {1, 15, 25} and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice. In any case where there is no coin whose value, when added to the lowest denomination, is lower than twice that of the denomination immediately less than it, the greedy algorithm works. i.e. {1,2,3} works because [1,3] and [2,2] add to the same value however {1, 15, 25} doesn't work because (for the change 30) 15+15>25+1 931. Minimum Falling Path Sum \u00b6 Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. A[i][j]: min sum from all upper level to current level i and position j, to get the ans, just find the min on the last row int minFallingPathSum (vector < vector < int >>& A) { int m = A.size(), n = A[ 0 ].size(); int res = INT_MAX; for ( int i = 1 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { A[i][j] += min( {A[i - 1 ][j], A[i - 1 ][max( 0 , j - 1 )], A[i - 1 ][min(m - 1 , j + 1 )]}); } } for ( int i = 0 ; i < n; ++ i) res = min(res, A[m - 1 ][i]); return res; } 983. Minimum Cost For Tickets \u00b6 In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel. Note: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 dp[i]: min cost for ith day. Note: if there is no travel plan, the cost will stay the same as the i-1 th day. int mincostTickets (vector < int >& days, vector < int >& costs) { unordered_set < int > travel(begin(days), end(days)); int dp[ 366 ] = {}; for ( int i = 1 ; i < 366 ; ++ i) { if (travel.find(i) == travel.end()) dp[i] = dp[i - 1 ]; else dp[i] = min({ dp[i - 1 ] + costs[ 0 ], dp[max( 0 , i - 7 )] + costs[ 1 ], dp[max( 0 , i - 30 )] + costs[ 2 ]}); } return dp[ 365 ]; } 650. 2 Keys Keyboard \u00b6 Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. dp[i]: min steps to get to get i 'A' characters. int dp[n + 1 ]; memset(dp, 0 , sizeof dp); for ( int i = 2 ; i <= n; ++ i) { dp[i] = i; // initially assume copy one and paste one by one for ( int j = i - 1 ; j >= 1 ; -- j) { if (i % j == 0 ) { dp[i] = dp[j] + i / j; // j is the maximum, so no need to check the rest break ; } } } return dp[n]; Optimize int s = 0 ; for ( int d = 2 ; d <= n; d ++ ) { while (n % d == 0 ) { s += d; n /= d; } } return s; 279. Perfect Squares \u00b6 Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. dp[i]: min # of perfect squares to form i int numSquares ( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; } 1049. Last Stone Weight II \u00b6 We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 <= stones.length <= 30 1 <= stones[i] <= 100 int lastStoneWeightII (vector < int >& stones) { int n = stones.size(), sum = 0 ; for ( int s : stones) sum += s; vector < bool > dp(sum + 1 , false); dp[ 0 ] = true; for ( int i = 0 ; i < n; ++ i) { for ( int j = sum / 2 ; j >= stones[i]; -- j) dp[j] = dp[j] | dp[j - stones[i]]; } for ( int i = sum / 2 ; i >= 0 ; -- i) if (dp[i]) return sum - i - i; return sum; } 120. Triangle \u00b6 Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i]: min cost from bottom to i-th row int minimumTotal (vector < vector < int >>& triangle) { vector < int > dp(triangle.back()); int n = triangle.size(); for ( int i = n - 2 ; i >= 0 ; -- i) { // rows for ( int j = 0 ; j <= i; ++ j) { // num of elem in each row = i + 1 dp[j] = min(dp[j], dp[j + 1 ]) + triangle[i][j]; // left: dp[j], right: dp[j + 1] } } return dp[ 0 ]; } 474. Ones and Zeroes \u00b6 Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\". Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\". My dp[i][j] means with i zeros and j ones, what is the max strings to be chosen from the strs. In order to calculate it, we find there is a relationship between # of 1 and 0, which is # of 1 + # of 0 = string size, this pattern of constraint usually leads to a knapsack problem. We can visualize it with the problem of knapsack: choose current string means dp[i-# of zero for current string][j - # of one for current string] + 1. not choose current string means dp[i][j] which means there is nothing changed as previous state. Why it has to start from m, n and decrease to 1 (or making sure there is at least # of 0 or 1 spots left in our case)? Because it prevents invalid counting. As we can see, our dp[m][n] is going to be updated sz times, and before we calculate i - zero[k] and j - one[k], they has to be valid. If we start from 0 and increase to m, n, these values will never be updated beforehand. int findMaxForm (vector < string >& strs, int m, int n) { int sz = strs.size(); int one[sz], zero[sz]; for ( int i = 0 ; i < sz; ++ i) { int c1 = 0 , c2 = 0 ; for ( char c : strs[i]) { if (c == '1' ) c2 ++ ; if (c == '0' ) c1 ++ ; } zero[i] = c1, one[i] = c2; } int dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int k = 0 ; k < sz; ++ k) { for ( int i = m; i >= zero[k]; -- i) { for ( int j = n; j >= one[k]; -- j) { dp[i][j] = max(dp[i][j], dp[i - zero[k]][j - one[k]] + 1 ); } } } return dp[m][n]; } Distinct Ways \u00b6 Merging Intervals \u00b6 DP on Strings \u00b6 Decision Making \u00b6","title":"Dp pattern"},{"location":"Leetcode/dp-pattern/#minimum-maximum-path-to-reach-a-target","text":"Given a target find minimum (maximum) cost / path / sum to reach the target.","title":"Minimum (Maximum) Path to Reach a Target"},{"location":"Leetcode/dp-pattern/#746-min-cost-climbing-stairs","text":"On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. dp[i] min cost to reach ith stair. for ( int i = 2 ; i <= n; ++ i) { dp[i] = min(dp[i - 1 ], dp[i - 2 ]) + (i == n ? 0 : cost[i]); // on last step, there is no need to proceed further. } return dp[n] with optimization int p1 = 0 , p2 = 0 ; for ( int i = 2 ; i <= cost.size(); ++ i) { int p = min(p1 + cost[i - 1 ], p2 + cost[i - 2 ]); p2 = p1; p1 = p; } return p1;","title":"746. Min Cost Climbing Stairs"},{"location":"Leetcode/dp-pattern/#64-minimum-path-sum","text":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum. dp[i][j]: min sum to reach x=i,y=j, dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] for ( int i = 1 ; i < n; ++ i) { for ( int j = 1 ; j < m; ++ j) { grid[i][j] = min(grid[i - 1 ][j], grid[i][j - 1 ]) + grid[i][j]; } } return grid[n - 1 ][m - 1 ]","title":"64. Minimum Path Sum"},{"location":"Leetcode/dp-pattern/#322-coin-change","text":"You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin. dp[j]: min # of coins to be used for j amount for ( int j = 1 ; j <= amount; ++ j) { for ( int i = 0 ; i < coins.size(); ++ i) { // try all coins if (coins[i] <= j) { // only try the one that is less than total required dp[j] = min(dp[j], dp[j - coins[i]] + 1 ); } } } return dp[amount];","title":"322. Coin Change"},{"location":"Leetcode/dp-pattern/#why-this-cannot-be-solved-by-greedy-algorithm","text":"Exception: But for some coin sets, there are sums for which the greedy algorithm fails. For example, for the set {1, 15, 25} and the sum 30, the greedy algorithm first chooses 25, leaving a remainder of 5, and then five 1s for a total of six coins. But the solution with the minimal number of coins is to choose 15 twice. In any case where there is no coin whose value, when added to the lowest denomination, is lower than twice that of the denomination immediately less than it, the greedy algorithm works. i.e. {1,2,3} works because [1,3] and [2,2] add to the same value however {1, 15, 25} doesn't work because (for the change 30) 15+15>25+1","title":"Why this cannot be solved by greedy algorithm?"},{"location":"Leetcode/dp-pattern/#931-minimum-falling-path-sum","text":"Given a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. A[i][j]: min sum from all upper level to current level i and position j, to get the ans, just find the min on the last row int minFallingPathSum (vector < vector < int >>& A) { int m = A.size(), n = A[ 0 ].size(); int res = INT_MAX; for ( int i = 1 ; i < m; ++ i) { for ( int j = 0 ; j < n; ++ j) { A[i][j] += min( {A[i - 1 ][j], A[i - 1 ][max( 0 , j - 1 )], A[i - 1 ][min(m - 1 , j + 1 )]}); } } for ( int i = 0 ; i < n; ++ i) res = min(res, A[m - 1 ][i]); return res; }","title":"931. Minimum Falling Path Sum"},{"location":"Leetcode/dp-pattern/#983-minimum-cost-for-tickets","text":"In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel. Note: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 dp[i]: min cost for ith day. Note: if there is no travel plan, the cost will stay the same as the i-1 th day. int mincostTickets (vector < int >& days, vector < int >& costs) { unordered_set < int > travel(begin(days), end(days)); int dp[ 366 ] = {}; for ( int i = 1 ; i < 366 ; ++ i) { if (travel.find(i) == travel.end()) dp[i] = dp[i - 1 ]; else dp[i] = min({ dp[i - 1 ] + costs[ 0 ], dp[max( 0 , i - 7 )] + costs[ 1 ], dp[max( 0 , i - 30 )] + costs[ 2 ]}); } return dp[ 365 ]; }","title":"983. Minimum Cost For Tickets"},{"location":"Leetcode/dp-pattern/#650-2-keys-keyboard","text":"Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. dp[i]: min steps to get to get i 'A' characters. int dp[n + 1 ]; memset(dp, 0 , sizeof dp); for ( int i = 2 ; i <= n; ++ i) { dp[i] = i; // initially assume copy one and paste one by one for ( int j = i - 1 ; j >= 1 ; -- j) { if (i % j == 0 ) { dp[i] = dp[j] + i / j; // j is the maximum, so no need to check the rest break ; } } } return dp[n]; Optimize int s = 0 ; for ( int d = 2 ; d <= n; d ++ ) { while (n % d == 0 ) { s += d; n /= d; } } return s;","title":"650. 2 Keys Keyboard"},{"location":"Leetcode/dp-pattern/#279-perfect-squares","text":"Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. dp[i]: min # of perfect squares to form i int numSquares ( int n) { int dp[n + 1 ], inf = 0x3f3f3f3f ; memset(dp, inf, sizeof dp); for ( int i = 0 ; i <= n; ++ i) { for ( int j = 1 ; j * j <= i; ++ j) { if (i - j * j >= 0 ) dp[i] = min(dp[i], dp[i - j * j] + 1 ); if (j * j == i) dp[i] = 1 ; } } return dp[n]; }","title":"279. Perfect Squares"},{"location":"Leetcode/dp-pattern/#1049-last-stone-weight-ii","text":"We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 <= stones.length <= 30 1 <= stones[i] <= 100 int lastStoneWeightII (vector < int >& stones) { int n = stones.size(), sum = 0 ; for ( int s : stones) sum += s; vector < bool > dp(sum + 1 , false); dp[ 0 ] = true; for ( int i = 0 ; i < n; ++ i) { for ( int j = sum / 2 ; j >= stones[i]; -- j) dp[j] = dp[j] | dp[j - stones[i]]; } for ( int i = sum / 2 ; i >= 0 ; -- i) if (dp[i]) return sum - i - i; return sum; }","title":"1049. Last Stone Weight II"},{"location":"Leetcode/dp-pattern/#120-triangle","text":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. dp[i]: min cost from bottom to i-th row int minimumTotal (vector < vector < int >>& triangle) { vector < int > dp(triangle.back()); int n = triangle.size(); for ( int i = n - 2 ; i >= 0 ; -- i) { // rows for ( int j = 0 ; j <= i; ++ j) { // num of elem in each row = i + 1 dp[j] = min(dp[j], dp[j + 1 ]) + triangle[i][j]; // left: dp[j], right: dp[j + 1] } } return dp[ 0 ]; }","title":"120. Triangle"},{"location":"Leetcode/dp-pattern/#474-ones-and-zeroes","text":"Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Example 1: Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3 Output: 4 Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\". Example 2: Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1 Output: 2 Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\". My dp[i][j] means with i zeros and j ones, what is the max strings to be chosen from the strs. In order to calculate it, we find there is a relationship between # of 1 and 0, which is # of 1 + # of 0 = string size, this pattern of constraint usually leads to a knapsack problem. We can visualize it with the problem of knapsack: choose current string means dp[i-# of zero for current string][j - # of one for current string] + 1. not choose current string means dp[i][j] which means there is nothing changed as previous state. Why it has to start from m, n and decrease to 1 (or making sure there is at least # of 0 or 1 spots left in our case)? Because it prevents invalid counting. As we can see, our dp[m][n] is going to be updated sz times, and before we calculate i - zero[k] and j - one[k], they has to be valid. If we start from 0 and increase to m, n, these values will never be updated beforehand. int findMaxForm (vector < string >& strs, int m, int n) { int sz = strs.size(); int one[sz], zero[sz]; for ( int i = 0 ; i < sz; ++ i) { int c1 = 0 , c2 = 0 ; for ( char c : strs[i]) { if (c == '1' ) c2 ++ ; if (c == '0' ) c1 ++ ; } zero[i] = c1, one[i] = c2; } int dp[m + 1 ][n + 1 ]; memset(dp, 0 , sizeof dp); for ( int k = 0 ; k < sz; ++ k) { for ( int i = m; i >= zero[k]; -- i) { for ( int j = n; j >= one[k]; -- j) { dp[i][j] = max(dp[i][j], dp[i - zero[k]][j - one[k]] + 1 ); } } } return dp[m][n]; }","title":"474. Ones and Zeroes"},{"location":"Leetcode/dp-pattern/#distinct-ways","text":"","title":"Distinct Ways"},{"location":"Leetcode/dp-pattern/#merging-intervals","text":"","title":"Merging Intervals"},{"location":"Leetcode/dp-pattern/#dp-on-strings","text":"","title":"DP on Strings"},{"location":"Leetcode/dp-pattern/#decision-making","text":"","title":"Decision Making"},{"location":"LibreOJ/10000/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 1\u300d\u6d3b\u52a8\u5b89\u6392 https://loj.ac/problem/10000 Analysis \u00b6 \u7c7b\u4f3ccourse schedule, O(n\\log(n)) O(n\\log(n)) Code \u00b6 /* * \u6d3b\u52a8\u5b89\u6392.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; pair < int , int > arr[ 1010 ]; int main ( int argc, char * argv[]) { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> arr[i].second >> arr[i].first; } sort(arr, arr + n); int start = - 1 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (arr[i].second >= start) { // find new end time start = arr[i].first; ++ res; } } cout << res; return 0 ; }","title":"10000"},{"location":"LibreOJ/10000/#analysis","text":"\u7c7b\u4f3ccourse schedule, O(n\\log(n)) O(n\\log(n))","title":"Analysis"},{"location":"LibreOJ/10000/#code","text":"/* * \u6d3b\u52a8\u5b89\u6392.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; pair < int , int > arr[ 1010 ]; int main ( int argc, char * argv[]) { int n; cin >> n; for ( int i = 0 ; i < n; ++ i) { cin >> arr[i].second >> arr[i].first; } sort(arr, arr + n); int start = - 1 , res = 0 ; for ( int i = 0 ; i < n; ++ i) { if (arr[i].second >= start) { // find new end time start = arr[i].first; ++ res; } } cout << res; return 0 ; }","title":"Code"},{"location":"LibreOJ/10001/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 2\u300d\u79cd\u6811 https://loj.ac/problem/10001 Analysis \u00b6 \u4ece\u524d\u5f80\u540e\u79cd\u6811\uff0c\u5982\u679c\u4e4b\u524d\u79cd\u8fc7\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5skip\u6389\u3002\u5982\u679c\u8fd8\u6709\u8981\u6c42\u6ca1\u6709\u8fbe\u6210\uff0c\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u7ee7\u7eed\u904d\u5386\uff0c\u6dfb\u52a0\u672a\u79cd\u7684\u5730\u65b9\u3002 e.g. x01000x010100101001 \u5728x x\u4e2d\u9700\u8981\u79cd\u4e09\u9897\u6811\uff1ab = 0, e = 5, t = 3 x01011x010100101001 b = 1, e = 6, t = 4 0x10110x10100101001 Time: O(h \\times max(e - a)) O(h \\times max(e - a)) Code \u00b6 /* * \u79cd\u6811.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; struct line { int b, e, t; } a[ 5010 ]; bool used[ 30010 ]; int main ( int argc, char * argv[]) { int n, h; cin >> n >> h; for ( int i = 0 ; i < h; ++ i) { cin >> a[i].b >> a[i].e >> a[i].t; } sort(a, a + h, []( const line & l, const line & r) { return l.e < r.e; }); // sort by finish time int res = 0 ; for ( int i = 0 ; i < h; ++ i) { int cnt = 0 ; for ( int j = a[i].b; j <= a[i].e; ++ j) { // first check if already satified if (used[j]) cnt ++ ; } if (cnt < a[i].t) { for ( int j = a[i].e; j >= a[i].b && cnt < a[i].t; -- j) { if ( ! used[j]) { used[j] = 1 ; cnt ++ ; res ++ ; } } } } cout << res; return 0 ; }","title":"10001"},{"location":"LibreOJ/10001/#analysis","text":"\u4ece\u524d\u5f80\u540e\u79cd\u6811\uff0c\u5982\u679c\u4e4b\u524d\u79cd\u8fc7\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5skip\u6389\u3002\u5982\u679c\u8fd8\u6709\u8981\u6c42\u6ca1\u6709\u8fbe\u6210\uff0c\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u7ee7\u7eed\u904d\u5386\uff0c\u6dfb\u52a0\u672a\u79cd\u7684\u5730\u65b9\u3002 e.g. x01000x010100101001 \u5728x x\u4e2d\u9700\u8981\u79cd\u4e09\u9897\u6811\uff1ab = 0, e = 5, t = 3 x01011x010100101001 b = 1, e = 6, t = 4 0x10110x10100101001 Time: O(h \\times max(e - a)) O(h \\times max(e - a))","title":"Analysis"},{"location":"LibreOJ/10001/#code","text":"/* * \u79cd\u6811.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; struct line { int b, e, t; } a[ 5010 ]; bool used[ 30010 ]; int main ( int argc, char * argv[]) { int n, h; cin >> n >> h; for ( int i = 0 ; i < h; ++ i) { cin >> a[i].b >> a[i].e >> a[i].t; } sort(a, a + h, []( const line & l, const line & r) { return l.e < r.e; }); // sort by finish time int res = 0 ; for ( int i = 0 ; i < h; ++ i) { int cnt = 0 ; for ( int j = a[i].b; j <= a[i].e; ++ j) { // first check if already satified if (used[j]) cnt ++ ; } if (cnt < a[i].t) { for ( int j = a[i].e; j >= a[i].b && cnt < a[i].t; -- j) { if ( ! used[j]) { used[j] = 1 ; cnt ++ ; res ++ ; } } } } cout << res; return 0 ; }","title":"Code"},{"location":"LibreOJ/10002/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 3\u300d\u55b7\u6c34\u88c5\u7f6e https://loj.ac/problem/10002 Analysis \u00b6 \u6bcf\u6b21\u8bb0\u5f55\u4e2d\u5fc3\u70b9\u7684\u4e24\u7aef\uff0c\u4e24\u7aef\u53ea\u80fd\u53d6\u84dd\u8272\u7684\u957f\u5ea6\uff0c\u56e0\u4e3a\u53ea\u6709\u84dd\u8272\u957f\u5ea6\u624d\u53ef\u4ee5\u4fdd\u8bc1\u6240\u6709\u7684\u70b9\u4ece\u4e2d\u5fc3\u70b9\u5230\u7ec8\u70b9\u662f\u5b8c\u5168cover\u5230\u7684\u3002\u7136\u540e\u6839\u636e\u5de6\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u6bcf\u6b21greedy\u53d6\u53ef\u4ee5cover\u5230\u7684\u6700\u53f3\u70b9\uff0c\u5f53\u53ef\u4ee5\u53d6\u5230\u7684\u6700\u53f3\u70b9\u6bd4\u5f53\u524d\u7684\u9762\u79ef\u7684\u957f\u5ea6\u8981\u5927\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4fbf\u505c\u6b62\u3002 Code \u00b6 /* * \u55b7\u6c34\u88c5\u7f6e.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int maxn = 2e4 + 5 ; int cnt; int n, L, W; struct line { double x, y; }; line lines[maxn]; bool cmp (line a, line b) { return a.x < b.x; } void read () { cin >> n >> L >> W; cnt = 0 ; int x, r; for ( int i = 1 ; i <= n; i ++ ) { cin >> x >> r; if (r <= W / 2 ) continue ; // skip if height cannot cover cnt ++ ; double len = sqrt(r * r - W * W / 4.0 ); // blue len lines[cnt].x = x - len; lines[cnt].y = x + len; } } void work () { sort(lines + 1 , lines + cnt + 1 , cmp); double last = 0 ; int ans = 0 ; while (last < L) { ans ++ ; double s = last; for ( int i = 1 ; i <= cnt; i ++ ) { if (lines[i].x <= s) { last = max(last, lines[i].y); } else { break ; } } if (last == s && s < L) { cout << - 1 << endl; return ; } } cout << ans << endl; } int main () { int k; cin >> k; for ( int j = 0 ; j < k; j ++ ) { read(); work(); } return 0 ; }","title":"10002"},{"location":"LibreOJ/10002/#analysis","text":"\u6bcf\u6b21\u8bb0\u5f55\u4e2d\u5fc3\u70b9\u7684\u4e24\u7aef\uff0c\u4e24\u7aef\u53ea\u80fd\u53d6\u84dd\u8272\u7684\u957f\u5ea6\uff0c\u56e0\u4e3a\u53ea\u6709\u84dd\u8272\u957f\u5ea6\u624d\u53ef\u4ee5\u4fdd\u8bc1\u6240\u6709\u7684\u70b9\u4ece\u4e2d\u5fc3\u70b9\u5230\u7ec8\u70b9\u662f\u5b8c\u5168cover\u5230\u7684\u3002\u7136\u540e\u6839\u636e\u5de6\u70b9\u6392\u5e8f\uff08\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u6bcf\u6b21greedy\u53d6\u53ef\u4ee5cover\u5230\u7684\u6700\u53f3\u70b9\uff0c\u5f53\u53ef\u4ee5\u53d6\u5230\u7684\u6700\u53f3\u70b9\u6bd4\u5f53\u524d\u7684\u9762\u79ef\u7684\u957f\u5ea6\u8981\u5927\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4fbf\u505c\u6b62\u3002","title":"Analysis"},{"location":"LibreOJ/10002/#code","text":"/* * \u55b7\u6c34\u88c5\u7f6e.cpp * Copyright (C) 2020 Haoyang <peter@peterchen.xyz> * * Distributed under terms of the MIT license. */ #include <bits/stdc++.h> using namespace std; const int maxn = 2e4 + 5 ; int cnt; int n, L, W; struct line { double x, y; }; line lines[maxn]; bool cmp (line a, line b) { return a.x < b.x; } void read () { cin >> n >> L >> W; cnt = 0 ; int x, r; for ( int i = 1 ; i <= n; i ++ ) { cin >> x >> r; if (r <= W / 2 ) continue ; // skip if height cannot cover cnt ++ ; double len = sqrt(r * r - W * W / 4.0 ); // blue len lines[cnt].x = x - len; lines[cnt].y = x + len; } } void work () { sort(lines + 1 , lines + cnt + 1 , cmp); double last = 0 ; int ans = 0 ; while (last < L) { ans ++ ; double s = last; for ( int i = 1 ; i <= cnt; i ++ ) { if (lines[i].x <= s) { last = max(last, lines[i].y); } else { break ; } } if (last == s && s < L) { cout << - 1 << endl; return ; } } cout << ans << endl; } int main () { int k; cin >> k; for ( int j = 0 ; j < k; j ++ ) { read(); work(); } return 0 ; }","title":"Code"},{"location":"LibreOJ/10003/","text":"\u300c\u4e00\u672c\u901a 1.1 \u4f8b 4\u300d\u52a0\u5de5\u751f\u4ea7\u8c03\u5ea6 https://loj.ac/problem/10003 Analysis \u00b6 \u56e0\u4e3aB\u4e00\u5b9a\u8981\u5728A\u4e4b\u540e\u624d\u53ef\u4ee5\u8fdb\u884c\uff0c\u6240\u4ee5\u603b\u65f6\u95f4\u6700\u5c0f\u7684\u8bdd\u8981\u5148\u628a\u9700\u8981A\u548c\u9700\u8981B\u7684\u5c0f\u7684\u65f6\u95f4\u653e\u5230\u6700\u524d\u9762\uff0c\u7136\u540e\u4f7f\u7528\u53cc\u6307\u9488\uff1a \u5982\u679c\u662fA\u90a3\u4e48\u4ece\u524d\u5f80\u540e\u6392\u5e8f \u5982\u679c\u662fB\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u6392\u5e8f Code \u00b6 #include <bits/stdc++.h> using namespace std; struct point { int i, minn, x, y; }; point a[ 1010 ]; int ans[ 1010 ]; const int inf = 0x3f3f3f3f ; int main () { int n; cin >> n; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].x; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].y; for ( int i = 1 ; i <= n; ++ i) { a[i].minn = min(a[i].x, a[i].y); // find the min a[i].i = i; } sort(a + 1 , a + n + 1 , []( const point & l, const point & r) { return l.minn < r.minn; }); int x = 1 , y = n; for ( int i = 1 ; i <= n; ++ i) { if (a[i].minn == a[i].x) // A should finish first ans[x ++ ] = a[i].i; else ans[y -- ] = a[i].i; } int timea = 0 , timeb = 0 , mina = inf, minb = inf; for ( int i = 1 ; i <= n; ++ i) { timea += a[i].x; timeb += a[i].y; mina = min(mina, a[i].x); minb = min(minb, a[i].y); } cout << max(timea + minb, timeb + mina) << endl; for ( int i = 1 ; i <= n; ++ i) cout << ans[i] << \" \" ; return 0 ; }","title":"10003"},{"location":"LibreOJ/10003/#analysis","text":"\u56e0\u4e3aB\u4e00\u5b9a\u8981\u5728A\u4e4b\u540e\u624d\u53ef\u4ee5\u8fdb\u884c\uff0c\u6240\u4ee5\u603b\u65f6\u95f4\u6700\u5c0f\u7684\u8bdd\u8981\u5148\u628a\u9700\u8981A\u548c\u9700\u8981B\u7684\u5c0f\u7684\u65f6\u95f4\u653e\u5230\u6700\u524d\u9762\uff0c\u7136\u540e\u4f7f\u7528\u53cc\u6307\u9488\uff1a \u5982\u679c\u662fA\u90a3\u4e48\u4ece\u524d\u5f80\u540e\u6392\u5e8f \u5982\u679c\u662fB\u90a3\u4e48\u4ece\u540e\u5f80\u524d\u6392\u5e8f","title":"Analysis"},{"location":"LibreOJ/10003/#code","text":"#include <bits/stdc++.h> using namespace std; struct point { int i, minn, x, y; }; point a[ 1010 ]; int ans[ 1010 ]; const int inf = 0x3f3f3f3f ; int main () { int n; cin >> n; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].x; for ( int i = 1 ; i <= n; ++ i) cin >> a[i].y; for ( int i = 1 ; i <= n; ++ i) { a[i].minn = min(a[i].x, a[i].y); // find the min a[i].i = i; } sort(a + 1 , a + n + 1 , []( const point & l, const point & r) { return l.minn < r.minn; }); int x = 1 , y = n; for ( int i = 1 ; i <= n; ++ i) { if (a[i].minn == a[i].x) // A should finish first ans[x ++ ] = a[i].i; else ans[y -- ] = a[i].i; } int timea = 0 , timeb = 0 , mina = inf, minb = inf; for ( int i = 1 ; i <= n; ++ i) { timea += a[i].x; timeb += a[i].y; mina = min(mina, a[i].x); minb = min(minb, a[i].y); } cout << max(timea + minb, timeb + mina) << endl; for ( int i = 1 ; i <= n; ++ i) cout << ans[i] << \" \" ; return 0 ; }","title":"Code"},{"location":"Python/class/","text":"del modname . the_answer # delete the attribute >>> class Complex: ... def __init__(self, realpart, imagpart) : ... self.r = realpart ... self.i = imagpart ... >>> x = Complex( 3.0 , - 4.5 ) >>> x.r, x.i ( 3.0 , - 4.5 )","title":"Class"},{"location":"Python/invoke-main/","text":"if __name__ == \"__main__\" : # execute only if run as a script main()","title":"Invoke main"},{"location":"Python/misc/","text":"Invoke Main \u00b6 if __name__ == \"__main__\" : # execute only if run as a script main () Initialize fix size list \u00b6 >>> lst = [ None ] * 5 >>> lst [ None , None , None , None , None ] for(int i = len; i >= 0; --i) \u00b6 range(10, 0, -1) Which gives [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]","title":"Misc"},{"location":"Python/misc/#invoke-main","text":"if __name__ == \"__main__\" : # execute only if run as a script main ()","title":"Invoke Main"},{"location":"Python/misc/#initialize-fix-size-list","text":">>> lst = [ None ] * 5 >>> lst [ None , None , None , None , None ]","title":"Initialize fix size list"},{"location":"Python/misc/#forint-i-len-i-0-i","text":"range(10, 0, -1) Which gives [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]","title":"for(int i = len; i &gt;= 0; --i)"},{"location":"c/malloc-lab/","text":"/* single word (4) or double word (8) alignment */ #define ALIGNMENT 8 /* rounds up to the nearest multiple of ALIGNMENT */ #define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7) #define INITCHUNKSIZE (1<<6) #define LISTLIMIT 20 #define REALLOC_BUFFER (1<<7)","title":"Malloc lab"},{"location":"c/misc/","text":"mod \u00b6 1024 % 10 ; // = 4 - 1024 % 10 ; //-4 inf \u00b6 use 0x3f3f3f3f if there is a need to do addition else use 0x7fffffff Tuple \u00b6 // packing/unpacking tuples #include <iostream> // std::cout #include <tuple> // std::tuple, std::make_tuple, std::tie int main () { int myint; char mychar; std :: tuple < int , float , char > mytuple; mytuple = std :: make_tuple ( 10 , 2.6 , 'a' ); // packing values into tuple std :: tie (myint, std :: ignore, mychar) = mytuple; // unpacking tuple into variables std :: cout << \"myint contains: \" << myint << '\\n' ; std :: cout << \"mychar contains: \" << mychar << '\\n' ; return 0 ; } Operator \u00b6 &: left & right in compiler doesn't have fix order (either left to right or right to left) : neg divide isn't right -> e.g. -3 / 2 = 101 >> 1 = 110 = -2 which is wrong set kth bit to zero: x & ~(1 << k)","title":"Misc"},{"location":"c/misc/#mod","text":"1024 % 10 ; // = 4 - 1024 % 10 ; //-4","title":"mod"},{"location":"c/misc/#inf","text":"use 0x3f3f3f3f if there is a need to do addition else use 0x7fffffff","title":"inf"},{"location":"c/misc/#tuple","text":"// packing/unpacking tuples #include <iostream> // std::cout #include <tuple> // std::tuple, std::make_tuple, std::tie int main () { int myint; char mychar; std :: tuple < int , float , char > mytuple; mytuple = std :: make_tuple ( 10 , 2.6 , 'a' ); // packing values into tuple std :: tie (myint, std :: ignore, mychar) = mytuple; // unpacking tuple into variables std :: cout << \"myint contains: \" << myint << '\\n' ; std :: cout << \"mychar contains: \" << mychar << '\\n' ; return 0 ; }","title":"Tuple"},{"location":"c/misc/#operator","text":"&: left & right in compiler doesn't have fix order (either left to right or right to left) : neg divide isn't right -> e.g. -3 / 2 = 101 >> 1 = 110 = -2 which is wrong set kth bit to zero: x & ~(1 << k)","title":"Operator"},{"location":"c/parse-string-to-int/","text":"use atoi(s.c_str()); because it can handle leading zero (drop it). what it does is convert the s to char*.","title":"Parse string to int"},{"location":"c/stl-complexity/","text":"String \u00b6 substr Space: O(n) O(n) , Time: O(n) O(n) \u00b6 s.substr(pos, n) Return a string containing n characters from s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos. string s ( \"hello world\" ); string s2 = s.substr( 0 , 5 ); // s2 = hello string s3 = s.substr( 6 ); // s3 = world string s4 = s.substr( 6 , 11 ); // s4 = world string s5 = s.substr( 12 ); // throws an out_of_range exception","title":"Stl complexity"},{"location":"c/stl-complexity/#string","text":"","title":"String"},{"location":"c/stl-complexity/#substr-space-onon-time-onon","text":"s.substr(pos, n) Return a string containing n characters from s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos. string s ( \"hello world\" ); string s2 = s.substr( 0 , 5 ); // s2 = hello string s3 = s.substr( 6 ); // s3 = world string s4 = s.substr( 6 , 11 ); // s4 = world string s5 = s.substr( 12 ); // throws an out_of_range exception","title":"substr Space: O(n)O(n), Time: O(n)O(n)"},{"location":"iOS/dialog-flow/","text":"For chat bot \u00b6 with Apple ARKit","title":"Dialog flow"},{"location":"iOS/dialog-flow/#for-chat-bot","text":"with Apple ARKit","title":"For chat bot"},{"location":"iOS/exam-ii-review-part-one/","text":"Gesture \u00b6 Tap Double Tap Drag Flick Pinch Spread Press Press and tap Add gesture recognizer in code Single Tap // ViewController.m: Single Tap - ( void ) viewDidLoad { [super viewDidLoad]; UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; /* if double click doubleTap.numberOfTapsRequired = 2; */ [self.view addGestureRecognizer:singleTap]; } - ( void ) singleTapRecognized: (UITapGestureRecognizer * ) recognizer { self.msgLabel.text = @\"You single tapped me!\" ; } Single & Double Tap // double tap UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; [self.view addGestureRecognizer: singleTap]; UITapGestureRecognizer * doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (doubleTapRecognized:)]; doubleTap.numberOfTapsRequired = 2 ; [self.view addGestureRecognizer: doubleTap]; // Only recognize single taps if they're not the first of two [singleTap requireGestureRecognizerToFail: doubleTap]; Swipe: should add left and right separately UISwipeGestureRecognizer * swipeLeft = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeLeft.direction = UISwipeGestureRecognizerDirectionLeft; [self.view addGestureRecognizer:swipeLeft]; UISwipeGestureRecognizer * swipeRight = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeRight.direction = UISwipeGestureRecognizerDirectionRight; [self.view addGestureRecognizer:swipeRight]; Selector * accept a method name * not explicit call Animation: Core Animation \u00b6 View Properties * frame (position and size) * transform * alpha (transparency) * color * background color Block properties 1. can be pass around to methods or functions as if they were values. 2. is OC object, so can be added to collections like NSArray or NSDictionary 3. capture values from enclosing scope 4. used for callback function: code to be exec when finish task Syntax ^ { NSLog( @\"This is a block\" ); } int multiplier = 7 ; int ( ^ myBlock)( int ) = ^ ( int num) { return num * multiplier; } fade-in example - ( void ) fadeInStudent: (NSString * ) name{ // Alpha = 0 means the text is transparent self.nameLabel.alpha = 0 ; self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { // Fade in the text of the label self.nameLabel.alpha = 1 ; }]; } more examples: // fade in nameLabel - ( void ) animateStudent: (NSString * )name{ self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { self.nameLabel.alpha = 1 ; }]; } // fade out then fade in - ( void ) displayStudent: (NSString * )name{ [UIView animateWithDuration: 1.0 animations: ^ { // Fade out old text of label self.nameLabel.alpha = 0 ; } completion: ^ ( BOOL finished) { // Upon completion, call animateStudent [self animateStudent:name]; }]; } Accelerometer Gyroscope \u00b6 Motion Events * move * shake * tilt the device Some Properties* 1. made up of three accelerometers 2. give measurements in g-forces * no movement -- 1g 3. Shake: UIEvent 4. General Orientation: UIDevice 5. Cancel a motion event: An event is canceled if the shake motion is interrupted or if iOS determines that the motion is not valid after all \u2013 for example, if the shaking lasts too long. Use motionCancelled:withEvent:*** Handle Shake Event - ( BOOL ) canBecomeFirstResponder { return YES; } - ( void ) viewDidAppear: ( BOOL )animated{ [super viewDidAppear:animated]; [self becomeFirstResponder]; } - ( void ) motionEnded: (UIEventSubtype)motion withEvent: (UIEvent * )event{ if (motion == UIEventSubtypeMotionShake){ NSLog( @\"You shook me!\" ); } } Responding Changes in Orientation - ( void ) viewDidLoad { // Request to turn on accelerometer and begin receiving accelerometer events [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[NSNotificationCenter defaultCenter] addObserver:self selector: @selector (orientationChanged:) name:UIDeviceOrientationDidChangeNotification object:nil]; } - ( void ) orientationChanged: (NSNotification * ) notification{ // Respond to changes in device orientation UIDeviceOrientation currentOrientation = [[UIDevice currentDevice] orientation]; } - ( void ) viewDidDisappear: ( BOOL )animated{ // Request to stop receiving accelerometer events and turn off accelerometer [[NSNotificationCenter defaultCenter] removeObserver:self]; [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; } CMMotionManager obtain data * Pull: An app requests that updates start and then periodically samples the most recent measurement of motion data. * Push: An app specifies an update interval and implements a block for handling the data. Then, it requests that updates start, and passes Core Motion an operation queue and the block. Core Motion delivers each update to the block, which executes as a task in the operation queue. Pull is the recommended approach for most apps, especially games. It is generally more efficient and requires less code. Push is appropriate for data-collection apps and similar apps that cannot miss a single sample measurement. startDeviceMotionUpdates \u2013 the pull approach * After you call this method, Core Motion continuously updates the deviceMotion property of CMMotionManager with the latest refined measurements of accelerometer and gyroscope activity, as encapsulated in a CMDeviceMotion object. startDeviceMotionUpdatesToQueue:withHandler: \u2013 the push approach * Before you call this method, assign an update interval to the deviceMotionUpdateInterval property, create an instance of NSOperationQueue , and implement a block of the CMDeviceMotionHandler type that handles the accelerometer updates. * Then, call the startDeviceMotionUpdatesToQueue: withHandler: method on the motion-manager object, passing in the operation queue and the block. Audio \u00b6 File Formats (audio container) and Data Format (audio encoding) * AAC, HE-AAC, AMR, ALAC, iLBC, iMA4...: df * If space is not an issue, just encode everything with linear PCM. * Not only is this the fastest way for your audio to play, but you can play multiple sounds simultaneously without running into any CPU resource issues. * If space is an issue, most likely you\u2019ll want to use AAC encoding for your background music and IMA4 encoding for your sound effects. Bit Rate * When you lower the bytes per second, you lose quality as well. * If your file is mostly speech, you can probably get away with a lower bit rate. Sample Rates * usually 44,100Hz, because it's the same for CD audio. Audio Session * Playback is enabled and recording is disabled. \u2013 When the user moves the Silent switch (or Ring/Silent switch on iPhone) to the \u201csilent\u201d position, your audio is silenced. \u2013 When the user presses the Sleep/Wake button to lock the screen, or when the Auto-Lock period expires, your audio is silenced. \u2013 When your audio starts, other audio on the device \u2013 such as iPod audio that was already playing \u2013 is silenced. System Sound Service * System Sound Services is intended for user-interface sound effects and user alerts \u2013 It is not intended for sound effects in games * Alert sounds work best when kept short \u2013 According to Apple, preferably 2 seconds or less AVAudioPlayer * Play background music * Extremely slow: will be a noticeable delay * If play in bg, check no other sound is playing to prevent two layers of musics going at once * Phone call will interrupt the music Add Audio Framework * Add AudioToolbox.framework in project targets * Import // QuoteViewController.m #import <AudioToolbox/AudioToolbox.h> #import \"QuoteViewController.h\" @interface QuoteViewController () @property ( readonly ) SystemSoundID soundFileID; Examples Setup for Sound // QuoteViewController.m NSString * soundFilePath = [[NSBundle mainBundle] pathForResource: @\"Tada\" ofType: @\"wav\" ]; NSURL * soundURL = [NSURL fileURLWithPath:soundFilePath]; AudioServicesCreateSystemSoundID(( __bridge CFURLRef _Nonnull)(soundURL), & _soundFileID); // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play sound file AudioServicesPlaySystemSound(self.soundFileID); [self displayQuote:[self.model randomQuote]]; } Setup for Vibration // QuoteViewController.m - ( void ) doubleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Vibrate AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); [self displayQuote:[self.model randomQuote]]; } Create property using AVFoundation // QuoteViewController.m #import <AVFoundation/AVFoundation.h> // Other imports\u2026 @interface QuoteViewController () @property ( strong , nonatomic ) AVAudioPlayer * audioPlayer; // QuoteViewController.m NSString * path = [NSString stringWithFormat: @\"%@/tone.mp3\" , [[NSBundle mainBundle] resourcePath]]; NSURL * soundURL = [NSURL fileURLWithPath:path]; NSError * error; self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:soundURL error: & error]; [self.audioPlayer prepareToPlay]; // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play audio [self.audioPlayer play]; [self displayQuote:[self.model randomQuote]]; } Delegates \u00b6 Protocol * Is a declaration of a list of methods * Two kinds of methods: optional and required Delegation * Allow for one to one communication between two instances: the delegate and delegator * Delegator: Instance that send events to delegate * Delegate: Process events sent from the delegator * The delegator is typically a framework object (i.e. textfield, tableview, etc.), and the delegate is typically a custom controller object. Three Steps Processes 1. In your custom class, adopt the delegate's protocol. 2. Implement the appropriate protocol methods. 3. Connect the delegate outlet of the delegator (i.e. textfield, tableview, etc.) to your custom class. Summary * Allowing some objects to be relatively fixed and others highly customized. * Maximum software reuse and MVC design pattern. Demo: or but not both // ViewController.h @interface ViewController < ProtocolName > @end // ViewController.m @interface ViewController () < ProtocolName > @end @implementation ViewController @end Table Views \u00b6 iOS can have an unlimited # of rows iOS tables can only be one col wide Plain Table View * Row seperated into labeled sections and index appears vertically on right (index list) * Header and footer: row are grouped, doesn't include index * Highlight: * In both styles, a table row becomes highlighted briefly when a user taps a selectable item. * If a row selection results in navigation to a new screen, the selected row becomes highlighted briefly as the new screen slides into place. * When the user navigates back to the previous screen, the originally selected row again becomes highlighted briefly to remind the user of the earlier selection (it doesn\u2019t remain highlighted). * Four Predefined Styles 1. UITableViewCellStyleDefault : The default cell style includes an optional image in the left end of the row, followed by a left-aligned title. 2. UITableViewCellStyleSubtitle : The subtitle style includes an optional image in the left end of the row, followed by a left- aligned title on one line and a left- aligned subtitle on the line below. 3. UITableViewCellStyleValue1 : The value 1 style displays a left-aligned title with, on the same line, a rightaligned subtitle in a lighter font. 4. UITableViewCellStyleValue2`: The value 2 style displays a right-aligned title in a blue font, followed on the same line by a left-aligned subtitle in a black font. Images don\u2019t fit well in this style. Reusing Cell * When you call [tableView dequeuereusablecellwithidentifier:] you either: A. Get a cell that has previously been created and isn't currently being used OR B. Create a new cell of the class you specified Examples // ExampleTableViewController.m // Return the number of sections - (NSInteger) numberOfSectionsInTableView: (UITableView * )tableView{ return 1 ; } // Return number of rows in the section - (NSInteger) tableView: (UITableView * )tableView numberOfRowsInSection: (NSInteger)section{ return 100 ; } // Configuring Rows (cell) - (UITableViewCell * ) tableView: (UITableView * )tableView cellForRowAtIndexPath: (NSIndexPath * )indexPath{ static NSString * cellIdentifier = @\"TableCell\" ; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; // Configure the cell cell.textLabel.text = [NSString stringWithFormat: @\"Row %d\" , indexPath.row]; return cell; } Relationships btw View Controllers * If the relationship is a segue , the destination view controller is instantiated when the segue is triggered. * If the relationship represents containment , the child view controller is instantiated when its parent is instantiated. * If the controller is not the destination or child of another controller, it is never instantiated automatically. You must instantiate it from the storyboard programmatically. * Segues: When a segue is triggered, iOS takes the following actions: 1. It instantiates the destination view controller using the attribute values you provided in the storyboard. 2. It gives the source view controller an opportunity to configure the new controller. 3. It performs the transition configured in the segue. * Summary: containment for parent-child connection; segues for two views.","title":"Exam ii review part one"},{"location":"iOS/exam-ii-review-part-one/#gesture","text":"Tap Double Tap Drag Flick Pinch Spread Press Press and tap Add gesture recognizer in code Single Tap // ViewController.m: Single Tap - ( void ) viewDidLoad { [super viewDidLoad]; UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; /* if double click doubleTap.numberOfTapsRequired = 2; */ [self.view addGestureRecognizer:singleTap]; } - ( void ) singleTapRecognized: (UITapGestureRecognizer * ) recognizer { self.msgLabel.text = @\"You single tapped me!\" ; } Single & Double Tap // double tap UITapGestureRecognizer * singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (singleTapRecognized:)]; [self.view addGestureRecognizer: singleTap]; UITapGestureRecognizer * doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action: @selector (doubleTapRecognized:)]; doubleTap.numberOfTapsRequired = 2 ; [self.view addGestureRecognizer: doubleTap]; // Only recognize single taps if they're not the first of two [singleTap requireGestureRecognizerToFail: doubleTap]; Swipe: should add left and right separately UISwipeGestureRecognizer * swipeLeft = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeLeft.direction = UISwipeGestureRecognizerDirectionLeft; [self.view addGestureRecognizer:swipeLeft]; UISwipeGestureRecognizer * swipeRight = [[UISwipeGestureRecognizer alloc] initWithTarget:self action: @selector (swipeGestureRecognized:)]; swipeRight.direction = UISwipeGestureRecognizerDirectionRight; [self.view addGestureRecognizer:swipeRight]; Selector * accept a method name * not explicit call","title":"Gesture"},{"location":"iOS/exam-ii-review-part-one/#animation-core-animation","text":"View Properties * frame (position and size) * transform * alpha (transparency) * color * background color Block properties 1. can be pass around to methods or functions as if they were values. 2. is OC object, so can be added to collections like NSArray or NSDictionary 3. capture values from enclosing scope 4. used for callback function: code to be exec when finish task Syntax ^ { NSLog( @\"This is a block\" ); } int multiplier = 7 ; int ( ^ myBlock)( int ) = ^ ( int num) { return num * multiplier; } fade-in example - ( void ) fadeInStudent: (NSString * ) name{ // Alpha = 0 means the text is transparent self.nameLabel.alpha = 0 ; self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { // Fade in the text of the label self.nameLabel.alpha = 1 ; }]; } more examples: // fade in nameLabel - ( void ) animateStudent: (NSString * )name{ self.nameLabel.text = name; [UIView animateWithDuration: 1.0 animations: ^ { self.nameLabel.alpha = 1 ; }]; } // fade out then fade in - ( void ) displayStudent: (NSString * )name{ [UIView animateWithDuration: 1.0 animations: ^ { // Fade out old text of label self.nameLabel.alpha = 0 ; } completion: ^ ( BOOL finished) { // Upon completion, call animateStudent [self animateStudent:name]; }]; }","title":"Animation: Core Animation"},{"location":"iOS/exam-ii-review-part-one/#accelerometer-gyroscope","text":"Motion Events * move * shake * tilt the device Some Properties* 1. made up of three accelerometers 2. give measurements in g-forces * no movement -- 1g 3. Shake: UIEvent 4. General Orientation: UIDevice 5. Cancel a motion event: An event is canceled if the shake motion is interrupted or if iOS determines that the motion is not valid after all \u2013 for example, if the shaking lasts too long. Use motionCancelled:withEvent:*** Handle Shake Event - ( BOOL ) canBecomeFirstResponder { return YES; } - ( void ) viewDidAppear: ( BOOL )animated{ [super viewDidAppear:animated]; [self becomeFirstResponder]; } - ( void ) motionEnded: (UIEventSubtype)motion withEvent: (UIEvent * )event{ if (motion == UIEventSubtypeMotionShake){ NSLog( @\"You shook me!\" ); } } Responding Changes in Orientation - ( void ) viewDidLoad { // Request to turn on accelerometer and begin receiving accelerometer events [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications]; [[NSNotificationCenter defaultCenter] addObserver:self selector: @selector (orientationChanged:) name:UIDeviceOrientationDidChangeNotification object:nil]; } - ( void ) orientationChanged: (NSNotification * ) notification{ // Respond to changes in device orientation UIDeviceOrientation currentOrientation = [[UIDevice currentDevice] orientation]; } - ( void ) viewDidDisappear: ( BOOL )animated{ // Request to stop receiving accelerometer events and turn off accelerometer [[NSNotificationCenter defaultCenter] removeObserver:self]; [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications]; } CMMotionManager obtain data * Pull: An app requests that updates start and then periodically samples the most recent measurement of motion data. * Push: An app specifies an update interval and implements a block for handling the data. Then, it requests that updates start, and passes Core Motion an operation queue and the block. Core Motion delivers each update to the block, which executes as a task in the operation queue. Pull is the recommended approach for most apps, especially games. It is generally more efficient and requires less code. Push is appropriate for data-collection apps and similar apps that cannot miss a single sample measurement. startDeviceMotionUpdates \u2013 the pull approach * After you call this method, Core Motion continuously updates the deviceMotion property of CMMotionManager with the latest refined measurements of accelerometer and gyroscope activity, as encapsulated in a CMDeviceMotion object. startDeviceMotionUpdatesToQueue:withHandler: \u2013 the push approach * Before you call this method, assign an update interval to the deviceMotionUpdateInterval property, create an instance of NSOperationQueue , and implement a block of the CMDeviceMotionHandler type that handles the accelerometer updates. * Then, call the startDeviceMotionUpdatesToQueue: withHandler: method on the motion-manager object, passing in the operation queue and the block.","title":"Accelerometer Gyroscope"},{"location":"iOS/exam-ii-review-part-one/#audio","text":"File Formats (audio container) and Data Format (audio encoding) * AAC, HE-AAC, AMR, ALAC, iLBC, iMA4...: df * If space is not an issue, just encode everything with linear PCM. * Not only is this the fastest way for your audio to play, but you can play multiple sounds simultaneously without running into any CPU resource issues. * If space is an issue, most likely you\u2019ll want to use AAC encoding for your background music and IMA4 encoding for your sound effects. Bit Rate * When you lower the bytes per second, you lose quality as well. * If your file is mostly speech, you can probably get away with a lower bit rate. Sample Rates * usually 44,100Hz, because it's the same for CD audio. Audio Session * Playback is enabled and recording is disabled. \u2013 When the user moves the Silent switch (or Ring/Silent switch on iPhone) to the \u201csilent\u201d position, your audio is silenced. \u2013 When the user presses the Sleep/Wake button to lock the screen, or when the Auto-Lock period expires, your audio is silenced. \u2013 When your audio starts, other audio on the device \u2013 such as iPod audio that was already playing \u2013 is silenced. System Sound Service * System Sound Services is intended for user-interface sound effects and user alerts \u2013 It is not intended for sound effects in games * Alert sounds work best when kept short \u2013 According to Apple, preferably 2 seconds or less AVAudioPlayer * Play background music * Extremely slow: will be a noticeable delay * If play in bg, check no other sound is playing to prevent two layers of musics going at once * Phone call will interrupt the music Add Audio Framework * Add AudioToolbox.framework in project targets * Import // QuoteViewController.m #import <AudioToolbox/AudioToolbox.h> #import \"QuoteViewController.h\" @interface QuoteViewController () @property ( readonly ) SystemSoundID soundFileID; Examples Setup for Sound // QuoteViewController.m NSString * soundFilePath = [[NSBundle mainBundle] pathForResource: @\"Tada\" ofType: @\"wav\" ]; NSURL * soundURL = [NSURL fileURLWithPath:soundFilePath]; AudioServicesCreateSystemSoundID(( __bridge CFURLRef _Nonnull)(soundURL), & _soundFileID); // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play sound file AudioServicesPlaySystemSound(self.soundFileID); [self displayQuote:[self.model randomQuote]]; } Setup for Vibration // QuoteViewController.m - ( void ) doubleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Vibrate AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); [self displayQuote:[self.model randomQuote]]; } Create property using AVFoundation // QuoteViewController.m #import <AVFoundation/AVFoundation.h> // Other imports\u2026 @interface QuoteViewController () @property ( strong , nonatomic ) AVAudioPlayer * audioPlayer; // QuoteViewController.m NSString * path = [NSString stringWithFormat: @\"%@/tone.mp3\" , [[NSBundle mainBundle] resourcePath]]; NSURL * soundURL = [NSURL fileURLWithPath:path]; NSError * error; self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:soundURL error: & error]; [self.audioPlayer prepareToPlay]; // QuoteViewController.m - ( void ) singleTapRecognized: (UITapGestureRecognizer * )recognizer{ // Play audio [self.audioPlayer play]; [self displayQuote:[self.model randomQuote]]; }","title":"Audio"},{"location":"iOS/exam-ii-review-part-one/#delegates","text":"Protocol * Is a declaration of a list of methods * Two kinds of methods: optional and required Delegation * Allow for one to one communication between two instances: the delegate and delegator * Delegator: Instance that send events to delegate * Delegate: Process events sent from the delegator * The delegator is typically a framework object (i.e. textfield, tableview, etc.), and the delegate is typically a custom controller object. Three Steps Processes 1. In your custom class, adopt the delegate's protocol. 2. Implement the appropriate protocol methods. 3. Connect the delegate outlet of the delegator (i.e. textfield, tableview, etc.) to your custom class. Summary * Allowing some objects to be relatively fixed and others highly customized. * Maximum software reuse and MVC design pattern. Demo: or but not both // ViewController.h @interface ViewController < ProtocolName > @end // ViewController.m @interface ViewController () < ProtocolName > @end @implementation ViewController @end","title":"Delegates"},{"location":"iOS/exam-ii-review-part-one/#table-views","text":"iOS can have an unlimited # of rows iOS tables can only be one col wide Plain Table View * Row seperated into labeled sections and index appears vertically on right (index list) * Header and footer: row are grouped, doesn't include index * Highlight: * In both styles, a table row becomes highlighted briefly when a user taps a selectable item. * If a row selection results in navigation to a new screen, the selected row becomes highlighted briefly as the new screen slides into place. * When the user navigates back to the previous screen, the originally selected row again becomes highlighted briefly to remind the user of the earlier selection (it doesn\u2019t remain highlighted). * Four Predefined Styles 1. UITableViewCellStyleDefault : The default cell style includes an optional image in the left end of the row, followed by a left-aligned title. 2. UITableViewCellStyleSubtitle : The subtitle style includes an optional image in the left end of the row, followed by a left- aligned title on one line and a left- aligned subtitle on the line below. 3. UITableViewCellStyleValue1 : The value 1 style displays a left-aligned title with, on the same line, a rightaligned subtitle in a lighter font. 4. UITableViewCellStyleValue2`: The value 2 style displays a right-aligned title in a blue font, followed on the same line by a left-aligned subtitle in a black font. Images don\u2019t fit well in this style. Reusing Cell * When you call [tableView dequeuereusablecellwithidentifier:] you either: A. Get a cell that has previously been created and isn't currently being used OR B. Create a new cell of the class you specified Examples // ExampleTableViewController.m // Return the number of sections - (NSInteger) numberOfSectionsInTableView: (UITableView * )tableView{ return 1 ; } // Return number of rows in the section - (NSInteger) tableView: (UITableView * )tableView numberOfRowsInSection: (NSInteger)section{ return 100 ; } // Configuring Rows (cell) - (UITableViewCell * ) tableView: (UITableView * )tableView cellForRowAtIndexPath: (NSIndexPath * )indexPath{ static NSString * cellIdentifier = @\"TableCell\" ; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; // Configure the cell cell.textLabel.text = [NSString stringWithFormat: @\"Row %d\" , indexPath.row]; return cell; } Relationships btw View Controllers * If the relationship is a segue , the destination view controller is instantiated when the segue is triggered. * If the relationship represents containment , the child view controller is instantiated when its parent is instantiated. * If the controller is not the destination or child of another controller, it is never instantiated automatically. You must instantiate it from the storyboard programmatically. * Segues: When a segue is triggered, iOS takes the following actions: 1. It instantiates the destination view controller using the attribute values you provided in the storyboard. 2. It gives the source view controller an opportunity to configure the new controller. 3. It performs the transition configured in the segue. * Summary: containment for parent-child connection; segues for two views.","title":"Table Views"},{"location":"iOS/exam-ii-review-part-two/","text":"On-class \u00b6 WebKit features (important) Multiple Storyboard prevent merge conflicts no swift to be tested no animation/accelerometer in coding Major Design pattern: delegation MVC Singleton (notification) Objective-C Data Types BOOL ID SELECTOR App States ARC vs. MRR: memory management Understand hw5 very well (code) Pass data/function between controllers: ?? blocks How to save data: ?? Creating a tableView (code) Delete cells Set delegate completion handler using blocks Scene & Segues \u00b6 Use blocks for communication between scenes (save or cancel) typedef returntype(^<#block name#>)(<#arguments#>); block properties should always be copy Two common styles: Show: left-to-right navigation Present Modally: full-screen cover Use prepareForSegue: to connect Set the completion handler: insert new quote into models; have table view reload data; dismiss view controller Data Persistence \u00b6 User Default: NSUserDefaults using key value (like NSDictionary ) Save files to the Document folder using plist Use SQLite Use Core Data Folder to save Documents Your application stores its data in Documents, with the exception of NSUserDefaults-based preference settings Library NSUserDefaults-based preference settings are stored in the Library/Preferences folder tmp Place to store temporary files that will not be backed up by iTunes, but your app has to be responsibility for deleting the files User Defaults No high performance No complex structure Not searchable NSString * const kCurrentIndexKey = @\"CurrentIndex\" ; - ( void ) save { NSUserDefaults * defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:[NSNumber numberWithInt:self.currentIndex] forKey:kCurrentIndexKey]; [defaults synchronize]; } - (NSNumber) read { NSNumber * readData = [[NSUserDefaults standardUserDefaults] objectForKey:kCurrentIndexKey]; return readData; } Use of const 1. Prevent mistype 2. Convenience to auto-complete 3. Declare outside of @interface and @implementation Inside Document Folder Accept types: Property List (xml) Text Files Archiving Objects -- NSCoding protocol NSString * documentsDirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[ 0 ]; // Create a file name for your file NSString * filename = @\"flashcards.plist\" ; // Generate the full file path _filePath = [NSString stringWithFormat: @\"%@/%@\" , documentsDirPath, filename]; NSLog( @\"file path %@\" , _filePath); NSArray * flashcardsFromDocumentsDir = [[NSArray alloc] initWithContentsOfFile:_filePath]; App life cycle \u00b6 App States * Not Running * Inactive (foreground) * Active (foreground) * Background * Suspended Memory \u00b6 Two Methods of application memory management 1. Manual retain-release: MRR 2. Automatic Reference Counting: ARC * Using reference-count * Invoke dealloc automatically MRR \u00b6 Cocoa's Policy * You own object you created: alloc new copy mutableCopy * Take ownership by using retain * When no longer need, relinquish it using release or autorelease (must relinquish object do not own) * \"Parent\" object maintain strong reference to \"children\", \"children\" have weak reference to \"parents\" Pratical Memory Management * Use accessor methods to set property values * Don't use accessor methods in initalizer and dealloc * Use weak reference to avoid retain cycles * Avoid dealloc object while using * Don't use dealloc to manage scarce resources * Collections own the objects they contain * Ownership policy is implemented using retain counts Retain Count * When create an object, RC (retain count) is 1 * When send a retain message, RC + 1 * When send a release message, RC - 1 * When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block. * If RC == 0 -> object dealloc ARC \u00b6 Insert retains and releases into code when compile Web View \u00b6 WebKit * Follow MVC framework * View: WebView * Object: WebFrameView and WebFrame * App Transport Security force to connect with web service through HTTPS Example: Read a pdf file - ( void ) viewDidLoad { [super viewDidLoad]; NSString * path = [[NSBundle mainBundle] pathForResource: @\"HIG\" ofType: @\"pdf\" ]; if (path){ NSData * pdfData = [NSData dataWithContentsOfFile:path]; [(UIWebView * )self.view loadData:pdfData MIMEType: @\"application/pdf\" textEncodingName: @\"utf-8\" baseURL:nil]; } } Read a url NSURL * url = [NSURL URLWithString: @\"https://www.apple.com\" ]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [self.myWebView loadRequest: request]; Cancel a loading request - ( void ) viewWillDisappear: ( BOOL )animated{ [super viewWillDisappear:animated]; if ([self.myWebView isLoading]){ [self.myWebView stopLoading]; } // Disconnect the delegate as the webview is hidden self.myWebView.delegate = nil; } Animation loading in WebView - ( void ) webViewDidStartLoad: (UIWebView * )webView{ [self.activityIndicator startAnimating]; } - ( void ) webViewDidFinishLoad: (UIWebView * )webView{ [self.activityIndicator stopAnimating]; } - ( void ) webView: (UIWebView * )webView didFailLoadWithError: (NSError * )error{ [self.activityIndicator stopAnimating]; } Notes A web view automatically converts telephone numbers that appear in web content to Phone links. You should not embed UIWebView or UITableView objects in UIScrollView objects. Table View Rewind \u00b6 Modifying Tables \u00b6 Delete table cells * Add navigation control * Enable edit button in viewDidLoad method * Use the public remove method in the model * Implement tableView: commitEditingStyle: forRowAtIndexPath method - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the row from the data source [self.model removeFlashcardAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view } }","title":"Exam ii review part two"},{"location":"iOS/exam-ii-review-part-two/#on-class","text":"WebKit features (important) Multiple Storyboard prevent merge conflicts no swift to be tested no animation/accelerometer in coding Major Design pattern: delegation MVC Singleton (notification) Objective-C Data Types BOOL ID SELECTOR App States ARC vs. MRR: memory management Understand hw5 very well (code) Pass data/function between controllers: ?? blocks How to save data: ?? Creating a tableView (code) Delete cells Set delegate completion handler using blocks","title":"On-class"},{"location":"iOS/exam-ii-review-part-two/#scene-segues","text":"Use blocks for communication between scenes (save or cancel) typedef returntype(^<#block name#>)(<#arguments#>); block properties should always be copy Two common styles: Show: left-to-right navigation Present Modally: full-screen cover Use prepareForSegue: to connect Set the completion handler: insert new quote into models; have table view reload data; dismiss view controller","title":"Scene &amp; Segues"},{"location":"iOS/exam-ii-review-part-two/#data-persistence","text":"User Default: NSUserDefaults using key value (like NSDictionary ) Save files to the Document folder using plist Use SQLite Use Core Data Folder to save Documents Your application stores its data in Documents, with the exception of NSUserDefaults-based preference settings Library NSUserDefaults-based preference settings are stored in the Library/Preferences folder tmp Place to store temporary files that will not be backed up by iTunes, but your app has to be responsibility for deleting the files User Defaults No high performance No complex structure Not searchable NSString * const kCurrentIndexKey = @\"CurrentIndex\" ; - ( void ) save { NSUserDefaults * defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:[NSNumber numberWithInt:self.currentIndex] forKey:kCurrentIndexKey]; [defaults synchronize]; } - (NSNumber) read { NSNumber * readData = [[NSUserDefaults standardUserDefaults] objectForKey:kCurrentIndexKey]; return readData; } Use of const 1. Prevent mistype 2. Convenience to auto-complete 3. Declare outside of @interface and @implementation Inside Document Folder Accept types: Property List (xml) Text Files Archiving Objects -- NSCoding protocol NSString * documentsDirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[ 0 ]; // Create a file name for your file NSString * filename = @\"flashcards.plist\" ; // Generate the full file path _filePath = [NSString stringWithFormat: @\"%@/%@\" , documentsDirPath, filename]; NSLog( @\"file path %@\" , _filePath); NSArray * flashcardsFromDocumentsDir = [[NSArray alloc] initWithContentsOfFile:_filePath];","title":"Data Persistence"},{"location":"iOS/exam-ii-review-part-two/#app-life-cycle","text":"App States * Not Running * Inactive (foreground) * Active (foreground) * Background * Suspended","title":"App life cycle"},{"location":"iOS/exam-ii-review-part-two/#memory","text":"Two Methods of application memory management 1. Manual retain-release: MRR 2. Automatic Reference Counting: ARC * Using reference-count * Invoke dealloc automatically","title":"Memory"},{"location":"iOS/exam-ii-review-part-two/#mrr","text":"Cocoa's Policy * You own object you created: alloc new copy mutableCopy * Take ownership by using retain * When no longer need, relinquish it using release or autorelease (must relinquish object do not own) * \"Parent\" object maintain strong reference to \"children\", \"children\" have weak reference to \"parents\" Pratical Memory Management * Use accessor methods to set property values * Don't use accessor methods in initalizer and dealloc * Use weak reference to avoid retain cycles * Avoid dealloc object while using * Don't use dealloc to manage scarce resources * Collections own the objects they contain * Ownership policy is implemented using retain counts Retain Count * When create an object, RC (retain count) is 1 * When send a retain message, RC + 1 * When send a release message, RC - 1 * When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block. * If RC == 0 -> object dealloc","title":"MRR"},{"location":"iOS/exam-ii-review-part-two/#arc","text":"Insert retains and releases into code when compile","title":"ARC"},{"location":"iOS/exam-ii-review-part-two/#web-view","text":"WebKit * Follow MVC framework * View: WebView * Object: WebFrameView and WebFrame * App Transport Security force to connect with web service through HTTPS Example: Read a pdf file - ( void ) viewDidLoad { [super viewDidLoad]; NSString * path = [[NSBundle mainBundle] pathForResource: @\"HIG\" ofType: @\"pdf\" ]; if (path){ NSData * pdfData = [NSData dataWithContentsOfFile:path]; [(UIWebView * )self.view loadData:pdfData MIMEType: @\"application/pdf\" textEncodingName: @\"utf-8\" baseURL:nil]; } } Read a url NSURL * url = [NSURL URLWithString: @\"https://www.apple.com\" ]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [self.myWebView loadRequest: request]; Cancel a loading request - ( void ) viewWillDisappear: ( BOOL )animated{ [super viewWillDisappear:animated]; if ([self.myWebView isLoading]){ [self.myWebView stopLoading]; } // Disconnect the delegate as the webview is hidden self.myWebView.delegate = nil; } Animation loading in WebView - ( void ) webViewDidStartLoad: (UIWebView * )webView{ [self.activityIndicator startAnimating]; } - ( void ) webViewDidFinishLoad: (UIWebView * )webView{ [self.activityIndicator stopAnimating]; } - ( void ) webView: (UIWebView * )webView didFailLoadWithError: (NSError * )error{ [self.activityIndicator stopAnimating]; } Notes A web view automatically converts telephone numbers that appear in web content to Phone links. You should not embed UIWebView or UITableView objects in UIScrollView objects.","title":"Web View"},{"location":"iOS/exam-ii-review-part-two/#table-view-rewind","text":"","title":"Table View Rewind"},{"location":"iOS/exam-ii-review-part-two/#modifying-tables","text":"Delete table cells * Add navigation control * Enable edit button in viewDidLoad method * Use the public remove method in the model * Implement tableView: commitEditingStyle: forRowAtIndexPath method - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the row from the data source [self.model removeFlashcardAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view } }","title":"Modifying Tables"},{"location":"iOS/ios-api/","text":"Taking picture and movie \u00b6 UIImagePickerController AV Foundation JSQMessageController for bubble DialogFlow for smart reply fabric.io submit app Analytics \u00b6 Mixpanel NSLocalization Deployment \u00b6 TestFlight: distribution","title":"Ios api"},{"location":"iOS/ios-api/#taking-picture-and-movie","text":"UIImagePickerController AV Foundation JSQMessageController for bubble DialogFlow for smart reply fabric.io submit app","title":"Taking picture and movie"},{"location":"iOS/ios-api/#analytics","text":"Mixpanel NSLocalization","title":"Analytics"},{"location":"iOS/ios-api/#deployment","text":"TestFlight: distribution","title":"Deployment"},{"location":"iOS/some-tools/","text":"dev.weev.it use for api dev \u00b6 Dialog Flow use for bot chat \u00b6 Vuforia \u00b6 Bing Speech API use for recognizing speech to string \u00b6","title":"Some tools"},{"location":"iOS/some-tools/#devweevit-use-for-api-dev","text":"","title":"dev.weev.it use for api dev"},{"location":"iOS/some-tools/#dialog-flow-use-for-bot-chat","text":"","title":"Dialog Flow use for bot chat"},{"location":"iOS/some-tools/#vuforia","text":"","title":"Vuforia"},{"location":"iOS/some-tools/#bing-speech-api-use-for-recognizing-speech-to-string","text":"","title":"Bing Speech API use for recognizing speech to string"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/","text":"Loss Function \u00b6 Multiclass SVM Loss: hinge loss \u00b6 S_{y_j} S_{y_j} is the predict right score (target score) S_j S_j is the predict wrong score (all the other) L_i = \\sum_{j \\neq y_i} max(0, S_j - S_{y_j} + 1) Total Loss is: L = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i L(W) = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i(f(x_i, W), y_i) To calculate the loss for predicting car: max(0, cat score - car score + 1) + max(0, frog score - car score + 1) = max(0, -2.6) + max(0, -1.9) = 0 after using the same method to calculate each of the classes, the averge is the result: (2.9 -> for cat + 0 -> for car + 12.9 -> for frog) / 3 = 5.27 Regularization \u00b6 \\lambda R(W) \\lambda R(W) This term makes sure to choose \"simpler\" W instead of complicated ones that only fit training data, so that the power is lower for each term (high penalty for using high power poly). Softmax Classifier (Multinomial Logistic Regression): cross-entropy loss \u00b6 score is the probabilities for each class, and the sum of all classes equals to one (100%). Loss for each category: L_i = -\\log P(Y = y_i | X = x_i) L_i = -\\log P(Y = y_i | X = x_i) P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} where s s is our model: s = f(x_i;W) s = f(x_i;W) plug in to the first equation: L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) The min loss is 0 and max loss is +inf Finding the lowest score (with respect to W) -- Optimization \u00b6 ramdon (never use) find the slope (using gradient: numberic for debugging and analytic for calculating) Gradient Descent \u00b6 while True : weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter update step_size is also the learning rate, it's the first thing to set Stochastic Gradient Descent (SGD) \u00b6 Use when there are a lot of training set, in each iteraion, take a samples data from the training set (typically 32/64/128/256) called minibatch while True : data_batch = sample_training_data(data, 256 ) weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update","title":"Cs231n lecture 3   loss function"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#loss-function","text":"","title":"Loss Function"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#multiclass-svm-loss-hinge-loss","text":"S_{y_j} S_{y_j} is the predict right score (target score) S_j S_j is the predict wrong score (all the other) L_i = \\sum_{j \\neq y_i} max(0, S_j - S_{y_j} + 1) Total Loss is: L = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i L(W) = \\frac{1}{N} \\times \\sum_{i = 1}^{N} L_i(f(x_i, W), y_i) To calculate the loss for predicting car: max(0, cat score - car score + 1) + max(0, frog score - car score + 1) = max(0, -2.6) + max(0, -1.9) = 0 after using the same method to calculate each of the classes, the averge is the result: (2.9 -> for cat + 0 -> for car + 12.9 -> for frog) / 3 = 5.27","title":"Multiclass SVM Loss: hinge loss"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#regularization","text":"\\lambda R(W) \\lambda R(W) This term makes sure to choose \"simpler\" W instead of complicated ones that only fit training data, so that the power is lower for each term (high penalty for using high power poly).","title":"Regularization"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#softmax-classifier-multinomial-logistic-regression-cross-entropy-loss","text":"score is the probabilities for each class, and the sum of all classes equals to one (100%). Loss for each category: L_i = -\\log P(Y = y_i | X = x_i) L_i = -\\log P(Y = y_i | X = x_i) P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} P(Y = y_i | X = x_i) = \\frac{e^sk}{\\sum_{j} e^s j} where s s is our model: s = f(x_i;W) s = f(x_i;W) plug in to the first equation: L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) L_i = -\\log (\\frac{e^sk}{\\sum_{j} e^s j}) The min loss is 0 and max loss is +inf","title":"Softmax Classifier (Multinomial Logistic Regression): cross-entropy loss"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#finding-the-lowest-score-with-respect-to-w-optimization","text":"ramdon (never use) find the slope (using gradient: numberic for debugging and analytic for calculating)","title":"Finding the lowest score (with respect to W) -- Optimization"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#gradient-descent","text":"while True : weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter update step_size is also the learning rate, it's the first thing to set","title":"Gradient Descent"},{"location":"machine%20learning/cs231n-lecture-3---loss-function/#stochastic-gradient-descent-sgd","text":"Use when there are a lot of training set, in each iteraion, take a samples data from the training set (typically 32/64/128/256) called minibatch while True : data_batch = sample_training_data(data, 256 ) weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update","title":"Stochastic Gradient Descent (SGD)"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/","text":"Computation Graph \u00b6 Backpropagation: used for finding gradient \u00b6 e.g. f(x,y,z) = (x + y) z where x = -2, y = 5, z = -4 Notations: \u00b6 q = x + y \\frac{\\partial q}{\\partial x} = 1, \\frac{\\partial q}{\\partial y} = 1 f = qz \\frac{\\partial f}{\\partial q} = z, \\frac{\\partial f}{\\partial z} = q goal is to find: \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} In order to get all the targets, we start from the last node where \\frac{\\partial f}{\\partial f} = q = 1 \\frac{\\partial f}{\\partial f} = q = 1 Then find the following in sequences: 1. \\frac{\\partial f}{\\partial z} = q = 1 2. \\frac{\\partial f}{\\partial q} = z = -4 3. \\frac{\\partial f}{\\partial y} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial y} = -4 \\times 1 = -4 -- using chain rule 4. \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial x} = -4 \\times 1 = -4 -- using chain rule Using Chain rule: Use upstreaming compound and multiple with the local compound to derive the desire partial derivative For each node, we just need \"local gradient\" which is the new upstream for the next level node. Another Example \u00b6 Sigmoid Function \u00b6 Because we already know the gradient for sigmoid function, we can just replace the sigmoid gate with the analyic gradient result. Patterns in backward flow \u00b6 add gate: gradient distributor (split to two branches because of two terms) max gate (e.g. max(0,1)=1): gradient router (one gradient is 0 and another is the full value) mul gate: gradient switcher (multiple the other one to derive the current one) Using matrix representation (Vectorization) \u00b6 Jacobian Matrix for derivative for each vector. However, we don't need to calculate Jacobian matrix, because each x in the row only affect the result element in the same row. Thus the matrix is diagonal. L2 norm: f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 Partial in respect to each q_i: \\frac{\\partial f}{\\partial q_i} = 2q_i or \\nabla_q f = 2q Then calculate gradient for W, we can use chain rule: \\frac{\\partial f}{\\partial W_{i,j}} = \\sum_{k} \\frac{\\partial f}{\\partial q_k} \\frac{\\partial q_k}{\\partial W_{i,j}} = 2^k q_i x_j Implement forward and backword for different gates \u00b6 class MultiplyGate (object): def forward (x,y): return x * y def backward (dz): dx = self . y * dz # cache y dy = self . x * dz return [dx, dy] where [dx, dy] is: \\frac{\\partial L}{\\partial x}, \\frac{\\partial L}{\\partial y} and dz is: \\frac{\\partial L}{\\partial z}","title":"Cs231n lecture 4   introduction to neural networks"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#computation-graph","text":"","title":"Computation Graph"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#backpropagation-used-for-finding-gradient","text":"e.g. f(x,y,z) = (x + y) z where x = -2, y = 5, z = -4","title":"Backpropagation: used for finding gradient"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#notations","text":"q = x + y \\frac{\\partial q}{\\partial x} = 1, \\frac{\\partial q}{\\partial y} = 1 f = qz \\frac{\\partial f}{\\partial q} = z, \\frac{\\partial f}{\\partial z} = q goal is to find: \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} In order to get all the targets, we start from the last node where \\frac{\\partial f}{\\partial f} = q = 1 \\frac{\\partial f}{\\partial f} = q = 1 Then find the following in sequences: 1. \\frac{\\partial f}{\\partial z} = q = 1 2. \\frac{\\partial f}{\\partial q} = z = -4 3. \\frac{\\partial f}{\\partial y} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial y} = -4 \\times 1 = -4 -- using chain rule 4. \\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial x} = -4 \\times 1 = -4 -- using chain rule Using Chain rule: Use upstreaming compound and multiple with the local compound to derive the desire partial derivative For each node, we just need \"local gradient\" which is the new upstream for the next level node.","title":"Notations:"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#another-example","text":"","title":"Another Example"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#sigmoid-function","text":"Because we already know the gradient for sigmoid function, we can just replace the sigmoid gate with the analyic gradient result.","title":"Sigmoid Function"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#patterns-in-backward-flow","text":"add gate: gradient distributor (split to two branches because of two terms) max gate (e.g. max(0,1)=1): gradient router (one gradient is 0 and another is the full value) mul gate: gradient switcher (multiple the other one to derive the current one)","title":"Patterns in backward flow"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#using-matrix-representation-vectorization","text":"Jacobian Matrix for derivative for each vector. However, we don't need to calculate Jacobian matrix, because each x in the row only affect the result element in the same row. Thus the matrix is diagonal. L2 norm: f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 f(q) = ||q||^2 = q_1^2 + q_2^2 + q_3^3 ... + q_n^2 Partial in respect to each q_i: \\frac{\\partial f}{\\partial q_i} = 2q_i or \\nabla_q f = 2q Then calculate gradient for W, we can use chain rule: \\frac{\\partial f}{\\partial W_{i,j}} = \\sum_{k} \\frac{\\partial f}{\\partial q_k} \\frac{\\partial q_k}{\\partial W_{i,j}} = 2^k q_i x_j","title":"Using matrix representation (Vectorization)"},{"location":"machine%20learning/cs231n-lecture-4---introduction-to-neural-networks/#implement-forward-and-backword-for-different-gates","text":"class MultiplyGate (object): def forward (x,y): return x * y def backward (dz): dx = self . y * dz # cache y dy = self . x * dz return [dx, dy] where [dx, dy] is: \\frac{\\partial L}{\\partial x}, \\frac{\\partial L}{\\partial y} and dz is: \\frac{\\partial L}{\\partial z}","title":"Implement forward and backword for different gates"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/","text":"CNN is good for spacial structure Filter \u00b6 stride (3 in this case): number of steps to move for each progress dimentino size: n * n filter size: F Output size = (N - F)/stride+1 => e.g. stride size = 3 won't work 1. To make this case working, adding a border surrounded (padding) will make N divisable (now N is 9 instead of 7) 2. To make the size remain the same dimentionally, we also use padding. Conv Layer \u00b6 Accpets a volume of size W_1\\times H_1 \\times D_1 W_1\\times H_1 \\times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F (or filter dimension), the stride S, the amount of zero padding P. Produces a volume of size W_2 W_2 \\times \\times H_2 H_2 \\times \\times D_2 D_2 W_2 = (W_1 - F + 2P)/S + 1 W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/s + 1 H_2 = (H_1 - F + 2P)/s + 1 (width and height are the same size) D_2 = K D_2 = K With parameter sharing, it produces F \\times F \\times D_1 F \\times F \\times D_1 weights per filter, for a total of (F \\cdot F \\cdot D_1) * K (F \\cdot F \\cdot D_1) * K weights In the output volume, the d-th depth slice (of size W_2 \\times H_2 W_2 \\times H_2 ) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S S , and then offset by d-th bias Pooling Layer \u00b6 input depth would be the same, and width and height would be shrink down by a factor Max-Pooling Layer \u00b6 Choosing the maximum within each filter. Find the region that has fired with higher value from the other region. Summary \u00b6 Accepts a volume of size W1\u00d7H1\u00d7D1 Requires two hyperparameters: their spatial extent F, the stride S, Produces a volume of size W2\u00d7H2\u00d7D2 where: W_2=(W_1\u2212F)/S+1 W_2=(W_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 D_2=D_1 D_2=D_1 Introduces zero parameters since it computes a fixed function of the input For Pooling layers, it is not common to pad the input using zero-padding. It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with F=3,S=2 F=3,S=2 (also called overlapping pooling), and more commonly F=2,S=2 F=2,S=2 . Pooling sizes with larger receptive fields are too destructive. Fully Connected Layer (FC) \u00b6 Stretch out to 1-d array, usually on the last layer.","title":"Cs231n lecture 5   convolutional neural networks"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#filter","text":"stride (3 in this case): number of steps to move for each progress dimentino size: n * n filter size: F Output size = (N - F)/stride+1 => e.g. stride size = 3 won't work 1. To make this case working, adding a border surrounded (padding) will make N divisable (now N is 9 instead of 7) 2. To make the size remain the same dimentionally, we also use padding.","title":"Filter"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#conv-layer","text":"Accpets a volume of size W_1\\times H_1 \\times D_1 W_1\\times H_1 \\times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F (or filter dimension), the stride S, the amount of zero padding P. Produces a volume of size W_2 W_2 \\times \\times H_2 H_2 \\times \\times D_2 D_2 W_2 = (W_1 - F + 2P)/S + 1 W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/s + 1 H_2 = (H_1 - F + 2P)/s + 1 (width and height are the same size) D_2 = K D_2 = K With parameter sharing, it produces F \\times F \\times D_1 F \\times F \\times D_1 weights per filter, for a total of (F \\cdot F \\cdot D_1) * K (F \\cdot F \\cdot D_1) * K weights In the output volume, the d-th depth slice (of size W_2 \\times H_2 W_2 \\times H_2 ) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S S , and then offset by d-th bias","title":"Conv Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#pooling-layer","text":"input depth would be the same, and width and height would be shrink down by a factor","title":"Pooling Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#max-pooling-layer","text":"Choosing the maximum within each filter. Find the region that has fired with higher value from the other region.","title":"Max-Pooling Layer"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#summary","text":"Accepts a volume of size W1\u00d7H1\u00d7D1 Requires two hyperparameters: their spatial extent F, the stride S, Produces a volume of size W2\u00d7H2\u00d7D2 where: W_2=(W_1\u2212F)/S+1 W_2=(W_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 H_2=(H_1\u2212F)/S+1 D_2=D_1 D_2=D_1 Introduces zero parameters since it computes a fixed function of the input For Pooling layers, it is not common to pad the input using zero-padding. It is worth noting that there are only two commonly seen variations of the max pooling layer found in practice: A pooling layer with F=3,S=2 F=3,S=2 (also called overlapping pooling), and more commonly F=2,S=2 F=2,S=2 . Pooling sizes with larger receptive fields are too destructive.","title":"Summary"},{"location":"machine%20learning/cs231n-lecture-5---convolutional-neural-networks/#fully-connected-layer-fc","text":"Stretch out to 1-d array, usually on the last layer.","title":"Fully Connected Layer (FC)"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/","text":"Overview \u00b6 One time setup: activation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamics: babysitting the learning process, parameter updates, hyperparameter optimization Evaluation: model ensembles Part 1 \u00b6 Activation functions Data preprocessing Weight initialization, Batch Normalization Babysitting the learning process Hyperparameter Optimization Activation Function \u00b6 Sigmoid \u00b6 \\sigma(x)=\\frac{1}{1+e^{-x}} \\sigma(x)=\\frac{1}{1+e^{-x}} if get high value -> approach to 1, low -> 0 problem 1: if too large, then the value is 1, or too small, then the value is 0 (killed gradient when saturated) problem 2: not zero-centered (gradient on w is always all positive or negative) which makes the parameter update inefficient problem 3: e^{-x} e^{-x} is computation expensive tanh \u00b6 tanh(x) tanh(x) in a range of [-1, 1] it's now zero centered (flip between - and + for same weight) problem 1: still kill gradient when saturated ReLU \u00b6 f(x)=max(0,x) f(x)=max(0,x) doesn't saturated in positive region computation efficient converge faster than sigmoid and tanh biologically plausible than sigmoid problem 1: not zero-centered problem 2: negative still saturated (annoyance, dead relu region) Leaky ReLU and Parametric Rectifier \u00b6 f(x)=max(0.01x, x) and f(x)=max(\\alpha x, x) Does not saturate Computationally efficient Converge much faster than sigmoid/tanh in practice will not \"die\" (no platu) Exponential Linear Unit (ELU) \u00b6 f(x)=x if x > 0 f(x)= alpha (exp(x)-1) if x <= 0 all benefits of ReLU closer to zero mean outputs negative sarturation regime compared with Leaky ReLU adds some robustness to noise problem 1: computation requires exp() Conclusion \u00b6 Use ReLU Try out Leaky ReLU/Maxout/ELU Try tanh but don't expect too much Don't use sigmoid Data Preprocessing \u00b6 for image, stick with zero-mean","title":"Cs231n lecture 6   training neural networks i"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#overview","text":"One time setup: activation functions, preprocessing, weight initialization, regularization, gradient checking Training dynamics: babysitting the learning process, parameter updates, hyperparameter optimization Evaluation: model ensembles","title":"Overview"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#part-1","text":"Activation functions Data preprocessing Weight initialization, Batch Normalization Babysitting the learning process Hyperparameter Optimization","title":"Part 1"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#activation-function","text":"","title":"Activation Function"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#sigmoid","text":"\\sigma(x)=\\frac{1}{1+e^{-x}} \\sigma(x)=\\frac{1}{1+e^{-x}} if get high value -> approach to 1, low -> 0 problem 1: if too large, then the value is 1, or too small, then the value is 0 (killed gradient when saturated) problem 2: not zero-centered (gradient on w is always all positive or negative) which makes the parameter update inefficient problem 3: e^{-x} e^{-x} is computation expensive","title":"Sigmoid"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#tanh","text":"tanh(x) tanh(x) in a range of [-1, 1] it's now zero centered (flip between - and + for same weight) problem 1: still kill gradient when saturated","title":"tanh"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#relu","text":"f(x)=max(0,x) f(x)=max(0,x) doesn't saturated in positive region computation efficient converge faster than sigmoid and tanh biologically plausible than sigmoid problem 1: not zero-centered problem 2: negative still saturated (annoyance, dead relu region)","title":"ReLU"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#leaky-relu-and-parametric-rectifier","text":"f(x)=max(0.01x, x) and f(x)=max(\\alpha x, x) Does not saturate Computationally efficient Converge much faster than sigmoid/tanh in practice will not \"die\" (no platu)","title":"Leaky ReLU and Parametric Rectifier"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#exponential-linear-unit-elu","text":"f(x)=x if x > 0 f(x)= alpha (exp(x)-1) if x <= 0 all benefits of ReLU closer to zero mean outputs negative sarturation regime compared with Leaky ReLU adds some robustness to noise problem 1: computation requires exp()","title":"Exponential Linear Unit (ELU)"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#conclusion","text":"Use ReLU Try out Leaky ReLU/Maxout/ELU Try tanh but don't expect too much Don't use sigmoid","title":"Conclusion"},{"location":"machine%20learning/cs231n-lecture-6---training-neural-networks-i/#data-preprocessing","text":"for image, stick with zero-mean","title":"Data Preprocessing"}]}